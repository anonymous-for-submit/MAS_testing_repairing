{"task_id": "HumanEval/116", "prompt": "def sort_array(arr):\t\n'''In this Kata, you have to sort an array of non-negative integers according to the number of ones in their binary representation in ascending order. You are given an array with non-negative integers in it. You need to sort them based on the count of ones in their binary representation. For similar number of ones, sort based on decimal value.\n\nIt must be implemented like this:\n>>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    '''", "entry_point": "sort_array", "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n", "test": ["def check(sort_array):\n\tassert sort_array([4, 1, 45, 10, 30, 7]) == [1, 4, 10, 7, 30, 45]", "def check(sort_array):\n\tassert sort_array([4, 2, 6, 15, 30]) == [2, 4, 6, 15, 30]", "def check(sort_array):\n\tassert sort_array([4, 10, 1, 5, 2]) == [1, 2, 4, 5, 10]", "def check(sort_array):\n\tassert sort_array([2, 3, 5, 5, 4]) == [2, 4, 3, 5, 5]", "def check(sort_array):\n\tassert sort_array([4, 9, 13, 13, 27]) == [4, 9, 13, 13, 27]", "def check(sort_array):\n\tassert sort_array([2, 3, 12, 20, 36]) == [2, 3, 12, 20, 36]", "def check(sort_array):\n\tassert sort_array([3, 3, 5, 4, 8]) == [4, 8, 3, 3, 5]", "def check(sort_array):\n\tassert sort_array([3, 10, 1, 4, 7]) == [1, 4, 3, 10, 7]", "def check(sort_array):\n\tassert sort_array([1, 1, 47, 13, 30, 3]) == [1, 1, 3, 13, 30, 47]", "def check(sort_array):\n\tassert sort_array([5, 7, 10, 21, 34]) == [5, 10, 34, 7, 21]", "def check(sort_array):\n\tassert sort_array([-4, -7, 0, -9, -1]) == [0, -4, -1, -9, -7]", "def check(sort_array):\n\tassert sort_array([7, 4, 46, 10, 29, 7]) == [4, 10, 7, 7, 29, 46]", "def check(sort_array):\n\tassert sort_array([6, 7, 5, 6, 4]) == [4, 5, 6, 6, 7]", "def check(sort_array):\n\tassert sort_array([6, 4, 13, 13, 29]) == [4, 6, 13, 13, 29]", "def check(sort_array):\n\tassert sort_array([2, 6, 1, 5, 9]) == [1, 2, 5, 6, 9]", "def check(sort_array):\n\tassert sort_array([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "def check(sort_array):\n\tassert sort_array([-6, -5, -5, -6, -6]) == [-6, -6, -6, -5, -5]", "def check(sort_array):\n\tassert sort_array([4, 4, 7, 17, 31]) == [4, 4, 17, 7, 31]", "def check(sort_array):\n\tassert sort_array([3, 4, 2, 1, 3]) == [1, 2, 4, 3, 3]", "def check(sort_array):\n\tassert sort_array([2,4,8,16,32]) == [2, 4, 8, 16, 32]", "def check(sort_array):\n\tassert sort_array([3, -4, -9, 0, -5]) == [0, -4, -9, -5, 3]", "def check(sort_array):\n\tassert sort_array([4, 1, 46, 14, 34, 9]) == [1, 4, 9, 34, 14, 46]", "def check(sort_array):\n\tassert sort_array([4, 8, 3, 21, 29]) == [4, 8, 3, 21, 29]", "def check(sort_array):\n\tassert sort_array([6, 1, 4, 5, 4]) == [1, 4, 4, 5, 6]", "def check(sort_array):\n\tassert sort_array([3, 7, 42, 9, 34, 5]) == [3, 5, 9, 34, 7, 42]", "def check(sort_array):\n\tassert sort_array([2, 5, 80, 8, 2, 6, 6, 3, 2, 6, 3]) == [2, 2, 2, 8, 3, 3, 5, 6, 6, 6, 80]", "def check(sort_array):\n\tassert sort_array([8, 4, 45, 11, 37, 8]) == [4, 8, 8, 11, 37, 45]", "def check(sort_array):\n\tassert sort_array([5, 8, 46, 17, 28, 1]) == [1, 8, 5, 17, 28, 46]", "def check(sort_array):\n\tassert sort_array([5, 5, 13, 20, 28]) == [5, 5, 20, 13, 28]", "def check(sort_array):\n\tassert sort_array([2, 11, 41, 15, 37, 3]) == [2, 3, 11, 37, 41, 15]", "def check(sort_array):\n\tassert sort_array([5, 3, 2, 3, 6]) == [2, 3, 3, 5, 6]", "def check(sort_array):\n\tassert sort_array([0, -3, -9, -7, -6]) == [0, -9, -6, -3, -7]", "def check(sort_array):\n\tassert sort_array([1, 5, 2, 2, 2]) == [1, 2, 2, 2, 5]", "def check(sort_array):\n\tassert sort_array([3, 4, 5, 8, 2]) == [2, 4, 8, 3, 5]", "def check(sort_array):\n\tassert sort_array([7, 7, 7, 17, 29]) == [17, 7, 7, 7, 29]", "def check(sort_array):\n\tassert sort_array([7, 6, 41, 12, 37, 6]) == [6, 6, 12, 7, 37, 41]", "def check(sort_array):\n\tassert sort_array([6, 9, 48, 12, 34, 4]) == [4, 6, 9, 12, 34, 48]", "def check(sort_array):\n\tassert sort_array([5, 10, 6, 3, 9]) == [3, 5, 6, 9, 10]", "def check(sort_array):\n\tassert sort_array([1,0,2,3,4]) == [0, 1, 2, 4, 3]", "def check(sort_array):\n\tassert sort_array([3, 8, 74, 5, 8, 3, 8, 9, 2, 1, 5]) == [1, 2, 8, 8, 8, 3, 3, 5, 5, 9, 74]", "def check(sort_array):\n\tassert sort_array([5, 9, 74, 7, 6, 7, 3, 2, 1, 5, 8]) == [1, 2, 8, 3, 5, 5, 6, 9, 7, 7, 74]", "def check(sort_array):\n\tassert sort_array([-7, -3, -4, -10, -10]) == [-4, -10, -10, -3, -7]", "def check(sort_array):\n\tassert sort_array([4, 2, 8, 14, 30]) == [2, 4, 8, 14, 30]", "def check(sort_array):\n\tassert sort_array([-3, -5, -9, -7, -4]) == [-4, -9, -5, -3, -7]", "def check(sort_array):\n\tassert sort_array([5, 2, 5, 4, 4]) == [2, 4, 4, 5, 5]", "def check(sort_array):\n\tassert sort_array([3, 2, 4, 17, 35]) == [2, 4, 3, 17, 35]", "def check(sort_array):\n\tassert sort_array([7, 5, 10, 21, 33]) == [5, 10, 33, 7, 21]", "def check(sort_array):\n\tassert sort_array([1, 6, 81, 8, 8, 2, 7, 8, 7, 8, 7]) == [1, 2, 8, 8, 8, 8, 6, 7, 7, 7, 81]", "def check(sort_array):\n\tassert sort_array([4, 10, 77, 3, 8, 2, 9, 3, 4, 8, 2]) == [2, 2, 4, 4, 8, 8, 3, 3, 9, 10, 77]", "def check(sort_array):\n\tassert sort_array([6, 11, 43, 9, 29, 10]) == [6, 9, 10, 11, 29, 43]", "def check(sort_array):\n\tassert sort_array([1, 5, 8, 16, 27]) == [1, 8, 16, 5, 27]", "def check(sort_array):\n\tassert sort_array([1, 5, 75, 6, 4, 3, 7, 11, 7, 2, 4]) == [1, 2, 4, 4, 3, 5, 6, 7, 7, 11, 75]", "def check(sort_array):\n\tassert sort_array([3, 5, 81, 6, 5, 6, 9, 5, 3, 3, 3]) == [3, 3, 3, 3, 5, 5, 5, 6, 6, 9, 81]", "def check(sort_array):\n\tassert sort_array([6, 8, 5, 2, 3]) == [2, 8, 3, 5, 6]", "def check(sort_array):\n\tassert sort_array([5, 9, 42, 8, 34, 10]) == [8, 5, 9, 10, 34, 42]", "def check(sort_array):\n\tassert sort_array([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(sort_array):\n\tassert sort_array([6, 7, 9, 21, 33]) == [6, 9, 33, 7, 21]", "def check(sort_array):\n\tassert sort_array([1, 7, 11, 12, 32]) == [1, 32, 12, 7, 11]", "def check(sort_array):\n\tassert sort_array([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]", "def check(sort_array):\n\tassert sort_array([4, 1, 13, 12, 33]) == [1, 4, 12, 33, 13]", "def check(sort_array):\n\tassert sort_array([3, 8, 78, 5, 10, 5, 9, 3, 4, 7, 1]) == [1, 4, 8, 3, 3, 5, 5, 9, 10, 7, 78]", "def check(sort_array):\n\tassert sort_array([2, 6, 6, 1, 6]) == [1, 2, 6, 6, 6]", "def check(sort_array):\n\tassert sort_array([4, 2, 3, 4, 9]) == [2, 4, 4, 3, 9]", "def check(sort_array):\n\tassert sort_array([3, 2, 2, 8, 3]) == [2, 2, 8, 3, 3]", "def check(sort_array):\n\tassert sort_array([5, 2, 1, 6, 5]) == [1, 2, 5, 5, 6]", "def check(sort_array):\n\tassert sort_array([4, 4, 9, 16, 32]) == [4, 4, 16, 32, 9]", "def check(sort_array):\n\tassert sort_array([2, -5, -5, -6, -4]) == [-4, 2, -6, -5, -5]", "def check(sort_array):\n\tassert sort_array([1, 3, 41, 16, 32, 3]) == [1, 16, 32, 3, 3, 41]", "def check(sort_array):\n\tassert sort_array([3, -7, -9, -2, -9]) == [-2, -9, -9, 3, -7]", "def check(sort_array):\n\tassert sort_array([-1, -6, 0, -2, -8]) == [0, -8, -2, -1, -6]", "def check(sort_array):\n\tassert sort_array([6, 2, 6, 17, 33]) == [2, 6, 6, 17, 33]", "def check(sort_array):\n\tassert sort_array([3, 1, 8, 19, 32]) == [1, 8, 32, 3, 19]", "def check(sort_array):\n\tassert sort_array([5, 6, 10, 15, 31]) == [5, 6, 10, 15, 31]", "def check(sort_array):\n\tassert sort_array([2, 0, -7, -5, -3]) == [0, 2, -5, -3, -7]", "def check(sort_array):\n\tassert sort_array([3, 1, -6, -4, -3]) == [-4, 1, -6, -3, 3]", "def check(sort_array):\n\tassert sort_array([2, 7, 11, 14, 37]) == [2, 7, 11, 14, 37]", "def check(sort_array):\n\tassert sort_array([6, 7, 9, 15, 30]) == [6, 9, 7, 15, 30]", "def check(sort_array):\n\tassert sort_array([4, 1, 75, 9, 7, 7, 4, 7, 4, 2, 5]) == [1, 2, 4, 4, 4, 5, 9, 7, 7, 7, 75]", "def check(sort_array):\n\tassert sort_array([7, 7, 79, 4, 3, 2, 10, 2, 2, 8, 8]) == [2, 2, 2, 4, 8, 8, 3, 10, 7, 7, 79]", "def check(sort_array):\n\tassert sort_array([-6, -5, -9, -4, -8]) == [-8, -4, -9, -6, -5]", "def check(sort_array):\n\tassert sort_array([7, 7, 12, 15, 29]) == [12, 7, 7, 15, 29]", "def check(sort_array):\n\tassert sort_array([3, 2, 76, 9, 5, 3, 4, 2, 3, 3, 5]) == [2, 2, 4, 3, 3, 3, 3, 5, 5, 9, 76]", "def check(sort_array):\n\tassert sort_array([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]", "def check(sort_array):\n\tassert sort_array([1, 3, 9, 15, 27]) == [1, 3, 9, 15, 27]", "def check(sort_array):\n\tassert sort_array([3, 5, 8, 17, 27]) == [8, 3, 5, 17, 27]", "def check(sort_array):\n\tassert sort_array([1, 3, 5, 1, 2]) == [1, 1, 2, 3, 5]", "def check(sort_array):\n\tassert sort_array([2, 2, 10, 13, 27]) == [2, 2, 10, 13, 27]", "def check(sort_array):\n\tassert sort_array([5, 6, 4, 1, 2]) == [1, 2, 4, 5, 6]", "def check(sort_array):\n\tassert sort_array([3, 2, 4, 2, 2]) == [2, 2, 2, 4, 3]", "def check(sort_array):\n\tassert sort_array([5, 4, 75, 8, 6, 2, 10, 4, 4, 6, 1]) == [1, 2, 4, 4, 4, 8, 5, 6, 6, 10, 75]", "def check(sort_array):\n\tassert sort_array([8, 9, 39, 9, 28, 3]) == [8, 3, 9, 9, 28, 39]", "def check(sort_array):\n\tassert sort_array([6, 9, 13, 16, 37]) == [16, 6, 9, 13, 37]", "def check(sort_array):\n\tassert sort_array([6, 9, 2, 6, 7]) == [2, 6, 6, 9, 7]", "def check(sort_array):\n\tassert sort_array([5, 3, 12, 17, 37]) == [3, 5, 12, 17, 37]", "def check(sort_array):\n\tassert sort_array([2, 9, 12, 15, 31]) == [2, 9, 12, 15, 31]", "def check(sort_array):\n\tassert sort_array([3, 6, 72, 3, 7, 6, 7, 6, 3, 8, 3]) == [8, 3, 3, 3, 3, 6, 6, 6, 72, 7, 7]", "def check(sort_array):\n\tassert sort_array([3, -3, -7, -6, -3]) == [-6, -3, -3, 3, -7]", "def check(sort_array):\n\tassert sort_array([4, 3, 4, 4, 1]) == [1, 4, 4, 4, 3]", "def check(sort_array):\n\tassert sort_array([-1, 1, -4, -6, -6]) == [-4, -1, 1, -6, -6]", "def check(sort_array):\n\tassert sort_array([4, 1, 6, 16, 30]) == [1, 4, 16, 6, 30]", "def check(sort_array):\n\tassert sort_array([2, 9, 1, 8, 8]) == [1, 2, 8, 8, 9]", "def check(sort_array):\n\tassert sort_array([5, 3, 2, 1, 7]) == [1, 2, 3, 5, 7]", "def check(sort_array):\n\tassert sort_array([3, 1, 6, 7, 7]) == [1, 3, 6, 7, 7]", "def check(sort_array):\n\tassert sort_array([1, 5, 3, 5, 1]) == [1, 1, 3, 5, 5]", "def check(sort_array):\n\tassert sort_array([1,5,2,3,4]) == [1, 2, 4, 3, 5]", "def check(sort_array):\n\tassert sort_array([]) == []", "def check(sort_array):\n\tassert sort_array([1, 10, 74, 7, 1, 2, 1, 2, 6, 6, 1]) == [1, 1, 1, 1, 2, 2, 6, 6, 10, 7, 74]", "def check(sort_array):\n\tassert sort_array([4, 4, 5, 4, 1]) == [1, 4, 4, 4, 5]", "def check(sort_array):\n\tassert sort_array([-4, 0, -1, -4, -7]) == [0, -4, -4, -1, -7]", "def check(sort_array):\n\tassert sort_array([4, 11, 45, 13, 29, 8]) == [4, 8, 11, 13, 29, 45]", "def check(sort_array):\n\tassert sort_array([3, 6, 3, 1, 7]) == [1, 3, 3, 6, 7]", "def check(sort_array):\n\tassert sort_array([2, 8, 76, 4, 7, 6, 6, 8, 6, 2, 8]) == [2, 2, 4, 8, 8, 8, 6, 6, 6, 7, 76]", "def check(sort_array):\n\tassert sort_array([1, 8, 7, 2, 3]) == [1, 2, 8, 3, 7]"], "test_case_list": ["assert sort_array([4, 1, 45, 10, 30, 7]) == [1, 4, 10, 7, 30, 45]", "assert sort_array([4, 2, 6, 15, 30]) == [2, 4, 6, 15, 30]", "assert sort_array([4, 10, 1, 5, 2]) == [1, 2, 4, 5, 10]", "assert sort_array([2, 3, 5, 5, 4]) == [2, 4, 3, 5, 5]", "assert sort_array([4, 9, 13, 13, 27]) == [4, 9, 13, 13, 27]", "assert sort_array([2, 3, 12, 20, 36]) == [2, 3, 12, 20, 36]", "assert sort_array([3, 3, 5, 4, 8]) == [4, 8, 3, 3, 5]", "assert sort_array([3, 10, 1, 4, 7]) == [1, 4, 3, 10, 7]", "assert sort_array([1, 1, 47, 13, 30, 3]) == [1, 1, 3, 13, 30, 47]", "assert sort_array([5, 7, 10, 21, 34]) == [5, 10, 34, 7, 21]", "assert sort_array([-4, -7, 0, -9, -1]) == [0, -4, -1, -9, -7]", "assert sort_array([7, 4, 46, 10, 29, 7]) == [4, 10, 7, 7, 29, 46]", "assert sort_array([6, 7, 5, 6, 4]) == [4, 5, 6, 6, 7]", "assert sort_array([6, 4, 13, 13, 29]) == [4, 6, 13, 13, 29]", "assert sort_array([2, 6, 1, 5, 9]) == [1, 2, 5, 6, 9]", "assert sort_array([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "assert sort_array([-6, -5, -5, -6, -6]) == [-6, -6, -6, -5, -5]", "assert sort_array([4, 4, 7, 17, 31]) == [4, 4, 17, 7, 31]", "assert sort_array([3, 4, 2, 1, 3]) == [1, 2, 4, 3, 3]", "assert sort_array([2,4,8,16,32]) == [2, 4, 8, 16, 32]", "assert sort_array([3, -4, -9, 0, -5]) == [0, -4, -9, -5, 3]", "assert sort_array([4, 1, 46, 14, 34, 9]) == [1, 4, 9, 34, 14, 46]", "assert sort_array([4, 8, 3, 21, 29]) == [4, 8, 3, 21, 29]", "assert sort_array([6, 1, 4, 5, 4]) == [1, 4, 4, 5, 6]", "assert sort_array([3, 7, 42, 9, 34, 5]) == [3, 5, 9, 34, 7, 42]", "assert sort_array([2, 5, 80, 8, 2, 6, 6, 3, 2, 6, 3]) == [2, 2, 2, 8, 3, 3, 5, 6, 6, 6, 80]", "assert sort_array([8, 4, 45, 11, 37, 8]) == [4, 8, 8, 11, 37, 45]", "assert sort_array([5, 8, 46, 17, 28, 1]) == [1, 8, 5, 17, 28, 46]", "assert sort_array([5, 5, 13, 20, 28]) == [5, 5, 20, 13, 28]", "assert sort_array([2, 11, 41, 15, 37, 3]) == [2, 3, 11, 37, 41, 15]", "assert sort_array([5, 3, 2, 3, 6]) == [2, 3, 3, 5, 6]", "assert sort_array([0, -3, -9, -7, -6]) == [0, -9, -6, -3, -7]", "assert sort_array([1, 5, 2, 2, 2]) == [1, 2, 2, 2, 5]", "assert sort_array([3, 4, 5, 8, 2]) == [2, 4, 8, 3, 5]", "assert sort_array([7, 7, 7, 17, 29]) == [17, 7, 7, 7, 29]", "assert sort_array([7, 6, 41, 12, 37, 6]) == [6, 6, 12, 7, 37, 41]", "assert sort_array([6, 9, 48, 12, 34, 4]) == [4, 6, 9, 12, 34, 48]", "assert sort_array([5, 10, 6, 3, 9]) == [3, 5, 6, 9, 10]", "assert sort_array([1,0,2,3,4]) == [0, 1, 2, 4, 3]", "assert sort_array([3, 8, 74, 5, 8, 3, 8, 9, 2, 1, 5]) == [1, 2, 8, 8, 8, 3, 3, 5, 5, 9, 74]", "assert sort_array([5, 9, 74, 7, 6, 7, 3, 2, 1, 5, 8]) == [1, 2, 8, 3, 5, 5, 6, 9, 7, 7, 74]", "assert sort_array([-7, -3, -4, -10, -10]) == [-4, -10, -10, -3, -7]", "assert sort_array([4, 2, 8, 14, 30]) == [2, 4, 8, 14, 30]", "assert sort_array([-3, -5, -9, -7, -4]) == [-4, -9, -5, -3, -7]", "assert sort_array([5, 2, 5, 4, 4]) == [2, 4, 4, 5, 5]", "assert sort_array([3, 2, 4, 17, 35]) == [2, 4, 3, 17, 35]", "assert sort_array([7, 5, 10, 21, 33]) == [5, 10, 33, 7, 21]", "assert sort_array([1, 6, 81, 8, 8, 2, 7, 8, 7, 8, 7]) == [1, 2, 8, 8, 8, 8, 6, 7, 7, 7, 81]", "assert sort_array([4, 10, 77, 3, 8, 2, 9, 3, 4, 8, 2]) == [2, 2, 4, 4, 8, 8, 3, 3, 9, 10, 77]", "assert sort_array([6, 11, 43, 9, 29, 10]) == [6, 9, 10, 11, 29, 43]", "assert sort_array([1, 5, 8, 16, 27]) == [1, 8, 16, 5, 27]", "assert sort_array([1, 5, 75, 6, 4, 3, 7, 11, 7, 2, 4]) == [1, 2, 4, 4, 3, 5, 6, 7, 7, 11, 75]", "assert sort_array([3, 5, 81, 6, 5, 6, 9, 5, 3, 3, 3]) == [3, 3, 3, 3, 5, 5, 5, 6, 6, 9, 81]", "assert sort_array([6, 8, 5, 2, 3]) == [2, 8, 3, 5, 6]", "assert sort_array([5, 9, 42, 8, 34, 10]) == [8, 5, 9, 10, 34, 42]", "assert sort_array([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.", "assert sort_array([6, 7, 9, 21, 33]) == [6, 9, 33, 7, 21]", "assert sort_array([1, 7, 11, 12, 32]) == [1, 32, 12, 7, 11]", "assert sort_array([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]", "assert sort_array([4, 1, 13, 12, 33]) == [1, 4, 12, 33, 13]", "assert sort_array([3, 8, 78, 5, 10, 5, 9, 3, 4, 7, 1]) == [1, 4, 8, 3, 3, 5, 5, 9, 10, 7, 78]", "assert sort_array([2, 6, 6, 1, 6]) == [1, 2, 6, 6, 6]", "assert sort_array([4, 2, 3, 4, 9]) == [2, 4, 4, 3, 9]", "assert sort_array([3, 2, 2, 8, 3]) == [2, 2, 8, 3, 3]", "assert sort_array([5, 2, 1, 6, 5]) == [1, 2, 5, 5, 6]", "assert sort_array([4, 4, 9, 16, 32]) == [4, 4, 16, 32, 9]", "assert sort_array([2, -5, -5, -6, -4]) == [-4, 2, -6, -5, -5]", "assert sort_array([1, 3, 41, 16, 32, 3]) == [1, 16, 32, 3, 3, 41]", "assert sort_array([3, -7, -9, -2, -9]) == [-2, -9, -9, 3, -7]", "assert sort_array([-1, -6, 0, -2, -8]) == [0, -8, -2, -1, -6]", "assert sort_array([6, 2, 6, 17, 33]) == [2, 6, 6, 17, 33]", "assert sort_array([3, 1, 8, 19, 32]) == [1, 8, 32, 3, 19]", "assert sort_array([5, 6, 10, 15, 31]) == [5, 6, 10, 15, 31]", "assert sort_array([2, 0, -7, -5, -3]) == [0, 2, -5, -3, -7]", "assert sort_array([3, 1, -6, -4, -3]) == [-4, 1, -6, -3, 3]", "assert sort_array([2, 7, 11, 14, 37]) == [2, 7, 11, 14, 37]", "assert sort_array([6, 7, 9, 15, 30]) == [6, 9, 7, 15, 30]", "assert sort_array([4, 1, 75, 9, 7, 7, 4, 7, 4, 2, 5]) == [1, 2, 4, 4, 4, 5, 9, 7, 7, 7, 75]", "assert sort_array([7, 7, 79, 4, 3, 2, 10, 2, 2, 8, 8]) == [2, 2, 2, 4, 8, 8, 3, 10, 7, 7, 79]", "assert sort_array([-6, -5, -9, -4, -8]) == [-8, -4, -9, -6, -5]", "assert sort_array([7, 7, 12, 15, 29]) == [12, 7, 7, 15, 29]", "assert sort_array([3, 2, 76, 9, 5, 3, 4, 2, 3, 3, 5]) == [2, 2, 4, 3, 3, 3, 3, 5, 5, 9, 76]", "assert sort_array([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]", "assert sort_array([1, 3, 9, 15, 27]) == [1, 3, 9, 15, 27]", "assert sort_array([3, 5, 8, 17, 27]) == [8, 3, 5, 17, 27]", "assert sort_array([1, 3, 5, 1, 2]) == [1, 1, 2, 3, 5]", "assert sort_array([2, 2, 10, 13, 27]) == [2, 2, 10, 13, 27]", "assert sort_array([5, 6, 4, 1, 2]) == [1, 2, 4, 5, 6]", "assert sort_array([3, 2, 4, 2, 2]) == [2, 2, 2, 4, 3]", "assert sort_array([5, 4, 75, 8, 6, 2, 10, 4, 4, 6, 1]) == [1, 2, 4, 4, 4, 8, 5, 6, 6, 10, 75]", "assert sort_array([8, 9, 39, 9, 28, 3]) == [8, 3, 9, 9, 28, 39]", "assert sort_array([6, 9, 13, 16, 37]) == [16, 6, 9, 13, 37]", "assert sort_array([6, 9, 2, 6, 7]) == [2, 6, 6, 9, 7]", "assert sort_array([5, 3, 12, 17, 37]) == [3, 5, 12, 17, 37]", "assert sort_array([2, 9, 12, 15, 31]) == [2, 9, 12, 15, 31]", "assert sort_array([3, 6, 72, 3, 7, 6, 7, 6, 3, 8, 3]) == [8, 3, 3, 3, 3, 6, 6, 6, 72, 7, 7]", "assert sort_array([3, -3, -7, -6, -3]) == [-6, -3, -3, 3, -7]", "assert sort_array([4, 3, 4, 4, 1]) == [1, 4, 4, 4, 3]", "assert sort_array([-1, 1, -4, -6, -6]) == [-4, -1, 1, -6, -6]", "assert sort_array([4, 1, 6, 16, 30]) == [1, 4, 16, 6, 30]", "assert sort_array([2, 9, 1, 8, 8]) == [1, 2, 8, 8, 9]", "assert sort_array([5, 3, 2, 1, 7]) == [1, 2, 3, 5, 7]", "assert sort_array([3, 1, 6, 7, 7]) == [1, 3, 6, 7, 7]", "assert sort_array([1, 5, 3, 5, 1]) == [1, 1, 3, 5, 5]", "assert sort_array([1,5,2,3,4]) == [1, 2, 4, 3, 5]", "assert sort_array([]) == []", "assert sort_array([1, 10, 74, 7, 1, 2, 1, 2, 6, 6, 1]) == [1, 1, 1, 1, 2, 2, 6, 6, 10, 7, 74]", "assert sort_array([4, 4, 5, 4, 1]) == [1, 4, 4, 4, 5]", "assert sort_array([-4, 0, -1, -4, -7]) == [0, -4, -4, -1, -7]", "assert sort_array([4, 11, 45, 13, 29, 8]) == [4, 8, 11, 13, 29, 45]", "assert sort_array([3, 6, 3, 1, 7]) == [1, 3, 3, 6, 7]", "assert sort_array([2, 8, 76, 4, 7, 6, 6, 8, 6, 2, 8]) == [2, 2, 4, 8, 8, 8, 6, 6, 6, 7, 76]", "assert sort_array([1, 8, 7, 2, 3]) == [1, 2, 8, 3, 7]"], "nl": "\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    ", "func": "def sort_array(arr):", "examples": ">>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    ", "repair_prompt": ["def sort_array(arr):\t\n'''In this Kata, you have to sort an array of non-negative integers according to the number of ones in their binary representation in ascending order. You are given an array with non-negative integers in it. You need to sort them based on the count of ones in their binary representation. For similar number of ones, sort based on decimal value.\n\nIt must be implemented like this:\n>>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    For numbers with the same number of ones, sorts by decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    def count_ones(n: int) -> int:\n        \"\"\"Returns the number of ones in the binary representation of a number.\"\"\"\n        return bin(n).count('1')\n\n    # Use sorted with a custom key that sorts by the number of ones, then by the number itself\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_array = [3, 7, 8, 9, 1, 2]\n    sorted_example = sort_array(example_array)\n    print(f\"Sorted array: {sorted_example}\")\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    If two numbers have the same number of ones, they are sorted by their decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    # Define a custom key function for sorting\n    def sort_key(x: int) -> tuple:\n        # Count the number of ones in the binary representation of x\n        ones_count = bin(x).count('1')\n        # Return a tuple (number of ones, original number) for sorting\n        return (ones_count, x)\n\n    # Use the sorted function with the custom key\n    sorted_arr = sorted(arr, key=sort_key)\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_array = [3, 7, 8, 9, 1, 2]\n    sorted_array = sort_array(example_array)\n    print(f\"Sorted array: {sorted_array}\")\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    If two numbers have the same number of ones, they are sorted by their decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    # Define a custom key function for sorting\n    def custom_sort_key(x: int) -> tuple:\n        # Count the number of ones in the binary representation of x\n        ones_count = bin(x).count('1')\n        # Return a tuple (number of ones, original number) for sorting\n        return (ones_count, x)\n\n    # Use the sorted function with the custom key\n    sorted_array = sorted(arr, key=custom_sort_key)\n    return sorted_array\n\n# Example usage\nif __name__ == \"__main__\":\n    example_array = [3, 7, 8, 9, 1, 2]\n    sorted_result = sort_array(example_array)\n    print(f\"Sorted array: {sorted_result}\")\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    If two numbers have the same number of ones, they are sorted by their decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    # Define a custom key function for sorting\n    def sort_key(x: int) -> tuple[int, int]:\n        # Count the number of ones in the binary representation of the number\n        num_ones = bin(x).count('1')\n        # Return a tuple with the number of ones and the number itself for sorting\n        return (num_ones, x)\n\n    # Use the sorted function with the custom key to sort the array\n    sorted_arr = sorted(arr, key=sort_key)\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test cases\n    print(sort_array([1, 5, 2, 3, 4]))  # Expected output: [1, 2, 4, 3, 5]\n    print(sort_array([1, 0, 2, 3, 4]))  # Expected output: [0, 1, 2, 4, 3]\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    For numbers with the same count of ones, sorts by decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    # Define a custom key function for sorting\n    def sort_key(x: int) -> tuple[int, int]:\n        # Count the number of ones in the binary representation of the number\n        ones_count = bin(x).count('1')\n        # Return a tuple with the count of ones and the number itself\n        return (ones_count, x)\n\n    # Use the sorted function with the custom key to sort the array\n    sorted_arr = sorted(arr, key=sort_key)\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example1 = [1, 5, 2, 3, 4]\n    example2 = [1, 0, 2, 3, 4]\n    \n    print(sort_array(example1))  # Output: [1, 2, 3, 4, 5]\n    print(sort_array(example2))  # Output: [0, 1, 2, 3, 4]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    For numbers with the same count of ones, sorts based on decimal value.\n\n    Parameters:\n    arr (List[int]): A list of non-negative integers.\n\n    Returns:\n    List[int]: A sorted list of integers.\n    \"\"\"\n    def count_ones(n: int) -> int:\n        \"\"\"Helper function to count the number of ones in the binary representation of a number.\"\"\"\n        return bin(n).count('1')\n\n    # Sort the array using a custom key: first by the number of ones, then by the number itself\n    sorted_array = sorted(arr, key=lambda x: (count_ones(x), x))\n    return sorted_array\n\n# Example usage:\n# if __name__ == \"__main__\":\n#     example_array = [3, 7, 8, 9]\n#     print(sort_array(example_array))  # Output: [8, 3, 9, 7]\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    If two numbers have the same number of ones, they are sorted by their decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    # Define a custom key function for sorting\n    def sort_key(x: int) -> tuple[int, int]:\n        # Count the number of ones in the binary representation of x\n        num_ones = bin(x).count('1')\n        # Return a tuple (number of ones, original number) for sorting\n        return (num_ones, x)\n\n    # Use the sorted function with the custom key\n    sorted_arr = sorted(arr, key=sort_key)\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test cases\n    example1 = [1, 5, 2, 3, 4]\n    example2 = [1, 0, 2, 3, 4]\n\n    # Print sorted arrays\n    print(sort_array(example1))  # Output: [1, 2, 4, 3, 5]\n    print(sort_array(example2))  # Output: [0, 1, 2, 4, 3]\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    If two numbers have the same number of ones, they are sorted by their decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    def count_ones(n: int) -> int:\n        \"\"\"Helper function to count the number of ones in the binary representation of a number.\"\"\"\n        return bin(n).count('1')\n\n    # Sort the array using a custom key\n    # The key is a tuple (number of ones, decimal value)\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_array = [3, 7, 8, 9, 1, 2]\n    sorted_example = sort_array(example_array)\n    print(f\"Sorted array: {sorted_example}\")\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    If two numbers have the same number of ones, they are sorted by their decimal value.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    # Define a custom key function for sorting\n    def sort_key(x: int) -> tuple:\n        # Count the number of ones in the binary representation of x\n        ones_count = bin(x).count('1')\n        # Return a tuple (number of ones, original number) for sorting\n        return (ones_count, x)\n\n    # Use the sorted function with the custom key\n    sorted_arr = sorted(arr, key=sort_key)\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_array = [3, 7, 8, 9]\n    sorted_array = sort_array(example_array)\n    print(f\"Sorted array: {sorted_array}\")\n", "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    Ties are broken by the decimal value of the numbers.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    def count_ones(n: int) -> int:\n        \"\"\"Counts the number of ones in the binary representation of a number.\n\n        Parameters:\n        n (int): A non-negative integer.\n\n        Returns:\n        int: The count of ones in the binary representation of the number.\n        \"\"\"\n        return bin(n).count('1')\n\n    # Sort the array using a custom key\n    # The key is a tuple (number of ones, decimal value)\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_array = [3, 7, 8, 9, 1, 2]\n    sorted_example = sort_array(example_array)\n    print(f\"Sorted array: {sorted_example}\")\n"], "plans": ["requirement analysis:\nThe requirement is to sort an array of non-negative integers based on the number of ones in their binary representation. The function should handle edge cases such as empty arrays and arrays with duplicate values. It should also be optimized for performance with large datasets.\nrequirement pool:\n- Implement the sorting algorithm based on binary ones count.\n- Optimize the algorithm for large datasets.\n- Provide comprehensive documentation and examples.\n- Ensure compatibility with various Python versions.\n- Include unit tests to verify functionality.\nWe will implement a function that sorts an array of non-negative integers based on the number of ones in their binary representation. For numbers with the same count of ones, we will sort them by their decimal value. We will use Python's built-in sorted function with a custom key to achieve this efficiently. This approach leverages Python's Timsort algorithm, which is highly efficient for large datasets.\n", "requirement analysis:\nThe function needs to sort arrays based on the number of ones in their binary representation, with ties broken by decimal value. It should handle non-negative integers efficiently and provide clear examples for users.\nrequirement pool:\n- Implement sorting based on binary representation\n- Optimize for performance with large arrays\n- Provide clear documentation and examples\n- Ensure compatibility with Python's list data structure\n- Consider edge cases like empty arrays\nWe will implement a function that sorts an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they will be sorted by their decimal value. We will use Python's built-in sorted function with a custom key to achieve this. This approach is efficient and leverages Python's optimized sorting algorithms.\n", "requirement analysis:\nThe function should sort an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they should be sorted by their decimal value. The function should handle edge cases such as empty arrays and arrays with duplicate values.\nrequirement pool:\n- Implement the sorting logic based on binary ones count\n- Optimize the function for performance with large arrays\n- Ensure the function handles edge cases like empty arrays\n- Provide comprehensive documentation and examples\n- Include unit tests to verify functionality\nWe will implement a function that sorts an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they will be sorted by their decimal value. We will use Python's built-in sorted function with a custom key to achieve this. The function will handle edge cases such as empty arrays and arrays with duplicate values. We will not handle negative numbers as they contradict the non-negative integer constraint.\n", "requirement analysis:\nThe function should sort an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they should be sorted by their decimal value. The function should handle edge cases such as empty arrays and arrays with duplicate values.\nrequirement pool:\n- Implement the main sorting logic based on binary ones count\n- Optimize the function for performance with large datasets\n- Ensure the function handles edge cases like empty arrays\n- Provide comprehensive documentation and examples\n- Write unit tests to validate the function's correctness\nWe will implement a function that sorts an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they will be sorted by their decimal value. We will use Python's built-in sorted() function with a custom key to achieve this. The function will handle edge cases such as empty arrays and arrays with duplicate values. We will not handle negative numbers as they contradict the non-negative integer constraint.\n", "requirement analysis:\nThe requirement is to sort an array of non-negative integers based on the number of ones in their binary representation. The function should handle edge cases such as empty arrays and arrays with duplicate values. It should also be efficient in terms of time complexity.\nrequirement pool:\n- Implement the sorting algorithm based on binary ones count.\n- Optimize the algorithm for large datasets.\n- Ensure the function is compatible with Python 3.x.\n- Provide comprehensive documentation and examples.\n- Include unit tests to verify functionality.\nWe will implement a function that sorts an array of non-negative integers based on the number of ones in their binary representation. For numbers with the same count of ones, we will sort them by their decimal value. We will use Python's built-in sorted() function with a custom key to achieve this efficiently. This approach ensures compatibility with Python 3.x and handles large datasets effectively.\n", "requirement analysis:\nThe requirement is to sort an array of non-negative integers based on the number of ones in their binary representation. The function should handle edge cases such as empty arrays and arrays with duplicate values. It should also be optimized for performance, especially with large datasets.\nrequirement pool:\n- Implement the sorting algorithm based on binary ones count.\n- Optimize the algorithm for large datasets.\n- Provide comprehensive documentation and examples.\n- Include error handling for invalid inputs.\n- Test the function with a variety of test cases.\nWe will use Python's built-in sorted function with a custom key to sort the array based on the number of ones in the binary representation. This approach is efficient and leverages Python's optimized sorting capabilities. We will ensure the function handles large datasets efficiently by using the Timsort algorithm, which is the default sorting algorithm in Python and is well-suited for real-time applications.\n", "requirement analysis:\nThe requirement is to sort an array of non-negative integers based on the number of ones in their binary representation. The function should handle edge cases such as empty arrays and arrays with duplicate values. It should also be optimized for performance with large datasets.\nrequirement pool:\n- Implement the sorting algorithm based on binary ones count.\n- Optimize the algorithm for large datasets.\n- Provide comprehensive documentation and examples.\n- Include error handling for invalid inputs.\n- Test the function with a variety of test cases.\nWe will use Python's built-in sorted function with a custom key to sort the array based on the number of ones in the binary representation. This approach is efficient and leverages Python's highly optimized sorting algorithm. We will ensure the function handles edge cases such as empty arrays and arrays with duplicate values. The function will also be documented with examples to enhance understanding.\n", "requirement analysis:\nThe function needs to sort an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they should be sorted by their decimal value. The function should handle edge cases such as empty arrays and arrays with duplicate values.\nrequirement pool:\n- Implement the sorting algorithm based on binary ones count.\n- Optimize the function for large input arrays.\n- Provide comprehensive documentation and examples.\n- Ensure compatibility with Python 3.x versions.\n- Include unit tests to verify functionality.\nWe will implement a sorting function that sorts an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they will be sorted by their decimal value. We will use Python's built-in sorted() function with a custom key to achieve this efficiently. This approach leverages Python's Timsort algorithm, which is highly efficient for real-world data. We will ensure compatibility with Python 3.x versions and provide comprehensive documentation and examples.\n", "requirement analysis:\nThe function should sort an array of non-negative integers based on the number of ones in their binary representation. If two numbers have the same number of ones, they should be sorted by their decimal value. The function should handle edge cases such as empty arrays and arrays with duplicate values.\nrequirement pool:\n- Implement the sorting algorithm based on binary ones count.\n- Optimize the function for performance with large arrays.\n- Write comprehensive documentation and examples.\n- Ensure compatibility with Python 3.x versions.\n- Include unit tests for edge cases.\nWe will implement a function that sorts an array of non-negative integers based on the number of ones in their binary representation. For numbers with the same count of ones, we will sort them by their decimal value. We will use Python's built-in sorted() function with a custom key to achieve this efficiently. This approach ensures compatibility with various Python versions and handles large arrays effectively.\n", "requirement analysis:\nThe function should accurately sort arrays based on the number of ones in their binary representation, ensuring that ties are broken by decimal value. It should handle non-negative integers and provide examples for clarity.\nrequirement pool:\n- Implement sorting based on binary representation\n- Ensure tie-breaking by decimal value\n- Optimize for large arrays\n- Provide clear documentation\n- Include usage examples\nWe will implement a function that sorts an array of non-negative integers based on the number of ones in their binary representation. For numbers with the same count of ones, we will sort them by their decimal value. We will use Python's built-in sorted function with a custom key to achieve this. This approach is efficient and leverages Python's robust sorting capabilities.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [113, 113, 113, 113, 113, 113, 113, 113, 113, 113], "completion": "from typing import List\n## main.py\n\ndef sort_array(arr: list[int]) -> list[int]:\n    \"\"\"Sorts an array of non-negative integers based on the number of ones in their binary representation.\n    Ties are broken by the decimal value of the numbers.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A sorted list of integers.\n    \"\"\"\n    def count_ones(n: int) -> int:\n        \"\"\"Counts the number of ones in the binary representation of a number.\n\n        Parameters:\n        n (int): A non-negative integer.\n\n        Returns:\n        int: The count of ones in the binary representation of the number.\n        \"\"\"\n        return bin(n).count('1')\n\n    # Sort the array using a custom key\n    # The key is a tuple (number of ones, decimal value)\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_array = [3, 7, 8, 9, 1, 2]\n    sorted_example = sort_array(example_array)\n    print(f\"Sorted array: {sorted_example}\")\n", "passed": true, "pass": true, "pass_num": 10, "round": 98, "mutate_method": "expand_one2two", "parent_index": 98}
