{"task_id": "HumanEval/55", "prompt": "def fib(n: int):\t\n'''Return the n-th Fibonacci number. The Fibonacci sequence is a famous sequence in mathematics. It starts with 0 and 1, and each subsequent number is the sum of the previous two numbers.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''", "entry_point": "fib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "test": ["def check(fib):\n\tassert fib(29) == 514229", "def check(fib):\n\tassert fib(25) == 75025", "def check(fib):\n\tassert fib(34) == 5702887", "def check(fib):\n\tassert fib(7) == 13", "def check(fib):\n\tassert fib(32) == 2178309", "def check(fib):\n\tassert fib(27) == 196418", "def check(fib):\n\tassert fib(16) == 987", "def check(fib):\n\tassert fib(14) == 377", "def check(fib):\n\tassert fib(33) == 3524578", "def check(fib):\n\tassert fib(20) == 6765", "def check(fib):\n\tassert fib(8) == 21", "def check(fib):\n\tassert fib(31) == 1346269", "def check(fib):\n\tassert fib(6) == 8", "def check(fib):\n\tassert fib(17) == 1597", "def check(fib):\n\tassert fib(2) == 1", "def check(fib):\n\tassert fib(1) == 1", "def check(fib):\n\tassert fib(30) == 832040", "def check(fib):\n\tassert fib(11) == 89", "def check(fib):\n\tassert fib(3) == 2", "def check(fib):\n\tassert fib(19) == 4181", "def check(fib):\n\tassert fib(21) == 10946", "def check(fib):\n\tassert fib(4) == 3", "def check(fib):\n\tassert fib(10) == 55", "def check(fib):\n\tassert fib(12) == 144", "def check(fib):\n\tassert fib(9) == 34", "def check(fib):\n\tassert fib(13) == 233", "def check(fib):\n\tassert fib(0) == 0", "def check(fib):\n\tassert fib(15) == 610", "def check(fib):\n\tassert fib(22) == 17711", "def check(fib):\n\tassert fib(24) == 46368", "def check(fib):\n\tassert fib(18) == 2584", "def check(fib):\n\tassert fib(28) == 317811", "def check(fib):\n\tassert fib(35) == 9227465"], "test_case_list": ["assert fib(29) == 514229", "assert fib(25) == 75025", "assert fib(34) == 5702887", "assert fib(7) == 13", "assert fib(32) == 2178309", "assert fib(27) == 196418", "assert fib(16) == 987", "assert fib(14) == 377", "assert fib(33) == 3524578", "assert fib(20) == 6765", "assert fib(8) == 21", "assert fib(31) == 1346269", "assert fib(6) == 8", "assert fib(17) == 1597", "assert fib(2) == 1", "assert fib(1) == 1", "assert fib(30) == 832040", "assert fib(11) == 89", "assert fib(3) == 2", "assert fib(19) == 4181", "assert fib(21) == 10946", "assert fib(4) == 3", "assert fib(10) == 55", "assert fib(12) == 144", "assert fib(9) == 34", "assert fib(13) == 233", "assert fib(0) == 0", "assert fib(15) == 610", "assert fib(22) == 17711", "assert fib(24) == 46368", "assert fib(18) == 2584", "assert fib(28) == 317811", "assert fib(35) == 9227465"], "nl": "Return n-th Fibonacci number.\n    ", "func": "def fib(n: int):", "examples": ">>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    ", "repair_prompt": ["def fib(n: int):\t\n'''Return the n-th Fibonacci number. The Fibonacci sequence is a famous sequence in mathematics. It starts with 0 and 1, and each subsequent number is the sum of the previous two numbers.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    This function computes the Fibonacci sequence iteratively to ensure efficiency,\n    especially for large input values. It avoids the overhead of recursive function calls\n    and stack overflow issues. The function includes input validation to handle non-integer\n    and negative values gracefully.\n    \n    :param n: The position in the Fibonacci sequence (must be a non-negative integer).\n    :return: The n-th Fibonacci number.\n    :raises ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n\n# Example usage:\n# try:\n#     result = fib(10)\n#     print(f\"The 10th Fibonacci number is: {result}\")\n# except ValueError as e:\n#     print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative or not an integer.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    This function uses an iterative method to compute the Fibonacci sequence,\n    which is more efficient for large inputs compared to a recursive approach.\n\n    Args:\n        n (int): The position in the Fibonacci sequence.\n\n    Returns:\n        int: The n-th Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n\n# Example usage:\n# print(fib(10))  # Output: 34\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    This function computes the Fibonacci sequence iteratively to avoid\n    the overhead of recursive calls and potential stack overflow issues.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n        \n    Returns:\n        int: The n-th Fibonacci number.\n        \n    Raises:\n        ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    # Validate input\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Iterative calculation\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n\n# Example usage:\n# print(fib(10))  # Output: 55\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Compute the n-th Fibonacci number using an iterative approach with memoization.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence to compute. Must be a non-negative integer.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Memoization dictionary to store computed Fibonacci numbers\n    memo = {0: 0, 1: 1}\n\n    # Iterative computation of Fibonacci numbers\n    for i in range(2, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n\n    return memo[n]\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        print(fib(10))  # Output: 55\n        print(fib(1))   # Output: 1\n        print(fib(8))   # Output: 21\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Iterative approach to calculate Fibonacci number\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence to calculate.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The position in the Fibonacci sequence must be a positive integer.\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n\n    # Initialize the memoization array with base cases\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    memo[2] = 1\n\n    # Iteratively compute Fibonacci numbers and store them in the memo array\n    for i in range(3, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n\n    return memo[n]\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        print(fib(10))  # Output: 55\n        print(fib(1))   # Output: 1\n        print(fib(8))   # Output: 21\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative or not an integer.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Iterative approach with memoization\n    fib_numbers = [0, 1]  # Initializing the first two Fibonacci numbers\n    for i in range(2, n + 1):\n        fib_numbers.append(fib_numbers[i - 1] + fib_numbers[i - 2])\n\n    return fib_numbers[n]\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        print(fib(10))  # Output: 55\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    This function efficiently computes the Fibonacci number at position n\n    using an iterative method, which is suitable for large inputs.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence to calculate.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n\n    prev, curr = 1, 1\n    for _ in range(3, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative or not an integer.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n"], "plans": ["requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle both small and large input values and provide accurate results. Additionally, the function should be easy to use and understand, with clear documentation and examples.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance with large inputs\n- Create a user-friendly interface for input and output\n- Provide educational content on the Fibonacci sequence\n- Include examples of Fibonacci numbers for various inputs\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. The function will include input validation to handle non-integer and negative values gracefully.\n", "requirement analysis:\nThe function should efficiently compute the n-th Fibonacci number using an iterative approach to handle large inputs. It should be well-documented to aid understanding and integration into other projects.\nrequirement pool:\n- Implement the Fibonacci function using an iterative approach.\n- Optimize the function for performance with large input values.\n- Provide comprehensive documentation and examples.\n- Include error handling for invalid inputs.\n- Consider adding a recursive implementation for educational purposes.\nWe will implement the Fibonacci function using an iterative approach to ensure efficient computation for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. Comprehensive documentation will be provided to aid understanding and integration.\n", "requirement analysis:\nThe requirement is to implement a function that calculates the n-th Fibonacci number. The function should be efficient and handle large inputs gracefully. Documentation should be clear to help users understand the sequence generation.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance\n- Provide comprehensive documentation\n- Ensure the function handles edge cases\n- Create a user-friendly interface for demonstration\nWe will implement the Fibonacci calculation using an iterative approach to optimize performance for large inputs. This approach avoids the overhead of recursive calls and stack usage, making it more efficient for handling large numbers. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. Comprehensive documentation will be provided to explain the sequence generation and usage of the function.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases such as n=0 and n=1, and should be optimized for larger values of n. The user should be able to understand the sequence generation process through examples.\nrequirement pool:\n- Implement the Fibonacci function to return the n-th number\n- Optimize the function for performance with large inputs\n- Provide examples and explanations of the Fibonacci sequence\n- Design a user-friendly interface for input and output\n- Include error handling for invalid inputs\nWe will implement a function to compute the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also include basic error handling for invalid inputs such as negative numbers or non-integer values.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle large inputs gracefully and provide clear documentation for users.\nrequirement pool:\n- Implement Fibonacci computation algorithm\n- Optimize for large input values\n- Provide user documentation and examples\n- Ensure code readability and maintainability\n- Include error handling for invalid inputs\nWe will implement the Fibonacci computation using an iterative approach to ensure efficient performance for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also use memoization to store previously computed Fibonacci numbers to further optimize performance. The function will include error handling for invalid inputs and provide clear documentation with examples.\n", "requirement analysis:\nThe requirement is to implement a function that returns the n-th Fibonacci number. The function should handle edge cases such as n=0 and n=1, and should be optimized for performance to handle large values of n efficiently.\nrequirement pool:\n- Implement the Fibonacci function to return the n-th number in the sequence.\n- Optimize the function for performance with large input values.\n- Provide comprehensive documentation and examples.\n- Include error handling for invalid inputs.\n- Create a user-friendly interface for the function.\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to optimize performance for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. The function will include error handling for invalid inputs, such as negative numbers, by raising a ValueError.\n", "requirement analysis:\nThe requirement is to implement a function that calculates the n-th Fibonacci number. The function should be efficient, especially for large values of n, and should be easy to understand and use.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large inputs\n- Provide comprehensive documentation\n- Include examples and edge cases in documentation\n- Ensure compatibility with existing Python libraries\nWe will implement the Fibonacci calculation using an iterative approach to ensure efficiency, especially for large inputs. This approach avoids the overhead of recursive function calls and stack depth issues. We will also use memoization to store previously computed Fibonacci numbers to further optimize performance. The function will be documented with examples and explanations of the Fibonacci sequence.\n", "requirement analysis:\nThe requirement is to implement a function that returns the n-th Fibonacci number. The function should be efficient and handle large values of n. It should also be well-documented to facilitate understanding and integration.\nrequirement pool:\n- Implement the Fibonacci function to return the n-th number\n- Optimize the function for performance with large inputs\n- Provide comprehensive documentation and examples\n- Include error handling for invalid inputs\n- Ensure compatibility with different Python versions\nWe will implement the Fibonacci function using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also use memoization to store previously computed Fibonacci numbers to further optimize performance. The function will include comprehensive documentation and examples to facilitate understanding and integration. We will use Python's built-in capabilities without additional libraries to keep the implementation simple and compatible across different Python versions.\n", "requirement analysis:\nThe requirement is to implement a function that accurately calculates the n-th Fibonacci number. The function should be efficient and handle large inputs gracefully. Documentation should be clear, with examples to aid understanding.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance\n- Provide comprehensive documentation\n- Include examples in the documentation\n- Ensure the function handles edge cases\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to ensure efficiency and handle large inputs gracefully. The function will be documented with examples and edge case handling. We will use Python's built-in capabilities to handle large integers, ensuring performance and accuracy.\n", "requirement analysis:\nThe requirement is to implement a function that returns the n-th Fibonacci number. The function should be efficient and handle large inputs gracefully. It should also be well-documented to facilitate understanding and integration.\nrequirement pool:\n- Implement the Fibonacci function to return the n-th number.\n- Optimize the function for performance with large inputs.\n- Ensure the function is well-documented and easy to understand.\n- Provide examples and test cases for the function.\n- Consider edge cases and error handling.\nWe will implement the Fibonacci function using an iterative approach to optimize performance for large inputs. This approach avoids the overhead of recursive function calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. The function will include detailed docstrings for documentation and will handle edge cases such as non-integer and negative inputs by raising appropriate exceptions.\n"], "scores": [1.0, 1.0, 0.0303, 1.0, 1.0, 1.0, 0.9697, 1.0, 0.9697, 1.0], "pass_results": [true, true, false, true, true, true, false, true, false, true], "pass_test_cases_num": [33, 33, 1, 33, 33, 33, 32, 33, 32, 33], "completion": "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative or not an integer.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n", "passed": true, "pass": true, "pass_num": 7, "round": 906, "mutate_method": "expand_one2two", "parent_index": 375}
