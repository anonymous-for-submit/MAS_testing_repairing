{"task_id": "HumanEval/160", "prompt": "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The initial list consists of fundamental algebraic operations, while the following list contains integers. Use the two given lists to build the algebric expression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": ["def check(do_algebra):\n\tassert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [8, 8, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [5, 1, 6]) == 5", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [12, 1, 6]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [2, 5, 7]) == 17", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [2, 3, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [6, 2, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [8, 2, 7]) == -120", "def check(do_algebra):\n\tassert do_algebra(['//', '**'], [4, 4, 4]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [5, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 2, 7]) == 71", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [9, 3, 8]) == 35", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "def check(do_algebra):\n\tassert do_algebra(['*', '-'], [6, 5, 7]) == 23", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "def check(do_algebra):\n\tassert do_algebra(['-', '*'], [3, 3, 6]) == -15", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 5, 2]) == -22", "def check(do_algebra):\n\tassert do_algebra(['+', '*'], [7, 3, 6]) == 25", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [3, 2, 8]) == 768", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [7, 3, 3]) == 189", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [8, 4, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [8, 2, 2]) == 128", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [3, 4, 4]) == 3", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [10, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [7, 3, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '-'], [6, 1, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [3, 7, 6]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "def check(do_algebra):\n\tassert do_algebra(['*', '*'], [5, 2, 7]) == 70", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 3, 4]) == -78", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [2, 7, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [10, 2, 8]) == 800", "def check(do_algebra):\n\tassert do_algebra(['+', '//'], [3, 6, 4]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 3, 5]) == 250", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [7, 3, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [3, 2, 4]) == 19", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "def check(do_algebra):\n\tassert do_algebra(['**', '-'], [3, 2, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "def check(do_algebra):\n\tassert do_algebra(['+', '+'], [4, 4, 1]) == 9", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [10, 7, 1]) == 4", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [8, 4, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [4, 8, 4]) == 36", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "test_case_list": ["assert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "assert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "assert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "assert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "assert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "assert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "assert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "assert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "assert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "assert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "assert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "assert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "assert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "assert do_algebra(['//', '//'], [8, 8, 7]) == 0", "assert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "assert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "assert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "assert do_algebra(['*', '**'], [5, 1, 6]) == 5", "assert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "assert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "assert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "assert do_algebra(['**', '//'], [12, 1, 6]) == 2", "assert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "assert do_algebra(['*', '+'], [2, 5, 7]) == 17", "assert do_algebra(['**', '*'], [2, 3, 1]) == 8", "assert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "assert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "assert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "assert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "assert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "assert do_algebra(['-', '**'], [6, 2, 2]) == 2", "assert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "assert do_algebra(['-', '**'], [8, 2, 7]) == -120", "assert do_algebra(['//', '**'], [4, 4, 4]) == 0", "assert do_algebra(['-', '//'], [5, 3, 8]) == 5", "assert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "assert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "assert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "assert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "assert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "assert do_algebra(['**', '+'], [8, 2, 7]) == 71", "assert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "assert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "assert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "assert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "assert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "assert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "assert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "assert do_algebra(['*', '+'], [9, 3, 8]) == 35", "assert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "assert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "assert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "assert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "assert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "assert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "assert do_algebra(['*', '-'], [6, 5, 7]) == 23", "assert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "assert do_algebra(['-', '*'], [3, 3, 6]) == -15", "assert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "assert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "assert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "assert do_algebra(['-', '**'], [3, 5, 2]) == -22", "assert do_algebra(['+', '*'], [7, 3, 6]) == 25", "assert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "assert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "assert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "assert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "assert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "assert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "assert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "assert do_algebra(['*', '**'], [3, 2, 8]) == 768", "assert do_algebra(['*', '**'], [7, 3, 3]) == 189", "assert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "assert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "assert do_algebra(['-', '+'], [8, 4, 3]) == 7", "assert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "assert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "assert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "assert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "assert do_algebra(['**', '*'], [8, 2, 2]) == 128", "assert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "assert do_algebra(['-', '+'], [3, 4, 4]) == 3", "assert do_algebra(['+', '-'], [10, 3, 8]) == 5", "assert do_algebra(['//', '*'], [7, 3, 4]) == 8", "assert do_algebra(['//', '-'], [6, 1, 2]) == 4", "assert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "assert do_algebra(['+', '-'], [3, 7, 6]) == 4", "assert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "assert do_algebra(['*', '*'], [5, 2, 7]) == 70", "assert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "assert do_algebra(['-', '**'], [3, 3, 4]) == -78", "assert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "assert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "assert do_algebra(['//', '//'], [2, 7, 1]) == 0", "assert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "assert do_algebra(['**', '*'], [10, 2, 8]) == 800", "assert do_algebra(['+', '//'], [3, 6, 4]) == 4", "assert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "assert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "assert do_algebra(['+', '**'], [7, 3, 5]) == 250", "assert do_algebra(['-', '//'], [7, 3, 2]) == 6", "assert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "assert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "assert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "assert do_algebra(['+', '**'], [3, 2, 4]) == 19", "assert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "assert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "assert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "assert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "assert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "assert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "assert do_algebra(['**', '-'], [3, 2, 9]) == 0", "assert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "assert do_algebra(['+', '+'], [4, 4, 1]) == 9", "assert do_algebra(['-', '+'], [10, 7, 1]) == 4", "assert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "assert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "assert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "assert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "assert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "assert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "assert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "assert do_algebra(['//', '*'], [8, 4, 2]) == 4", "assert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "assert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "assert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "assert do_algebra(['*', '+'], [4, 8, 4]) == 36", "assert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "nl": "\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    ", "func": "def do_algebra(operator, operand):", "examples": "Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    ", "repair_prompt": ["def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The initial list consists of fundamental algebraic operations, while the following list contains integers. Use the two given lists to build the algebric expression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists are not compatible or if division by zero occurs.\n    \"\"\"\n    # Validate input lists\n    if len(operator) + 1 != len(operand):\n        raise ValueError(\"The number of operands must be one more than the number of operators.\")\n    \n    # Construct expression string\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        if op not in ['+', '-', '*', '//', '**']:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        expression += f\" {op} {operand[i + 1]}\"\n    \n    # Evaluate expression using eval\n    try:\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ValueError(\"Division by zero occurred in the expression.\")\n    except Exception as e:\n        raise ValueError(f\"An error occurred while evaluating the expression: {e}\")\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers representing the operands.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to their corresponding functions in the operator module\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate over operators and operands to compute the result\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n        \n        # Get the corresponding function for the operator\n        operation = operator_map[op]\n        \n        # Apply the operation to the current result and the next operand\n        result = operation(result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression using the given operators and operands.\n\n    This function respects the order of operations (PEMDAS/BODMAS) and utilizes\n    Python's built-in capabilities for arithmetic operations.\n\n    Parameters:\n    operator (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    if not operator or not operand or len(operator) != len(operand) - 1:\n        raise ValueError(\"Invalid input: operators and operands must be non-empty and properly matched.\")\n\n    # Helper function to perform a single operation\n    def apply_operation(op: str, a: int, b: int) -> int:\n        if op == '+':\n            return a + b\n        elif op == '-':\n            return a - b\n        elif op == '*':\n            return a * b\n        elif op == '//':\n            if b == 0:\n                raise ZeroDivisionError(\"Division by zero is undefined.\")\n            return a // b\n        elif op == '**':\n            return a ** b\n        else:\n            raise ValueError(f\"Unsupported operator: {op}\")\n\n    # Process the operations respecting the order of operations\n    # First handle '**' (exponentiation)\n    i = 0\n    while i < len(operator):\n        if operator[i] == '**':\n            operand[i] = apply_operation(operator[i], operand[i], operand[i + 1])\n            del operand[i + 1]\n            del operator[i]\n        else:\n            i += 1\n\n    # Then handle '*' and '//'\n    i = 0\n    while i < len(operator):\n        if operator[i] in ('*', '//'):\n            operand[i] = apply_operation(operator[i], operand[i], operand[i + 1])\n            del operand[i + 1]\n            del operator[i]\n        else:\n            i += 1\n\n    # Finally handle '+' and '-'\n    i = 0\n    while i < len(operator):\n        operand[i] = apply_operation(operator[i], operand[i], operand[i + 1])\n        del operand[i + 1]\n        del operator[i]\n\n    return operand[0]\n\n# Example usage:\n# result = do_algebra(['+', '*', '**'], [2, 3, 4, 2])\n# print(result)  # Output should be 50\n", "from typing import List\n## main.py\n\nimport operator\n\ndef do_algebra(operator_list: list[str], operand_list: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n    \n    Args:\n        operator_list: List of strings representing algebraic operations ('+', '-', '*', '//', '**').\n        operand_list: List of non-negative integers.\n    \n    Returns:\n        The result of the evaluated expression as an integer.\n    \n    Raises:\n        ValueError: If the operator_list contains invalid operators or operand_list contains negative integers.\n    \"\"\"\n    # Validate input lengths\n    if len(operator_list) != len(operand_list) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Validate operators and operands\n    valid_operators = {'+', '-', '*', '//', '**'}\n    for op in operator_list:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator: {op}\")\n    \n    for num in operand_list:\n        if num < 0:\n            raise ValueError(f\"Invalid operand: {num} (must be non-negative)\")\n    \n    # Map operators to functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Evaluate expression using mapped functions\n    result = operand_list[0]\n    for i, op in enumerate(operator_list):\n        func = operator_map[op]\n        result = func(result, operand_list[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists are not correctly formatted.\n    \"\"\"\n    if not operator or not operand:\n        raise ValueError(\"Operator and operand lists cannot be empty.\")\n    \n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operand[0]\n    \n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operator):\n        if op not in ['+', '-', '*', '//', '**']:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        \n        if op == '+':\n            result += operand[i + 1]\n        elif op == '-':\n            result -= operand[i + 1]\n        elif op == '*':\n            result *= operand[i + 1]\n        elif op == '//':\n            if operand[i + 1] == 0:\n                raise ValueError(\"Division by zero is not allowed.\")\n            result //= operand[i + 1]\n        elif op == '**':\n            result **= operand[i + 1]\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n    \n    Args:\n        operator: A list of strings representing basic algebraic operations ('+', '-', '*', '//', '**').\n        operand: A list of integers representing the operands.\n    \n    Returns:\n        The result of the evaluated expression as an integer.\n    \"\"\"\n    if not operator or not operand or len(operator) != len(operand) - 1:\n        raise ValueError(\"Invalid input: operators and operands must be non-empty and properly matched.\")\n\n    # Initialize the result with the first operand\n    result = operand[0]\n\n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operator):\n        if op == '+':\n            result += operand[i + 1]\n        elif op == '-':\n            result -= operand[i + 1]\n        elif op == '*':\n            result *= operand[i + 1]\n        elif op == '//':\n            if operand[i + 1] == 0:\n                raise ZeroDivisionError(\"Division by zero is not allowed.\")\n            result //= operand[i + 1]\n        elif op == '**':\n            result **= operand[i + 1]\n        else:\n            raise ValueError(f\"Unsupported operator: {op}\")\n\n    return result\n\n# Example usage:\n# operators = ['+', '*', '**']\n# operands = [2, 3, 4, 2]\n# result = do_algebra(operators, operands)\n# print(result)  # Output: 100\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers to be used in the expression.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Validate input\n    if not all(isinstance(op, str) and op in operator_map for op in operators):\n        raise ValueError(\"Invalid operator found. Supported operators are: '+', '-', '*', '//', '**'.\")\n    \n    if not all(isinstance(operand, int) for operand in operands):\n        raise ValueError(\"All operands must be integers.\")\n    \n    # Ensure there is one more operand than operators\n    if len(operands) != len(operators) + 1:\n        raise ValueError(\"The number of operands must be one more than the number of operators.\")\n    \n    # Start with the first operand\n    result = operands[0]\n    \n    # Apply each operator in sequence\n    for i, op in enumerate(operators):\n        result = operator_map[op](result, operands[i + 1])\n    \n    return result\n\n# Example usage:\n# result = do_algebra(['+', '*', '-'], [3, 5, 2, 4])\n# print(result)  # Output should be 13\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression using the provided operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers representing the operands.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the number of operators is not one less than the number of operands.\n    ZeroDivisionError: If division by zero is attempted.\n    \"\"\"\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    result = operands[0]\n    for i, operator in enumerate(operators):\n        try:\n            if operator == '+':\n                result += operands[i + 1]\n            elif operator == '-':\n                result -= operands[i + 1]\n            elif operator == '*':\n                result *= operands[i + 1]\n            elif operator == '//':\n                if operands[i + 1] == 0:\n                    raise ZeroDivisionError(\"Division by zero is not allowed.\")\n                result //= operands[i + 1]\n            elif operator == '**':\n                result **= operands[i + 1]\n            else:\n                raise ValueError(f\"Invalid operator: {operator}\")\n        except ZeroDivisionError as e:\n            print(f\"Error: {e}\")\n            return None\n        except ValueError as e:\n            print(f\"Error: {e}\")\n            return None\n\n    return result\n", "from typing import List\n## main.py\n\nimport operator\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers to be used in the expression.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If division by zero is attempted or an invalid operator is provided.\n    \"\"\"\n    # Mapping of string operators to functions using the operator module\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n\n    # Validate input lists\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Initialize the result with the first operand\n    result = operands[0]\n\n    # Iterate through operators and operands\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n\n        # Handle division by zero\n        if op == '//' and operands[i + 1] == 0:\n            raise ValueError(\"Division by zero is not allowed.\")\n\n        # Apply each operator in sequence\n        result = operator_map[op](result, operands[i + 1])\n\n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list of str): A list of operators as strings ('+', '-', '*', '//', '**').\n    operands (list of int): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n\n    # Validate input lists\n    if not operators or not operands:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Initialize the result with the first operand\n    result = operands[0]\n\n    # Iterate through operators and operands to evaluate the expression\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        \n        # Check for division by zero\n        if op == '//' and operands[i + 1] == 0:\n            raise ZeroDivisionError(\"Division by zero is not allowed.\")\n        \n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n\n    return result\n"], "plans": ["requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle errors gracefully when the input lists do not meet the specified conditions. The solution should be optimized for performance, especially when dealing with large numbers.\nrequirement pool:\n- Implement the main algebraic evaluation logic\n- Develop error handling for incompatible input lists\n- Optimize performance for large number calculations\n- Create a user-friendly interface for input and output\n- Ensure cross-platform compatibility\nWe will implement a function that evaluates algebraic expressions using the provided operators and operands. The function will ensure that the input lists are compatible and handle errors gracefully. We will use Python's built-in eval function to parse and evaluate the expression, ensuring that the order of operations is respected. Additionally, we will handle edge cases such as division by zero and negative exponents by implementing custom error handling.\n", "requirement analysis:\nThe requirement is to create a function that evaluates an algebraic expression using two lists: one for operators and one for operands. The function must handle basic operations and respect the order of operations. The input constraints ensure that the lists are compatible for forming a valid expression.\nrequirement pool:\n- Implement the main function to evaluate expressions\n- Ensure the function handles all specified operations\n- Optimize the function for performance\n- Create a user-friendly interface for input\n- Provide clear error messages for invalid inputs\nWe will implement a function that evaluates an algebraic expression using two lists: one for operators and one for operands. The function will handle basic operations and respect the order of operations using the 'operator' module from Python's standard library to map string operators to their corresponding functions. This approach ensures accurate evaluation and leverages Python's built-in capabilities for performance optimization.\n", "requirement analysis:\nThe requirement is to create a function that evaluates an algebraic expression using two lists: one for operators and one for operands. The function should handle basic operations such as addition, subtraction, multiplication, floor division, and exponentiation. The operators and operands must be combined in a way that respects the order of operations.\nrequirement pool:\n- Implement the main function to evaluate expressions using given operators and operands.\n- Ensure the function handles all specified operations correctly.\n- Create a user-friendly interface for inputting operators and operands.\n- Optimize the function for performance and quick calculations.\n- Provide clear documentation and examples for users.\nWe will implement a function that evaluates algebraic expressions using the operator and operand lists. The function will respect the order of operations (PEMDAS/BODMAS) and utilize Python's built-in capabilities for arithmetic operations. We will ensure the function handles all specified operations correctly and provide clear documentation and examples for users.\n", "requirement analysis:\nThe requirement is to create a function that evaluates an algebraic expression based on two lists: operators and operands. The operators include basic arithmetic operations, and the operands are non-negative integers. The function should handle the order of operations correctly and return the evaluated result.\nrequirement pool:\n- Implement the main function to evaluate expressions using given operators and operands.\n- Ensure the function handles errors gracefully, such as mismatched list lengths.\n- Optimize the function for performance with large operand lists.\n- Create a user interface for inputting operators and operands.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function that evaluates algebraic expressions using the given operators and operands. The function will ensure the correct order of operations is followed using Python's built-in capabilities. We will use the 'operator' module to map string operators to their corresponding functions, ensuring efficient and accurate calculations.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle various operations and ensure the input lists are correctly formatted. The function should be optimized for performance and provide clear error handling.\nrequirement pool:\n- Implement the main algebraic evaluation function.\n- Ensure error handling for invalid inputs.\n- Optimize performance for large expressions.\n- Develop a user-friendly interface for input.\n- Provide documentation and examples for users.\nWe will implement a function that evaluates algebraic expressions using the provided operators and operands. The function will ensure correct order of operations and handle errors for invalid inputs. We will use Python's built-in capabilities for arithmetic operations and error handling.\n", "requirement analysis:\nThe requirement is to create a function that evaluates an algebraic expression based on given operators and operands. The function should handle basic operations and respect the order of operations. The input constraints ensure that the function will always have a valid expression to evaluate.\nrequirement pool:\n- Implement the main function to evaluate expressions using given operators and operands.\n- Design a user-friendly interface for inputting operators and operands.\n- Ensure the function handles large numbers efficiently.\n- Provide detailed feedback on the order of operations applied.\n- Allow users to correct their input easily.\nWe will implement a function that evaluates algebraic expressions using the given operators and operands. The function will respect the order of operations and handle large numbers efficiently. We will use Python's built-in capabilities for arithmetic operations and ensure the function is optimized for performance.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The user interface should allow easy input of operators and operands.\nrequirement pool:\n- Implement the core algebra evaluation logic\n- Design a user-friendly interface for input\n- Ensure performance optimization for quick calculations\n- Provide detailed error messages for invalid inputs\n- Include a tutorial or help section for users\nWe will implement a function that takes two lists: one for operators and another for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in the correct order of operations. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring efficient and accurate calculations.\n", "requirement analysis:\nThe function should correctly parse and evaluate the algebraic expression using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The input constraints ensure that there is always a valid expression to evaluate.\nrequirement pool:\n- Implement the core function to evaluate expressions using operators and operands.\n- Design a simple UI for inputting operators and operands.\n- Ensure the function handles edge cases, such as division by zero.\n- Provide a detailed explanation of the order of operations applied.\n- Optimize the function for performance with large input sizes.\nWe will implement a function that evaluates an algebraic expression using the provided operators and operands. The function will handle the order of operations by iterating through the operators and operands, applying each operation in sequence. We will use Python's built-in capabilities to perform arithmetic operations. The function will also include error handling for cases like division by zero.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle basic operations and respect the order of operations. The user interface should allow easy input and modification of lists, and the system should perform efficiently even with large numbers.\nrequirement pool:\n- Implement the main algebraic evaluation function\n- Design a user-friendly interface for input\n- Ensure performance optimization for large numbers\n- Provide clear documentation of order of operations\n- Allow easy modification of operators and operands\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through these lists and applying the operators in the correct order of operations. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring efficient and accurate computation. The function will handle edge cases such as division by zero by raising appropriate exceptions.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle basic operations and ensure the order of operations is respected. The interface should be intuitive for users to input data and receive results quickly.\nrequirement pool:\n- Implement the main algebra evaluation function\n- Design a user-friendly interface for input\n- Optimize performance for quick calculations\n- Provide detailed calculation steps for user understanding\n- Ensure compatibility with various data input formats\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operations in the correct order. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring accurate and efficient evaluation.\n"], "scores": [1.0, 0.6124, 1.0, 0.6124, 0.6124, 0.6124, 0.6124, 0.6124, 0.6124, 0.6124], "pass_results": [true, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [129, 79, 129, 79, 79, 79, 79, 79, 79, 79], "completion": "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list of str): A list of operators as strings ('+', '-', '*', '//', '**').\n    operands (list of int): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n\n    # Validate input lists\n    if not operators or not operands:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Initialize the result with the first operand\n    result = operands[0]\n\n    # Iterate through operators and operands to evaluate the expression\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        \n        # Check for division by zero\n        if op == '//' and operands[i + 1] == 0:\n            raise ZeroDivisionError(\"Division by zero is not allowed.\")\n        \n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n\n    return result\n", "passed": true, "pass": true, "pass_num": 2, "round": 511, "mutate_method": "rephrase_one", "parent_index": 131}
