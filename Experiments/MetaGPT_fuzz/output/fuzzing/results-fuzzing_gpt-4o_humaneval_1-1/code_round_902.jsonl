{"task_id": "HumanEval/68", "prompt": "def pluck(arr):\t\n'''Given an array representing a branch of a tree that has non-negative integer nodes, your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found, you should return the node that has the smallest index. The plucked node should be returned in a list, [ smallest_value, its index ]. If there are no even values or the given array is empty, return [].\nExample 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    '''", "entry_point": "pluck", "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "test": ["def check(pluck):\n\tassert pluck([5, 7, 3]) == []", "def check(pluck):\n\tassert pluck([3, 5, 2, 5, 3, 2]) == [2, 2]", "def check(pluck):\n\tassert pluck([2, 6, 9, 4, 8]) == [2, 0]", "def check(pluck):\n\tassert pluck([7, 7, 8]) == [8, 2]", "def check(pluck):\n\tassert pluck([3, 11, 6, 5]) == [6, 2]", "def check(pluck):\n\tassert pluck([7, 4, 6, 4, 7, 7]) == [4, 1]", "def check(pluck):\n\tassert pluck([6, 7, 10, 8, 8]) == [6, 0]", "def check(pluck):\n\tassert pluck([8, 3, 2, 5]) == [2, 2]", "def check(pluck):\n\tassert pluck([1, 1, 7, 4, 3, 7]) == [4, 3]", "def check(pluck):\n\tassert pluck([8, 1, 12, 4, 4]) == [4, 3]", "def check(pluck):\n\tassert pluck([7, 3, 1, 1, 3, 7]) == []", "def check(pluck):\n\tassert pluck([8, 11, 2, 2]) == [2, 2]", "def check(pluck):\n\tassert pluck([1, 3, 7, 2, 1, 3]) == [2, 3]", "def check(pluck):\n\tassert pluck([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"", "def check(pluck):\n\tassert pluck([6, 3, 3, 2, 8, 7]) == [2, 3]", "def check(pluck):\n\tassert pluck([3, 1, 8, 4, 5, 5]) == [4, 3]", "def check(pluck):\n\tassert pluck([1, 4, 4, 3, 5, 4]) == [4, 1]", "def check(pluck):\n\tassert pluck([5, 1, 6, 2, 4, 1]) == [2, 3]", "def check(pluck):\n\tassert pluck([2, 5, 3, 1]) == [2, 0]", "def check(pluck):\n\tassert pluck([]) == [], \"Error\"", "def check(pluck):\n\tassert pluck([7, 6, 4]) == [4, 2]", "def check(pluck):\n\tassert pluck([4,2,3]) == [2, 1], \"Error\"", "def check(pluck):\n\tassert pluck([8, 2, 3, 1, 8, 3]) == [2, 1]", "def check(pluck):\n\tassert pluck([1, 3, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([6, 4, 4, 4, 8, 6]) == [4, 1]", "def check(pluck):\n\tassert pluck([7, 9, 7, 1]) == [], \"Error\"", "def check(pluck):\n\tassert pluck([1, 5, 5]) == []", "def check(pluck):\n\tassert pluck([7, 5, 13, 4, 8]) == [4, 3]", "def check(pluck):\n\tassert pluck([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.", "def check(pluck):\n\tassert pluck([10, 9, 6, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([5, 4, 8, 1]) == [4, 1]", "def check(pluck):\n\tassert pluck([2, 7, 8]) == [2, 0]", "def check(pluck):\n\tassert pluck([1, 1, 1]) == []", "def check(pluck):\n\tassert pluck([6, 7, 2, 4, 5, 1]) == [2, 2]", "def check(pluck):\n\tassert pluck([7, 6, 7, 1]) == [6, 1], \"Error\"", "def check(pluck):\n\tassert pluck([11, 11, 3, 4]) == [4, 3]", "def check(pluck):\n\tassert pluck([4, 6, 5, 4, 4, 2]) == [2, 5]", "def check(pluck):\n\tassert pluck([5, 4, 2, 1, 3, 4]) == [2, 2]", "def check(pluck):\n\tassert pluck([4, 2, 4]) == [2, 1]", "def check(pluck):\n\tassert pluck([3, 1, 3, 3, 6, 4]) == [4, 5]", "def check(pluck):\n\tassert pluck([9, 5, 2, 4, 9, 6]) == [2, 2]", "def check(pluck):\n\tassert pluck([2, 7, 6, 5, 3]) == [2, 0]", "def check(pluck):\n\tassert pluck([10, 1, 4, 3, 4]) == [4, 2]", "def check(pluck):\n\tassert pluck([7, 1, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([5, 7, 7, 5, 10, 7]) == [10, 4]", "def check(pluck):\n\tassert pluck([1,2,3]) == [2, 1], \"Error\"", "def check(pluck):\n\tassert pluck([9, 10, 3, 3]) == [10, 1]", "def check(pluck):\n\tassert pluck([7, 7, 5]) == []", "def check(pluck):\n\tassert pluck([5, 1, 2, 1, 6, 6]) == [2, 2]", "def check(pluck):\n\tassert pluck([6, 9, 9, 4, 10]) == [4, 3]", "def check(pluck):\n\tassert pluck([2, 4, 2, 2, 7, 4]) == [2, 0]", "def check(pluck):\n\tassert pluck([5, 1, 4, 4, 10, 5]) == [4, 2]", "def check(pluck):\n\tassert pluck([10, 6, 6, 3]) == [6, 1]", "def check(pluck):\n\tassert pluck([]) == []", "def check(pluck):\n\tassert pluck([6, 2, 6, 4, 8, 7]) == [2, 1]", "def check(pluck):\n\tassert pluck([2, 3, 3]) == [2, 0]", "def check(pluck):\n\tassert pluck([1, 4, 8]) == [4, 1]", "def check(pluck):\n\tassert pluck([2, 11, 10, 5]) == [2, 0]", "def check(pluck):\n\tassert pluck([5, 6, 8, 1, 5, 4]) == [4, 5]", "def check(pluck):\n\tassert pluck([5, 4, 5, 5, 6, 6]) == [4, 1]", "def check(pluck):\n\tassert pluck([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"", "def check(pluck):\n\tassert pluck([9, 1, 3, 5, 8, 1]) == [8, 4]", "def check(pluck):\n\tassert pluck([7, 1, 5, 6, 13]) == [6, 3]", "def check(pluck):\n\tassert pluck([3, 1, 1, 2, 1, 1]) == [2, 3]", "def check(pluck):\n\tassert pluck([2, 1, 3, 8, 4]) == [2, 0]", "def check(pluck):\n\tassert pluck([5, 5, 2]) == [2, 2]", "def check(pluck):\n\tassert pluck([9, 2, 12, 8, 6]) == [2, 1]", "def check(pluck):\n\tassert pluck([4, 3, 4]) == [4, 0]", "def check(pluck):\n\tassert pluck([7, 3, 9, 3, 8]) == [8, 4]", "def check(pluck):\n\tassert pluck([7, 3, 4]) == [4, 2]", "def check(pluck):\n\tassert pluck([2, 4, 7]) == [2, 0]", "def check(pluck):\n\tassert pluck([10, 5, 6, 3, 4, 2]) == [2, 5]", "def check(pluck):\n\tassert pluck([2, 5, 7]) == [2, 0]", "def check(pluck):\n\tassert pluck([6, 4, 5]) == [4, 1]", "def check(pluck):\n\tassert pluck([12, 4, 12, 5]) == [4, 1]", "def check(pluck):\n\tassert pluck([2, 1, 6]) == [2, 0]", "def check(pluck):\n\tassert pluck([4, 1, 4, 3, 3, 6]) == [4, 0]", "def check(pluck):\n\tassert pluck([5, 4, 1]) == [4, 1]", "def check(pluck):\n\tassert pluck([4, 4, 6]) == [4, 0]", "def check(pluck):\n\tassert pluck([7, 3, 12, 9, 13]) == [12, 2]", "def check(pluck):\n\tassert pluck([8, 1, 8]) == [8, 0]", "def check(pluck):\n\tassert pluck([4, 6, 5, 2, 7, 1]) == [2, 3]", "def check(pluck):\n\tassert pluck([5, 9, 12, 1]) == [12, 2]", "def check(pluck):\n\tassert pluck([1, 2, 4]) == [2, 1]", "def check(pluck):\n\tassert pluck([7, 6, 7]) == [6, 1]", "def check(pluck):\n\tassert pluck([5, 1, 13, 2, 13]) == [2, 3]", "def check(pluck):\n\tassert pluck([4, 5, 8, 3, 9, 1]) == [4, 0]", "def check(pluck):\n\tassert pluck([5, 3, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([12, 1, 12, 1]) == [12, 0]", "def check(pluck):\n\tassert pluck([3, 3, 1, 3, 2, 6]) == [2, 4]", "def check(pluck):\n\tassert pluck([5, 6, 4, 1, 12]) == [4, 2]", "def check(pluck):\n\tassert pluck([4, 4, 3, 7, 12]) == [4, 0]", "def check(pluck):\n\tassert pluck([8, 6, 8]) == [6, 1]", "def check(pluck):\n\tassert pluck([7, 6, 1]) == [6, 1]", "def check(pluck):\n\tassert pluck([2, 8, 6, 5]) == [2, 0]", "def check(pluck):\n\tassert pluck([3, 2, 9, 6]) == [2, 1]", "def check(pluck):\n\tassert pluck([2, 4, 8]) == [2, 0]", "def check(pluck):\n\tassert pluck([3, 7, 6]) == [6, 2]", "def check(pluck):\n\tassert pluck([2, 2, 8]) == [2, 0]"], "test_case_list": ["assert pluck([5, 7, 3]) == []", "assert pluck([3, 5, 2, 5, 3, 2]) == [2, 2]", "assert pluck([2, 6, 9, 4, 8]) == [2, 0]", "assert pluck([7, 7, 8]) == [8, 2]", "assert pluck([3, 11, 6, 5]) == [6, 2]", "assert pluck([7, 4, 6, 4, 7, 7]) == [4, 1]", "assert pluck([6, 7, 10, 8, 8]) == [6, 0]", "assert pluck([8, 3, 2, 5]) == [2, 2]", "assert pluck([1, 1, 7, 4, 3, 7]) == [4, 3]", "assert pluck([8, 1, 12, 4, 4]) == [4, 3]", "assert pluck([7, 3, 1, 1, 3, 7]) == []", "assert pluck([8, 11, 2, 2]) == [2, 2]", "assert pluck([1, 3, 7, 2, 1, 3]) == [2, 3]", "assert pluck([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"", "assert pluck([6, 3, 3, 2, 8, 7]) == [2, 3]", "assert pluck([3, 1, 8, 4, 5, 5]) == [4, 3]", "assert pluck([1, 4, 4, 3, 5, 4]) == [4, 1]", "assert pluck([5, 1, 6, 2, 4, 1]) == [2, 3]", "assert pluck([2, 5, 3, 1]) == [2, 0]", "assert pluck([]) == [], \"Error\"", "assert pluck([7, 6, 4]) == [4, 2]", "assert pluck([4,2,3]) == [2, 1], \"Error\"", "assert pluck([8, 2, 3, 1, 8, 3]) == [2, 1]", "assert pluck([1, 3, 6]) == [6, 2]", "assert pluck([6, 4, 4, 4, 8, 6]) == [4, 1]", "assert pluck([7, 9, 7, 1]) == [], \"Error\"", "assert pluck([1, 5, 5]) == []", "assert pluck([7, 5, 13, 4, 8]) == [4, 3]", "assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.", "assert pluck([10, 9, 6, 6]) == [6, 2]", "assert pluck([5, 4, 8, 1]) == [4, 1]", "assert pluck([2, 7, 8]) == [2, 0]", "assert pluck([1, 1, 1]) == []", "assert pluck([6, 7, 2, 4, 5, 1]) == [2, 2]", "assert pluck([7, 6, 7, 1]) == [6, 1], \"Error\"", "assert pluck([11, 11, 3, 4]) == [4, 3]", "assert pluck([4, 6, 5, 4, 4, 2]) == [2, 5]", "assert pluck([5, 4, 2, 1, 3, 4]) == [2, 2]", "assert pluck([4, 2, 4]) == [2, 1]", "assert pluck([3, 1, 3, 3, 6, 4]) == [4, 5]", "assert pluck([9, 5, 2, 4, 9, 6]) == [2, 2]", "assert pluck([2, 7, 6, 5, 3]) == [2, 0]", "assert pluck([10, 1, 4, 3, 4]) == [4, 2]", "assert pluck([7, 1, 6]) == [6, 2]", "assert pluck([5, 7, 7, 5, 10, 7]) == [10, 4]", "assert pluck([1,2,3]) == [2, 1], \"Error\"", "assert pluck([9, 10, 3, 3]) == [10, 1]", "assert pluck([7, 7, 5]) == []", "assert pluck([5, 1, 2, 1, 6, 6]) == [2, 2]", "assert pluck([6, 9, 9, 4, 10]) == [4, 3]", "assert pluck([2, 4, 2, 2, 7, 4]) == [2, 0]", "assert pluck([5, 1, 4, 4, 10, 5]) == [4, 2]", "assert pluck([10, 6, 6, 3]) == [6, 1]", "assert pluck([]) == []", "assert pluck([6, 2, 6, 4, 8, 7]) == [2, 1]", "assert pluck([2, 3, 3]) == [2, 0]", "assert pluck([1, 4, 8]) == [4, 1]", "assert pluck([2, 11, 10, 5]) == [2, 0]", "assert pluck([5, 6, 8, 1, 5, 4]) == [4, 5]", "assert pluck([5, 4, 5, 5, 6, 6]) == [4, 1]", "assert pluck([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"", "assert pluck([9, 1, 3, 5, 8, 1]) == [8, 4]", "assert pluck([7, 1, 5, 6, 13]) == [6, 3]", "assert pluck([3, 1, 1, 2, 1, 1]) == [2, 3]", "assert pluck([2, 1, 3, 8, 4]) == [2, 0]", "assert pluck([5, 5, 2]) == [2, 2]", "assert pluck([9, 2, 12, 8, 6]) == [2, 1]", "assert pluck([4, 3, 4]) == [4, 0]", "assert pluck([7, 3, 9, 3, 8]) == [8, 4]", "assert pluck([7, 3, 4]) == [4, 2]", "assert pluck([2, 4, 7]) == [2, 0]", "assert pluck([10, 5, 6, 3, 4, 2]) == [2, 5]", "assert pluck([2, 5, 7]) == [2, 0]", "assert pluck([6, 4, 5]) == [4, 1]", "assert pluck([12, 4, 12, 5]) == [4, 1]", "assert pluck([2, 1, 6]) == [2, 0]", "assert pluck([4, 1, 4, 3, 3, 6]) == [4, 0]", "assert pluck([5, 4, 1]) == [4, 1]", "assert pluck([4, 4, 6]) == [4, 0]", "assert pluck([7, 3, 12, 9, 13]) == [12, 2]", "assert pluck([8, 1, 8]) == [8, 0]", "assert pluck([4, 6, 5, 2, 7, 1]) == [2, 3]", "assert pluck([5, 9, 12, 1]) == [12, 2]", "assert pluck([1, 2, 4]) == [2, 1]", "assert pluck([7, 6, 7]) == [6, 1]", "assert pluck([5, 1, 13, 2, 13]) == [2, 3]", "assert pluck([4, 5, 8, 3, 9, 1]) == [4, 0]", "assert pluck([5, 3, 6]) == [6, 2]", "assert pluck([12, 1, 12, 1]) == [12, 0]", "assert pluck([3, 3, 1, 3, 2, 6]) == [2, 4]", "assert pluck([5, 6, 4, 1, 12]) == [4, 2]", "assert pluck([4, 4, 3, 7, 12]) == [4, 0]", "assert pluck([8, 6, 8]) == [6, 1]", "assert pluck([7, 6, 1]) == [6, 1]", "assert pluck([2, 8, 6, 5]) == [2, 0]", "assert pluck([3, 2, 9, 6]) == [2, 1]", "assert pluck([2, 4, 8]) == [2, 0]", "assert pluck([3, 7, 6]) == [6, 2]", "assert pluck([2, 2, 8]) == [2, 0]"], "nl": "\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    ", "func": "def pluck(arr):", "examples": "Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    ", "repair_prompt": ["def pluck(arr):\t\n'''Given an array representing a branch of a tree that has non-negative integer nodes, your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found, you should return the node that has the smallest index. The plucked node should be returned in a list, [ smallest_value, its index ]. If there are no even values or the given array is empty, return [].\nExample 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    this function returns the node with the smallest even value and its index in the format\n    [smallest_value, its index]. If there are no even values or the array is empty, it returns\n    an empty list.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A list containing the smallest even value and its index, or an empty list if no\n    even values are found.\n    \"\"\"\n    smallest_even = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([5, 3, 2, 8, 1, 4])\n# print(result)  # Output should be [2, 2]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array of non-negative integers, return the smallest even node and its index.\n    If no even numbers are present or the array is empty, return an empty list.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A list containing the smallest even number and its index, or an empty list.\n    \"\"\"\n    # Initialize variables to track the smallest even number and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate through the array to find the smallest even number\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the number is even\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    # Return the result based on the findings\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([1, 3, 2, 4, 6])\n# print(result)  # Output: [2, 2]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array of non-negative integers, return the smallest even value and its index in a list.\n    If no even values are present or the array is empty, return an empty list.\n\n    Args:\n        arr (list[int]): A list of non-negative integers.\n\n    Returns:\n        list[int]: A list containing the smallest even number and its index, or an empty list if no even numbers are found.\n    \"\"\"\n    smallest_even = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"Finds the smallest even number and its index in the given array.\n\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    this function returns the node with the smallest even value and its index in a list\n    [smallest_value, its index]. If there are no even values or the array is empty, it\n    returns an empty list.\n\n    Args:\n        arr (list[int]): A list of non-negative integers.\n\n    Returns:\n        list[int]: A list containing the smallest even value and its index, or an empty\n        list if no even values are present.\n    \"\"\"\n    smallest_even = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([5, 3, 2, 8, 1, 4])\n# print(result)  # Output: [2, 2]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array of non-negative integers, return the smallest even number and its index in a list.\n    If no even numbers are present, return an empty list.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A list containing the smallest even number and its index, or an empty list if no even numbers are found.\n    \"\"\"\n    # Initialize variables to store the smallest even number and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate through the array to find the smallest even number\n    for index, number in enumerate(arr):\n        if number % 2 == 0:  # Check if the number is even\n            if smallest_even is None or number < smallest_even:\n                smallest_even = number\n                smallest_index = index\n\n    # Return the result based on whether an even number was found\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    this function plucks the node with the smallest even value and returns it in a list\n    [smallest_value, its index]. If no even values are present or the array is empty,\n    it returns an empty list.\n\n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n\n    Returns:\n    list[int]: A list containing the smallest even value and its index, or an empty list\n    if no even values are found.\n    \"\"\"\n    smallest_even = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    this function plucks the node with the smallest even value and returns it along with its index.\n    If no even values are present or the array is empty, it returns an empty list.\n    \n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n    \n    Returns:\n    list[int]: A list containing the smallest even value and its index, or an empty list if no even values are found.\n    \"\"\"\n    smallest_even = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([5, 3, 2, 8, 1, 4])\n# print(result)  # Output should be [2, 2] since 2 is the smallest even number at index 2.\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array of non-negative integers, return the smallest even number and its index.\n    If no even number is found or the array is empty, return an empty list.\n    \n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n    \n    Returns:\n    list[int]: A list containing the smallest even number and its index, or an empty list.\n    \"\"\"\n    # Initialize variables to track the smallest even number and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate through the array to find the smallest even number\n    for index, number in enumerate(arr):\n        if number % 2 == 0:  # Check if the number is even\n            if smallest_even is None or number < smallest_even:\n                smallest_even = number\n                smallest_index = index\n\n    # Return the result as a list if an even number was found\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([5, 3, 2, 8, 1, 4])\n# print(result)  # Output should be [2, 2]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array of non-negative integers, return the smallest even number and its index in the form [smallest_value, index].\n    If no even numbers are present or the array is empty, return an empty list.\n    \n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n    \n    Returns:\n    list[int]: A list containing the smallest even number and its index, or an empty list if no even numbers are found.\n    \"\"\"\n    # Initialize variables to store the smallest even number and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate over the array to find the smallest even number\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the number is even\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    # Return the result in the required format\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([5, 3, 2, 8, 1, 4])\n# print(result)  # Output should be [2, 2]\n", "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array of non-negative integers, return the smallest even value and its index.\n    If no even values are present or the array is empty, return an empty list.\n    \n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n    \n    Returns:\n    list[int]: A list containing the smallest even value and its index, or an empty list.\n    \"\"\"\n    # Initialize variables to store the smallest even number and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate through the array to find the smallest even number\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the number is even\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    # Return the result based on whether an even number was found\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([5, 3, 2, 8, 1, 4])\n# print(result)  # Output should be [2, 2]\n"], "plans": ["requirement analysis:\nThe function should efficiently identify the smallest even node in an array, prioritizing performance and clarity. It must handle edge cases such as empty arrays and arrays without even numbers.\nrequirement pool:\n- Implement the main function to select the smallest even node\n- Optimize the function for large arrays\n- Ensure the output format is clear and consistent\n- Handle edge cases like empty arrays\n- Document the function with examples and explanations\nWe will implement a function that iterates through the array to find the smallest even number and its index. The function will handle edge cases such as empty arrays and arrays without even numbers by returning an empty list. We will use Python's built-in functions to ensure efficiency and clarity.\n", "requirement analysis:\nThe function should efficiently identify and return the smallest even node and its index from an array. It must handle edge cases such as empty arrays and arrays without even numbers, returning an empty list in such cases.\nrequirement pool:\n- Implement the function to find the smallest even node\n- Ensure the function returns the correct index\n- Optimize for performance with large arrays\n- Handle edge cases like empty arrays\n- Provide clear documentation for integration\nWe will implement a simple function using built-in Python capabilities to efficiently find the smallest even node and its index. The function will iterate through the array once, keeping track of the smallest even number and its index. This approach ensures optimal performance even for large arrays. We will handle edge cases by returning an empty list if no even numbers are found or if the array is empty.\n", "requirement analysis:\nThe function should efficiently identify the smallest even value in an array and return it along with its index. It must handle edge cases such as empty arrays and arrays without even numbers. The solution should be optimized for performance given the constraints of up to 10,000 nodes.\nrequirement pool:\n- Implement the main function to find the smallest even value and its index\n- Optimize the function for performance with large arrays\n- Ensure the function handles edge cases correctly\n- Write comprehensive tests for various scenarios\n- Document the function usage and edge cases\nWe will use Python's built-in functions to efficiently iterate through the array and find the smallest even value. This approach ensures simplicity and high performance without the need for additional libraries. The function will handle edge cases such as empty arrays and arrays without even numbers by returning an empty list in those scenarios.\n", "requirement analysis:\nThe function should efficiently find the smallest even value in an array and return it along with its index. It must handle edge cases such as empty arrays and arrays with no even numbers. Performance is crucial given the constraint of handling up to 10,000 elements.\nrequirement pool:\n- Implement the main function to find the smallest even value and its index\n- Optimize the function for performance with large arrays\n- Ensure the function handles edge cases like empty arrays\n- Provide comprehensive documentation and examples\n- Conduct performance testing and optimization\nWe will implement a function named `pluck` that iterates through the given array to find the smallest even number and its index. The function will handle edge cases such as empty arrays and arrays with no even numbers by returning an empty list. The implementation will focus on performance and readability, ensuring it can handle arrays with up to 10,000 elements efficiently.\n", "requirement analysis:\nThe function should efficiently find the smallest even number in an array and return it with its index. It must handle arrays up to 10,000 elements and return an empty list if no even numbers are present.\nrequirement pool:\n- Implement the main function to find the smallest even number\n- Optimize the function for large input arrays\n- Ensure the function handles edge cases like empty arrays\n- Provide comprehensive documentation and examples\n- Conduct performance testing on various input sizes\nWe will implement a function that iterates through the array to find the smallest even number and its index. The function will handle edge cases such as empty arrays and arrays with no even numbers by returning an empty list. We will use Python's built-in functions to ensure efficiency and readability.\n", "requirement analysis:\nThe function should efficiently find the smallest even number in an array and return it along with its index. It must handle arrays up to 10,000 elements and return an empty list if no even numbers are present. The function should prioritize performance and clarity.\nrequirement pool:\n- Implement the main function to find the smallest even number and its index\n- Optimize the function for performance with large arrays\n- Ensure the function handles edge cases, such as empty arrays\n- Provide comprehensive documentation and examples\n- Conduct performance testing and optimization\nWe will implement a function that iterates through the array to find the smallest even number and its index. The function will be optimized for performance by using a single pass through the array, ensuring it handles up to 10,000 elements efficiently. We will use Python's built-in capabilities to achieve this without additional libraries, as they provide sufficient performance for the task.\n", "requirement analysis:\nThe function should efficiently find the smallest even value in an array and return it along with its index. It must handle arrays up to 10,000 elements and return an empty list if no even values are present. The function should prioritize performance and clarity.\nrequirement pool:\n- Implement the main function logic to find the smallest even value.\n- Ensure the function handles edge cases like empty arrays.\n- Optimize the function for performance with large inputs.\n- Provide comprehensive documentation and examples.\n- Conduct performance testing and benchmarking.\nWe will implement a function that iterates through the array to find the smallest even number and its index. The function will handle edge cases such as empty arrays or arrays with no even numbers by returning an empty list. The implementation will focus on performance by using a single pass through the array, ensuring it can handle up to 10,000 elements efficiently.\n", "requirement analysis:\nThe function should efficiently find the smallest even number in an array and return it along with its index. It must handle edge cases such as empty arrays and arrays with no even numbers. The solution should be optimized for performance given the constraint of up to 10,000 elements.\nrequirement pool:\n- Implement the main function to find the smallest even number and its index\n- Optimize the function for performance with large arrays\n- Ensure the function handles edge cases like empty arrays\n- Provide comprehensive documentation and examples\n- Write unit tests to validate functionality\nWe will implement a function that iterates through the array to find the smallest even number and its index. The function will handle edge cases such as empty arrays and arrays with no even numbers by returning an empty list. We will use a simple loop to ensure readability and performance, given the constraint of up to 10,000 elements.\n", "requirement analysis:\nThe function should efficiently identify and return the smallest even node from an array, considering both value and index. It must handle edge cases such as empty arrays and arrays without even numbers, ensuring robust performance across all scenarios.\nrequirement pool:\n- Implement the main function logic to find the smallest even node\n- Optimize the function for large input arrays\n- Ensure the function handles edge cases like empty arrays\n- Document the function with clear examples and explanations\n- Test the function across various scenarios to ensure reliability\nWe will implement a function that iterates through the array to find the smallest even number and its index. The function will handle edge cases such as empty arrays and arrays without even numbers by returning an empty list. We will use built-in Python functions for efficiency and simplicity, ensuring the function is optimized for performance and memory usage.\n", "requirement analysis:\nThe function should efficiently find the smallest even value in an array and return it along with its index. It must handle edge cases such as empty arrays and arrays without even numbers. The solution should be optimized for performance, especially for large arrays up to 10,000 elements.\nrequirement pool:\n- Implement the main function to find the smallest even value and its index\n- Optimize the function for performance with large arrays\n- Ensure the function handles edge cases like empty arrays\n- Provide comprehensive documentation and examples\n- Conduct performance testing and benchmarking\nWe will implement a function that iterates through the array to find the smallest even number and its index. The function will handle edge cases such as empty arrays and arrays without even numbers. We will use built-in Python list methods for simplicity and performance, as they are efficient for the given constraints.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [99, 99, 99, 99, 99, 99, 99, 99, 99, 99], "completion": "from typing import List\n## main.py\n\ndef pluck(arr: list[int]) -> list[int]:\n    \"\"\"\n    Given an array of non-negative integers, return the smallest even value and its index.\n    If no even values are present or the array is empty, return an empty list.\n    \n    Parameters:\n    arr (list[int]): A list of non-negative integers.\n    \n    Returns:\n    list[int]: A list containing the smallest even value and its index, or an empty list.\n    \"\"\"\n    # Initialize variables to store the smallest even number and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate through the array to find the smallest even number\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the number is even\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    # Return the result based on whether an even number was found\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []\n\n# Example usage:\n# result = pluck([5, 3, 2, 8, 1, 4])\n# print(result)  # Output should be [2, 2]\n", "passed": true, "pass": true, "pass_num": 10, "round": 902, "mutate_method": "expand_one2two", "parent_index": 421}
