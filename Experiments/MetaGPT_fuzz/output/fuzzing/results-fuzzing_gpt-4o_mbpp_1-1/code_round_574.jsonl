{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 573, "prompt": "Create a Python function that computes the product of distinct numbers in a provided list.", "code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "test_imports": [], "test_list": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000", "assert unique_product([1, 2, 3, 1,]) == 6", "assert unique_product([7, 8, 9, 0, 1, 1]) == 0", "assert unique_product([8, 17, 29, 43, 17, 49, 55, 45]) == 20567269800", "assert unique_product([5, 25, 28, 35, 23, 48, 55, 37]) == 275213400000", "assert unique_product([8, 21, 31, 36, 18, 45, 57, 35]) == 302971233600", "assert unique_product([11, 22, 30, 41, 17, 55, 60, 40]) == 667949040000", "assert unique_product([9, 15, 31, 44, 23, 55, 56, 45]) == 587001492000", "assert unique_product([9, 16, 26, 44, 24, 55, 64, 42]) == 584509685760", "assert unique_product([11, 17, 31, 41, 22, 54, 64, 36]) == 650558075904", "assert unique_product([8, 18, 34, 44, 20, 50, 59, 42]) == 533820672000", "assert unique_product([14, 19, 35, 44, 17, 45, 63, 42]) == 829189191600", "assert unique_product([12, 16, 27, 43, 22, 54, 61, 35]) == 565389538560", "assert unique_product([6, 22, 25, 39, 21, 51, 64, 39]) == 8821612800", "assert unique_product([9, 17, 29, 38, 22, 50, 59, 44]) == 481471293600", "assert unique_product([8, 16, 26, 40, 22, 55, 62, 41]) == 409453158400", "assert unique_product([11, 25, 30, 44, 15, 48, 58, 39]) == 591196320000", "assert unique_product([14, 21, 26, 36, 24, 52, 58, 40]) == 796756746240", "assert unique_product([10, 22, 25, 37, 21, 49, 64, 42]) == 562871232000", "assert unique_product([12, 19, 33, 41, 23, 50, 64, 37]) == 840063628800", "assert unique_product([8, 15, 28, 38, 25, 51, 55, 40]) == 358142400000", "assert unique_product([13, 19, 34, 40, 18, 54, 55, 43]) == 772206177600", "assert unique_product([9, 23, 31, 42, 18, 51, 62, 45]) == 690284647080", "assert unique_product([10, 23, 26, 42, 19, 46, 63, 35]) == 484028017200", "assert unique_product([13, 15, 29, 39, 24, 55, 59, 42]) == 721393873200", "assert unique_product([13, 24, 34, 43, 20, 48, 57, 43]) == 24960199680", "assert unique_product([6, 18, 34, 35, 25, 49, 57, 43]) == 385878087000", "assert unique_product([14, 20, 30, 44, 16, 48, 59, 44]) == 16747315200", "assert unique_product([14, 18, 25, 43, 15, 52, 55, 38]) == 441621180000", "assert unique_product([14, 25, 32, 45, 19, 46, 62, 41]) == 1119740832000", "assert unique_product([9, 16, 31, 37, 18, 52, 59, 41]) == 373970742912", "assert unique_product([8, 24, 34, 45, 19, 50, 64, 44]) == 785866752000", "assert unique_product([14, 24, 33, 44, 19, 55, 63, 41]) == 1316881177920", "assert unique_product([5, 21, 27, 36, 22, 55, 62, 37]) == 283292024400", "assert unique_product([12, 23, 34, 38, 21, 50, 59, 35]) == 773180604000", "assert unique_product([11, 25, 35, 41, 18, 50, 61, 39]) == 844931587500", "assert unique_product([6, 2, 1, 1]) == 12", "assert unique_product([3, 6, 1, 5]) == 90", "assert unique_product([2, 4, 1, 3]) == 24", "assert unique_product([6, 5, 2, 3]) == 180", "assert unique_product([5, 4, 1, 1]) == 20", "assert unique_product([2, 1, 3, 3]) == 6", "assert unique_product([5, 6, 7, 1]) == 210", "assert unique_product([3, 3, 3, 6]) == 18", "assert unique_product([4, 3, 4, 6]) == 72", "assert unique_product([6, 4, 6, 5]) == 120", "assert unique_product([3, 1, 6, 1]) == 18", "assert unique_product([6, 7, 5, 2]) == 420", "assert unique_product([2, 3, 7, 1]) == 42", "assert unique_product([5, 1, 1, 6]) == 30", "assert unique_product([3, 4, 3, 1]) == 12", "assert unique_product([4, 4, 1, 5]) == 20", "assert unique_product([2, 1, 2, 6]) == 12", "assert unique_product([1, 4, 2, 4]) == 8", "assert unique_product([3, 4, 8, 6]) == 576", "assert unique_product([3, 7, 3, 2]) == 42", "assert unique_product([4, 6, 5, 4]) == 120", "assert unique_product([4, 5, 7, 2]) == 280", "assert unique_product([1, 1, 5, 5]) == 5", "assert unique_product([3, 3, 3, 6]) == 18", "assert unique_product([6, 6, 3, 1]) == 18", "assert unique_product([4, 2, 5, 1]) == 40", "assert unique_product([2, 2, 3, 1]) == 6", "assert unique_product([6, 5, 4, 5]) == 120", "assert unique_product([5, 3, 2, 2]) == 30", "assert unique_product([4, 5, 4, 5]) == 20", "assert unique_product([4, 7, 1, 2]) == 56", "assert unique_product([3, 3, 3, 3]) == 3", "assert unique_product([1, 7, 3, 4]) == 84", "assert unique_product([5, 13, 11, 4, 2, 6]) == 34320", "assert unique_product([2, 7, 9, 1, 2, 4]) == 504", "assert unique_product([3, 13, 7, 1, 3, 2]) == 546", "assert unique_product([11, 8, 10, 3, 1, 4]) == 10560", "assert unique_product([4, 5, 9, 3, 4, 5]) == 540", "assert unique_product([9, 12, 5, 5, 4, 5]) == 2160", "assert unique_product([12, 4, 10, 1, 4, 2]) == 960", "assert unique_product([6, 9, 13, 1, 3, 4]) == 8424", "assert unique_product([2, 3, 6, 5, 1, 3]) == 180", "assert unique_product([4, 6, 14, 2, 2, 1]) == 672", "assert unique_product([6, 9, 12, 4, 3, 6]) == 7776", "assert unique_product([10, 6, 4, 5, 5, 2]) == 2400", "assert unique_product([4, 9, 4, 2, 4, 4]) == 72", "assert unique_product([6, 10, 8, 1, 5, 4]) == 9600", "assert unique_product([2, 4, 10, 2, 3, 1]) == 240", "assert unique_product([6, 9, 10, 2, 4, 6]) == 4320", "assert unique_product([10, 9, 12, 5, 4, 1]) == 21600", "assert unique_product([12, 6, 4, 1, 5, 1]) == 1440", "assert unique_product([8, 3, 4, 1, 5, 1]) == 480", "assert unique_product([3, 10, 8, 3, 1, 1]) == 240", "assert unique_product([7, 13, 14, 2, 2, 6]) == 15288", "assert unique_product([8, 7, 4, 4, 1, 5]) == 1120", "assert unique_product([2, 4, 10, 4, 6, 3]) == 1440", "assert unique_product([8, 6, 6, 2, 4, 2]) == 384", "assert unique_product([9, 9, 12, 5, 3, 1]) == 1620", "assert unique_product([9, 13, 5, 4, 2, 5]) == 4680", "assert unique_product([2, 7, 4, 4, 2, 4]) == 56", "assert unique_product([4, 10, 8, 3, 5, 5]) == 4800", "assert unique_product([5, 4, 11, 3, 4, 1]) == 660", "assert unique_product([12, 8, 4, 4, 6, 4]) == 2304", "assert unique_product([11, 10, 10, 2, 2, 3]) == 660", "assert unique_product([12, 9, 11, 1, 4, 2]) == 9504", "assert unique_product([5, 6, 4, 3, 5, 6]) == 360"], "entry_point": "unique_product", "repair_prompt": ["Create a Python function unique_product that computes the product of distinct numbers in a provided list.\nunique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000\n"], "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in a provided list.\n\n    Parameters:\n    numbers (list): A list of numbers (integers or floats).\n\n    Returns:\n    int: The product of the unique numbers in the list.\n\n    Raises:\n    ValueError: If the input list contains non-numeric elements.\n    \"\"\"\n    # Check for non-numeric elements\n    for num in numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"All elements in the list must be numeric.\")\n\n    # Convert list to set to remove duplicates\n    unique_numbers = set(numbers)\n\n    # Handle empty list case\n    if not unique_numbers:\n        return 1  # Returning 1 as the product of an empty set\n\n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n\n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in a provided list.\n\n    Parameters:\n    numbers (List): A list of numbers which may contain duplicates.\n\n    Returns:\n    int: The product of the unique numbers in the list.\n\n    Raises:\n    ValueError: If the list contains non-numeric values.\n    \"\"\"\n    # Filter out non-numeric values and convert to a set to remove duplicates\n    unique_numbers = set()\n    for num in numbers:\n        if isinstance(num, (int, float)):\n            unique_numbers.add(num)\n        else:\n            raise ValueError(\"List contains non-numeric values.\")\n\n    # Compute the product of the unique numbers\n    product = math.prod(unique_numbers)\n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List[int]) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in the provided list.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The product of unique numbers in the list.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Calculate the product of the unique numbers\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List[float]) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in the provided list.\n\n    Parameters:\n    numbers (List[float]): A list of numbers which can include duplicates.\n\n    Returns:\n    int: The product of unique numbers in the list. Returns 1 for an empty list.\n\n    Raises:\n    ValueError: If the list contains non-numeric values.\n    \"\"\"\n    # Convert list to set to ensure uniqueness\n    unique_numbers = set(numbers)\n\n    # Check for non-numeric values\n    for num in unique_numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"List contains non-numeric values.\")\n\n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n\n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in the provided list.\n\n    Parameters:\n    numbers (list): A list of numbers which may contain duplicates and non-numeric values.\n\n    Returns:\n    int: The product of the unique numbers in the list.\n\n    Raises:\n    ValueError: If the list contains non-numeric values.\n    \"\"\"\n    # Convert list to set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Validate all elements are numeric\n    for num in unique_numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"List contains non-numeric values.\")\n    \n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\n\nfrom functools import reduce\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in a provided list.\n\n    Parameters:\n    numbers (list): A list of numbers which may contain duplicates.\n\n    Returns:\n    int: The product of the unique numbers in the list.\n\n    Raises:\n    ValueError: If any element in the list is not a number.\n    \"\"\"\n    # Convert list to set to remove duplicates\n    unique_numbers = set(numbers)\n\n    # Validate all elements are numeric\n    for num in unique_numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"All elements must be numbers.\")\n\n    # Handle empty list by returning 1\n    if not unique_numbers:\n        return 1\n\n    # Compute product of unique numbers\n    product = reduce(lambda x, y: x * y, unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in a provided list.\n\n    Parameters:\n    numbers (List): A list of numbers which may contain duplicates and non-numeric values.\n\n    Returns:\n    int: The product of unique numbers in the list.\n\n    Raises:\n    TypeError: If any non-numeric value is present in the list.\n    \"\"\"\n    # Convert list to set to ensure uniqueness\n    unique_numbers = set(numbers)\n    \n    # Validate all elements are numeric\n    for num in unique_numbers:\n        if not isinstance(num, (int, float)):\n            raise TypeError(f\"Non-numeric value found: {num}\")\n    \n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Computes the product of distinct numbers in the provided list.\n\n    Parameters:\n    numbers (list): A list of numbers.\n\n    Returns:\n    int: The product of unique numbers.\n\n    Raises:\n    ValueError: If the input is not a list or contains non-numeric elements.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list.\")\n\n    # Convert list to set to ensure uniqueness\n    unique_numbers = set(numbers)\n\n    # Initialize product to 1 (multiplicative identity)\n    product = 1\n\n    for num in unique_numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"All elements in the list must be numbers.\")\n        product *= num\n\n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List[float]) -> float:\n    \"\"\"\n    Computes the product of distinct numbers in the provided list.\n\n    Parameters:\n    numbers (List[float]): A list of numbers.\n\n    Returns:\n    float: The product of distinct numbers.\n\n    Raises:\n    ValueError: If the list contains non-numeric elements.\n    \"\"\"\n    # Ensure all elements are numeric\n    for num in numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"All elements must be numeric.\")\n\n    # Convert list to set to ensure distinct elements\n    distinct_numbers = set(numbers)\n\n    # Calculate product using math.prod\n    product = math.prod(distinct_numbers)\n\n    return product\n\n# Example usage:\n# result = unique_product([1, 2, 3, 2, 4])\n# print(result)  # Output should be 24, since 1*2*3*4 = 24\n", "from typing import List\n## main.py\n\ndef unique_product(numbers: list) -> int:\n    '''\n    Computes the product of distinct numbers in the provided list.\n    \n    Parameters:\n    numbers (list): A list of numbers which may contain duplicates.\n    \n    Returns:\n    int: The product of unique numbers in the list.\n    \n    Raises:\n    ValueError: If the list contains non-numeric inputs.\n    '''\n    # Convert the list to a set to remove duplicates\n    try:\n        unique_numbers = set(numbers)\n    except TypeError:\n        raise ValueError(\"The list contains non-numeric inputs.\")\n\n    # Initialize the product variable\n    product = 1\n\n    # Calculate the product of unique numbers\n    for number in unique_numbers:\n        if not isinstance(number, (int, float)):\n            raise ValueError(\"The list contains non-numeric inputs.\")\n        product *= number\n\n    return product\n"], "plans": ["requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring that duplicates do not affect the result. It should handle various input sizes and types, providing meaningful feedback for invalid inputs.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers.\n- Optimize the function for performance with large datasets.\n- Include error handling for non-numeric inputs.\n- Provide comprehensive documentation and examples.\n- Ensure compatibility with Python 3.6 and above.\nWe will implement the unique_product function using Python's built-in set to filter out duplicate numbers and the math.prod function to compute the product of the unique numbers. This approach ensures efficiency and simplicity. We will include error handling to manage non-numeric inputs by raising informative exceptions. The function will be optimized for performance with large datasets by leveraging the efficiency of set operations and the math.prod function.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring duplicates are removed before calculation. It should handle large lists and provide accurate results.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers\n- Optimize the function for performance with large datasets\n- Include comprehensive documentation and examples\n- Ensure compatibility with different Python versions\n- Add error handling for non-numeric inputs\nWe will implement the unique_product function using Python's built-in set to remove duplicates and the math.prod function from the math module to compute the product of the unique numbers. This approach ensures efficiency and simplicity, leveraging Python's optimized built-in capabilities. We will also include error handling for non-numeric inputs by filtering out non-numeric values before processing.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring that duplicates do not affect the result. It should handle large lists and edge cases, such as empty lists, gracefully.\nrequirement pool:\n- Implement the unique_product function\n- Ensure the function handles duplicates correctly\n- Optimize the function for performance\n- Provide comprehensive documentation\n- Include test cases for edge scenarios\nWe will implement the unique_product function using Python's built-in set to handle uniqueness and the math.prod function to compute the product. This approach ensures efficiency and simplicity, leveraging Python's standard library for optimal performance.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring that duplicates do not affect the result. It should handle large datasets and edge cases, such as empty lists or lists with non-numeric values, gracefully.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers\n- Ensure the function handles empty lists and returns 1\n- Optimize the function for performance with large datasets\n- Include comprehensive documentation and examples\n- Add error handling for non-numeric inputs\nWe will implement the unique_product function using Python's built-in set to ensure uniqueness and the math.prod function to calculate the product. This approach is efficient and leverages Python's standard library for performance. We will handle edge cases such as empty lists by returning 1 and will raise an error for non-numeric inputs to ensure data integrity.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring that duplicates do not affect the result. It should handle various data types and edge cases, such as empty lists or lists with non-numeric values.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers\n- Optimize the function for performance with large datasets\n- Include comprehensive error handling and input validation\n- Provide detailed documentation and usage examples\n- Ensure compatibility with Python 3.6 and above\nWe will implement the unique_product function using Python's built-in set to filter out duplicate numbers and the math.prod function to compute the product of the unique numbers. This approach ensures efficiency and simplicity. We will handle non-numeric values by raising a ValueError to ensure data integrity.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring that duplicates do not affect the result. It should handle large lists and provide accurate results.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers.\n- Optimize the function for performance with large datasets.\n- Include comprehensive documentation and examples.\n- Ensure compatibility with different Python versions.\n- Add error handling for non-numeric inputs.\nWe will implement the unique_product function using Python's built-in set to filter out duplicate numbers from the list, and then use the functools.reduce function to compute the product of the unique numbers. This approach ensures that the function is both efficient and easy to understand. We will also include error handling to manage non-numeric inputs by raising a ValueError. The function will be optimized for performance by minimizing the use of additional data structures and leveraging Python's efficient built-in operations.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring that duplicates do not affect the result. It should handle large lists and edge cases, such as empty lists or lists with non-numeric values, gracefully.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers\n- Ensure the function handles empty lists without errors\n- Optimize the function for performance with large datasets\n- Include comprehensive documentation and examples\n- Add error handling for non-numeric inputs\nWe will implement the unique_product function using Python's built-in set to ensure uniqueness and the math.prod function for efficient product calculation. The function will handle non-numeric values by raising a TypeError, ensuring that only valid numeric inputs are processed. This approach balances performance and usability, leveraging Python's efficient built-in capabilities.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, handle invalid inputs gracefully, and be optimized for performance with large datasets.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers\n- Ensure the function handles invalid inputs with appropriate error messages\n- Optimize the function for performance with large numbers\n- Document the function with examples and usage instructions\n- Test the function with various edge cases\nWe will use built-in Python functions to efficiently compute the product of unique numbers in a list. The function will handle invalid inputs by checking the type of the input and will raise a ValueError with a clear message if the input is not a list. For performance optimization, we will use a set to ensure uniqueness and reduce computational complexity.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring no duplicates are considered. It should handle edge cases like empty lists and provide meaningful error messages for invalid inputs.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers.\n- Ensure the function handles edge cases such as empty lists.\n- Provide clear documentation and usage examples.\n- Optimize the function for performance with large datasets.\n- Include error handling for invalid inputs.\nWe will implement the unique_product function using Python's built-in set to ensure distinct elements and the math.prod function for efficient product calculation. This approach is simple, efficient, and leverages Python's standard library for optimal performance. We will also include error handling for non-numeric inputs and provide documentation with examples.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring no duplicates are included in the calculation. It should handle large lists and provide accurate results.\nrequirement pool:\n- Implement the unique_product function to compute the product of distinct numbers\n- Optimize the function for performance with large datasets\n- Provide comprehensive documentation for the function\n- Include error handling for non-numeric inputs\n- Add unit tests to verify function correctness\nWe will implement the unique_product function using built-in Python functions to ensure simplicity and efficiency. The function will convert the list to a set to remove duplicates, then calculate the product using a loop. This approach avoids the overhead of additional libraries and is optimized for performance with large datasets. We will also include error handling for non-numeric inputs and provide comprehensive documentation.\n"], "test": ["def check(unique_product):\n\tassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000", "def check(unique_product):\n\tassert unique_product([1, 2, 3, 1,]) == 6", "def check(unique_product):\n\tassert unique_product([7, 8, 9, 0, 1, 1]) == 0", "def check(unique_product):\n\tassert unique_product([8, 17, 29, 43, 17, 49, 55, 45]) == 20567269800", "def check(unique_product):\n\tassert unique_product([5, 25, 28, 35, 23, 48, 55, 37]) == 275213400000", "def check(unique_product):\n\tassert unique_product([8, 21, 31, 36, 18, 45, 57, 35]) == 302971233600", "def check(unique_product):\n\tassert unique_product([11, 22, 30, 41, 17, 55, 60, 40]) == 667949040000", "def check(unique_product):\n\tassert unique_product([9, 15, 31, 44, 23, 55, 56, 45]) == 587001492000", "def check(unique_product):\n\tassert unique_product([9, 16, 26, 44, 24, 55, 64, 42]) == 584509685760", "def check(unique_product):\n\tassert unique_product([11, 17, 31, 41, 22, 54, 64, 36]) == 650558075904", "def check(unique_product):\n\tassert unique_product([8, 18, 34, 44, 20, 50, 59, 42]) == 533820672000", "def check(unique_product):\n\tassert unique_product([14, 19, 35, 44, 17, 45, 63, 42]) == 829189191600", "def check(unique_product):\n\tassert unique_product([12, 16, 27, 43, 22, 54, 61, 35]) == 565389538560", "def check(unique_product):\n\tassert unique_product([6, 22, 25, 39, 21, 51, 64, 39]) == 8821612800", "def check(unique_product):\n\tassert unique_product([9, 17, 29, 38, 22, 50, 59, 44]) == 481471293600", "def check(unique_product):\n\tassert unique_product([8, 16, 26, 40, 22, 55, 62, 41]) == 409453158400", "def check(unique_product):\n\tassert unique_product([11, 25, 30, 44, 15, 48, 58, 39]) == 591196320000", "def check(unique_product):\n\tassert unique_product([14, 21, 26, 36, 24, 52, 58, 40]) == 796756746240", "def check(unique_product):\n\tassert unique_product([10, 22, 25, 37, 21, 49, 64, 42]) == 562871232000", "def check(unique_product):\n\tassert unique_product([12, 19, 33, 41, 23, 50, 64, 37]) == 840063628800", "def check(unique_product):\n\tassert unique_product([8, 15, 28, 38, 25, 51, 55, 40]) == 358142400000", "def check(unique_product):\n\tassert unique_product([13, 19, 34, 40, 18, 54, 55, 43]) == 772206177600", "def check(unique_product):\n\tassert unique_product([9, 23, 31, 42, 18, 51, 62, 45]) == 690284647080", "def check(unique_product):\n\tassert unique_product([10, 23, 26, 42, 19, 46, 63, 35]) == 484028017200", "def check(unique_product):\n\tassert unique_product([13, 15, 29, 39, 24, 55, 59, 42]) == 721393873200", "def check(unique_product):\n\tassert unique_product([13, 24, 34, 43, 20, 48, 57, 43]) == 24960199680", "def check(unique_product):\n\tassert unique_product([6, 18, 34, 35, 25, 49, 57, 43]) == 385878087000", "def check(unique_product):\n\tassert unique_product([14, 20, 30, 44, 16, 48, 59, 44]) == 16747315200", "def check(unique_product):\n\tassert unique_product([14, 18, 25, 43, 15, 52, 55, 38]) == 441621180000", "def check(unique_product):\n\tassert unique_product([14, 25, 32, 45, 19, 46, 62, 41]) == 1119740832000", "def check(unique_product):\n\tassert unique_product([9, 16, 31, 37, 18, 52, 59, 41]) == 373970742912", "def check(unique_product):\n\tassert unique_product([8, 24, 34, 45, 19, 50, 64, 44]) == 785866752000", "def check(unique_product):\n\tassert unique_product([14, 24, 33, 44, 19, 55, 63, 41]) == 1316881177920", "def check(unique_product):\n\tassert unique_product([5, 21, 27, 36, 22, 55, 62, 37]) == 283292024400", "def check(unique_product):\n\tassert unique_product([12, 23, 34, 38, 21, 50, 59, 35]) == 773180604000", "def check(unique_product):\n\tassert unique_product([11, 25, 35, 41, 18, 50, 61, 39]) == 844931587500", "def check(unique_product):\n\tassert unique_product([6, 2, 1, 1]) == 12", "def check(unique_product):\n\tassert unique_product([3, 6, 1, 5]) == 90", "def check(unique_product):\n\tassert unique_product([2, 4, 1, 3]) == 24", "def check(unique_product):\n\tassert unique_product([6, 5, 2, 3]) == 180", "def check(unique_product):\n\tassert unique_product([5, 4, 1, 1]) == 20", "def check(unique_product):\n\tassert unique_product([2, 1, 3, 3]) == 6", "def check(unique_product):\n\tassert unique_product([5, 6, 7, 1]) == 210", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 6]) == 18", "def check(unique_product):\n\tassert unique_product([4, 3, 4, 6]) == 72", "def check(unique_product):\n\tassert unique_product([6, 4, 6, 5]) == 120", "def check(unique_product):\n\tassert unique_product([3, 1, 6, 1]) == 18", "def check(unique_product):\n\tassert unique_product([6, 7, 5, 2]) == 420", "def check(unique_product):\n\tassert unique_product([2, 3, 7, 1]) == 42", "def check(unique_product):\n\tassert unique_product([5, 1, 1, 6]) == 30", "def check(unique_product):\n\tassert unique_product([3, 4, 3, 1]) == 12", "def check(unique_product):\n\tassert unique_product([4, 4, 1, 5]) == 20", "def check(unique_product):\n\tassert unique_product([2, 1, 2, 6]) == 12", "def check(unique_product):\n\tassert unique_product([1, 4, 2, 4]) == 8", "def check(unique_product):\n\tassert unique_product([3, 4, 8, 6]) == 576", "def check(unique_product):\n\tassert unique_product([3, 7, 3, 2]) == 42", "def check(unique_product):\n\tassert unique_product([4, 6, 5, 4]) == 120", "def check(unique_product):\n\tassert unique_product([4, 5, 7, 2]) == 280", "def check(unique_product):\n\tassert unique_product([1, 1, 5, 5]) == 5", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 6]) == 18", "def check(unique_product):\n\tassert unique_product([6, 6, 3, 1]) == 18", "def check(unique_product):\n\tassert unique_product([4, 2, 5, 1]) == 40", "def check(unique_product):\n\tassert unique_product([2, 2, 3, 1]) == 6", "def check(unique_product):\n\tassert unique_product([6, 5, 4, 5]) == 120", "def check(unique_product):\n\tassert unique_product([5, 3, 2, 2]) == 30", "def check(unique_product):\n\tassert unique_product([4, 5, 4, 5]) == 20", "def check(unique_product):\n\tassert unique_product([4, 7, 1, 2]) == 56", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 3]) == 3", "def check(unique_product):\n\tassert unique_product([1, 7, 3, 4]) == 84", "def check(unique_product):\n\tassert unique_product([5, 13, 11, 4, 2, 6]) == 34320", "def check(unique_product):\n\tassert unique_product([2, 7, 9, 1, 2, 4]) == 504", "def check(unique_product):\n\tassert unique_product([3, 13, 7, 1, 3, 2]) == 546", "def check(unique_product):\n\tassert unique_product([11, 8, 10, 3, 1, 4]) == 10560", "def check(unique_product):\n\tassert unique_product([4, 5, 9, 3, 4, 5]) == 540", "def check(unique_product):\n\tassert unique_product([9, 12, 5, 5, 4, 5]) == 2160", "def check(unique_product):\n\tassert unique_product([12, 4, 10, 1, 4, 2]) == 960", "def check(unique_product):\n\tassert unique_product([6, 9, 13, 1, 3, 4]) == 8424", "def check(unique_product):\n\tassert unique_product([2, 3, 6, 5, 1, 3]) == 180", "def check(unique_product):\n\tassert unique_product([4, 6, 14, 2, 2, 1]) == 672", "def check(unique_product):\n\tassert unique_product([6, 9, 12, 4, 3, 6]) == 7776", "def check(unique_product):\n\tassert unique_product([10, 6, 4, 5, 5, 2]) == 2400", "def check(unique_product):\n\tassert unique_product([4, 9, 4, 2, 4, 4]) == 72", "def check(unique_product):\n\tassert unique_product([6, 10, 8, 1, 5, 4]) == 9600", "def check(unique_product):\n\tassert unique_product([2, 4, 10, 2, 3, 1]) == 240", "def check(unique_product):\n\tassert unique_product([6, 9, 10, 2, 4, 6]) == 4320", "def check(unique_product):\n\tassert unique_product([10, 9, 12, 5, 4, 1]) == 21600", "def check(unique_product):\n\tassert unique_product([12, 6, 4, 1, 5, 1]) == 1440", "def check(unique_product):\n\tassert unique_product([8, 3, 4, 1, 5, 1]) == 480", "def check(unique_product):\n\tassert unique_product([3, 10, 8, 3, 1, 1]) == 240", "def check(unique_product):\n\tassert unique_product([7, 13, 14, 2, 2, 6]) == 15288", "def check(unique_product):\n\tassert unique_product([8, 7, 4, 4, 1, 5]) == 1120", "def check(unique_product):\n\tassert unique_product([2, 4, 10, 4, 6, 3]) == 1440", "def check(unique_product):\n\tassert unique_product([8, 6, 6, 2, 4, 2]) == 384", "def check(unique_product):\n\tassert unique_product([9, 9, 12, 5, 3, 1]) == 1620", "def check(unique_product):\n\tassert unique_product([9, 13, 5, 4, 2, 5]) == 4680", "def check(unique_product):\n\tassert unique_product([2, 7, 4, 4, 2, 4]) == 56", "def check(unique_product):\n\tassert unique_product([4, 10, 8, 3, 5, 5]) == 4800", "def check(unique_product):\n\tassert unique_product([5, 4, 11, 3, 4, 1]) == 660", "def check(unique_product):\n\tassert unique_product([12, 8, 4, 4, 6, 4]) == 2304", "def check(unique_product):\n\tassert unique_product([11, 10, 10, 2, 2, 3]) == 660", "def check(unique_product):\n\tassert unique_product([12, 9, 11, 1, 4, 2]) == 9504", "def check(unique_product):\n\tassert unique_product([5, 6, 4, 3, 5, 6]) == 360"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef unique_product(numbers: list) -> int:\n    '''\n    Computes the product of distinct numbers in the provided list.\n    \n    Parameters:\n    numbers (list): A list of numbers which may contain duplicates.\n    \n    Returns:\n    int: The product of unique numbers in the list.\n    \n    Raises:\n    ValueError: If the list contains non-numeric inputs.\n    '''\n    # Convert the list to a set to remove duplicates\n    try:\n        unique_numbers = set(numbers)\n    except TypeError:\n        raise ValueError(\"The list contains non-numeric inputs.\")\n\n    # Initialize the product variable\n    product = 1\n\n    # Calculate the product of unique numbers\n    for number in unique_numbers:\n        if not isinstance(number, (int, float)):\n            raise ValueError(\"The list contains non-numeric inputs.\")\n        product *= number\n\n    return product\n", "passed": true, "pass": true, "pass_num": 10, "round": 574, "mutate_method": "rephrase_one", "parent_index": 283}
