{"source_file": "Mike's Copy of Benchmark Questions Verification V2.ipynb", "task_id": 103, "prompt": "Write a function to determine the Eulerian number a(n, m). This involves calculating a specific value of the Eulerian number, which is defined for two non-negative integers n and m.", "code": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))", "test_imports": [], "test_list": ["assert eulerian_num(3, 1) == 4", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(5, 3) == 26", "assert eulerian_num(4, 3) == 1", "assert eulerian_num(7, 3) == 2416", "assert eulerian_num(3, 1) == 4", "assert eulerian_num(1, 3) == 0", "assert eulerian_num(7, 2) == 1191", "assert eulerian_num(3, 4) == 0", "assert eulerian_num(4, 4) == 0", "assert eulerian_num(7, 2) == 1191", "assert eulerian_num(5, 3) == 26", "assert eulerian_num(2, 2) == 0", "assert eulerian_num(6, 1) == 57", "assert eulerian_num(5, 2) == 66", "assert eulerian_num(8, 5) == 4293", "assert eulerian_num(6, 2) == 302", "assert eulerian_num(7, 4) == 1191", "assert eulerian_num(4, 3) == 1", "assert eulerian_num(7, 1) == 120", "assert eulerian_num(7, 1) == 120", "assert eulerian_num(5, 5) == 0", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(6, 1) == 57", "assert eulerian_num(6, 5) == 1", "assert eulerian_num(6, 3) == 302", "assert eulerian_num(5, 4) == 1", "assert eulerian_num(7, 2) == 1191", "assert eulerian_num(3, 4) == 0", "assert eulerian_num(8, 3) == 15619", "assert eulerian_num(1, 6) == 0", "assert eulerian_num(2, 5) == 0", "assert eulerian_num(4, 5) == 0", "assert eulerian_num(1, 1) == 0", "assert eulerian_num(6, 2) == 302", "assert eulerian_num(8, 2) == 4293", "assert eulerian_num(2, 4) == 0", "assert eulerian_num(5, 5) == 0", "assert eulerian_num(1, 3) == 0", "assert eulerian_num(1, 4) == 0", "assert eulerian_num(9, 3) == 88234", "assert eulerian_num(1, 4) == 0", "assert eulerian_num(3, 1) == 4", "assert eulerian_num(6, 5) == 1", "assert eulerian_num(3, 4) == 0", "assert eulerian_num(9, 2) == 14608", "assert eulerian_num(9, 6) == 14608", "assert eulerian_num(3, 4) == 0", "assert eulerian_num(3, 6) == 0", "assert eulerian_num(8, 2) == 4293", "assert eulerian_num(1, 2) == 0", "assert eulerian_num(6, 3) == 302", "assert eulerian_num(3, 5) == 0", "assert eulerian_num(1, 4) == 0", "assert eulerian_num(6, 2) == 302", "assert eulerian_num(1, 4) == 0", "assert eulerian_num(2, 3) == 0", "assert eulerian_num(2, 5) == 0", "assert eulerian_num(8, 6) == 247", "assert eulerian_num(9, 1) == 502", "assert eulerian_num(6, 4) == 57", "assert eulerian_num(5, 1) == 26", "assert eulerian_num(2, 1) == 1", "assert eulerian_num(6, 4) == 57", "assert eulerian_num(2, 2) == 0", "assert eulerian_num(1, 2) == 0", "assert eulerian_num(7, 3) == 2416", "assert eulerian_num(2, 6) == 0", "assert eulerian_num(5, 5) == 0", "assert eulerian_num(9, 1) == 502", "assert eulerian_num(5, 7) == 0", "assert eulerian_num(1, 5) == 0", "assert eulerian_num(10, 1) == 1013", "assert eulerian_num(1, 2) == 0", "assert eulerian_num(6, 7) == 0", "assert eulerian_num(10, 5) == 1310354", "assert eulerian_num(3, 1) == 4", "assert eulerian_num(5, 5) == 0", "assert eulerian_num(6, 3) == 302", "assert eulerian_num(8, 2) == 4293", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(2, 4) == 0", "assert eulerian_num(6, 3) == 302", "assert eulerian_num(7, 1) == 120", "assert eulerian_num(9, 2) == 14608", "assert eulerian_num(2, 8) == 0", "assert eulerian_num(9, 2) == 14608", "assert eulerian_num(9, 1) == 502", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(2, 8) == 0", "assert eulerian_num(4, 6) == 0", "assert eulerian_num(7, 4) == 1191", "assert eulerian_num(1, 3) == 0", "assert eulerian_num(10, 5) == 1310354", "assert eulerian_num(5, 8) == 0", "assert eulerian_num(5, 5) == 0", "assert eulerian_num(4, 1) == 11", "assert eulerian_num(3, 5) == 0", "assert eulerian_num(10, 8) == 1013", "assert eulerian_num(8, 1) == 247", "assert eulerian_num(5, 6) == 0", "assert eulerian_num(2, 5) == 0"], "entry_point": "eulerian_num", "repair_prompt": ["Write a function eulerian_num to determine the Eulerian number a(n, m). This involves calculating a specific value of the Eulerian number, which is defined for two non-negative integers n and m.\neulerian_num(3, 1) == 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    Eulerian numbers are defined by the recurrence relation:\n    a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m)\n\n    :param n: Non-negative integer representing the row.\n    :param m: Non-negative integer representing the column.\n    :return: The Eulerian number a(n, m).\n    \"\"\"\n    if n < 0 or m < 0:\n        raise ValueError(\"Both n and m must be non-negative integers.\")\n    if m >= n:\n        return 0\n    if m == 0:\n        return 1\n\n    @lru_cache(maxsize=None)\n    def calculate_eulerian(n: int, m: int) -> int:\n        if m >= n:\n            return 0\n        if m == 0:\n            return 1\n        return (n - m) * calculate_eulerian(n - 1, m - 1) + (m + 1) * calculate_eulerian(n - 1, m)\n\n    return calculate_eulerian(n, m)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    The Eulerian number a(n, m) is defined by the recursive formula:\n    a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m)\n\n    :param n: Non-negative integer representing the number of elements.\n    :param m: Non-negative integer representing the number of elements greater than the previous element.\n    :return: The Eulerian number a(n, m).\n    \"\"\"\n    if n < 0 or m < 0:\n        raise ValueError(\"Both n and m must be non-negative integers.\")\n    if m >= n:\n        return 0\n    if m == 0:\n        return 1\n\n    @lru_cache(maxsize=None)\n    def recursive_eulerian(n: int, m: int) -> int:\n        if m == 0:\n            return 1\n        if m >= n:\n            return 0\n        return (n - m) * recursive_eulerian(n - 1, m - 1) + (m + 1) * recursive_eulerian(n - 1, m)\n\n    return recursive_eulerian(n, m)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n    \n    The Eulerian number a(n, m) is defined recursively as:\n    a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m)\n    \n    :param n: Non-negative integer representing the row.\n    :param m: Non-negative integer representing the column.\n    :return: The Eulerian number a(n, m).\n    \"\"\"\n    if m >= n or n < 0 or m < 0:\n        return 0\n    if m == 0:\n        return 1\n    \n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)\n\n# Apply memoization to optimize recursive calls\neulerian_num = lru_cache(maxsize=None)(eulerian_num)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    Args:\n        n (int): Non-negative integer representing the number of elements.\n        m (int): Non-negative integer representing the number of elements greater than the previous element.\n\n    Returns:\n        int: The Eulerian number a(n, m).\n    \"\"\"\n    # Validate inputs\n    if not isinstance(n, int) or not isinstance(m, int):\n        raise ValueError(\"Both n and m must be integers.\")\n    if n < 0 or m < 0:\n        raise ValueError(\"Both n and m must be non-negative integers.\")\n    if m >= n:\n        return 0 if n > 0 else 1\n\n    @lru_cache(maxsize=None)\n    def recursive_eulerian(n: int, m: int) -> int:\n        if m == 0:\n            return 1 if n == 0 else 0\n        return (n - m) * recursive_eulerian(n - 1, m - 1) + (m + 1) * recursive_eulerian(n - 1, m)\n\n    return recursive_eulerian(n, m)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number A(n, m) for given non-negative integers n and m.\n\n    The Eulerian number A(n, m) is defined recursively as:\n    A(n, m) = (n - m) * A(n - 1, m - 1) + (m + 1) * A(n - 1, m)\n\n    :param n: Non-negative integer representing the first parameter of the Eulerian number.\n    :param m: Non-negative integer representing the second parameter of the Eulerian number.\n    :return: The Eulerian number A(n, m).\n    \"\"\"\n    # Base cases\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n\n    # Use memoization to optimize recursive calls\n    @lru_cache(maxsize=None)\n    def recursive_eulerian(n: int, m: int) -> int:\n        if m >= n or n == 0:\n            return 0\n        if m == 0:\n            return 1\n        return (n - m) * recursive_eulerian(n - 1, m - 1) + (m + 1) * recursive_eulerian(n - 1, m)\n\n    return recursive_eulerian(n, m)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    The Eulerian number a(n, m) is defined recursively as:\n    a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m)\n\n    :param n: A non-negative integer representing the first parameter of the Eulerian number.\n    :param m: A non-negative integer representing the second parameter of the Eulerian number.\n    :return: The Eulerian number a(n, m).\n    \"\"\"\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0:\n        return 1 if n == 0 else 0\n\n    return _eulerian_num_memoized(n, m)\n\n@lru_cache(maxsize=None)\ndef _eulerian_num_memoized(n: int, m: int) -> int:\n    \"\"\"\n    Helper function to calculate the Eulerian number using memoization.\n\n    :param n: A non-negative integer representing the first parameter of the Eulerian number.\n    :param m: A non-negative integer representing the second parameter of the Eulerian number.\n    :return: The Eulerian number a(n, m).\n    \"\"\"\n    if n == 0:\n        return 1 if m == 0 else 0\n    if m == 0:\n        return 1 if n == 0 else 0\n\n    return (n - m) * _eulerian_num_memoized(n - 1, m - 1) + (m + 1) * _eulerian_num_memoized(n - 1, m)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n    \n    Args:\n        n: Non-negative integer representing the row.\n        m: Non-negative integer representing the column.\n    \n    Returns:\n        The Eulerian number a(n, m).\n    \"\"\"\n    if n < 0 or m < 0:\n        raise ValueError(\"n and m must be non-negative integers.\")\n    \n    @lru_cache(maxsize=None)\n    def calculate_eulerian(n: int, m: int) -> int:\n        if m >= n or m < 0:\n            return 0\n        if n == 0:\n            return 1 if m == 0 else 0\n        return (n - m) * calculate_eulerian(n - 1, m - 1) + (m + 1) * calculate_eulerian(n - 1, m)\n    \n    return calculate_eulerian(n, m)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    The Eulerian number a(n, m) is the number of permutations of the numbers\n    1 to n in which exactly m elements are greater than the previous element.\n\n    :param n: A non-negative integer representing the number of permutations.\n    :param m: A non-negative integer representing the number of ascents.\n    :return: The Eulerian number a(n, m).\n    \"\"\"\n    # Validate input\n    if n < 0 or m < 0:\n        raise ValueError(\"Both n and m must be non-negative integers.\")\n    if m >= n:\n        return 0\n\n    @lru_cache(maxsize=None)\n    def recursive_eulerian(n: int, m: int) -> int:\n        # Base case\n        if m == 0:\n            return 1 if n == 0 else 0\n        # Recursive case\n        return (n - m) * recursive_eulerian(n - 1, m - 1) + (m + 1) * recursive_eulerian(n - 1, m)\n\n    return recursive_eulerian(n, m)\n\n# Example usage:\n# print(eulerian_num(4, 2))  # Output should be 11\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    The Eulerian number a(n, m) is the number of permutations of the numbers\n    1 to n in which exactly m elements are greater than the previous element.\n\n    Args:\n        n (int): Non-negative integer representing the row.\n        m (int): Non-negative integer representing the column.\n\n    Returns:\n        int: The Eulerian number a(n, m).\n\n    Raises:\n        ValueError: If n or m is negative.\n    \"\"\"\n    if n < 0 or m < 0:\n        raise ValueError(\"Both n and m must be non-negative integers.\")\n\n    @lru_cache(maxsize=None)\n    def calculate_eulerian(n: int, m: int) -> int:\n        if m >= n or m < 0:\n            return 0\n        if n == 0:\n            return 1 if m == 0 else 0\n        return (n - m) * calculate_eulerian(n - 1, m - 1) + (m + 1) * calculate_eulerian(n - 1, m)\n\n    return calculate_eulerian(n, m)\n\n# Example usage:\n# result = eulerian_num(4, 2)\n# print(result)  # Output should be 11\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n\n    Parameters:\n    n (int): A non-negative integer representing the row.\n    m (int): A non-negative integer representing the column.\n\n    Returns:\n    int: The Eulerian number a(n, m).\n    \"\"\"\n    if n < 0 or m < 0:\n        raise ValueError(\"Both n and m must be non-negative integers.\")\n    if m >= n:\n        return 0 if m > n else 1\n\n    @lru_cache(maxsize=None)\n    def recursive_eulerian(n: int, m: int) -> int:\n        if m == 0:\n            return 1\n        if m >= n:\n            return 0\n        return (n - m) * recursive_eulerian(n - 1, m - 1) + (m + 1) * recursive_eulerian(n - 1, m)\n\n    return recursive_eulerian(n, m)\n"], "plans": ["requirement analysis:\nThe requirement is to create a function that accurately calculates Eulerian numbers for given non-negative integers n and m. Eulerian numbers are a specific sequence of numbers in combinatorics, and the function should be efficient enough to handle large values of n and m.\nrequirement pool:\n- Implement the Eulerian number calculation function\n- Optimize the function for performance\n- Provide documentation and usage examples\n- Ensure compatibility with existing mathematical libraries\n- Include error handling for invalid inputs\nWe will implement the Eulerian number calculation using a recursive formula. Eulerian numbers can be calculated using the recurrence relation: a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m). This approach is straightforward and can be optimized using memoization to handle larger inputs efficiently. We will use Python's built-in functools library to implement memoization.\n", "requirement analysis:\nThe requirement is to create a function that accurately computes Eulerian numbers for given non-negative integers n and m. Eulerian numbers are a sequence of integers that count permutations of the numbers 1 to n in which exactly m elements are greater than the previous element.\nrequirement pool:\n- Implement the eulerian_num function to compute Eulerian numbers\n- Optimize the function for performance with large inputs\n- Provide documentation and examples for user understanding\n- Integrate the function into a larger mathematical toolkit\n- Develop a user interface for interactive computation\nWe will implement the eulerian_num function using a recursive approach with memoization to optimize performance for large inputs. The Eulerian number a(n, m) can be calculated using the recursive formula: a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m). We will use Python's functools.lru_cache to cache results of recursive calls, which will significantly improve performance.\n", "requirement analysis:\nThe requirement is to create a function that accurately calculates Eulerian numbers for given non-negative integers n and m. Eulerian numbers are used in combinatorics and have specific properties that need to be considered in the implementation.\nrequirement pool:\n- Implement the eulerian_num function to calculate Eulerian numbers\n- Optimize the function for performance with large inputs\n- Provide documentation and examples for user understanding\n- Ensure compatibility with existing mathematical libraries\n- Create a user-friendly interface for input and output\nWe will implement the eulerian_num function using a recursive approach with memoization to optimize performance for large inputs. The Eulerian number a(n, m) can be calculated using the recursive formula: a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m). We will use Python's functools.lru_cache to cache results of recursive calls to improve efficiency.\n", "requirement analysis:\nThe requirement is to implement a function that calculates Eulerian numbers for given non-negative integers n and m. Eulerian numbers are a sequence of integers that count permutations of the numbers 1 to n in which exactly m elements are greater than the previous element.\nrequirement pool:\n- Implement the eulerian_num function to calculate Eulerian numbers\n- Optimize the function for performance with large inputs\n- Provide documentation and examples for users\n- Ensure compatibility with existing mathematical libraries\n- Include error handling for invalid inputs\nWe will implement the eulerian_num function using a recursive approach with memoization to optimize performance for large inputs. The function will calculate Eulerian numbers based on the recursive formula: a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m). We will use Python's functools library to handle memoization efficiently.\n", "requirement analysis:\nThe requirement is to create a function that accurately calculates Eulerian numbers for given non-negative integers n and m. Eulerian numbers are used in combinatorics and have specific properties that need to be considered in the implementation.\nrequirement pool:\n- Implement the Eulerian number calculation function\n- Optimize the function for performance with large inputs\n- Provide documentation and examples for users\n- Ensure compatibility with other mathematical libraries\n- Create a user-friendly interface for input and output\nWe will implement the Eulerian number calculation using a recursive formula with memoization to optimize performance. The Eulerian number A(n, m) can be calculated using the formula: A(n, m) = (n - m) * A(n - 1, m - 1) + (m + 1) * A(n - 1, m). We will use Python's functools.lru_cache to memoize results and improve efficiency for large inputs.\n", "requirement analysis:\nThe requirement is to create a function that accurately calculates Eulerian numbers for given non-negative integers n and m. The function should be efficient and handle large inputs gracefully.\nrequirement pool:\n- Implement the Eulerian number calculation function\n- Optimize the function for performance\n- Provide documentation and usage examples\n- Ensure compatibility with existing mathematical libraries\n- Create a user-friendly interface for input and output\nWe will implement the Eulerian number calculation using a recursive approach with memoization to optimize performance for large inputs. The Eulerian number a(n, m) can be calculated using the recursive formula: a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m). We will use Python's functools.lru_cache to memoize results of subproblems.\n", "requirement analysis:\nThe requirement is to create a function that accurately calculates Eulerian numbers for given non-negative integers n and m. The function should be efficient and handle large inputs gracefully.\nrequirement pool:\n- Implement the Eulerian number calculation function\n- Optimize the function for performance\n- Provide documentation and usage examples\n- Ensure compatibility with existing mathematical libraries\n- Include error handling for invalid inputs\nWe will implement the Eulerian number calculation using a recursive formula. Eulerian numbers can be calculated using the recurrence relation: a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m). This approach is efficient for small values of n and m, but for larger values, we will optimize using memoization to store previously computed results and avoid redundant calculations.\n", "requirement analysis:\nThe requirement is to create a function that accurately calculates Eulerian numbers for given non-negative integers n and m. The function should be efficient and handle large inputs gracefully.\nrequirement pool:\n- Implement the eulerian_num function to calculate Eulerian numbers\n- Optimize the function for performance with large inputs\n- Provide documentation and examples for users\n- Ensure compatibility with existing mathematical libraries\n- Create a user-friendly interface for input and output\nWe will implement the eulerian_num function using a recursive approach with memoization to efficiently calculate Eulerian numbers. This approach will help in optimizing performance for large inputs. We will use the functools library for memoization.\n", "requirement analysis:\nThe requirement is to create a function that accurately computes Eulerian numbers for given non-negative integers n and m. Eulerian numbers are a specific sequence in combinatorics, and the function should handle edge cases and large inputs efficiently.\nrequirement pool:\n- Implement the Eulerian number calculation function\n- Optimize the function for performance\n- Include comprehensive documentation\n- Provide example use cases\n- Ensure compatibility with existing mathematical libraries\nWe will implement the Eulerian number calculation using a recursive approach with memoization to optimize performance for large inputs. The function will strictly enforce non-negative integers for n and m, as Eulerian numbers are defined for these values. We will use Python's built-in data structures and libraries to ensure compatibility and efficiency.\n", "requirement analysis:\nThe requirement is to create a function that accurately computes Eulerian numbers for given non-negative integers n and m. Eulerian numbers are a specific sequence of numbers in combinatorics, and the function should handle edge cases and provide correct results for typical inputs.\nrequirement pool:\n- Implement the Eulerian number calculation function\n- Optimize the function for performance\n- Include documentation and usage examples\n- Ensure compatibility with existing mathematical libraries\n- Provide error handling for invalid inputs\nWe will implement the Eulerian number calculation using a recursive approach with memoization to optimize performance for large inputs. The function will handle edge cases and provide error handling for invalid inputs. We will use Python's built-in libraries to ensure compatibility and simplicity.\n"], "test": ["def check(eulerian_num):\n\tassert eulerian_num(3, 1) == 4", "def check(eulerian_num):\n\tassert eulerian_num(4, 1) == 11", "def check(eulerian_num):\n\tassert eulerian_num(5, 3) == 26", "def check(eulerian_num):\n\tassert eulerian_num(4, 3) == 1", "def check(eulerian_num):\n\tassert eulerian_num(7, 3) == 2416", "def check(eulerian_num):\n\tassert eulerian_num(3, 1) == 4", "def check(eulerian_num):\n\tassert eulerian_num(1, 3) == 0", "def check(eulerian_num):\n\tassert eulerian_num(7, 2) == 1191", "def check(eulerian_num):\n\tassert eulerian_num(3, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(4, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(7, 2) == 1191", "def check(eulerian_num):\n\tassert eulerian_num(5, 3) == 26", "def check(eulerian_num):\n\tassert eulerian_num(2, 2) == 0", "def check(eulerian_num):\n\tassert eulerian_num(6, 1) == 57", "def check(eulerian_num):\n\tassert eulerian_num(5, 2) == 66", "def check(eulerian_num):\n\tassert eulerian_num(8, 5) == 4293", "def check(eulerian_num):\n\tassert eulerian_num(6, 2) == 302", "def check(eulerian_num):\n\tassert eulerian_num(7, 4) == 1191", "def check(eulerian_num):\n\tassert eulerian_num(4, 3) == 1", "def check(eulerian_num):\n\tassert eulerian_num(7, 1) == 120", "def check(eulerian_num):\n\tassert eulerian_num(7, 1) == 120", "def check(eulerian_num):\n\tassert eulerian_num(5, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(4, 1) == 11", "def check(eulerian_num):\n\tassert eulerian_num(6, 1) == 57", "def check(eulerian_num):\n\tassert eulerian_num(6, 5) == 1", "def check(eulerian_num):\n\tassert eulerian_num(6, 3) == 302", "def check(eulerian_num):\n\tassert eulerian_num(5, 4) == 1", "def check(eulerian_num):\n\tassert eulerian_num(7, 2) == 1191", "def check(eulerian_num):\n\tassert eulerian_num(3, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(8, 3) == 15619", "def check(eulerian_num):\n\tassert eulerian_num(1, 6) == 0", "def check(eulerian_num):\n\tassert eulerian_num(2, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(4, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(1, 1) == 0", "def check(eulerian_num):\n\tassert eulerian_num(6, 2) == 302", "def check(eulerian_num):\n\tassert eulerian_num(8, 2) == 4293", "def check(eulerian_num):\n\tassert eulerian_num(2, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(5, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(1, 3) == 0", "def check(eulerian_num):\n\tassert eulerian_num(1, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(9, 3) == 88234", "def check(eulerian_num):\n\tassert eulerian_num(1, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(3, 1) == 4", "def check(eulerian_num):\n\tassert eulerian_num(6, 5) == 1", "def check(eulerian_num):\n\tassert eulerian_num(3, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(9, 2) == 14608", "def check(eulerian_num):\n\tassert eulerian_num(9, 6) == 14608", "def check(eulerian_num):\n\tassert eulerian_num(3, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(3, 6) == 0", "def check(eulerian_num):\n\tassert eulerian_num(8, 2) == 4293", "def check(eulerian_num):\n\tassert eulerian_num(1, 2) == 0", "def check(eulerian_num):\n\tassert eulerian_num(6, 3) == 302", "def check(eulerian_num):\n\tassert eulerian_num(3, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(1, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(6, 2) == 302", "def check(eulerian_num):\n\tassert eulerian_num(1, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(2, 3) == 0", "def check(eulerian_num):\n\tassert eulerian_num(2, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(8, 6) == 247", "def check(eulerian_num):\n\tassert eulerian_num(9, 1) == 502", "def check(eulerian_num):\n\tassert eulerian_num(6, 4) == 57", "def check(eulerian_num):\n\tassert eulerian_num(5, 1) == 26", "def check(eulerian_num):\n\tassert eulerian_num(2, 1) == 1", "def check(eulerian_num):\n\tassert eulerian_num(6, 4) == 57", "def check(eulerian_num):\n\tassert eulerian_num(2, 2) == 0", "def check(eulerian_num):\n\tassert eulerian_num(1, 2) == 0", "def check(eulerian_num):\n\tassert eulerian_num(7, 3) == 2416", "def check(eulerian_num):\n\tassert eulerian_num(2, 6) == 0", "def check(eulerian_num):\n\tassert eulerian_num(5, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(9, 1) == 502", "def check(eulerian_num):\n\tassert eulerian_num(5, 7) == 0", "def check(eulerian_num):\n\tassert eulerian_num(1, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(10, 1) == 1013", "def check(eulerian_num):\n\tassert eulerian_num(1, 2) == 0", "def check(eulerian_num):\n\tassert eulerian_num(6, 7) == 0", "def check(eulerian_num):\n\tassert eulerian_num(10, 5) == 1310354", "def check(eulerian_num):\n\tassert eulerian_num(3, 1) == 4", "def check(eulerian_num):\n\tassert eulerian_num(5, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(6, 3) == 302", "def check(eulerian_num):\n\tassert eulerian_num(8, 2) == 4293", "def check(eulerian_num):\n\tassert eulerian_num(4, 1) == 11", "def check(eulerian_num):\n\tassert eulerian_num(2, 4) == 0", "def check(eulerian_num):\n\tassert eulerian_num(6, 3) == 302", "def check(eulerian_num):\n\tassert eulerian_num(7, 1) == 120", "def check(eulerian_num):\n\tassert eulerian_num(9, 2) == 14608", "def check(eulerian_num):\n\tassert eulerian_num(2, 8) == 0", "def check(eulerian_num):\n\tassert eulerian_num(9, 2) == 14608", "def check(eulerian_num):\n\tassert eulerian_num(9, 1) == 502", "def check(eulerian_num):\n\tassert eulerian_num(4, 1) == 11", "def check(eulerian_num):\n\tassert eulerian_num(2, 8) == 0", "def check(eulerian_num):\n\tassert eulerian_num(4, 6) == 0", "def check(eulerian_num):\n\tassert eulerian_num(7, 4) == 1191", "def check(eulerian_num):\n\tassert eulerian_num(1, 3) == 0", "def check(eulerian_num):\n\tassert eulerian_num(10, 5) == 1310354", "def check(eulerian_num):\n\tassert eulerian_num(5, 8) == 0", "def check(eulerian_num):\n\tassert eulerian_num(5, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(4, 1) == 11", "def check(eulerian_num):\n\tassert eulerian_num(3, 5) == 0", "def check(eulerian_num):\n\tassert eulerian_num(10, 8) == 1013", "def check(eulerian_num):\n\tassert eulerian_num(8, 1) == 247", "def check(eulerian_num):\n\tassert eulerian_num(5, 6) == 0", "def check(eulerian_num):\n\tassert eulerian_num(2, 5) == 0"], "scores": [1.0, 1.0, 1.0, 0.4216, 1.0, 0.4216, 0.4216, 0.4216, 0.4216, 0.9118], "pass_results": [true, true, true, false, true, false, false, false, false, false], "pass_test_cases_num": [102, 102, 102, 43, 102, 43, 43, 43, 43, 93], "completion": "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef eulerian_num(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the Eulerian number A(n, m) for given non-negative integers n and m.\n\n    The Eulerian number A(n, m) is defined recursively as:\n    A(n, m) = (n - m) * A(n - 1, m - 1) + (m + 1) * A(n - 1, m)\n\n    :param n: Non-negative integer representing the first parameter of the Eulerian number.\n    :param m: Non-negative integer representing the second parameter of the Eulerian number.\n    :return: The Eulerian number A(n, m).\n    \"\"\"\n    # Base cases\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n\n    # Use memoization to optimize recursive calls\n    @lru_cache(maxsize=None)\n    def recursive_eulerian(n: int, m: int) -> int:\n        if m >= n or n == 0:\n            return 0\n        if m == 0:\n            return 1\n        return (n - m) * recursive_eulerian(n - 1, m - 1) + (m + 1) * recursive_eulerian(n - 1, m)\n\n    return recursive_eulerian(n, m)\n", "passed": true, "pass": true, "pass_num": 4, "round": 749, "mutate_method": "expand_one2two", "parent_index": 43}
