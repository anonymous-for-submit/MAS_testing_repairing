{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 573, "prompt": "Write a python function to calculate the product of the unique numbers in a given list. Ensure your function handles edge cases, such as empty lists or lists with all identical elements, appropriately.", "code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "test_imports": [], "test_list": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000", "assert unique_product([1, 2, 3, 1,]) == 6", "assert unique_product([7, 8, 9, 0, 1, 1]) == 0", "assert unique_product([8, 17, 29, 43, 17, 49, 55, 45]) == 20567269800", "assert unique_product([5, 25, 28, 35, 23, 48, 55, 37]) == 275213400000", "assert unique_product([8, 21, 31, 36, 18, 45, 57, 35]) == 302971233600", "assert unique_product([11, 22, 30, 41, 17, 55, 60, 40]) == 667949040000", "assert unique_product([9, 15, 31, 44, 23, 55, 56, 45]) == 587001492000", "assert unique_product([9, 16, 26, 44, 24, 55, 64, 42]) == 584509685760", "assert unique_product([11, 17, 31, 41, 22, 54, 64, 36]) == 650558075904", "assert unique_product([8, 18, 34, 44, 20, 50, 59, 42]) == 533820672000", "assert unique_product([14, 19, 35, 44, 17, 45, 63, 42]) == 829189191600", "assert unique_product([12, 16, 27, 43, 22, 54, 61, 35]) == 565389538560", "assert unique_product([6, 22, 25, 39, 21, 51, 64, 39]) == 8821612800", "assert unique_product([9, 17, 29, 38, 22, 50, 59, 44]) == 481471293600", "assert unique_product([8, 16, 26, 40, 22, 55, 62, 41]) == 409453158400", "assert unique_product([11, 25, 30, 44, 15, 48, 58, 39]) == 591196320000", "assert unique_product([14, 21, 26, 36, 24, 52, 58, 40]) == 796756746240", "assert unique_product([10, 22, 25, 37, 21, 49, 64, 42]) == 562871232000", "assert unique_product([12, 19, 33, 41, 23, 50, 64, 37]) == 840063628800", "assert unique_product([8, 15, 28, 38, 25, 51, 55, 40]) == 358142400000", "assert unique_product([13, 19, 34, 40, 18, 54, 55, 43]) == 772206177600", "assert unique_product([9, 23, 31, 42, 18, 51, 62, 45]) == 690284647080", "assert unique_product([10, 23, 26, 42, 19, 46, 63, 35]) == 484028017200", "assert unique_product([13, 15, 29, 39, 24, 55, 59, 42]) == 721393873200", "assert unique_product([13, 24, 34, 43, 20, 48, 57, 43]) == 24960199680", "assert unique_product([6, 18, 34, 35, 25, 49, 57, 43]) == 385878087000", "assert unique_product([14, 20, 30, 44, 16, 48, 59, 44]) == 16747315200", "assert unique_product([14, 18, 25, 43, 15, 52, 55, 38]) == 441621180000", "assert unique_product([14, 25, 32, 45, 19, 46, 62, 41]) == 1119740832000", "assert unique_product([9, 16, 31, 37, 18, 52, 59, 41]) == 373970742912", "assert unique_product([8, 24, 34, 45, 19, 50, 64, 44]) == 785866752000", "assert unique_product([14, 24, 33, 44, 19, 55, 63, 41]) == 1316881177920", "assert unique_product([5, 21, 27, 36, 22, 55, 62, 37]) == 283292024400", "assert unique_product([12, 23, 34, 38, 21, 50, 59, 35]) == 773180604000", "assert unique_product([11, 25, 35, 41, 18, 50, 61, 39]) == 844931587500", "assert unique_product([6, 2, 1, 1]) == 12", "assert unique_product([3, 6, 1, 5]) == 90", "assert unique_product([2, 4, 1, 3]) == 24", "assert unique_product([6, 5, 2, 3]) == 180", "assert unique_product([5, 4, 1, 1]) == 20", "assert unique_product([2, 1, 3, 3]) == 6", "assert unique_product([5, 6, 7, 1]) == 210", "assert unique_product([3, 3, 3, 6]) == 18", "assert unique_product([4, 3, 4, 6]) == 72", "assert unique_product([6, 4, 6, 5]) == 120", "assert unique_product([3, 1, 6, 1]) == 18", "assert unique_product([6, 7, 5, 2]) == 420", "assert unique_product([2, 3, 7, 1]) == 42", "assert unique_product([5, 1, 1, 6]) == 30", "assert unique_product([3, 4, 3, 1]) == 12", "assert unique_product([4, 4, 1, 5]) == 20", "assert unique_product([2, 1, 2, 6]) == 12", "assert unique_product([1, 4, 2, 4]) == 8", "assert unique_product([3, 4, 8, 6]) == 576", "assert unique_product([3, 7, 3, 2]) == 42", "assert unique_product([4, 6, 5, 4]) == 120", "assert unique_product([4, 5, 7, 2]) == 280", "assert unique_product([1, 1, 5, 5]) == 5", "assert unique_product([3, 3, 3, 6]) == 18", "assert unique_product([6, 6, 3, 1]) == 18", "assert unique_product([4, 2, 5, 1]) == 40", "assert unique_product([2, 2, 3, 1]) == 6", "assert unique_product([6, 5, 4, 5]) == 120", "assert unique_product([5, 3, 2, 2]) == 30", "assert unique_product([4, 5, 4, 5]) == 20", "assert unique_product([4, 7, 1, 2]) == 56", "assert unique_product([3, 3, 3, 3]) == 3", "assert unique_product([1, 7, 3, 4]) == 84", "assert unique_product([5, 13, 11, 4, 2, 6]) == 34320", "assert unique_product([2, 7, 9, 1, 2, 4]) == 504", "assert unique_product([3, 13, 7, 1, 3, 2]) == 546", "assert unique_product([11, 8, 10, 3, 1, 4]) == 10560", "assert unique_product([4, 5, 9, 3, 4, 5]) == 540", "assert unique_product([9, 12, 5, 5, 4, 5]) == 2160", "assert unique_product([12, 4, 10, 1, 4, 2]) == 960", "assert unique_product([6, 9, 13, 1, 3, 4]) == 8424", "assert unique_product([2, 3, 6, 5, 1, 3]) == 180", "assert unique_product([4, 6, 14, 2, 2, 1]) == 672", "assert unique_product([6, 9, 12, 4, 3, 6]) == 7776", "assert unique_product([10, 6, 4, 5, 5, 2]) == 2400", "assert unique_product([4, 9, 4, 2, 4, 4]) == 72", "assert unique_product([6, 10, 8, 1, 5, 4]) == 9600", "assert unique_product([2, 4, 10, 2, 3, 1]) == 240", "assert unique_product([6, 9, 10, 2, 4, 6]) == 4320", "assert unique_product([10, 9, 12, 5, 4, 1]) == 21600", "assert unique_product([12, 6, 4, 1, 5, 1]) == 1440", "assert unique_product([8, 3, 4, 1, 5, 1]) == 480", "assert unique_product([3, 10, 8, 3, 1, 1]) == 240", "assert unique_product([7, 13, 14, 2, 2, 6]) == 15288", "assert unique_product([8, 7, 4, 4, 1, 5]) == 1120", "assert unique_product([2, 4, 10, 4, 6, 3]) == 1440", "assert unique_product([8, 6, 6, 2, 4, 2]) == 384", "assert unique_product([9, 9, 12, 5, 3, 1]) == 1620", "assert unique_product([9, 13, 5, 4, 2, 5]) == 4680", "assert unique_product([2, 7, 4, 4, 2, 4]) == 56", "assert unique_product([4, 10, 8, 3, 5, 5]) == 4800", "assert unique_product([5, 4, 11, 3, 4, 1]) == 660", "assert unique_product([12, 8, 4, 4, 6, 4]) == 2304", "assert unique_product([11, 10, 10, 2, 2, 3]) == 660", "assert unique_product([12, 9, 11, 1, 4, 2]) == 9504", "assert unique_product([5, 6, 4, 3, 5, 6]) == 360"], "entry_point": "unique_product", "repair_prompt": ["Write a python function unique_product to calculate the product of the unique numbers in a given list. Ensure your function handles edge cases, such as empty lists or lists with all identical elements, appropriately.\nunique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000\n"], "completions": ["from typing import List\n## main.py\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in the list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers.\n\n    Raises:\n    ValueError: If the list contains non-numeric elements.\n    \"\"\"\n    if not numbers:\n        return 1\n\n    # Check for non-numeric elements\n    for element in numbers:\n        if not isinstance(element, (int, float)):\n            raise ValueError(\"List contains non-numeric elements.\")\n\n    # Convert list to set to get unique numbers\n    unique_numbers = set(numbers)\n\n    # Calculate product of unique numbers\n    product = 1\n    for number in unique_numbers:\n        product *= number\n\n    return product\n", "from typing import List\n## main.py\n\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers. Returns 1 for an empty list.\n    \"\"\"\n    # Convert the list to a set to filter out unique elements\n    unique_numbers = set(numbers)\n    \n    # Calculate the product of unique elements using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers. Returns 1 for an empty list.\n    \"\"\"\n    # Convert the list to a set to filter out unique elements\n    unique_numbers = set(numbers)\n    \n    # Calculate the product of unique elements using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\n\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in the list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers.\n\n    Raises:\n    ValueError: If the list contains non-numeric values.\n    \"\"\"\n    if not numbers:\n        return 1  # Return 1 for empty list as the product of no numbers is 1\n\n    # Check for non-numeric values and raise an error\n    for num in numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"List contains non-numeric values.\")\n\n    # Convert list to set to ensure uniqueness\n    unique_numbers = set(numbers)\n\n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n\n    return product\n", "from typing import List\n## main.py\n\ndef unique_product(numbers: list) -> int:\n    '''\n    Calculate the product of unique numbers in a list.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The product of unique numbers.\n    \n    Raises:\n    ValueError: If the list contains non-numeric elements.\n    '''\n    if not numbers:\n        return 1\n    \n    try:\n        unique_numbers = set(numbers)\n    except TypeError:\n        raise ValueError(\"List contains non-numeric elements.\")\n    \n    product = 1\n    for number in unique_numbers:\n        if not isinstance(number, (int, float)):\n            raise ValueError(\"List contains non-numeric elements.\")\n        product *= number\n    \n    return product\n", "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n\n    Args:\n        numbers: List of integers or floats.\n\n    Returns:\n        Product of unique numbers.\n\n    Raises:\n        ValueError: If the list contains non-numeric values.\n    \"\"\"\n    # Validate input to ensure all elements are numeric\n    for num in numbers:\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"All elements in the list must be numeric.\")\n\n    # Convert list to set to ensure uniqueness\n    unique_numbers = set(numbers)\n\n    # Calculate the product using math.prod\n    product = math.prod(unique_numbers)\n\n    return product\n", "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> int:\n    '''\n    Calculate the product of unique numbers in the list.\n    \n    Parameters:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    int: The product of unique numbers.\n    \n    Raises:\n    ValueError: If the list contains non-numeric elements.\n    '''\n    if not numbers:\n        return 1\n    \n    try:\n        # Convert list to set to ensure uniqueness\n        unique_numbers = set(numbers)\n        \n        # Calculate the product using math.prod\n        product = math.prod(unique_numbers)\n        \n        return product\n    except TypeError:\n        raise ValueError(\"The list contains non-numeric elements.\")\n", "from typing import List\n## main.py\n\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers. Returns 1 for an empty list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list of integers.\")\n    \n    # Convert list to set to get unique numbers\n    unique_numbers = set(numbers)\n    \n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers. Returns 1 for an empty list.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Calculate the product using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers. Returns 1 for an empty list.\n    \"\"\"\n    # Extract unique numbers using set\n    unique_numbers = set(numbers)\n    \n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n"], "plans": ["requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, handling edge cases like empty lists and lists with identical elements. It should be optimized for performance and provide clear error handling.\nrequirement pool:\n- Implement the unique_product function to calculate the product of unique numbers\n- Ensure the function handles empty lists without errors\n- Handle lists with all identical elements correctly\n- Optimize the function for performance with large lists\n- Provide clear error messages for invalid inputs\nWe will implement the unique_product function using built-in Python functions to ensure efficiency and simplicity. The function will utilize a set to filter out unique numbers from the list, then calculate their product. We will handle edge cases such as empty lists and lists with all identical elements by returning appropriate values. For invalid inputs, such as non-numeric elements, the function will raise a ValueError with a clear message.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list. It must handle edge cases such as empty lists and lists with all identical elements. The implementation should be optimized for performance and include clear documentation.\nrequirement pool:\n- Implement the unique_product function\n- Handle edge cases like empty lists\n- Optimize for performance with large lists\n- Provide comprehensive documentation\n- Include unit tests for various scenarios\nWe will implement the unique_product function using Python's built-in set to filter out unique elements from the list. We will then use the math.prod function to calculate the product of these unique elements. This approach ensures simplicity and efficiency, leveraging Python's native capabilities. We will handle edge cases by returning 1 for empty lists, as the product of an empty set is conventionally 1, and by correctly processing lists with all identical elements.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list, handling edge cases such as empty lists and lists with identical elements. The solution should be optimized for performance and provide clear documentation for ease of use.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers\n- Handle edge cases such as empty lists\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation and examples\n- Include unit tests to verify functionality\nWe will use Python's built-in set to filter out unique elements from the list and then use the math.prod function to calculate the product of these unique elements. This approach is efficient and leverages Python's standard library for simplicity and performance. For edge cases, the function will return 1 for an empty list, as the product of no numbers is conventionally 1, and handle lists with all identical elements by returning the product of the single unique element.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, handle edge cases like empty lists or lists with identical elements, and provide clear error handling for invalid inputs.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers\n- Handle edge cases such as empty lists\n- Handle lists with all identical elements\n- Optimize the function for large input lists\n- Provide clear error messages for invalid inputs\nWe will implement a function named unique_product that calculates the product of unique numbers in a list. We will use Python's built-in set to handle uniqueness efficiently and math.prod to calculate the product. The function will handle edge cases such as empty lists and lists with all identical elements. It will also provide clear error messages for invalid inputs, such as non-numeric values.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list, handling edge cases such as empty lists and lists with identical elements. It should be easy to read and maintain, with clear error handling for invalid inputs.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers\n- Handle edge cases such as empty lists\n- Handle lists with all identical elements\n- Optimize the function for large input lists\n- Provide clear error messages for invalid inputs\nWe will use Python's built-in set to filter out unique elements from the list and then use a simple loop to calculate the product of these unique numbers. This approach is efficient and easy to read. We will handle edge cases such as empty lists and lists with all identical elements by checking the length of the unique set. For invalid inputs, we will raise a ValueError with a clear message.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, handling edge cases like empty lists and lists with identical elements. It should be optimized for performance and provide clear error handling.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers\n- Handle edge cases such as empty lists\n- Handle lists with all identical elements\n- Optimize the function for performance\n- Provide clear error messages for invalid inputs\nWe will implement a function named `unique_product` that calculates the product of unique numbers in a list. The function will first convert the list to a set to ensure uniqueness, then calculate the product using the `math.prod` function for efficiency. We will handle edge cases such as empty lists by returning 1 (the multiplicative identity) and lists with all identical elements by ensuring the set operation handles uniqueness. We will also include error handling for non-numeric inputs by raising a ValueError with a clear message.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, handling edge cases like empty lists and lists with identical elements. It should be optimized for performance and provide clear error handling.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers\n- Handle edge cases such as empty lists\n- Handle lists with all identical elements\n- Optimize for performance with large lists\n- Provide clear error messages for invalid inputs\nWe will implement a function named unique_product that calculates the product of unique numbers in a list. We will use Python's built-in set to handle uniqueness efficiently and math.prod for calculating the product. The function will include error handling for non-numeric inputs and edge cases like empty lists or lists with identical elements.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list. It must handle edge cases such as empty lists and lists with identical elements. The solution should be optimized for performance and memory usage.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers.\n- Handle edge cases such as empty lists and lists with identical elements.\n- Optimize the function for performance with large datasets.\n- Provide clear error messages for invalid inputs.\n- Include documentation and examples for user guidance.\nWe will implement a function named `unique_product` that calculates the product of unique numbers in a list. The function will handle edge cases such as empty lists by returning 1 (as the product of an empty set is conventionally 1) and lists with all identical elements by returning the product of the single unique element. We will use Python's built-in set to filter out unique elements and the `math.prod` function for efficient product calculation. This approach ensures optimal performance and memory usage.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers, handle edge cases like empty lists and lists with identical elements, and optimize performance for large datasets.\nrequirement pool:\n- Calculate product of unique numbers\n- Handle empty list edge case\n- Handle lists with identical elements\n- Optimize performance for large lists\n- Provide user-friendly error messages\nWe will use Python's built-in set to remove duplicates from the list and then use the math.prod function to calculate the product of the unique numbers. This approach ensures efficient handling of duplicates and leverages Python's standard library for performance optimization. We will also handle edge cases such as empty lists and lists with all identical elements by returning 1 for an empty list and calculating the product of a single unique element if all elements are identical.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list, handling edge cases such as empty lists and lists with identical elements. It should return 1 for empty lists and correctly compute the product for lists with duplicates.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers.\n- Ensure the function handles empty lists and returns 1.\n- Optimize the function for performance with large lists.\n- Test the function with lists containing all identical elements.\n- Document the function usage and edge case handling.\nWe will use Python's built-in set to extract unique elements from the list and then use the math.prod function to calculate the product of these unique elements. This approach ensures efficient handling of duplicates and edge cases such as empty lists or lists with all identical elements.\n"], "test": ["def check(unique_product):\n\tassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000", "def check(unique_product):\n\tassert unique_product([1, 2, 3, 1,]) == 6", "def check(unique_product):\n\tassert unique_product([7, 8, 9, 0, 1, 1]) == 0", "def check(unique_product):\n\tassert unique_product([8, 17, 29, 43, 17, 49, 55, 45]) == 20567269800", "def check(unique_product):\n\tassert unique_product([5, 25, 28, 35, 23, 48, 55, 37]) == 275213400000", "def check(unique_product):\n\tassert unique_product([8, 21, 31, 36, 18, 45, 57, 35]) == 302971233600", "def check(unique_product):\n\tassert unique_product([11, 22, 30, 41, 17, 55, 60, 40]) == 667949040000", "def check(unique_product):\n\tassert unique_product([9, 15, 31, 44, 23, 55, 56, 45]) == 587001492000", "def check(unique_product):\n\tassert unique_product([9, 16, 26, 44, 24, 55, 64, 42]) == 584509685760", "def check(unique_product):\n\tassert unique_product([11, 17, 31, 41, 22, 54, 64, 36]) == 650558075904", "def check(unique_product):\n\tassert unique_product([8, 18, 34, 44, 20, 50, 59, 42]) == 533820672000", "def check(unique_product):\n\tassert unique_product([14, 19, 35, 44, 17, 45, 63, 42]) == 829189191600", "def check(unique_product):\n\tassert unique_product([12, 16, 27, 43, 22, 54, 61, 35]) == 565389538560", "def check(unique_product):\n\tassert unique_product([6, 22, 25, 39, 21, 51, 64, 39]) == 8821612800", "def check(unique_product):\n\tassert unique_product([9, 17, 29, 38, 22, 50, 59, 44]) == 481471293600", "def check(unique_product):\n\tassert unique_product([8, 16, 26, 40, 22, 55, 62, 41]) == 409453158400", "def check(unique_product):\n\tassert unique_product([11, 25, 30, 44, 15, 48, 58, 39]) == 591196320000", "def check(unique_product):\n\tassert unique_product([14, 21, 26, 36, 24, 52, 58, 40]) == 796756746240", "def check(unique_product):\n\tassert unique_product([10, 22, 25, 37, 21, 49, 64, 42]) == 562871232000", "def check(unique_product):\n\tassert unique_product([12, 19, 33, 41, 23, 50, 64, 37]) == 840063628800", "def check(unique_product):\n\tassert unique_product([8, 15, 28, 38, 25, 51, 55, 40]) == 358142400000", "def check(unique_product):\n\tassert unique_product([13, 19, 34, 40, 18, 54, 55, 43]) == 772206177600", "def check(unique_product):\n\tassert unique_product([9, 23, 31, 42, 18, 51, 62, 45]) == 690284647080", "def check(unique_product):\n\tassert unique_product([10, 23, 26, 42, 19, 46, 63, 35]) == 484028017200", "def check(unique_product):\n\tassert unique_product([13, 15, 29, 39, 24, 55, 59, 42]) == 721393873200", "def check(unique_product):\n\tassert unique_product([13, 24, 34, 43, 20, 48, 57, 43]) == 24960199680", "def check(unique_product):\n\tassert unique_product([6, 18, 34, 35, 25, 49, 57, 43]) == 385878087000", "def check(unique_product):\n\tassert unique_product([14, 20, 30, 44, 16, 48, 59, 44]) == 16747315200", "def check(unique_product):\n\tassert unique_product([14, 18, 25, 43, 15, 52, 55, 38]) == 441621180000", "def check(unique_product):\n\tassert unique_product([14, 25, 32, 45, 19, 46, 62, 41]) == 1119740832000", "def check(unique_product):\n\tassert unique_product([9, 16, 31, 37, 18, 52, 59, 41]) == 373970742912", "def check(unique_product):\n\tassert unique_product([8, 24, 34, 45, 19, 50, 64, 44]) == 785866752000", "def check(unique_product):\n\tassert unique_product([14, 24, 33, 44, 19, 55, 63, 41]) == 1316881177920", "def check(unique_product):\n\tassert unique_product([5, 21, 27, 36, 22, 55, 62, 37]) == 283292024400", "def check(unique_product):\n\tassert unique_product([12, 23, 34, 38, 21, 50, 59, 35]) == 773180604000", "def check(unique_product):\n\tassert unique_product([11, 25, 35, 41, 18, 50, 61, 39]) == 844931587500", "def check(unique_product):\n\tassert unique_product([6, 2, 1, 1]) == 12", "def check(unique_product):\n\tassert unique_product([3, 6, 1, 5]) == 90", "def check(unique_product):\n\tassert unique_product([2, 4, 1, 3]) == 24", "def check(unique_product):\n\tassert unique_product([6, 5, 2, 3]) == 180", "def check(unique_product):\n\tassert unique_product([5, 4, 1, 1]) == 20", "def check(unique_product):\n\tassert unique_product([2, 1, 3, 3]) == 6", "def check(unique_product):\n\tassert unique_product([5, 6, 7, 1]) == 210", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 6]) == 18", "def check(unique_product):\n\tassert unique_product([4, 3, 4, 6]) == 72", "def check(unique_product):\n\tassert unique_product([6, 4, 6, 5]) == 120", "def check(unique_product):\n\tassert unique_product([3, 1, 6, 1]) == 18", "def check(unique_product):\n\tassert unique_product([6, 7, 5, 2]) == 420", "def check(unique_product):\n\tassert unique_product([2, 3, 7, 1]) == 42", "def check(unique_product):\n\tassert unique_product([5, 1, 1, 6]) == 30", "def check(unique_product):\n\tassert unique_product([3, 4, 3, 1]) == 12", "def check(unique_product):\n\tassert unique_product([4, 4, 1, 5]) == 20", "def check(unique_product):\n\tassert unique_product([2, 1, 2, 6]) == 12", "def check(unique_product):\n\tassert unique_product([1, 4, 2, 4]) == 8", "def check(unique_product):\n\tassert unique_product([3, 4, 8, 6]) == 576", "def check(unique_product):\n\tassert unique_product([3, 7, 3, 2]) == 42", "def check(unique_product):\n\tassert unique_product([4, 6, 5, 4]) == 120", "def check(unique_product):\n\tassert unique_product([4, 5, 7, 2]) == 280", "def check(unique_product):\n\tassert unique_product([1, 1, 5, 5]) == 5", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 6]) == 18", "def check(unique_product):\n\tassert unique_product([6, 6, 3, 1]) == 18", "def check(unique_product):\n\tassert unique_product([4, 2, 5, 1]) == 40", "def check(unique_product):\n\tassert unique_product([2, 2, 3, 1]) == 6", "def check(unique_product):\n\tassert unique_product([6, 5, 4, 5]) == 120", "def check(unique_product):\n\tassert unique_product([5, 3, 2, 2]) == 30", "def check(unique_product):\n\tassert unique_product([4, 5, 4, 5]) == 20", "def check(unique_product):\n\tassert unique_product([4, 7, 1, 2]) == 56", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 3]) == 3", "def check(unique_product):\n\tassert unique_product([1, 7, 3, 4]) == 84", "def check(unique_product):\n\tassert unique_product([5, 13, 11, 4, 2, 6]) == 34320", "def check(unique_product):\n\tassert unique_product([2, 7, 9, 1, 2, 4]) == 504", "def check(unique_product):\n\tassert unique_product([3, 13, 7, 1, 3, 2]) == 546", "def check(unique_product):\n\tassert unique_product([11, 8, 10, 3, 1, 4]) == 10560", "def check(unique_product):\n\tassert unique_product([4, 5, 9, 3, 4, 5]) == 540", "def check(unique_product):\n\tassert unique_product([9, 12, 5, 5, 4, 5]) == 2160", "def check(unique_product):\n\tassert unique_product([12, 4, 10, 1, 4, 2]) == 960", "def check(unique_product):\n\tassert unique_product([6, 9, 13, 1, 3, 4]) == 8424", "def check(unique_product):\n\tassert unique_product([2, 3, 6, 5, 1, 3]) == 180", "def check(unique_product):\n\tassert unique_product([4, 6, 14, 2, 2, 1]) == 672", "def check(unique_product):\n\tassert unique_product([6, 9, 12, 4, 3, 6]) == 7776", "def check(unique_product):\n\tassert unique_product([10, 6, 4, 5, 5, 2]) == 2400", "def check(unique_product):\n\tassert unique_product([4, 9, 4, 2, 4, 4]) == 72", "def check(unique_product):\n\tassert unique_product([6, 10, 8, 1, 5, 4]) == 9600", "def check(unique_product):\n\tassert unique_product([2, 4, 10, 2, 3, 1]) == 240", "def check(unique_product):\n\tassert unique_product([6, 9, 10, 2, 4, 6]) == 4320", "def check(unique_product):\n\tassert unique_product([10, 9, 12, 5, 4, 1]) == 21600", "def check(unique_product):\n\tassert unique_product([12, 6, 4, 1, 5, 1]) == 1440", "def check(unique_product):\n\tassert unique_product([8, 3, 4, 1, 5, 1]) == 480", "def check(unique_product):\n\tassert unique_product([3, 10, 8, 3, 1, 1]) == 240", "def check(unique_product):\n\tassert unique_product([7, 13, 14, 2, 2, 6]) == 15288", "def check(unique_product):\n\tassert unique_product([8, 7, 4, 4, 1, 5]) == 1120", "def check(unique_product):\n\tassert unique_product([2, 4, 10, 4, 6, 3]) == 1440", "def check(unique_product):\n\tassert unique_product([8, 6, 6, 2, 4, 2]) == 384", "def check(unique_product):\n\tassert unique_product([9, 9, 12, 5, 3, 1]) == 1620", "def check(unique_product):\n\tassert unique_product([9, 13, 5, 4, 2, 5]) == 4680", "def check(unique_product):\n\tassert unique_product([2, 7, 4, 4, 2, 4]) == 56", "def check(unique_product):\n\tassert unique_product([4, 10, 8, 3, 5, 5]) == 4800", "def check(unique_product):\n\tassert unique_product([5, 4, 11, 3, 4, 1]) == 660", "def check(unique_product):\n\tassert unique_product([12, 8, 4, 4, 6, 4]) == 2304", "def check(unique_product):\n\tassert unique_product([11, 10, 10, 2, 2, 3]) == 660", "def check(unique_product):\n\tassert unique_product([12, 9, 11, 1, 4, 2]) == 9504", "def check(unique_product):\n\tassert unique_product([5, 6, 4, 3, 5, 6]) == 360"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numbers in a list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of unique numbers. Returns 1 for an empty list.\n    \"\"\"\n    # Extract unique numbers using set\n    unique_numbers = set(numbers)\n    \n    # Calculate product using math.prod\n    product = math.prod(unique_numbers)\n    \n    return product\n", "passed": true, "pass": true, "pass_num": 10, "round": 283, "mutate_method": "add_1_sentence_at_end", "parent_index": 283}
