{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 803, "prompt": "Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ Ensure your solution considers edge cases such as negative numbers and zero.", "code": "def is_perfect_square(n) :\n    i = 1\n    while (i * i<= n):\n        if ((n % i == 0) and (n / i == i)):\n            return True     \n        i = i + 1\n    return False", "test_imports": [], "test_list": ["assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(7) == False", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(8) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(6) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(5) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(41) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(33) == False", "assert is_Perfect_Square(41) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(38) == False", "assert is_Perfect_Square(34) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(36) == True", "assert is_Perfect_Square(31) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(40) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(37) == False", "assert is_Perfect_Square(35) == False", "assert is_Perfect_Square(38) == False", "assert is_Perfect_Square(32) == False", "assert is_Perfect_Square(39) == False", "assert is_Perfect_Square(32) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(12) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(18) == False", "assert is_Perfect_Square(17) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(18) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(13) == False", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(17) == False", "assert is_Perfect_Square(10) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(14) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(16) == True", "assert is_Perfect_Square(15) == False", "assert is_Perfect_Square(11) == False", "assert is_Perfect_Square(9) == True", "assert is_Perfect_Square(19) == False", "assert is_Perfect_Square(14) == False"], "entry_point": "is_Perfect_Square", "repair_prompt": ["Write a function is_Perfect_Square to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/ Ensure your solution considers edge cases such as negative numbers and zero.\nis_Perfect_Square(10) == False\n"], "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    # Handle edge case for negative numbers\n    if n < 0:\n        return False\n    \n    # Calculate the integer square root of n\n    sqrt_n = math.isqrt(n)\n    \n    # Check if squaring the integer square root equals the original number\n    return sqrt_n * sqrt_n == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    '''\n    Check if the given number is a perfect square.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    '''\n    # Handle negative numbers\n    if n < 0:\n        return False\n    \n    # Calculate the integer square root of n\n    sqrt_n = math.isqrt(n)\n    \n    # Check if the square of the integer square root equals n\n    return sqrt_n * sqrt_n == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    # Handle edge case for negative numbers\n    if n < 0:\n        return False\n    \n    # Calculate the square root of the number\n    sqrt_n = math.isqrt(n)\n    \n    # Check if the square of the calculated square root equals the original number\n    return sqrt_n * sqrt_n == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    # Calculate the integer square root of n\n    root = math.isqrt(n)\n    \n    # Check if the square of the integer root equals n\n    return root * root == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    # Compute the square root of n\n    sqrt_n = math.sqrt(n)\n    \n    # Check if the square root is an integer\n    return sqrt_n.is_integer()\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    # Handle edge case for negative numbers\n    if n < 0:\n        return False\n    \n    # Compute the square root of n\n    sqrt_n = math.sqrt(n)\n    \n    # Check if the square root is an integer\n    return sqrt_n.is_integer()\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False  # Negative numbers cannot be perfect squares\n\n    sqrt_n = math.isqrt(n)  # Efficient integer square root\n    return sqrt_n * sqrt_n == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    elif n == 0:\n        return True\n    else:\n        sqrt_n = math.isqrt(n)  # Use integer square root for precision\n        return sqrt_n * sqrt_n == n\n", "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n == n\n"], "plans": ["requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering edge cases like negative numbers and zero. It should be efficient for large inputs and provide clear output.\nrequirement pool:\n- Implement the main function to check for perfect squares.\n- Optimize the function for performance with large numbers.\n- Handle edge cases such as negative numbers and zero.\n- Provide detailed documentation and examples.\n- Include unit tests for various scenarios.\nWe will implement a function using Python's math library to efficiently check if a number is a perfect square. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero. The math library provides a reliable and efficient way to perform square root calculations, which is essential for determining perfect squares.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, including handling edge cases like negative numbers and zero. It should be efficient and provide clear output.\nrequirement pool:\n- Implement the main function to check for perfect squares.\n- Ensure the function handles negative numbers and zero correctly.\n- Optimize the function for performance with large numbers.\n- Provide user-friendly error messages or outputs.\n- Consider extending functionality to return the square root if it is a perfect square.\nWe will implement a function using Python's built-in math library to efficiently check if a number is a perfect square. The function will handle edge cases such as negative numbers and zero by returning False for these cases. We will use math.isqrt to compute the integer square root and verify if squaring it returns the original number.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering edge cases such as negative numbers and zero. The output should be a boolean value indicating the result.\nrequirement pool:\n- Implement the function to check perfect square accurately.\n- Ensure the function handles negative numbers and zero.\n- Optimize the function for performance.\n- Provide documentation for the function usage.\n- Include test cases for various scenarios.\nWe will implement a simple function using Python's built-in math library to check if a number is a perfect square. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero. The math.isqrt function will be used to compute the integer square root efficiently.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering edge cases like negative numbers and zero. It should be efficient for large inputs and provide a boolean output.\nrequirement pool:\n- Implement the main function to check for perfect squares.\n- Optimize the function for large numbers.\n- Ensure the function handles negative numbers and zero correctly.\n- Provide documentation and examples for users.\n- Include test cases for various edge scenarios.\nWe will implement a function that checks if a given integer is a perfect square by using the math library for efficient computation. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering both positive and negative numbers, as well as zero. It should be efficient and provide immediate feedback.\nrequirement pool:\n- Implement the perfect square checking algorithm.\n- Handle edge cases such as negative numbers and zero.\n- Optimize the function for performance.\n- Ensure the function is easy to integrate into larger applications.\n- Provide user-friendly error messages for invalid inputs.\nWe will implement a function `is_Perfect_Square` using Python's built-in math library to check if a number is a perfect square. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero. The function will be optimized for performance by using integer square root calculation.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering edge cases like negative numbers and zero. It should be efficient and provide clear output.\nrequirement pool:\n- Implement the perfect square checking algorithm.\n- Handle edge cases such as negative numbers and zero.\n- Optimize for performance to handle large numbers.\n- Provide user-friendly error messages for invalid inputs.\n- Include documentation and examples for user guidance.\nWe will implement a function to check if a number is a perfect square using the math library for efficient computation. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero. We will ensure the function is optimized for performance and provides clear feedback to users.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering edge cases like negative numbers and zero. It should be efficient for large inputs and provide clear output.\nrequirement pool:\n- Implement the main function to check for perfect squares.\n- Optimize the function for performance with large numbers.\n- Ensure the function handles edge cases like negative numbers and zero.\n- Provide documentation and examples for users.\n- Include test cases for various scenarios.\nWe will implement a function named is_Perfect_Square that checks if a given integer is a perfect square. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero. We will use the math library to efficiently compute the square root and check if it is an integer.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering edge cases like negative numbers and zero. It should be efficient for large numbers and provide clear output.\nrequirement pool:\n- Implement the main function to check for perfect squares.\n- Optimize the function for large number inputs.\n- Ensure the function handles negative numbers and zero correctly.\n- Provide detailed documentation and examples.\n- Include unit tests for various edge cases.\nWe will implement a function named is_Perfect_Square that checks if a given number is a perfect square. The function will handle edge cases such as negative numbers and zero. We will use the math library to efficiently compute the square root and check if the square of the integer part of the square root equals the original number.\n", "requirement analysis:\nThe function should accurately determine if a number is a perfect square, considering edge cases like negative numbers and zero. It should be efficient for large numbers and provide a boolean output.\nrequirement pool:\n- Implement the main function to check for perfect squares.\n- Handle edge cases such as negative numbers and zero.\n- Optimize the function for performance with large numbers.\n- Ensure the function is easy to integrate into other projects.\n- Provide documentation and examples for users.\nWe will implement a function named is_Perfect_Square that checks if a given integer is a perfect square. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero. For positive numbers, it will use the math library to compute the square root and check if the square of the integer part of the square root equals the original number.\n", "requirement analysis:\nThe function should efficiently determine if a number is a perfect square, considering edge cases like negative numbers and zero. It should return a boolean value indicating the result.\nrequirement pool:\n- Implement the main function to check for perfect squares.\n- Optimize the function for performance with large numbers.\n- Ensure the function handles edge cases such as negative numbers and zero.\n- Provide documentation and examples for using the function.\n- Include unit tests to verify the function's correctness.\nWe will implement a function named is_Perfect_Square that checks if a given integer is a perfect square. The function will handle edge cases such as negative numbers and zero by returning False for negative numbers and True for zero. We will use the math library for efficient computation of the square root and check if the square of the integer part of the square root equals the original number.\n"], "test": ["def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(7) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(8) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(6) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(5) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(41) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(33) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(41) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(38) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(34) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(36) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(31) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(40) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(37) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(35) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(38) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(32) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(39) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(32) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(12) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(18) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(17) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(18) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(13) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(17) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(10) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(16) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(15) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(11) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(9) == True", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(19) == False", "def check(is_Perfect_Square):\n\tassert is_Perfect_Square(14) == False"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\nimport math\n\ndef is_Perfect_Square(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    sqrt_n = math.isqrt(n)\n    return sqrt_n * sqrt_n == n\n", "passed": true, "pass": true, "pass_num": 10, "round": 265, "mutate_method": "add_1_sentence_at_end", "parent_index": 265}
