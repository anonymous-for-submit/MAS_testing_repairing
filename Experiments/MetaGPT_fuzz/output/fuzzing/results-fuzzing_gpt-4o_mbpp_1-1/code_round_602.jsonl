{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 752, "prompt": "Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, and so forth. There is a distinct pattern in the sequence.", "code": "def jacobsthal_num(n): \n\tdp = [0] * (n + 1) \n\tdp[0] = 0\n\tdp[1] = 1\n\tfor i in range(2, n+1): \n\t\tdp[i] = dp[i - 1] + 2 * dp[i - 2] \n\treturn dp[n]", "test_imports": [], "test_list": ["assert jacobsthal_num(5) == 11", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(9) == 171", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(9) == 171", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(10) == 341", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(9) == 171", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(10) == 341", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(3) == 3", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(3) == 3", "assert jacobsthal_num(3) == 3", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(9) == 171", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(3) == 3", "assert jacobsthal_num(7) == 43", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(3) == 3", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(3) == 3", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(8) == 85", "assert jacobsthal_num(6) == 21", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(4) == 5", "assert jacobsthal_num(2) == 1", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(9) == 171", "assert jacobsthal_num(3) == 3", "assert jacobsthal_num(1) == 1", "assert jacobsthal_num(5) == 11", "assert jacobsthal_num(1) == 1"], "entry_point": "jacobsthal_num", "repair_prompt": ["Write a function jacobsthal_num to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, and so forth. There is a distinct pattern in the sequence.\njacobsthal_num(5) == 11\n"], "completions": ["from typing import List\n## main.py\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    The Jacobsthal numbers are defined by the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2) with initial conditions J(0) = 0, J(1) = 1.\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n\n    Raises:\n    ValueError: If the input is not a non-negative integer.\n\n    Examples:\n    >>> jacobsthal_num(0)\n    0\n    >>> jacobsthal_num(1)\n    1\n    >>> jacobsthal_num(5)\n    11\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Memoization dictionary to store previously calculated Jacobsthal numbers\n    memo = {0: 0, 1: 1}\n\n    def calculate_jacobsthal(k: int) -> int:\n        \"\"\"Helper function to calculate Jacobsthal number using memoization.\"\"\"\n        if k not in memo:\n            memo[k] = calculate_jacobsthal(k - 1) + 2 * calculate_jacobsthal(k - 2)\n        return memo[k]\n\n    return calculate_jacobsthal(n)\n\n# Example usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def _jacobsthal_recursive(m: int) -> int:\n        if m == 0:\n            return 0\n        elif m == 1:\n            return 1\n        else:\n            return _jacobsthal_recursive(m - 1) + 2 * _jacobsthal_recursive(m - 2)\n\n    return _jacobsthal_recursive(n)\n", "from typing import List\n## main.py\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number using a recursive approach with memoization.\n\n    The Jacobsthal sequence is defined as:\n    J(0) = 0\n    J(1) = 1\n    J(n) = J(n-1) + 2 * J(n-2) for n > 1\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    # Memoization dictionary to store previously calculated Jacobsthal numbers\n    memo = {0: 0, 1: 1}\n\n    def calculate_jacobsthal(num: int) -> int:\n        \"\"\"Helper function to calculate Jacobsthal number recursively.\"\"\"\n        if num in memo:\n            return memo[num]\n        \n        # Calculate the Jacobsthal number using the recursive formula\n        memo[num] = calculate_jacobsthal(num - 1) + 2 * calculate_jacobsthal(num - 2)\n        return memo[num]\n\n    return calculate_jacobsthal(n)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test the function with a few examples\n    print(jacobsthal_num(0))  # Output: 0\n    print(jacobsthal_num(1))  # Output: 1\n    print(jacobsthal_num(5))  # Output: 11\n    print(jacobsthal_num(10)) # Output: 341\n", "from typing import List\n## main.py\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    The Jacobsthal numbers are defined by the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2), with base cases J(0) = 0 and J(1) = 1.\n\n    Parameters:\n    n (int): The index of the Jacobsthal number to calculate.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Initialize memoization array\n    memo = [0] * (n + 1)\n    memo[0] = 0\n    memo[1] = 1\n\n    # Fill the memoization array using the recurrence relation\n    for i in range(2, n + 1):\n        memo[i] = memo[i - 1] + 2 * memo[i - 2]\n\n    return memo[n]\n\n# Example usage:\n# print(jacobsthal_num(5))  # Output should be 11\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number using recursion with memoization.\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The position in the Jacobsthal sequence must be a non-negative integer.\")\n    \n    @lru_cache(maxsize=None)\n    def _jacobsthal_recursive(m: int) -> int:\n        if m == 0:\n            return 0\n        elif m == 1:\n            return 1\n        else:\n            return _jacobsthal_recursive(m - 1) + 2 * _jacobsthal_recursive(m - 2)\n\n    return _jacobsthal_recursive(n)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    Parameters:\n    n (int): The index of the Jacobsthal number to calculate.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def calculate_jacobsthal(m: int) -> int:\n        if m == 0:\n            return 0\n        elif m == 1:\n            return 1\n        else:\n            return calculate_jacobsthal(m - 1) + 2 * calculate_jacobsthal(m - 2)\n\n    return calculate_jacobsthal(n)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number using a recursive approach with memoization.\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def _jacobsthal_recursive(m: int) -> int:\n        if m == 0:\n            return 0\n        elif m == 1:\n            return 1\n        else:\n            return _jacobsthal_recursive(m - 1) + 2 * _jacobsthal_recursive(m - 2)\n\n    return _jacobsthal_recursive(n)\n\n# Example usage:\n# print(jacobsthal_num(5))  # Output: 11\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number using recursion with memoization.\n    \n    The Jacobsthal numbers follow the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2) with initial conditions J(0) = 0 and J(1) = 1.\n    \n    Args:\n        n (int): The position in the Jacobsthal sequence (0-indexed).\n        \n    Returns:\n        int: The nth Jacobsthal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The position in the Jacobsthal sequence must be a non-negative integer.\")\n    \n    @lru_cache(maxsize=None)\n    def _jacobsthal_recursive(m: int) -> int:\n        if m == 0:\n            return 0\n        elif m == 1:\n            return 1\n        else:\n            return _jacobsthal_recursive(m - 1) + 2 * _jacobsthal_recursive(m - 2)\n    \n    return _jacobsthal_recursive(n)\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    The Jacobsthal numbers are defined by the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2) with initial conditions J(0) = 0, J(1) = 1.\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The input must be a non-negative integer.\")\n    \n    @lru_cache(maxsize=None)\n    def _jacobsthal_recursive(k: int) -> int:\n        if k == 0:\n            return 0\n        elif k == 1:\n            return 1\n        else:\n            return _jacobsthal_recursive(k - 1) + 2 * _jacobsthal_recursive(k - 2)\n\n    return _jacobsthal_recursive(n)\n\n# Example usage:\nif __name__ == \"__main__\":\n    try:\n        position = 10  # Example position\n        result = jacobsthal_num(position)\n        print(f\"The {position}th Jacobsthal number is: {result}\")\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    The Jacobsthal numbers are defined by the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2) with initial conditions J(0) = 0, J(1) = 1.\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n\n    Raises:\n    ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Memoization dictionary to store previously computed Jacobsthal numbers\n    memo = {0: 0, 1: 1}\n\n    def _jacobsthal_recursive(k: int) -> int:\n        \"\"\"Helper function to compute Jacobsthal number using recursion with memoization.\"\"\"\n        if k in memo:\n            return memo[k]\n        # Recursive calculation with memoization\n        memo[k] = _jacobsthal_recursive(k - 1) + 2 * _jacobsthal_recursive(k - 2)\n        return memo[k]\n\n    return _jacobsthal_recursive(n)\n\n# Example usage:\n# print(jacobsthal_num(5))  # Output: 11\n"], "plans": ["requirement analysis:\nThe function should accurately compute the nth Jacobsthal number using the known sequence pattern. It should be efficient for large values of n and provide clear documentation for users and developers.\nrequirement pool:\n- Implement the Jacobsthal number calculation algorithm\n- Optimize the function for performance with large inputs\n- Provide documentation and usage examples\n- Include error handling for invalid inputs\n- Ensure compatibility with different Python versions\nWe will implement the Jacobsthal number calculation using a recursive approach with memoization to optimize performance for large inputs. The function will be documented with examples and will include input validation to handle invalid inputs gracefully.\n", "requirement analysis:\nThe requirement is to implement a function that calculates the nth Jacobsthal number. The sequence follows a specific pattern where each number is derived from a formula involving previous numbers. The function should be efficient and handle large inputs gracefully.\nrequirement pool:\n- Implement the Jacobsthal number calculation function\n- Optimize the function for performance\n- Provide comprehensive documentation\n- Include error handling for invalid inputs\n- Create test cases for various input scenarios\nWe will implement the Jacobsthal number calculation using a recursive approach with memoization to optimize performance for large inputs. The memoization technique will store previously computed values to avoid redundant calculations, thus improving efficiency. We will use Python's built-in functools library to facilitate memoization.\n", "requirement analysis:\nThe function should accurately compute the nth Jacobsthal number using the known sequence pattern. It should be efficient for large values of n and include documentation for ease of understanding.\nrequirement pool:\n- Implement the Jacobsthal number calculation function\n- Optimize the function for performance\n- Include comprehensive documentation\n- Provide examples and test cases\n- Ensure compatibility with different Python versions\nWe will implement the Jacobsthal number calculation using a recursive approach with memoization to optimize performance for large inputs. The function will be documented with clear examples and explanations. We will use Python's built-in capabilities to handle large integers efficiently.\n", "requirement analysis:\nThe function should efficiently compute the nth Jacobsthal number using the known recurrence relation. It should handle edge cases such as very small or very large inputs and provide results quickly.\nrequirement pool:\n- Implement the Jacobsthal number calculation function\n- Optimize the function for performance\n- Write comprehensive documentation\n- Create test cases for various input sizes\n- Ensure compatibility with Python 3.x\nWe will implement the Jacobsthal number calculation using the recurrence relation: J(n) = J(n-1) + 2*J(n-2), with base cases J(0) = 0 and J(1) = 1. This approach will be efficient for small to moderately large inputs. For very large inputs, we will use memoization to optimize performance and avoid redundant calculations.\n", "requirement analysis:\nThe function should accurately compute the nth Jacobsthal number using the known sequence pattern. It should handle large values of n efficiently and provide clear documentation for users.\nrequirement pool:\n- Implement the Jacobsthal number calculation algorithm\n- Optimize the function for performance with large inputs\n- Include examples and documentation for user understanding\n- Ensure compatibility with other mathematical libraries\n- Provide error handling for invalid inputs\nWe will implement the Jacobsthal number calculation using a recursive approach with memoization to optimize performance for large inputs. This will ensure efficient computation by storing previously calculated results. We will use Python's built-in libraries to handle memoization.\n", "requirement analysis:\nThe function should accurately compute the nth Jacobsthal number using the known sequence pattern. It should handle large inputs efficiently and provide clear documentation for users to understand its usage.\nrequirement pool:\n- Implement the Jacobsthal number calculation algorithm\n- Optimize the function for performance with large inputs\n- Include comprehensive documentation and examples\n- Ensure compatibility with existing mathematical libraries\n- Provide error handling for invalid inputs\nWe will implement the Jacobsthal number calculation using a recursive formula with memoization to optimize performance for large inputs. The formula for Jacobsthal numbers is J(n) = J(n-1) + 2*J(n-2) with base cases J(0) = 0 and J(1) = 1. We will use the functools library to implement memoization.\n", "requirement analysis:\nThe function should efficiently compute the nth Jacobsthal number using the known sequence pattern. It should handle large values of n and provide accurate results.\nrequirement pool:\n- Implement the Jacobsthal number calculation function\n- Optimize the function for performance\n- Include documentation and usage examples\n- Ensure compatibility with existing mathematical libraries\n- Provide error handling for invalid inputs\nWe will implement the Jacobsthal number calculation using a recursive approach with memoization to optimize performance for large inputs. This will ensure that previously computed values are stored and reused, reducing the computational overhead. We will use Python's built-in functools library to achieve this.\n", "requirement analysis:\nThe requirement is to develop a function that calculates the nth Jacobsthal number. The sequence follows a specific pattern, and the function should be efficient enough to handle large inputs. The user should be able to easily input a number and receive the correct Jacobsthal number as output.\nrequirement pool:\n- Implement the Jacobsthal number calculation function.\n- Optimize the function for performance with large inputs.\n- Create a user-friendly interface for input and output.\n- Provide educational content about the Jacobsthal sequence.\n- Include examples to demonstrate the sequence pattern.\nWe will implement a function to calculate the nth Jacobsthal number using a recursive formula with memoization to optimize performance for large inputs. The Jacobsthal numbers follow the recurrence relation: J(n) = J(n-1) + 2*J(n-2) with initial conditions J(0) = 0 and J(1) = 1. We will use the 'functools.lru_cache' decorator to cache results of previous calculations, which will significantly improve performance for large input values.\n", "requirement analysis:\nThe function should accurately compute the nth Jacobsthal number using the known sequence pattern. It should handle large values of n efficiently and provide clear documentation for users to understand its usage.\nrequirement pool:\n- Implement the Jacobsthal number calculation algorithm\n- Optimize the function for performance with large inputs\n- Include comprehensive documentation and usage examples\n- Ensure compatibility with existing mathematical libraries\n- Provide error handling for invalid inputs\nWe will implement the Jacobsthal number calculation using a recursive approach with memoization to optimize performance for large inputs. This approach will ensure that we do not recompute values unnecessarily, thus improving efficiency. We will use Python's built-in functools library to facilitate memoization. Additionally, we will provide comprehensive documentation and examples to help users understand the function's usage.\n", "requirement analysis:\nThe function should accurately compute the nth Jacobsthal number using the known sequence pattern. It should handle large inputs efficiently and provide clear documentation for users to understand its usage.\nrequirement pool:\n- Implement the Jacobsthal number calculation function\n- Optimize the function for performance with large inputs\n- Provide documentation and usage examples\n- Ensure compatibility with existing mathematical libraries\n- Include error handling for invalid inputs\nWe will implement the Jacobsthal number calculation using a recursive approach with memoization to optimize performance for large inputs. The function will be simple and efficient, leveraging Python's built-in capabilities. We will also include error handling for invalid inputs and provide clear documentation with examples.\n"], "test": ["def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(9) == 171", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(9) == 171", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(10) == 341", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(9) == 171", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(10) == 341", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(3) == 3", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(3) == 3", "def check(jacobsthal_num):\n\tassert jacobsthal_num(3) == 3", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(9) == 171", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(3) == 3", "def check(jacobsthal_num):\n\tassert jacobsthal_num(7) == 43", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(3) == 3", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(3) == 3", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(8) == 85", "def check(jacobsthal_num):\n\tassert jacobsthal_num(6) == 21", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(4) == 5", "def check(jacobsthal_num):\n\tassert jacobsthal_num(2) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(9) == 171", "def check(jacobsthal_num):\n\tassert jacobsthal_num(3) == 3", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1", "def check(jacobsthal_num):\n\tassert jacobsthal_num(5) == 11", "def check(jacobsthal_num):\n\tassert jacobsthal_num(1) == 1"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef jacobsthal_num(n: int) -> int:\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    The Jacobsthal numbers are defined by the recurrence relation:\n    J(n) = J(n-1) + 2*J(n-2) with initial conditions J(0) = 0, J(1) = 1.\n\n    Parameters:\n    n (int): The position in the Jacobsthal sequence.\n\n    Returns:\n    int: The nth Jacobsthal number.\n\n    Raises:\n    ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Memoization dictionary to store previously computed Jacobsthal numbers\n    memo = {0: 0, 1: 1}\n\n    def _jacobsthal_recursive(k: int) -> int:\n        \"\"\"Helper function to compute Jacobsthal number using recursion with memoization.\"\"\"\n        if k in memo:\n            return memo[k]\n        # Recursive calculation with memoization\n        memo[k] = _jacobsthal_recursive(k - 1) + 2 * _jacobsthal_recursive(k - 2)\n        return memo[k]\n\n    return _jacobsthal_recursive(n)\n\n# Example usage:\n# print(jacobsthal_num(5))  # Output: 11\n", "passed": true, "pass": true, "pass_num": 10, "round": 602, "mutate_method": "expand_one2two", "parent_index": 238}
