{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 721, "prompt": "Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. Each cell in the matrix has a cost associated with it. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.", "code": "def maxAverageOfPath(cost):\n  N = len(cost)\n  dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n  dp[0][0] = cost[0][0]\n  for i in range(1, N):\n    dp[i][0] = dp[i - 1][0] + cost[i][0]\n  for j in range(1, N):\n    dp[0][j] = dp[0][j - 1] + cost[0][j]\n  for i in range(1, N):\n    for j in range(1, N):\n      dp[i][j] = max(dp[i - 1][j],\n                     dp[i][j - 1]) + cost[i][j]\n  return dp[N - 1][N - 1] / (2 * N - 1)", "test_imports": [], "test_list": ["assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "assert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "assert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "assert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "assert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "assert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "assert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "assert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "assert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "assert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "assert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "assert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "assert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "assert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "assert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "assert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "assert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "assert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "assert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "assert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "assert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "assert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "assert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "assert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "assert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "assert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "assert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "assert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "assert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "assert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "assert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "assert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "assert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "assert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "assert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "assert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "assert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "assert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "assert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "assert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "assert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "assert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "assert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "assert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "assert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "assert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "assert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "assert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "assert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "assert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "assert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "assert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "assert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "assert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "assert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "assert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "assert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "assert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "assert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "assert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "assert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "assert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "assert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "assert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "assert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "assert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "assert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "assert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "assert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "assert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "assert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "assert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "assert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "assert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "assert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "assert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "assert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "assert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "assert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "assert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "assert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "assert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "assert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "assert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "assert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "assert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "assert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "assert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "assert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "assert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "assert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "assert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "assert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "entry_point": "maxAverageOfPath", "repair_prompt": ["Given a maxAverageOfPath square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. Each cell in the matrix has a cost associated with it. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nmaxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a square matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    # Validate input\n    if not matrix or len(matrix) != N or any(len(row) != N for row in matrix):\n        raise ValueError(\"Input must be a square matrix of size N*N.\")\n    \n    # Initialize a DP table to store the maximum sum path to each cell\n    dp = np.full((N, N), -np.inf)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the DP table\n    for i in range(N):\n        for j in range(N):\n            if i > 0:\n                dp[i][j] = max(dp[i][j], dp[i-1][j] + matrix[i][j])\n            if j > 0:\n                dp[i][j] = max(dp[i][j], dp[i][j-1] + matrix[i][j])\n\n    # Calculate the maximum average path\n    max_sum = dp[N-1][N-1]\n    max_average = max_sum / (2 * N - 1)\n\n    return max_average\n", "from typing import List\n## main.py\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> tuple[float, list[tuple[int, int]]]:\n    \"\"\"\n    Calculate the path with the maximum average cost in a matrix.\n\n    Parameters:\n    matrix (list[list[int]]): A 2D list representing the cost matrix.\n    n (int): The size of the matrix (n x n).\n\n    Returns:\n    tuple[float, list[tuple[int, int]]]: A tuple containing the maximum average and the path as a list of coordinates.\n    \"\"\"\n    if n == 0 or not matrix or not matrix[0]:\n        return 0.0, []\n\n    # Initialize a 2D list to store the maximum sum up to each cell\n    max_sum = [[0] * n for _ in range(n)]\n    # Initialize a 2D list to store the path taken to reach each cell\n    path = [[[] for _ in range(n)] for _ in range(n)]\n\n    # Base case: start from the top-left corner\n    max_sum[0][0] = matrix[0][0]\n    path[0][0] = [(0, 0)]\n\n    # Fill the first row\n    for j in range(1, n):\n        max_sum[0][j] = max_sum[0][j - 1] + matrix[0][j]\n        path[0][j] = path[0][j - 1] + [(0, j)]\n\n    # Fill the first column\n    for i in range(1, n):\n        max_sum[i][0] = max_sum[i - 1][0] + matrix[i][0]\n        path[i][0] = path[i - 1][0] + [(i, 0)]\n\n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if max_sum[i - 1][j] > max_sum[i][j - 1]:\n                max_sum[i][j] = max_sum[i - 1][j] + matrix[i][j]\n                path[i][j] = path[i - 1][j] + [(i, j)]\n            else:\n                max_sum[i][j] = max_sum[i][j - 1] + matrix[i][j]\n                path[i][j] = path[i][j - 1] + [(i, j)]\n\n    # Calculate the maximum average\n    total_steps = 2 * n - 1  # Total steps in the path from (0,0) to (n-1,n-1)\n    max_average = max_sum[n - 1][n - 1] / total_steps\n\n    return max_average, path[n - 1][n - 1]\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path cost in a matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n == 0 or not matrix:\n        return 0.0\n\n    # Initialize a DP table to store the maximum sum up to each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill the rest of the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # The maximum sum path is now in the bottom-right corner of the dp table\n    max_sum = dp[n-1][n-1]\n\n    # Calculate the maximum average by dividing the max sum by the number of steps\n    # The number of steps is (2n - 1) for a path from top-left to bottom-right\n    max_average = max_sum / (2 * n - 1)\n\n    return max_average\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a square matrix.\n\n    Parameters:\n    matrix (list[list[int]]): A square matrix of integers representing costs.\n    n (int): The size of the matrix (n x n).\n\n    Returns:\n    float: The maximum average path value.\n    \"\"\"\n    # Initialize dp_sum and dp_count matrices\n    dp_sum = np.zeros((n, n), dtype=int)\n    dp_count = np.zeros((n, n), dtype=int)\n\n    # Base case: start from the top-left corner\n    dp_sum[0][0] = matrix[0][0]\n    dp_count[0][0] = 1\n\n    # Fill the first row\n    for j in range(1, n):\n        dp_sum[0][j] = dp_sum[0][j-1] + matrix[0][j]\n        dp_count[0][j] = dp_count[0][j-1] + 1\n\n    # Fill the first column\n    for i in range(1, n):\n        dp_sum[i][0] = dp_sum[i-1][0] + matrix[i][0]\n        dp_count[i][0] = dp_count[i-1][0] + 1\n\n    # Fill the rest of the dp_sum and dp_count matrices\n    for i in range(1, n):\n        for j in range(1, n):\n            if dp_sum[i-1][j] > dp_sum[i][j-1]:\n                dp_sum[i][j] = dp_sum[i-1][j] + matrix[i][j]\n                dp_count[i][j] = dp_count[i-1][j] + 1\n            else:\n                dp_sum[i][j] = dp_sum[i][j-1] + matrix[i][j]\n                dp_count[i][j] = dp_count[i][j-1] + 1\n\n    # Calculate the maximum average path value\n    max_average = dp_sum[n-1][n-1] / dp_count[n-1][n-1]\n    return max_average\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path cost in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A 2D list representing the cost matrix.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Matrix size must be greater than 0.\")\n    \n    # Initialize the DP table with negative infinity values\n    dp = np.full((n, n), -np.inf)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the DP table\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = max(dp[i][j], dp[i-1][j] + matrix[i][j])\n            if j > 0:\n                dp[i][j] = max(dp[i][j], dp[i][j-1] + matrix[i][j])\n\n    # Calculate the maximum average cost\n    max_path_cost = dp[n-1][n-1]\n    max_average_cost = max_path_cost / (2 * n - 1)\n\n    return max_average_cost\n\n# Example usage\nif __name__ == \"__main__\":\n    matrix_example = [\n        [5, 3, 2],\n        [1, 4, 6],\n        [7, 8, 9]\n    ]\n    n_example = 3\n    result = maxAverageOfPath(matrix_example, n_example)\n    print(f\"The maximum average path cost is: {result}\")\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> Tuple[float, List[Tuple[int, int]]]:\n    \"\"\"\n    Calculate the path with the maximum average cost in a matrix using dynamic programming.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    Tuple[float, List[Tuple[int, int]]]: The maximum average cost and the path taken as a list of coordinates.\n    \"\"\"\n    # Initialize DP and path matrices\n    dp = np.zeros((N, N), dtype=float)\n    path = [[None for _ in range(N)] for _ in range(N)]\n\n    # Base case: start from the top-left corner\n    dp[0][0] = matrix[0][0]\n    path[0][0] = [(0, 0)]\n\n    # Fill the first row and first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        path[i][0] = path[i-1][0] + [(i, 0)]\n        \n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n        path[0][i] = path[0][i-1] + [(0, i)]\n\n    # Fill the rest of the dp and path matrices\n    for i in range(1, N):\n        for j in range(1, N):\n            if dp[i-1][j] > dp[i][j-1]:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n                path[i][j] = path[i-1][j] + [(i, j)]\n            else:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n                path[i][j] = path[i][j-1] + [(i, j)]\n\n    # Calculate the maximum average cost\n    max_average_cost = dp[N-1][N-1] / (2 * N - 1)\n    max_path = path[N-1][N-1]\n\n    return max_average_cost, max_path\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average cost path in a matrix.\n\n    Parameters:\n    matrix (list of list of int): The N*N matrix with costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n == 0 or not matrix:\n        return 0.0\n\n    # Initialize a DP table to store the maximum sum up to each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill the rest of the DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # The maximum sum path is now in the bottom-right corner of the DP table\n    max_sum = dp[n-1][n-1]\n\n    # Calculate the maximum average by dividing the maximum sum by the number of steps\n    # The number of steps is (2n - 1) for a path from top-left to bottom-right\n    max_average = max_sum / (2 * n - 1)\n\n    return max_average\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef maxAverageOfPath(matrix: list[list[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average cost path in a matrix.\n\n    Parameters:\n    matrix (list of list of int): The N*N matrix with costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Matrix size must be greater than 0.\")\n    \n    # Initialize a DP table to store the maximum sum path to each cell\n    dp = np.zeros((n, n), dtype=float)\n    dp[0][0] = matrix[0][0]\n\n    # Fill the first row and first column of the DP table\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    # Iterate over the matrix to fill the DP table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Calculate the maximum average cost\n    max_sum = dp[n-1][n-1]\n    max_average = max_sum / (2 * n - 1)  # Path length is always 2*n - 1 for a square matrix\n\n    return max_average\n\n# Example usage\nif __name__ == \"__main__\":\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    n = 3\n    result = maxAverageOfPath(matrix, n)\n    print(f\"The maximum average cost of a path is: {result}\")\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef maxAverageOfPath(matrix: List[List[int]], N: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    N (int): The size of the matrix.\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    # Initialize memoization table\n    memo = [[None for _ in range(N)] for _ in range(N)]\n\n    def dp(x: int, y: int) -> Tuple[int, int]:\n        \"\"\"\n        Dynamic programming function to calculate the maximum path sum and the number of cells.\n\n        Parameters:\n        x (int): Current row index.\n        y (int): Current column index.\n\n        Returns:\n        Tuple[int, int]: A tuple containing the maximum path sum and the number of cells in the path.\n        \"\"\"\n        # Base case: if we reach the bottom-right corner\n        if x == N - 1 and y == N - 1:\n            return matrix[x][y], 1\n\n        # If already computed, return the stored result\n        if memo[x][y] is not None:\n            return memo[x][y]\n\n        # Initialize maximum path sum and cell count\n        max_sum, cell_count = float('-inf'), 0\n\n        # Move right\n        if y + 1 < N:\n            right_sum, right_count = dp(x, y + 1)\n            if right_sum > max_sum:\n                max_sum = right_sum\n                cell_count = right_count\n\n        # Move down\n        if x + 1 < N:\n            down_sum, down_count = dp(x + 1, y)\n            if down_sum > max_sum:\n                max_sum = down_sum\n                cell_count = down_count\n\n        # Include current cell in the path\n        max_sum += matrix[x][y]\n        cell_count += 1\n\n        # Store the result in memoization table\n        memo[x][y] = (max_sum, cell_count)\n        return memo[x][y]\n\n    # Calculate the maximum path sum and the number of cells from the top-left corner\n    total_sum, total_cells = dp(0, 0)\n\n    # Calculate and return the maximum average\n    return total_sum / total_cells if total_cells > 0 else 0.0\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    \n    # Initialize a 2D list to store the maximum sum of costs for each cell\n    max_sum = [[0] * n for _ in range(n)]\n    \n    # Initialize a 2D list to store the number of cells visited for each path\n    cell_count = [[0] * n for _ in range(n)]\n    \n    # Fill the first cell\n    max_sum[0][0] = matrix[0][0]\n    cell_count[0][0] = 1\n    \n    # Fill the first row\n    for j in range(1, n):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n        cell_count[0][j] = cell_count[0][j-1] + 1\n    \n    # Fill the first column\n    for i in range(1, n):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n        cell_count[i][0] = cell_count[i-1][0] + 1\n    \n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if max_sum[i-1][j] > max_sum[i][j-1]:\n                max_sum[i][j] = max_sum[i-1][j] + matrix[i][j]\n                cell_count[i][j] = cell_count[i-1][j] + 1\n            else:\n                max_sum[i][j] = max_sum[i][j-1] + matrix[i][j]\n                cell_count[i][j] = cell_count[i][j-1] + 1\n    \n    # Calculate the maximum average\n    max_average = max_sum[n-1][n-1] / cell_count[n-1][n-1]\n    \n    return max_average\n"], "plans": ["requirement analysis:\nThe requirement is to find the path with the maximum average cost in a square matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide clear error messages for invalid inputs.\nrequirement pool:\n- Implement the main algorithm to find the maximum average path.\n- Optimize the algorithm for large matrices.\n- Develop error handling for invalid matrix inputs.\n- Create a user-friendly interface for input and output.\n- Ensure the solution is scalable and maintainable.\nWe will implement a dynamic programming approach to efficiently calculate the maximum average path in a square matrix. This approach will ensure optimal performance for large matrices by storing intermediate results and avoiding redundant calculations. We will use NumPy for efficient matrix operations and error handling to manage invalid inputs such as non-square matrices or matrices with negative costs.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently compute the average and handle large matrices while providing clear output.\nrequirement pool:\n- Implement the main algorithm to find the maximum average path.\n- Optimize the algorithm for large matrix sizes.\n- Provide detailed output of the path taken.\n- Ensure the solution is user-friendly.\n- Test the solution with various matrix sizes.\nWe will implement a dynamic programming approach to efficiently find the path with the maximum average cost in the matrix. This approach will allow us to handle large matrices by storing intermediate results and avoiding redundant calculations. We will use Python's built-in capabilities and libraries like NumPy for efficient numerical computations if necessary.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle large matrices and provide clear output.\nrequirement pool:\n- Implement the main algorithm to find the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and easy to understand.\n- Include error handling for invalid matrix inputs.\n- Provide documentation for the function usage.\nWe will implement a dynamic programming approach to efficiently find the path with the maximum average cost in the matrix. This approach will ensure optimal performance even for large matrices. We will use NumPy for efficient matrix operations and calculations.\n", "requirement analysis:\nThe requirement is to develop a function that calculates the maximum average path in a square matrix. The function should efficiently handle matrices of varying sizes and provide accurate results. The path is restricted to movements right or down, starting from the top-left and ending at the bottom-right.\nrequirement pool:\n- Develop the core algorithm to find the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the function handles edge cases gracefully.\n- Provide comprehensive documentation and examples.\n- Implement unit tests to verify the function's correctness.\nWe will implement a dynamic programming approach to efficiently compute the maximum average path in the matrix. The algorithm will use a 2D list to store the maximum sum of costs up to each cell, and another 2D list to store the number of cells in the path up to each cell. This will allow us to compute the average cost for each path ending at the bottom-right cell. We will use the numpy library for efficient matrix operations.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle large matrices and provide clear output.\nrequirement pool:\n- Implement the main algorithm to calculate maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and understandable.\n- Include error handling for invalid inputs.\n- Provide documentation for the function usage.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. This approach will efficiently handle large matrices by storing intermediate results to avoid redundant calculations. We will use the NumPy library to facilitate matrix operations and improve performance.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle large matrices and provide clear output of the path taken.\nrequirement pool:\n- Implement efficient path calculation algorithm\n- Optimize for large matrix performance\n- Provide detailed path output\n- Ensure user-friendly interface\n- Include error handling for invalid inputs\nWe will implement a dynamic programming approach to efficiently calculate the path with the maximum average cost. This approach will ensure optimal performance even for large matrices. We will use NumPy for efficient matrix operations and maintain a path matrix to track the path taken.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to find the path with maximum average cost.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the solution is easy to understand and use.\n- Provide detailed documentation for the function.\n- Include test cases for different matrix sizes and scenarios.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. This approach will efficiently handle large matrices by storing intermediate results to avoid redundant calculations. We will use the numpy library for efficient matrix operations.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to find the path with maximum average cost.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is clear and understandable.\n- Test the solution with various matrix sizes and configurations.\n- Document the solution and provide usage examples.\nWe will implement a dynamic programming approach to solve the problem of finding the path with the maximum average cost in a matrix. This approach will efficiently handle large matrices by storing intermediate results to avoid redundant calculations. We will use the numpy library for efficient matrix operations.\n", "requirement analysis:\nThe requirement is to find the path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to calculate the maximum average path.\n- Optimize the algorithm for performance with large matrices.\n- Ensure the output is user-friendly and easy to interpret.\n- Include error handling for invalid matrix inputs.\n- Provide documentation for the function usage.\nWe will implement a dynamic programming solution to efficiently calculate the maximum average path in the matrix. The algorithm will traverse the matrix from the top-left to the bottom-right, maintaining a running total of costs and the number of cells visited. We will use memoization to store intermediate results and avoid redundant calculations, optimizing performance for large matrices.\n", "requirement analysis:\nThe requirement is to find a path with the maximum average cost in a matrix, moving only right or down. The solution should efficiently handle matrices of varying sizes and provide a clear output of the path and its average cost.\nrequirement pool:\n- Implement the core algorithm to find the maximum average path\n- Develop a user interface for inputting matrices and displaying results\n- Create documentation explaining the algorithm and usage\n- Add visualization for the path with the maximum average\n- Include an option to export results\nWe will implement a dynamic programming approach to efficiently find the path with the maximum average cost in the matrix. The algorithm will traverse the matrix from the top-left to the bottom-right, calculating the maximum sum of costs for each cell while keeping track of the number of cells visited. The average will be computed by dividing the total cost by the number of cells in the path. We will use Python's built-in capabilities and libraries like NumPy for matrix operations to ensure scalability and efficiency.\n"], "test": ["def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 ", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 3, 1], [1, 4, 5], [2, 6, 6]], 3) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 3], [11, 3, 7], [3, 1, 10]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 2], [4, 8, 3], [2, 6, 9]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 6], [5, 6, 4], [9, 4, 14]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 2], [9, 5, 3], [9, 3, 11]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [10, 10, 1], [5, 3, 4]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 6], [1, 3, 9], [4, 6, 14]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 8], [9, 9, 2], [12, 8, 14]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 4], [7, 9, 8], [8, 7, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 4], [7, 3, 5], [2, 7, 4]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 5, 1], [7, 9, 7], [7, 3, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 4], [6, 2, 7], [9, 4, 6]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 8], [7, 3, 5], [3, 1, 4]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 6], [2, 4, 7], [9, 6, 12]], 3) == 6.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 6], [6, 3, 1], [9, 8, 8]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [11, 4, 8], [12, 3, 13]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [3, 9, 2], [9, 5, 10]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [11, 4, 4], [5, 2, 11]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 3], [10, 10, 7], [3, 1, 5]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 5], [9, 1, 4], [6, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 6], [10, 4, 9], [8, 2, 11]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 4], [3, 3, 9], [4, 3, 5]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 8], [9, 9, 7], [4, 1, 8]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [3, 5, 4], [10, 1, 6]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 7], [3, 8, 9], [12, 6, 9]], 3) == 6.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 2], [6, 5, 8], [11, 1, 12]], 1) == 1.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 5, 2], [6, 1, 2], [2, 3, 7]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 2, 1], [3, 1, 8], [11, 1, 6]], 3) == 4.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 6], [2, 5, 2], [3, 3, 7]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 3, 5], [9, 8, 6], [12, 5, 4]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 3, 6], [7, 6, 8], [7, 4, 8]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 3, 1], [9, 6, 3], [6, 8, 13]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 6, 7], [5, 8, 5], [5, 6, 12]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 4, 7], [11, 8, 10], [7, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 3, 7], [4, 8, 2], [8, 5, 9]], 2) == 5.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [3, 1, 6], [5, 8, 12]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 1, 3], [9, 10, 6], [12, 3, 14]], 3) == 8.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 5], [9, 9, 10], [3, 2, 13]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 9], [9, 1, 4], [12, 2, 15]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 3, 8], [3, 1, 4], [9, 2, 15]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 9], [4, 11, 4], [3, 4, 9]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 1], [2, 1, 4], [12, 6, 9]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 5], [5, 4, 7], [11, 3, 13]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 9], [12, 8, 5], [5, 2, 9]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 1], [5, 5, 7], [13, 8, 14]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 4, 3], [9, 7, 8], [11, 6, 6]], 3) == 7.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 4, 7], [11, 1, 1], [5, 9, 12]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 1, 9], [2, 8, 10], [5, 9, 6]], 2) == 3.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 6], [12, 2, 5], [4, 6, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 9], [4, 6, 3], [10, 1, 13]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 2], [6, 1, 1], [10, 4, 8]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 4], [10, 6, 6], [13, 3, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 8, 1], [2, 2, 6], [3, 8, 5]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 7], [9, 1, 6], [13, 1, 5]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 4], [7, 4, 9], [6, 6, 10]], 1) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 7, 8], [9, 7, 2], [11, 3, 6]], 1) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 4, 4], [2, 1, 8], [12, 7, 12]], 2) == 3.3333333333333335", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 2, 3], [12, 6, 3], [13, 1, 11]], 3) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 2, 5], [2, 3, 4], [5, 6, 12]], 2) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 1, 7], [4, 8, 2], [5, 2, 12]], 3) == 6.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 6, 5], [7, 7, 2], [11, 4, 13]], 3) == 7.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 6, 1], [10, 1, 3], [3, 8, 12]], 2) == 4.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 1, 2], [12, 4, 6], [13, 2, 14]], 3) == 9.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 7], [3, 7, 9], [9, 8, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 1, 1], [4, 7, 3], [6, 7, 9]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 4, 3], [6, 4, 4], [7, 3, 14]], 2) == 4.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 2, 9], [12, 2, 9], [4, 7, 7]], 1) == 2.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 7, 2], [5, 4, 7], [9, 5, 10]], 2) == 5.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 9, 1], [13, 5, 2], [4, 5, 11]], 2) == 6.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 2, 1], [11, 12, 9], [4, 9, 14]], 2) == 9.666666666666666", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 7, 10], [3, 9, 4], [11, 1, 7]], 3) == 6.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 9, 5], [6, 7, 3], [6, 7, 10]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 8, 3], [11, 10, 3], [11, 1, 12]], 1) == 4.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 9], [5, 11, 7], [9, 4, 10]], 2) == 8.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 6, 8], [10, 7, 4], [10, 8, 14]], 2) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 3, 3], [8, 4, 8], [12, 1, 14]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [8, 12, 2], [14, 4, 9]], 3) == 8.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 5, 4], [12, 7, 1], [12, 7, 11]], 3) == 9.2", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 5, 10], [10, 10, 4], [11, 6, 8]], 1) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 8, 8], [10, 7, 5], [6, 1, 9]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 7, 4], [8, 7, 3], [11, 2, 8]], 2) == 5.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 5, 6], [4, 2, 8], [6, 6, 10]], 2) == 2.6666666666666665", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 5], [3, 2, 5], [4, 3, 15]], 2) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 8, 4], [9, 5, 11], [11, 8, 14]], 1) == 6.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[7, 9, 2], [13, 3, 2], [9, 10, 6]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 7, 10], [8, 10, 11], [4, 3, 8]], 2) == 7.666666666666667", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 6, 8], [12, 11, 4], [14, 6, 16]], 3) == 10.6", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 2, 4], [12, 3, 9], [9, 7, 14]], 3) == 9.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 4], [4, 4, 7], [12, 5, 11]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[1, 8, 4], [11, 10, 8], [11, 1, 13]], 2) == 7.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[4, 9, 9], [5, 6, 11], [14, 8, 16]], 3) == 9.8", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 8, 10], [11, 5, 9], [11, 5, 6]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[3, 1, 4], [6, 11, 7], [5, 8, 7]], 1) == 3.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 6, 1], [11, 11, 3], [10, 3, 8]], 2) == 8.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[5, 8, 5], [9, 10, 3], [12, 5, 6]], 3) == 7.4", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 4, 5], [4, 7, 9], [4, 2, 6]], 2) == 6.333333333333333", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[8, 7, 8], [9, 11, 1], [4, 7, 8]], 2) == 9.333333333333334", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[2, 7, 8], [6, 2, 9], [8, 8, 9]], 3) == 7.0", "def check(maxAverageOfPath):\n\tassert maxAverageOfPath([[6, 5, 2], [13, 8, 8], [12, 2, 7]], 3) == 8.4"], "scores": [0.3333, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [false, false, true, true, true, false, true, true, true, true], "pass_test_cases_num": [34, 0, 102, 102, 102, 0, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef maxAverageOfPath(matrix: List[List[int]], n: int) -> float:\n    \"\"\"\n    Calculate the maximum average path in a given N*N matrix.\n\n    Parameters:\n    matrix (List[List[int]]): A square matrix of size N*N with integer costs.\n    n (int): The size of the matrix (N).\n\n    Returns:\n    float: The maximum average cost of a path from top-left to bottom-right.\n    \"\"\"\n    \n    # Initialize a 2D list to store the maximum sum of costs for each cell\n    max_sum = [[0] * n for _ in range(n)]\n    \n    # Initialize a 2D list to store the number of cells visited for each path\n    cell_count = [[0] * n for _ in range(n)]\n    \n    # Fill the first cell\n    max_sum[0][0] = matrix[0][0]\n    cell_count[0][0] = 1\n    \n    # Fill the first row\n    for j in range(1, n):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n        cell_count[0][j] = cell_count[0][j-1] + 1\n    \n    # Fill the first column\n    for i in range(1, n):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n        cell_count[i][0] = cell_count[i-1][0] + 1\n    \n    # Fill the rest of the matrix\n    for i in range(1, n):\n        for j in range(1, n):\n            if max_sum[i-1][j] > max_sum[i][j-1]:\n                max_sum[i][j] = max_sum[i-1][j] + matrix[i][j]\n                cell_count[i][j] = cell_count[i-1][j] + 1\n            else:\n                max_sum[i][j] = max_sum[i][j-1] + matrix[i][j]\n                cell_count[i][j] = cell_count[i][j-1] + 1\n    \n    # Calculate the maximum average\n    max_average = max_sum[n-1][n-1] / cell_count[n-1][n-1]\n    \n    return max_average\n", "passed": true, "pass": true, "pass_num": 7, "round": 532, "mutate_method": "expand_one2two", "parent_index": 213}
