{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 635, "prompt": "Write a function to sort the given list. Ensure that the function handles both numerical and string inputs gracefully. It is important that the function should handle numerical inputs seamlessly. It should also manage string inputs in an efficient manner.", "code": "import heapq as hq\ndef heap_sort(iterable):\n    h = []\n    for value in iterable:\n        hq.heappush(h, value)\n    return [hq.heappop(h) for i in range(len(h))]", "test_imports": [], "test_list": ["assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "assert heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]", "assert heap_sort( [7, 1, 9, 5])==[1,5,7,9]", "assert heap_sort([5, 1, 10, 4, 12, 3, 1, 3, 3, 5]) == [1, 1, 3, 3, 3, 4, 5, 5, 10, 12]", "assert heap_sort([6, 3, 3, 2, 6, 5, 4, 5, 11, 2]) == [2, 2, 3, 3, 4, 5, 5, 6, 6, 11]", "assert heap_sort([2, 6, 7, 5, 9, 3, 4, 3, 9, 5]) == [2, 3, 3, 4, 5, 5, 6, 7, 9, 9]", "assert heap_sort([6, 7, 4, 11, 10, 3, 5, 2, 6, 2]) == [2, 2, 3, 4, 5, 6, 6, 7, 10, 11]", "assert heap_sort([2, 1, 5, 10, 8, 5, 4, 4, 5, 2]) == [1, 2, 2, 4, 4, 5, 5, 5, 8, 10]", "assert heap_sort([6, 2, 5, 8, 9, 7, 2, 2, 5, 1]) == [1, 2, 2, 2, 5, 5, 6, 7, 8, 9]", "assert heap_sort([5, 2, 6, 9, 10, 2, 7, 5, 9, 3]) == [2, 2, 3, 5, 5, 6, 7, 9, 9, 10]", "assert heap_sort([2, 1, 5, 2, 12, 3, 9, 9, 8, 3]) == [1, 2, 2, 3, 3, 5, 8, 9, 9, 12]", "assert heap_sort([4, 4, 4, 5, 8, 3, 5, 3, 11, 2]) == [2, 3, 3, 4, 4, 4, 5, 5, 8, 11]", "assert heap_sort([4, 4, 5, 8, 14, 7, 8, 3, 7, 4]) == [3, 4, 4, 4, 5, 7, 7, 8, 8, 14]", "assert heap_sort([4, 3, 4, 3, 5, 1, 2, 6, 12, 1]) == [1, 1, 2, 3, 3, 4, 4, 5, 6, 12]", "assert heap_sort([3, 2, 10, 7, 11, 3, 2, 3, 11, 1]) == [1, 2, 2, 3, 3, 3, 7, 10, 11, 11]", "assert heap_sort([1, 4, 5, 2, 14, 4, 2, 6, 7, 5]) == [1, 2, 2, 4, 4, 5, 5, 6, 7, 14]", "assert heap_sort([2, 5, 9, 7, 10, 2, 7, 1, 5, 5]) == [1, 2, 2, 5, 5, 5, 7, 7, 9, 10]", "assert heap_sort([2, 4, 4, 10, 4, 5, 9, 5, 8, 1]) == [1, 2, 4, 4, 4, 5, 5, 8, 9, 10]", "assert heap_sort([1, 3, 6, 9, 5, 1, 2, 4, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]", "assert heap_sort([2, 2, 8, 9, 10, 4, 7, 1, 7, 1]) == [1, 1, 2, 2, 4, 7, 7, 8, 9, 10]", "assert heap_sort([2, 1, 2, 12, 12, 2, 1, 1, 7, 2]) == [1, 1, 1, 2, 2, 2, 2, 7, 12, 12]", "assert heap_sort([4, 5, 10, 12, 13, 6, 3, 9, 10, 1]) == [1, 3, 4, 5, 6, 9, 10, 10, 12, 13]", "assert heap_sort([4, 6, 1, 2, 7, 1, 7, 1, 8, 1]) == [1, 1, 1, 1, 2, 4, 6, 7, 7, 8]", "assert heap_sort([4, 7, 7, 9, 6, 2, 8, 5, 8, 3]) == [2, 3, 4, 5, 6, 7, 7, 8, 8, 9]", "assert heap_sort([4, 1, 2, 4, 5, 1, 2, 4, 12, 5]) == [1, 1, 2, 2, 4, 4, 4, 5, 5, 12]", "assert heap_sort([4, 4, 1, 4, 9, 2, 7, 5, 7, 4]) == [1, 2, 4, 4, 4, 4, 5, 7, 7, 9]", "assert heap_sort([2, 8, 6, 10, 14, 4, 5, 2, 6, 5]) == [2, 2, 4, 5, 5, 6, 6, 8, 10, 14]", "assert heap_sort([4, 6, 8, 4, 10, 2, 4, 1, 7, 1]) == [1, 1, 2, 4, 4, 4, 6, 7, 8, 10]", "assert heap_sort([6, 3, 3, 11, 13, 5, 7, 5, 5, 2]) == [2, 3, 3, 5, 5, 5, 6, 7, 11, 13]", "assert heap_sort([4, 2, 5, 11, 12, 6, 4, 11, 8, 5]) == [2, 4, 4, 5, 5, 6, 8, 11, 11, 12]", "assert heap_sort([1, 6, 3, 12, 7, 4, 5, 11, 3, 2]) == [1, 2, 3, 3, 4, 5, 6, 7, 11, 12]", "assert heap_sort([2, 6, 5, 5, 4, 4, 2, 1, 12, 3]) == [1, 2, 2, 3, 4, 4, 5, 5, 6, 12]", "assert heap_sort([3, 1, 7, 12, 7, 1, 8, 4, 7, 2]) == [1, 1, 2, 3, 4, 7, 7, 7, 8, 12]", "assert heap_sort([5, 8, 4, 11, 8, 7, 4, 2, 4, 2]) == [2, 2, 4, 4, 4, 5, 7, 8, 8, 11]", "assert heap_sort([2, 8, 9, 2, 10, 4, 5, 7, 3, 2]) == [2, 2, 2, 3, 4, 5, 7, 8, 9, 10]", "assert heap_sort([3, 2, 5, 2, 8, 4, 4, 7, 10, 1]) == [1, 2, 2, 3, 4, 4, 5, 7, 8, 10]", "assert heap_sort([23, 35, 21, 90, 16, 69, 78, 22, 55]) == [16, 21, 22, 23, 35, 55, 69, 78, 90]", "assert heap_sort([21, 36, 24, 82, 9, 63, 74, 28, 53]) == [9, 21, 24, 28, 36, 53, 63, 74, 82]", "assert heap_sort([23, 31, 24, 82, 11, 64, 70, 25, 58]) == [11, 23, 24, 25, 31, 58, 64, 70, 82]", "assert heap_sort([30, 35, 22, 86, 17, 61, 73, 22, 53]) == [17, 22, 22, 30, 35, 53, 61, 73, 86]", "assert heap_sort([20, 36, 18, 87, 12, 67, 72, 25, 62]) == [12, 18, 20, 25, 36, 62, 67, 72, 87]", "assert heap_sort([21, 39, 25, 84, 17, 69, 72, 24, 54]) == [17, 21, 24, 25, 39, 54, 69, 72, 84]", "assert heap_sort([29, 36, 20, 90, 14, 69, 71, 30, 57]) == [14, 20, 29, 30, 36, 57, 69, 71, 90]", "assert heap_sort([28, 36, 26, 90, 16, 61, 76, 23, 53]) == [16, 23, 26, 28, 36, 53, 61, 76, 90]", "assert heap_sort([26, 32, 27, 88, 11, 67, 74, 29, 61]) == [11, 26, 27, 29, 32, 61, 67, 74, 88]", "assert heap_sort([21, 39, 26, 88, 19, 60, 70, 25, 55]) == [19, 21, 25, 26, 39, 55, 60, 70, 88]", "assert heap_sort([25, 36, 18, 83, 19, 62, 78, 25, 63]) == [18, 19, 25, 25, 36, 62, 63, 78, 83]", "assert heap_sort([30, 33, 23, 90, 17, 64, 70, 24, 59]) == [17, 23, 24, 30, 33, 59, 64, 70, 90]", "assert heap_sort([20, 35, 22, 90, 9, 62, 78, 28, 60]) == [9, 20, 22, 28, 35, 60, 62, 78, 90]", "assert heap_sort([25, 36, 25, 81, 10, 69, 80, 27, 55]) == [10, 25, 25, 27, 36, 55, 69, 80, 81]", "assert heap_sort([27, 31, 17, 88, 10, 66, 76, 26, 57]) == [10, 17, 26, 27, 31, 57, 66, 76, 88]", "assert heap_sort([21, 36, 19, 85, 11, 69, 78, 22, 61]) == [11, 19, 21, 22, 36, 61, 69, 78, 85]", "assert heap_sort([22, 31, 22, 82, 16, 62, 77, 24, 62]) == [16, 22, 22, 24, 31, 62, 62, 77, 82]", "assert heap_sort([20, 30, 26, 88, 18, 68, 77, 28, 57]) == [18, 20, 26, 28, 30, 57, 68, 77, 88]", "assert heap_sort([28, 40, 17, 89, 19, 65, 79, 24, 56]) == [17, 19, 24, 28, 40, 56, 65, 79, 89]", "assert heap_sort([24, 40, 18, 87, 10, 66, 75, 22, 60]) == [10, 18, 22, 24, 40, 60, 66, 75, 87]", "assert heap_sort([21, 32, 21, 80, 15, 60, 70, 29, 61]) == [15, 21, 21, 29, 32, 60, 61, 70, 80]", "assert heap_sort([28, 35, 25, 88, 12, 68, 76, 21, 55]) == [12, 21, 25, 28, 35, 55, 68, 76, 88]", "assert heap_sort([29, 31, 17, 90, 16, 67, 72, 21, 57]) == [16, 17, 21, 29, 31, 57, 67, 72, 90]", "assert heap_sort([28, 36, 23, 85, 16, 66, 76, 21, 53]) == [16, 21, 23, 28, 36, 53, 66, 76, 85]", "assert heap_sort([26, 36, 18, 90, 17, 64, 72, 22, 58]) == [17, 18, 22, 26, 36, 58, 64, 72, 90]", "assert heap_sort([24, 40, 21, 86, 18, 62, 74, 28, 60]) == [18, 21, 24, 28, 40, 60, 62, 74, 86]", "assert heap_sort([29, 30, 27, 82, 17, 61, 72, 26, 62]) == [17, 26, 27, 29, 30, 61, 62, 72, 82]", "assert heap_sort([30, 32, 27, 84, 18, 64, 79, 21, 56]) == [18, 21, 27, 30, 32, 56, 64, 79, 84]", "assert heap_sort([28, 34, 26, 89, 16, 60, 76, 26, 59]) == [16, 26, 26, 28, 34, 59, 60, 76, 89]", "assert heap_sort([20, 40, 25, 90, 17, 60, 75, 22, 60]) == [17, 20, 22, 25, 40, 60, 60, 75, 90]", "assert heap_sort([21, 33, 23, 89, 9, 60, 79, 26, 62]) == [9, 21, 23, 26, 33, 60, 62, 79, 89]", "assert heap_sort([24, 30, 19, 82, 11, 67, 77, 26, 56]) == [11, 19, 24, 26, 30, 56, 67, 77, 82]", "assert heap_sort([30, 31, 23, 89, 18, 67, 71, 28, 61]) == [18, 23, 28, 30, 31, 61, 67, 71, 89]", "assert heap_sort([7, 6, 14, 5]) == [5, 6, 7, 14]", "assert heap_sort([10, 2, 14, 1]) == [1, 2, 10, 14]", "assert heap_sort([7, 1, 4, 9]) == [1, 4, 7, 9]", "assert heap_sort([8, 4, 10, 4]) == [4, 4, 8, 10]", "assert heap_sort([4, 6, 9, 5]) == [4, 5, 6, 9]", "assert heap_sort([6, 6, 8, 4]) == [4, 6, 6, 8]", "assert heap_sort([2, 3, 14, 2]) == [2, 2, 3, 14]", "assert heap_sort([5, 2, 12, 4]) == [2, 4, 5, 12]", "assert heap_sort([11, 3, 8, 2]) == [2, 3, 8, 11]", "assert heap_sort([11, 5, 4, 8]) == [4, 5, 8, 11]", "assert heap_sort([3, 5, 8, 2]) == [2, 3, 5, 8]", "assert heap_sort([8, 4, 9, 2]) == [2, 4, 8, 9]", "assert heap_sort([4, 4, 4, 6]) == [4, 4, 4, 6]", "assert heap_sort([12, 6, 9, 8]) == [6, 8, 9, 12]", "assert heap_sort([4, 2, 12, 3]) == [2, 3, 4, 12]", "assert heap_sort([9, 2, 4, 3]) == [2, 3, 4, 9]", "assert heap_sort([8, 5, 4, 4]) == [4, 4, 5, 8]", "assert heap_sort([9, 1, 11, 4]) == [1, 4, 9, 11]", "assert heap_sort([7, 2, 7, 2]) == [2, 2, 7, 7]", "assert heap_sort([6, 3, 13, 7]) == [3, 6, 7, 13]", "assert heap_sort([10, 4, 12, 8]) == [4, 8, 10, 12]", "assert heap_sort([2, 3, 4, 5]) == [2, 3, 4, 5]", "assert heap_sort([4, 5, 7, 10]) == [4, 5, 7, 10]", "assert heap_sort([11, 2, 7, 9]) == [2, 7, 9, 11]", "assert heap_sort([11, 6, 7, 5]) == [5, 6, 7, 11]", "assert heap_sort([7, 4, 11, 2]) == [2, 4, 7, 11]", "assert heap_sort([6, 4, 9, 5]) == [4, 5, 6, 9]", "assert heap_sort([12, 3, 11, 4]) == [3, 4, 11, 12]", "assert heap_sort([7, 2, 6, 10]) == [2, 6, 7, 10]", "assert heap_sort([10, 5, 9, 2]) == [2, 5, 9, 10]", "assert heap_sort([12, 5, 6, 5]) == [5, 5, 6, 12]", "assert heap_sort([11, 1, 5, 5]) == [1, 5, 5, 11]", "assert heap_sort([10, 2, 6, 7]) == [2, 6, 7, 10]"], "entry_point": "heap_sort", "repair_prompt": ["Write a function heap_sort to sort the given list. Ensure that the function handles both numerical and string inputs gracefully. It is important that the function should handle numerical inputs seamlessly. It should also manage string inputs in an efficient manner.\nheap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"], "completions": ["from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Union\n\ndef heap_sort(arr: List[Union[int, float, str]]) -> List[Union[int, float, str]]:\n    \"\"\"Sorts a list of numerical or string elements using heap sort.\n\n    This function handles mixed data types by converting all elements to strings\n    before sorting to ensure a consistent comparison method.\n\n    Args:\n        arr (List[Union[int, float, str]]): A list of numerical or string elements.\n\n    Returns:\n        List[Union[int, float, str]]: A sorted list of elements.\n    \"\"\"\n    # Convert all elements to strings for consistent comparison\n    str_arr = [str(element) for element in arr]\n    \n    # Create a heap from the list\n    heapq.heapify(str_arr)\n    \n    # Extract elements from the heap in sorted order\n    sorted_arr = [heapq.heappop(str_arr) for _ in range(len(str_arr))]\n    \n    return sorted_arr\n\n# Example usage\nif __name__ == \"__main__\":\n    example_list = [3, \"apple\", 1.5, \"banana\", 2]\n    sorted_list = heap_sort(example_list)\n    print(\"Sorted List:\", sorted_list)\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Union\n\ndef heap_sort(data: List[Union[int, str]]) -> List[Union[int, str]]:\n    \"\"\"Sorts a list of numbers or strings using the heap sort algorithm.\n\n    This function uses the heapq library to convert the list into a heap and\n    then extracts elements in sorted order. It assumes that the list contains\n    homogeneous data types (either all numbers or all strings).\n\n    Args:\n        data (List[Union[int, str]]): A list of numbers or strings to be sorted.\n\n    Returns:\n        List[Union[int, str]]: A new list containing the sorted elements.\n    \"\"\"\n    # Create a copy of the data to avoid modifying the original list\n    heap = data[:]\n    \n    # Transform the list into a heap\n    heapq.heapify(heap)\n    \n    # Extract elements from the heap in sorted order\n    sorted_list = [heapq.heappop(heap) for _ in range(len(heap))]\n    \n    return sorted_list\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test with a list of integers\n    numbers = [5, 3, 8, 1, 2, 7]\n    print(\"Sorted numbers:\", heap_sort(numbers))\n    \n    # Test with a list of strings\n    strings = [\"apple\", \"orange\", \"banana\", \"pear\"]\n    print(\"Sorted strings:\", heap_sort(strings))\n", "from typing import List\n## main.py\nimport heapq\n\ndef heap_sort(input_list: list) -> list:\n    \"\"\"\n    Sorts a list of numbers or strings using heap sort.\n\n    Parameters:\n    input_list (list): A list of numbers or strings to be sorted.\n\n    Returns:\n    list: A sorted list.\n\n    Raises:\n    ValueError: If the input list contains mixed data types or unsupported types.\n    \"\"\"\n    if not input_list:\n        return []\n\n    # Check for mixed data types\n    first_type = type(input_list[0])\n    if not all(isinstance(item, first_type) for item in input_list):\n        raise ValueError(\"Input list contains mixed data types.\")\n\n    # Use heapq to perform heap sort\n    heapq.heapify(input_list)\n    sorted_list = [heapq.heappop(input_list) for _ in range(len(input_list))]\n    \n    return sorted_list\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\n        print(\"Sorted numbers:\", heap_sort(numbers))\n        \n        strings = [\"apple\", \"orange\", \"banana\", \"pear\"]\n        print(\"Sorted strings:\", heap_sort(strings))\n        \n        mixed = [1, \"apple\", 3.14]\n        print(\"Sorted mixed:\", heap_sort(mixed))  # This will raise ValueError\n    except ValueError as e:\n        print(\"Error:\", e)\n", "from typing import List\n## main.py\nimport heapq\n\ndef heap_sort(input_list: list) -> list:\n    \"\"\"\n    Sorts a list of numerical and string inputs using heap sort.\n\n    Parameters:\n    input_list (list): A list containing numerical and/or string elements.\n\n    Returns:\n    list: A sorted list with numbers first followed by strings.\n    \"\"\"\n    # Separate numbers and strings\n    numbers = [item for item in input_list if isinstance(item, (int, float))]\n    strings = [item for item in input_list if isinstance(item, str)]\n\n    # Sort numbers using heapq\n    heapq.heapify(numbers)\n    sorted_numbers = [heapq.heappop(numbers) for _ in range(len(numbers))]\n\n    # Sort strings in a case-insensitive manner\n    sorted_strings = sorted(strings, key=lambda s: s.lower())\n\n    # Combine sorted numbers and strings\n    return sorted_numbers + sorted_strings\n\n# Example usage\nif __name__ == \"__main__\":\n    example_list = [3, \"apple\", 1, \"Banana\", 2, \"cherry\"]\n    sorted_list = heap_sort(example_list)\n    print(sorted_list)\n", "from typing import List\n## main.py\n\ndef heap_sort(arr: list) -> list:\n    \"\"\"\n    Sorts a list of numbers or strings using the heap sort algorithm.\n\n    Parameters:\n    arr (list): A list of numbers or strings to be sorted.\n\n    Returns:\n    list: A new list containing the sorted elements.\n    \"\"\"\n    def heapify(arr: list, n: int, i: int) -> None:\n        \"\"\"Helper function to maintain the heap property.\"\"\"\n        largest = i  # Initialize largest as root\n        left = 2 * i + 1  # left = 2*i + 1\n        right = 2 * i + 2  # right = 2*i + 2\n\n        # See if left child of root exists and is greater than root\n        if left < n and arr[i] < arr[left]:\n            largest = left\n\n        # See if right child of root exists and is greater than root\n        if right < n and arr[largest] < arr[right]:\n            largest = right\n\n        # Change root, if needed\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]  # swap\n\n            # Heapify the root.\n            heapify(arr, n, largest)\n\n    def build_max_heap(arr: list) -> None:\n        \"\"\"Builds a max heap from the input list.\"\"\"\n        n = len(arr)\n        # Build a maxheap.\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n\n    def sort_heap(arr: list) -> None:\n        \"\"\"Sorts the heap.\"\"\"\n        n = len(arr)\n        # One by one extract elements\n        for i in range(n - 1, 0, -1):\n            arr[i], arr[0] = arr[0], arr[i]  # swap\n            heapify(arr, i, 0)\n\n    # Create a copy of the array to avoid modifying the original list\n    arr_copy = arr[:]\n    build_max_heap(arr_copy)\n    sort_heap(arr_copy)\n    return arr_copy\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Union\n\ndef heap_sort(data: List[Union[int, str]]) -> List[Union[int, str]]:\n    \"\"\"\n    Sorts a list of numbers or strings using heap sort algorithm.\n\n    Parameters:\n    data (list): A list of numbers or strings to be sorted.\n\n    Returns:\n    list: A sorted list.\n\n    Raises:\n    TypeError: If the list contains mixed data types or unsupported types.\n    \"\"\"\n    if not data:\n        return []\n\n    # Check if all elements are of the same type\n    first_type = type(data[0])\n    if not all(isinstance(item, first_type) for item in data):\n        raise TypeError(\"List contains mixed data types or unsupported types.\")\n\n    # Use heapq to perform heap sort\n    heapq.heapify(data)\n    sorted_data = [heapq.heappop(data) for _ in range(len(data))]\n\n    return sorted_data\n\n# Example usage:\n# sorted_numbers = heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])\n# sorted_strings = heap_sort([\"apple\", \"orange\", \"banana\", \"pear\"])\n", "from typing import List\n## main.py\nimport heapq\nfrom typing import List, Union\n\ndef heap_sort(data: List[Union[int, str]]) -> List[Union[int, str]]:\n    \"\"\"\n    Sorts a list of numbers or strings using heap sort.\n\n    Parameters:\n    data (list): A list of numbers or strings to be sorted.\n\n    Returns:\n    list: A sorted list.\n\n    Raises:\n    TypeError: If the list contains mixed data types or unsupported types.\n    \"\"\"\n    if not data:\n        return data\n\n    # Check for data type consistency\n    first_type = type(data[0])\n    if not all(isinstance(item, first_type) for item in data):\n        raise TypeError(\"List contains mixed data types or unsupported types.\")\n\n    # Use heapq to perform heap sort\n    heapq.heapify(data)\n    sorted_data = [heapq.heappop(data) for _ in range(len(data))]\n    \n    return sorted_data\n\n# Example usage:\nif __name__ == \"__main__\":\n    try:\n        numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\n        sorted_numbers = heap_sort(numbers)\n        print(\"Sorted numbers:\", sorted_numbers)\n\n        strings = [\"apple\", \"orange\", \"banana\", \"pear\"]\n        sorted_strings = heap_sort(strings)\n        print(\"Sorted strings:\", sorted_strings)\n\n        mixed = [1, \"apple\", 3, \"banana\"]\n        sorted_mixed = heap_sort(mixed)  # This will raise a TypeError\n    except TypeError as e:\n        print(\"Error:\", e)\n", "from typing import List\n## main.py\nimport heapq\n\ndef heap_sort(input_list: list) -> list:\n    \"\"\"\n    Sorts a list of numerical or string inputs using heap sort.\n    \n    Args:\n        input_list: List of integers, floats, or strings.\n        \n    Returns:\n        Sorted list.\n        \n    Raises:\n        ValueError: If the input list contains mixed data types or unsupported types.\n    \"\"\"\n    if not input_list:\n        return []\n\n    # Validate input list\n    if not all(isinstance(item, (int, float, str)) for item in input_list):\n        raise ValueError(\"Input list must contain only integers, floats, or strings.\")\n\n    # Check for mixed data types\n    data_types = set(type(item) for item in input_list)\n    if len(data_types) > 1:\n        raise ValueError(\"Input list must not contain mixed data types.\")\n\n    # Convert strings to ASCII values for sorting\n    if all(isinstance(item, str) for item in input_list):\n        input_list = [ord(char) for char in ''.join(input_list)]\n\n    # Perform heap sort using heapq\n    heapq.heapify(input_list)\n    sorted_list = [heapq.heappop(input_list) for _ in range(len(input_list))]\n\n    # Convert ASCII values back to strings if necessary\n    if all(isinstance(item, int) for item in sorted_list) and len(data_types) == 1 and str in data_types:\n        sorted_list = [chr(item) for item in sorted_list]\n\n    return sorted_list\n", "from typing import List\n## main.py\nimport heapq\nfrom typing import List, Union\n\ndef heap_sort(input_list: List[Union[int, float, str]]) -> List[Union[int, float, str]]:\n    \"\"\"\n    Sorts a list of numerical or string inputs using heap sort.\n\n    Parameters:\n    input_list (List[Union[int, float, str]]): A list containing numerical or string elements.\n\n    Returns:\n    List[Union[int, float, str]]: A sorted list of the same type as input.\n    \"\"\"\n    if not input_list:\n        return []\n\n    # Determine if the list contains strings\n    is_string_list = all(isinstance(item, str) for item in input_list)\n\n    if is_string_list:\n        # Sort strings directly\n        sorted_list = sorted(input_list)\n    else:\n        # Assume numerical list and perform heap sort directly\n        heapq.heapify(input_list)\n        sorted_list = [heapq.heappop(input_list) for _ in range(len(input_list))]\n\n    return sorted_list\n", "from typing import List\n## main.py\nimport heapq\nfrom typing import List, Union\n\ndef heap_sort(data: List[Union[int, str]]) -> List[Union[int, str]]:\n    \"\"\"\n    Sorts a list of numbers or strings using heap sort.\n\n    Parameters:\n    data (list): A list of numbers or strings to be sorted.\n\n    Returns:\n    list: A sorted list of the same type as the input.\n\n    Raises:\n    TypeError: If the list contains unsupported or mixed data types.\n    \"\"\"\n    if not data:\n        return data\n\n    # Check if all elements are of the same type\n    first_type = type(data[0])\n    if not all(isinstance(item, first_type) for item in data):\n        raise TypeError(\"List contains mixed or unsupported data types.\")\n\n    # Use heapq to perform heap sort\n    heapq.heapify(data)\n    sorted_data = [heapq.heappop(data) for _ in range(len(data))]\n\n    return sorted_data\n"], "plans": ["requirement analysis:\nThe function must efficiently sort both numerical and string inputs, ensuring seamless handling of mixed data types. The algorithm should be robust and optimized for performance.\nrequirement pool:\n- Implement heap sort algorithm for numerical inputs\n- Ensure efficient handling of string inputs\n- Optimize for mixed data types\n- Test performance on large datasets\n- Provide clear documentation and examples\nWe will implement the heap sort algorithm using the heapq library from Python's standard library, which provides efficient heap operations. This will ensure that both numerical and string inputs are handled efficiently. For mixed data types, we will sort them by converting all elements to strings, ensuring a consistent comparison method.\n", "requirement analysis:\nThe function must efficiently sort both numerical and string inputs, ensuring seamless operation for numerical data and efficient handling of strings. The algorithm should be robust and reliable, providing consistent results across different types of data.\nrequirement pool:\n- Implement heap sort for numerical inputs\n- Ensure efficient handling of string inputs\n- Optimize performance for large datasets\n- Provide clear documentation for usage\n- Include error handling for invalid inputs\nWe will implement a heap sort function that can handle both numerical and string inputs. The function will use the heapq library from Python's standard library, which provides an efficient implementation of the heap queue algorithm. This will ensure that the function is both fast and reliable for sorting. The function will first convert the input list into a heap and then extract elements in sorted order. We will ensure that the function can handle both integers and strings by using Python's built-in comparison operators, which work seamlessly for these data types.\n", "requirement analysis:\nThe function must efficiently sort both numerical and string inputs, ensuring seamless integration and performance. It should handle errors gracefully and be optimized for large datasets.\nrequirement pool:\n- Implement heap sort algorithm for numerical inputs\n- Ensure string inputs are sorted alphabetically\n- Optimize performance for large lists\n- Provide error handling for invalid inputs\n- Document the function for easy integration\nWe will implement a heap sort algorithm using the heapq library from Python's standard library, which provides efficient heap operations. This will ensure optimal performance for numerical inputs. For string inputs, we will use the same heap sort logic, as heapq can handle string comparisons naturally. The function will check the input type and sort accordingly, providing error handling for invalid inputs.\n", "requirement analysis:\nThe function must efficiently sort both numerical and string inputs, ensuring robustness and reliability. It should handle edge cases such as empty lists and mixed data types without errors.\nrequirement pool:\n- Implement heap sort algorithm for numerical inputs\n- Ensure efficient handling of string inputs\n- Optimize for performance with large datasets\n- Handle edge cases gracefully\n- Provide clear documentation and examples\nWe will implement the heap sort algorithm using Python's built-in heapq library to efficiently manage both numerical and string inputs. The function will handle edge cases such as empty lists and mixed data types gracefully. For mixed data types, we will sort numbers first followed by strings, ensuring case-insensitive sorting for strings.\n", "requirement analysis:\nThe function must efficiently sort both numerical and string inputs, ensuring seamless integration with existing codebases. It should prioritize performance and reliability, especially for numerical data, while maintaining flexibility for string data.\nrequirement pool:\n- Implement heap sort algorithm for numerical inputs\n- Ensure efficient handling of string inputs\n- Optimize performance for large datasets\n- Provide clear documentation for integration\n- Include error handling for invalid inputs\nWe will implement the heap sort algorithm to handle both numerical and string inputs. The heap sort algorithm is chosen for its efficiency and reliability in sorting. We will use Python's built-in capabilities to manage comparisons between elements, ensuring that both numbers and strings are sorted correctly. The function will be designed to handle edge cases such as mixed-case strings and special characters by using Python's default string comparison behavior, which is lexicographical.\n", "requirement analysis:\nThe function must efficiently sort both numerical and string inputs, ensuring that it can handle mixed data types without errors. It should prioritize performance and provide clear error messages for unsupported data types.\nrequirement pool:\n- Implement heap sort algorithm for numerical data\n- Extend heap sort to handle string data\n- Optimize sorting performance for large datasets\n- Implement error handling for unsupported data types\n- Provide documentation for usage and limitations\nWe will implement a heap sort algorithm that can handle both numerical and string inputs. The function will first check the type of elements in the list to ensure they are either all numbers or all strings. If mixed types are detected, an error will be raised. We will use the heapq library for efficient heap operations, which is part of Python's standard library and optimized for performance. The function will also include error handling for unsupported data types.\n", "requirement analysis:\nThe function should efficiently sort both numerical and string inputs using heap sort. It must handle edge cases such as empty lists and mixed data types, providing clear error messages for unsupported types.\nrequirement pool:\n- Implement heap sort for numerical inputs\n- Implement heap sort for string inputs\n- Optimize sorting performance for large datasets\n- Provide error handling for unsupported data types\n- Document usage and edge cases\nWe will implement a heap sort function that can handle both numerical and string inputs. The function will use the heapq library from Python's standard library to efficiently manage the heap operations. We will ensure that the function can sort lists of numbers and strings separately, and provide error handling for unsupported data types such as mixed lists of numbers and strings.\n", "requirement analysis:\nThe function must handle both numerical and string inputs efficiently. Numerical inputs should be sorted seamlessly, while string inputs require careful handling to ensure correct order. The function should be robust and reliable, providing consistent results across different types of data.\nrequirement pool:\n- Implement heap sort for numerical inputs\n- Ensure string inputs are sorted correctly\n- Optimize performance for large datasets\n- Provide clear error handling for invalid inputs\n- Document the function usage and edge cases\nWe will implement a heap sort function using the heapq library from Python's standard library, which provides efficient heap operations. This will ensure that both numerical and string inputs are sorted correctly. The function will convert strings to their ASCII values for sorting, ensuring correct order. We will handle errors gracefully and provide informative messages for incorrect inputs.\n", "requirement analysis:\nThe function must handle both numerical and string inputs efficiently. It should prioritize seamless sorting for numerical data while ensuring string data is sorted without errors. The function should be robust and easy to integrate into existing codebases.\nrequirement pool:\n- Implement heap sort for numerical inputs\n- Ensure string inputs are sorted efficiently\n- Optimize performance for large datasets\n- Provide clear documentation for integration\n- Include error handling for invalid inputs\nWe will implement a heap sort function using the heapq library from Python's standard library, which provides efficient heap operations. This approach will ensure that both numerical and string inputs are sorted efficiently. The function will convert strings to their ASCII values for sorting and then back to strings after sorting.\n", "requirement analysis:\nThe function must efficiently sort both numerical and string inputs, ensuring seamless handling of numerical data and efficient management of string data. It should provide robust error handling for unsupported data types.\nrequirement pool:\n- Implement heap sort algorithm for numerical inputs\n- Implement heap sort algorithm for string inputs\n- Optimize sorting performance for large datasets\n- Provide error handling for unsupported data types\n- Ensure easy integration into existing projects\nWe will implement a heap sort algorithm using the heapq library from Python's standard library, which provides efficient heap operations. This will allow us to handle both numerical and string inputs gracefully. The function will check the type of elements in the list to ensure they are either all numbers or all strings, and will raise an error for unsupported or mixed data types.\n"], "test": ["def check(heap_sort):\n\tassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "def check(heap_sort):\n\tassert heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]", "def check(heap_sort):\n\tassert heap_sort( [7, 1, 9, 5])==[1,5,7,9]", "def check(heap_sort):\n\tassert heap_sort([5, 1, 10, 4, 12, 3, 1, 3, 3, 5]) == [1, 1, 3, 3, 3, 4, 5, 5, 10, 12]", "def check(heap_sort):\n\tassert heap_sort([6, 3, 3, 2, 6, 5, 4, 5, 11, 2]) == [2, 2, 3, 3, 4, 5, 5, 6, 6, 11]", "def check(heap_sort):\n\tassert heap_sort([2, 6, 7, 5, 9, 3, 4, 3, 9, 5]) == [2, 3, 3, 4, 5, 5, 6, 7, 9, 9]", "def check(heap_sort):\n\tassert heap_sort([6, 7, 4, 11, 10, 3, 5, 2, 6, 2]) == [2, 2, 3, 4, 5, 6, 6, 7, 10, 11]", "def check(heap_sort):\n\tassert heap_sort([2, 1, 5, 10, 8, 5, 4, 4, 5, 2]) == [1, 2, 2, 4, 4, 5, 5, 5, 8, 10]", "def check(heap_sort):\n\tassert heap_sort([6, 2, 5, 8, 9, 7, 2, 2, 5, 1]) == [1, 2, 2, 2, 5, 5, 6, 7, 8, 9]", "def check(heap_sort):\n\tassert heap_sort([5, 2, 6, 9, 10, 2, 7, 5, 9, 3]) == [2, 2, 3, 5, 5, 6, 7, 9, 9, 10]", "def check(heap_sort):\n\tassert heap_sort([2, 1, 5, 2, 12, 3, 9, 9, 8, 3]) == [1, 2, 2, 3, 3, 5, 8, 9, 9, 12]", "def check(heap_sort):\n\tassert heap_sort([4, 4, 4, 5, 8, 3, 5, 3, 11, 2]) == [2, 3, 3, 4, 4, 4, 5, 5, 8, 11]", "def check(heap_sort):\n\tassert heap_sort([4, 4, 5, 8, 14, 7, 8, 3, 7, 4]) == [3, 4, 4, 4, 5, 7, 7, 8, 8, 14]", "def check(heap_sort):\n\tassert heap_sort([4, 3, 4, 3, 5, 1, 2, 6, 12, 1]) == [1, 1, 2, 3, 3, 4, 4, 5, 6, 12]", "def check(heap_sort):\n\tassert heap_sort([3, 2, 10, 7, 11, 3, 2, 3, 11, 1]) == [1, 2, 2, 3, 3, 3, 7, 10, 11, 11]", "def check(heap_sort):\n\tassert heap_sort([1, 4, 5, 2, 14, 4, 2, 6, 7, 5]) == [1, 2, 2, 4, 4, 5, 5, 6, 7, 14]", "def check(heap_sort):\n\tassert heap_sort([2, 5, 9, 7, 10, 2, 7, 1, 5, 5]) == [1, 2, 2, 5, 5, 5, 7, 7, 9, 10]", "def check(heap_sort):\n\tassert heap_sort([2, 4, 4, 10, 4, 5, 9, 5, 8, 1]) == [1, 2, 4, 4, 4, 5, 5, 8, 9, 10]", "def check(heap_sort):\n\tassert heap_sort([1, 3, 6, 9, 5, 1, 2, 4, 5, 3]) == [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]", "def check(heap_sort):\n\tassert heap_sort([2, 2, 8, 9, 10, 4, 7, 1, 7, 1]) == [1, 1, 2, 2, 4, 7, 7, 8, 9, 10]", "def check(heap_sort):\n\tassert heap_sort([2, 1, 2, 12, 12, 2, 1, 1, 7, 2]) == [1, 1, 1, 2, 2, 2, 2, 7, 12, 12]", "def check(heap_sort):\n\tassert heap_sort([4, 5, 10, 12, 13, 6, 3, 9, 10, 1]) == [1, 3, 4, 5, 6, 9, 10, 10, 12, 13]", "def check(heap_sort):\n\tassert heap_sort([4, 6, 1, 2, 7, 1, 7, 1, 8, 1]) == [1, 1, 1, 1, 2, 4, 6, 7, 7, 8]", "def check(heap_sort):\n\tassert heap_sort([4, 7, 7, 9, 6, 2, 8, 5, 8, 3]) == [2, 3, 4, 5, 6, 7, 7, 8, 8, 9]", "def check(heap_sort):\n\tassert heap_sort([4, 1, 2, 4, 5, 1, 2, 4, 12, 5]) == [1, 1, 2, 2, 4, 4, 4, 5, 5, 12]", "def check(heap_sort):\n\tassert heap_sort([4, 4, 1, 4, 9, 2, 7, 5, 7, 4]) == [1, 2, 4, 4, 4, 4, 5, 7, 7, 9]", "def check(heap_sort):\n\tassert heap_sort([2, 8, 6, 10, 14, 4, 5, 2, 6, 5]) == [2, 2, 4, 5, 5, 6, 6, 8, 10, 14]", "def check(heap_sort):\n\tassert heap_sort([4, 6, 8, 4, 10, 2, 4, 1, 7, 1]) == [1, 1, 2, 4, 4, 4, 6, 7, 8, 10]", "def check(heap_sort):\n\tassert heap_sort([6, 3, 3, 11, 13, 5, 7, 5, 5, 2]) == [2, 3, 3, 5, 5, 5, 6, 7, 11, 13]", "def check(heap_sort):\n\tassert heap_sort([4, 2, 5, 11, 12, 6, 4, 11, 8, 5]) == [2, 4, 4, 5, 5, 6, 8, 11, 11, 12]", "def check(heap_sort):\n\tassert heap_sort([1, 6, 3, 12, 7, 4, 5, 11, 3, 2]) == [1, 2, 3, 3, 4, 5, 6, 7, 11, 12]", "def check(heap_sort):\n\tassert heap_sort([2, 6, 5, 5, 4, 4, 2, 1, 12, 3]) == [1, 2, 2, 3, 4, 4, 5, 5, 6, 12]", "def check(heap_sort):\n\tassert heap_sort([3, 1, 7, 12, 7, 1, 8, 4, 7, 2]) == [1, 1, 2, 3, 4, 7, 7, 7, 8, 12]", "def check(heap_sort):\n\tassert heap_sort([5, 8, 4, 11, 8, 7, 4, 2, 4, 2]) == [2, 2, 4, 4, 4, 5, 7, 8, 8, 11]", "def check(heap_sort):\n\tassert heap_sort([2, 8, 9, 2, 10, 4, 5, 7, 3, 2]) == [2, 2, 2, 3, 4, 5, 7, 8, 9, 10]", "def check(heap_sort):\n\tassert heap_sort([3, 2, 5, 2, 8, 4, 4, 7, 10, 1]) == [1, 2, 2, 3, 4, 4, 5, 7, 8, 10]", "def check(heap_sort):\n\tassert heap_sort([23, 35, 21, 90, 16, 69, 78, 22, 55]) == [16, 21, 22, 23, 35, 55, 69, 78, 90]", "def check(heap_sort):\n\tassert heap_sort([21, 36, 24, 82, 9, 63, 74, 28, 53]) == [9, 21, 24, 28, 36, 53, 63, 74, 82]", "def check(heap_sort):\n\tassert heap_sort([23, 31, 24, 82, 11, 64, 70, 25, 58]) == [11, 23, 24, 25, 31, 58, 64, 70, 82]", "def check(heap_sort):\n\tassert heap_sort([30, 35, 22, 86, 17, 61, 73, 22, 53]) == [17, 22, 22, 30, 35, 53, 61, 73, 86]", "def check(heap_sort):\n\tassert heap_sort([20, 36, 18, 87, 12, 67, 72, 25, 62]) == [12, 18, 20, 25, 36, 62, 67, 72, 87]", "def check(heap_sort):\n\tassert heap_sort([21, 39, 25, 84, 17, 69, 72, 24, 54]) == [17, 21, 24, 25, 39, 54, 69, 72, 84]", "def check(heap_sort):\n\tassert heap_sort([29, 36, 20, 90, 14, 69, 71, 30, 57]) == [14, 20, 29, 30, 36, 57, 69, 71, 90]", "def check(heap_sort):\n\tassert heap_sort([28, 36, 26, 90, 16, 61, 76, 23, 53]) == [16, 23, 26, 28, 36, 53, 61, 76, 90]", "def check(heap_sort):\n\tassert heap_sort([26, 32, 27, 88, 11, 67, 74, 29, 61]) == [11, 26, 27, 29, 32, 61, 67, 74, 88]", "def check(heap_sort):\n\tassert heap_sort([21, 39, 26, 88, 19, 60, 70, 25, 55]) == [19, 21, 25, 26, 39, 55, 60, 70, 88]", "def check(heap_sort):\n\tassert heap_sort([25, 36, 18, 83, 19, 62, 78, 25, 63]) == [18, 19, 25, 25, 36, 62, 63, 78, 83]", "def check(heap_sort):\n\tassert heap_sort([30, 33, 23, 90, 17, 64, 70, 24, 59]) == [17, 23, 24, 30, 33, 59, 64, 70, 90]", "def check(heap_sort):\n\tassert heap_sort([20, 35, 22, 90, 9, 62, 78, 28, 60]) == [9, 20, 22, 28, 35, 60, 62, 78, 90]", "def check(heap_sort):\n\tassert heap_sort([25, 36, 25, 81, 10, 69, 80, 27, 55]) == [10, 25, 25, 27, 36, 55, 69, 80, 81]", "def check(heap_sort):\n\tassert heap_sort([27, 31, 17, 88, 10, 66, 76, 26, 57]) == [10, 17, 26, 27, 31, 57, 66, 76, 88]", "def check(heap_sort):\n\tassert heap_sort([21, 36, 19, 85, 11, 69, 78, 22, 61]) == [11, 19, 21, 22, 36, 61, 69, 78, 85]", "def check(heap_sort):\n\tassert heap_sort([22, 31, 22, 82, 16, 62, 77, 24, 62]) == [16, 22, 22, 24, 31, 62, 62, 77, 82]", "def check(heap_sort):\n\tassert heap_sort([20, 30, 26, 88, 18, 68, 77, 28, 57]) == [18, 20, 26, 28, 30, 57, 68, 77, 88]", "def check(heap_sort):\n\tassert heap_sort([28, 40, 17, 89, 19, 65, 79, 24, 56]) == [17, 19, 24, 28, 40, 56, 65, 79, 89]", "def check(heap_sort):\n\tassert heap_sort([24, 40, 18, 87, 10, 66, 75, 22, 60]) == [10, 18, 22, 24, 40, 60, 66, 75, 87]", "def check(heap_sort):\n\tassert heap_sort([21, 32, 21, 80, 15, 60, 70, 29, 61]) == [15, 21, 21, 29, 32, 60, 61, 70, 80]", "def check(heap_sort):\n\tassert heap_sort([28, 35, 25, 88, 12, 68, 76, 21, 55]) == [12, 21, 25, 28, 35, 55, 68, 76, 88]", "def check(heap_sort):\n\tassert heap_sort([29, 31, 17, 90, 16, 67, 72, 21, 57]) == [16, 17, 21, 29, 31, 57, 67, 72, 90]", "def check(heap_sort):\n\tassert heap_sort([28, 36, 23, 85, 16, 66, 76, 21, 53]) == [16, 21, 23, 28, 36, 53, 66, 76, 85]", "def check(heap_sort):\n\tassert heap_sort([26, 36, 18, 90, 17, 64, 72, 22, 58]) == [17, 18, 22, 26, 36, 58, 64, 72, 90]", "def check(heap_sort):\n\tassert heap_sort([24, 40, 21, 86, 18, 62, 74, 28, 60]) == [18, 21, 24, 28, 40, 60, 62, 74, 86]", "def check(heap_sort):\n\tassert heap_sort([29, 30, 27, 82, 17, 61, 72, 26, 62]) == [17, 26, 27, 29, 30, 61, 62, 72, 82]", "def check(heap_sort):\n\tassert heap_sort([30, 32, 27, 84, 18, 64, 79, 21, 56]) == [18, 21, 27, 30, 32, 56, 64, 79, 84]", "def check(heap_sort):\n\tassert heap_sort([28, 34, 26, 89, 16, 60, 76, 26, 59]) == [16, 26, 26, 28, 34, 59, 60, 76, 89]", "def check(heap_sort):\n\tassert heap_sort([20, 40, 25, 90, 17, 60, 75, 22, 60]) == [17, 20, 22, 25, 40, 60, 60, 75, 90]", "def check(heap_sort):\n\tassert heap_sort([21, 33, 23, 89, 9, 60, 79, 26, 62]) == [9, 21, 23, 26, 33, 60, 62, 79, 89]", "def check(heap_sort):\n\tassert heap_sort([24, 30, 19, 82, 11, 67, 77, 26, 56]) == [11, 19, 24, 26, 30, 56, 67, 77, 82]", "def check(heap_sort):\n\tassert heap_sort([30, 31, 23, 89, 18, 67, 71, 28, 61]) == [18, 23, 28, 30, 31, 61, 67, 71, 89]", "def check(heap_sort):\n\tassert heap_sort([7, 6, 14, 5]) == [5, 6, 7, 14]", "def check(heap_sort):\n\tassert heap_sort([10, 2, 14, 1]) == [1, 2, 10, 14]", "def check(heap_sort):\n\tassert heap_sort([7, 1, 4, 9]) == [1, 4, 7, 9]", "def check(heap_sort):\n\tassert heap_sort([8, 4, 10, 4]) == [4, 4, 8, 10]", "def check(heap_sort):\n\tassert heap_sort([4, 6, 9, 5]) == [4, 5, 6, 9]", "def check(heap_sort):\n\tassert heap_sort([6, 6, 8, 4]) == [4, 6, 6, 8]", "def check(heap_sort):\n\tassert heap_sort([2, 3, 14, 2]) == [2, 2, 3, 14]", "def check(heap_sort):\n\tassert heap_sort([5, 2, 12, 4]) == [2, 4, 5, 12]", "def check(heap_sort):\n\tassert heap_sort([11, 3, 8, 2]) == [2, 3, 8, 11]", "def check(heap_sort):\n\tassert heap_sort([11, 5, 4, 8]) == [4, 5, 8, 11]", "def check(heap_sort):\n\tassert heap_sort([3, 5, 8, 2]) == [2, 3, 5, 8]", "def check(heap_sort):\n\tassert heap_sort([8, 4, 9, 2]) == [2, 4, 8, 9]", "def check(heap_sort):\n\tassert heap_sort([4, 4, 4, 6]) == [4, 4, 4, 6]", "def check(heap_sort):\n\tassert heap_sort([12, 6, 9, 8]) == [6, 8, 9, 12]", "def check(heap_sort):\n\tassert heap_sort([4, 2, 12, 3]) == [2, 3, 4, 12]", "def check(heap_sort):\n\tassert heap_sort([9, 2, 4, 3]) == [2, 3, 4, 9]", "def check(heap_sort):\n\tassert heap_sort([8, 5, 4, 4]) == [4, 4, 5, 8]", "def check(heap_sort):\n\tassert heap_sort([9, 1, 11, 4]) == [1, 4, 9, 11]", "def check(heap_sort):\n\tassert heap_sort([7, 2, 7, 2]) == [2, 2, 7, 7]", "def check(heap_sort):\n\tassert heap_sort([6, 3, 13, 7]) == [3, 6, 7, 13]", "def check(heap_sort):\n\tassert heap_sort([10, 4, 12, 8]) == [4, 8, 10, 12]", "def check(heap_sort):\n\tassert heap_sort([2, 3, 4, 5]) == [2, 3, 4, 5]", "def check(heap_sort):\n\tassert heap_sort([4, 5, 7, 10]) == [4, 5, 7, 10]", "def check(heap_sort):\n\tassert heap_sort([11, 2, 7, 9]) == [2, 7, 9, 11]", "def check(heap_sort):\n\tassert heap_sort([11, 6, 7, 5]) == [5, 6, 7, 11]", "def check(heap_sort):\n\tassert heap_sort([7, 4, 11, 2]) == [2, 4, 7, 11]", "def check(heap_sort):\n\tassert heap_sort([6, 4, 9, 5]) == [4, 5, 6, 9]", "def check(heap_sort):\n\tassert heap_sort([12, 3, 11, 4]) == [3, 4, 11, 12]", "def check(heap_sort):\n\tassert heap_sort([7, 2, 6, 10]) == [2, 6, 7, 10]", "def check(heap_sort):\n\tassert heap_sort([10, 5, 9, 2]) == [2, 5, 9, 10]", "def check(heap_sort):\n\tassert heap_sort([12, 5, 6, 5]) == [5, 5, 6, 12]", "def check(heap_sort):\n\tassert heap_sort([11, 1, 5, 5]) == [1, 5, 5, 11]", "def check(heap_sort):\n\tassert heap_sort([10, 2, 6, 7]) == [2, 6, 7, 10]"], "scores": [0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [false, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [0, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\nimport heapq\nfrom typing import List, Union\n\ndef heap_sort(data: List[Union[int, str]]) -> List[Union[int, str]]:\n    \"\"\"\n    Sorts a list of numbers or strings using heap sort.\n\n    Parameters:\n    data (list): A list of numbers or strings to be sorted.\n\n    Returns:\n    list: A sorted list of the same type as the input.\n\n    Raises:\n    TypeError: If the list contains unsupported or mixed data types.\n    \"\"\"\n    if not data:\n        return data\n\n    # Check if all elements are of the same type\n    first_type = type(data[0])\n    if not all(isinstance(item, first_type) for item in data):\n        raise TypeError(\"List contains mixed or unsupported data types.\")\n\n    # Use heapq to perform heap sort\n    heapq.heapify(data)\n    sorted_data = [heapq.heappop(data) for _ in range(len(data))]\n\n    return sorted_data\n", "passed": true, "pass": true, "pass_num": 9, "round": 721, "mutate_method": "expand_one2two", "parent_index": 487}
