{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 389, "prompt": "Develop a function to determine the n'th Lucas number. You should ensure that the function handles edge cases effectively, such as when n is 0 or negative.", "code": "def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ", "test_imports": [], "test_list": ["assert find_lucas(9) == 76", "assert find_lucas(4) == 7", "assert find_lucas(3) == 4", "assert find_lucas(11) == 199", "assert find_lucas(10) == 123", "assert find_lucas(6) == 18", "assert find_lucas(7) == 29", "assert find_lucas(7) == 29", "assert find_lucas(10) == 123", "assert find_lucas(4) == 7", "assert find_lucas(7) == 29", "assert find_lucas(13) == 521", "assert find_lucas(12) == 322", "assert find_lucas(11) == 199", "assert find_lucas(12) == 322", "assert find_lucas(8) == 47", "assert find_lucas(9) == 76", "assert find_lucas(6) == 18", "assert find_lucas(10) == 123", "assert find_lucas(7) == 29", "assert find_lucas(7) == 29", "assert find_lucas(8) == 47", "assert find_lucas(4) == 7", "assert find_lucas(8) == 47", "assert find_lucas(7) == 29", "assert find_lucas(5) == 11", "assert find_lucas(5) == 11", "assert find_lucas(13) == 521", "assert find_lucas(14) == 843", "assert find_lucas(4) == 7", "assert find_lucas(5) == 11", "assert find_lucas(9) == 76", "assert find_lucas(5) == 11", "assert find_lucas(6) == 18", "assert find_lucas(14) == 843", "assert find_lucas(8) == 47", "assert find_lucas(1) == 1", "assert find_lucas(9) == 76", "assert find_lucas(4) == 7", "assert find_lucas(8) == 47", "assert find_lucas(1) == 1", "assert find_lucas(4) == 7", "assert find_lucas(7) == 29", "assert find_lucas(7) == 29", "assert find_lucas(1) == 1", "assert find_lucas(4) == 7", "assert find_lucas(1) == 1", "assert find_lucas(8) == 47", "assert find_lucas(4) == 7", "assert find_lucas(1) == 1", "assert find_lucas(4) == 7", "assert find_lucas(6) == 18", "assert find_lucas(2) == 3", "assert find_lucas(2) == 3", "assert find_lucas(4) == 7", "assert find_lucas(2) == 3", "assert find_lucas(3) == 4", "assert find_lucas(8) == 47", "assert find_lucas(2) == 3", "assert find_lucas(5) == 11", "assert find_lucas(9) == 76", "assert find_lucas(3) == 4", "assert find_lucas(2) == 3", "assert find_lucas(8) == 47", "assert find_lucas(5) == 11", "assert find_lucas(7) == 29", "assert find_lucas(5) == 11", "assert find_lucas(8) == 47", "assert find_lucas(5) == 11", "assert find_lucas(2) == 3", "assert find_lucas(7) == 29", "assert find_lucas(7) == 29", "assert find_lucas(4) == 7", "assert find_lucas(8) == 47", "assert find_lucas(3) == 4", "assert find_lucas(1) == 1", "assert find_lucas(6) == 18", "assert find_lucas(5) == 11", "assert find_lucas(3) == 4", "assert find_lucas(3) == 4", "assert find_lucas(7) == 29", "assert find_lucas(7) == 29", "assert find_lucas(2) == 3", "assert find_lucas(3) == 4", "assert find_lucas(3) == 4", "assert find_lucas(8) == 47", "assert find_lucas(5) == 11", "assert find_lucas(3) == 4", "assert find_lucas(1) == 1", "assert find_lucas(4) == 7", "assert find_lucas(8) == 47", "assert find_lucas(5) == 11", "assert find_lucas(5) == 11", "assert find_lucas(7) == 29", "assert find_lucas(6) == 18", "assert find_lucas(8) == 47", "assert find_lucas(7) == 29", "assert find_lucas(7) == 29", "assert find_lucas(8) == 47", "assert find_lucas(8) == 47", "assert find_lucas(8) == 47", "assert find_lucas(4) == 7"], "entry_point": "find_lucas", "repair_prompt": ["Develop a function find_lucas to determine the n'th Lucas number. You should ensure that the function handles edge cases effectively, such as when n is 0 or negative.\nfind_lucas(9) == 76\n"], "completions": ["from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    '''\n    Calculate the nth Lucas number.\n\n    Parameters:\n    n (int): The position in the Lucas sequence.\n\n    Returns:\n    int: The nth Lucas number or raises ValueError for negative n.\n    '''\n    if n < 0:\n        raise ValueError(\"Invalid input: n must be a non-negative integer.\")\n    \n    # Base cases for Lucas numbers\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Iterative calculation for n > 1\n    previous, current = 2, 1\n    for _ in range(2, n + 1):\n        previous, current = current, previous + current\n    \n    return current\n", "from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Lucas number.\n\n    Parameters:\n    n (int): The index of the Lucas number to calculate.\n\n    Returns:\n    int: The n-th Lucas number.\n\n    Raises:\n    ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The index n must be a non-negative integer.\")\n\n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n\n    # Iterative calculation for Lucas numbers\n    previous, current = 2, 1\n    for _ in range(2, n + 1):\n        previous, current = current, previous + current\n\n    return current\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Lucas number using recursion and memoization.\n\n    Parameters:\n    n (int): The index of the Lucas number to calculate.\n\n    Returns:\n    int: The n-th Lucas number.\n\n    Raises:\n    ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The index n must be a non-negative integer.\")\n\n    @lru_cache(maxsize=None)\n    def lucas_recursive(index: int) -> int:\n        if index == 0:\n            return 2\n        elif index == 1:\n            return 1\n        else:\n            return lucas_recursive(index - 1) + lucas_recursive(index - 2)\n\n    return lucas_recursive(n)\n\n# Example usage:\n# print(find_lucas(10))  # Output: 123\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the nth Lucas number.\n\n    The Lucas numbers are a sequence similar to the Fibonacci numbers, \n    except they start with 2 and 1. The nth Lucas number is defined as:\n    L(n) = L(n-1) + L(n-2) with initial values L(0) = 2 and L(1) = 1.\n\n    Parameters:\n    n (int): The position in the Lucas sequence.\n\n    Returns:\n    int: The nth Lucas number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The position in the Lucas sequence cannot be negative.\")\n    \n    @lru_cache(maxsize=None)\n    def lucas_recursive(k: int) -> int:\n        if k == 0:\n            return 2\n        elif k == 1:\n            return 1\n        else:\n            return lucas_recursive(k - 1) + lucas_recursive(k - 2)\n\n    return lucas_recursive(n)\n", "from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    '''\n    Calculate the n-th Lucas number.\n\n    Parameters:\n    n (int): The index of the Lucas number to calculate.\n\n    Returns:\n    int: The n-th Lucas number if n is non-negative.\n    Raises:\n    ValueError: If n is negative.\n    '''\n    if n < 0:\n        raise ValueError(\"Invalid input: n must be non-negative.\")\n    \n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Iterative calculation for Lucas numbers\n    previous, current = 2, 1\n    for _ in range(2, n + 1):\n        next_lucas = previous + current\n        previous, current = current, next_lucas\n    \n    return current\n", "from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Lucas number.\n\n    Parameters:\n    n (int): The index of the Lucas number to calculate.\n\n    Returns:\n    int: The n-th Lucas number or raises ValueError for negative n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Negative index is not allowed for Lucas numbers.\")\n    \n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Iterative calculation for Lucas numbers\n    previous, current = 2, 1\n    for _ in range(2, n + 1):\n        previous, current = current, previous + current\n    \n    return current\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the nth Lucas number.\n\n    Parameters:\n    n (int): The position in the Lucas sequence.\n\n    Returns:\n    int: The nth Lucas number.\n\n    Raises:\n    ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The position in the Lucas sequence cannot be negative.\")\n\n    @lru_cache(maxsize=None)\n    def lucas_recursive(m: int) -> int:\n        if m == 0:\n            return 2\n        elif m == 1:\n            return 1\n        else:\n            return lucas_recursive(m - 1) + lucas_recursive(m - 2)\n\n    return lucas_recursive(n)\n", "from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the nth Lucas number.\n    \n    The Lucas numbers are similar to the Fibonacci numbers, but start with 2 and 1.\n    The sequence is defined as:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    :param n: The position in the Lucas sequence (0-based index).\n    :return: The nth Lucas number or None for invalid input.\n    \"\"\"\n    if n < 0:\n        return None  # Return None for negative input as per the design requirement.\n    \n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Iterative calculation for Lucas numbers\n    previous, current = 2, 1\n    for _ in range(2, n + 1):\n        previous, current = current, previous + current\n    \n    return current\n", "from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the nth Lucas number.\n\n    Parameters:\n    n (int): The position in the Lucas sequence.\n\n    Returns:\n    int: The nth Lucas number.\n    \"\"\"\n    # Handle edge cases\n    if n < 0:\n        raise ValueError(\"The position in the Lucas sequence cannot be negative.\")\n    elif n == 0:\n        return 2\n    elif n == 1:\n        return 1\n\n    # Use memoization to store previously calculated Lucas numbers\n    memo = {0: 2, 1: 1}\n\n    def calculate_lucas(num: int) -> int:\n        \"\"\"Helper function to calculate Lucas number using memoization.\"\"\"\n        if num in memo:\n            return memo[num]\n        # Calculate the Lucas number recursively and store it in the memo dictionary\n        memo[num] = calculate_lucas(num - 1) + calculate_lucas(num - 2)\n        return memo[num]\n\n    return calculate_lucas(n)\n\n# Example usage:\n# print(find_lucas(10))  # Output: 123\n", "from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Lucas number.\n\n    Parameters:\n    n (int): The index of the Lucas number to calculate.\n\n    Returns:\n    int: The n-th Lucas number.\n\n    Raises:\n    ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The index n must be a non-negative integer.\")\n\n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n\n    # Iterative calculation for n >= 2\n    previous, current = 2, 1\n    for _ in range(2, n + 1):\n        previous, current = current, previous + current\n\n    return current\n"], "plans": ["requirement analysis:\nThe function must accurately compute the Lucas number for any integer n, including handling n=0 and negative values. It should be optimized for performance to handle large n efficiently.\nrequirement pool:\n- Implement the main function to calculate Lucas numbers.\n- Ensure the function handles edge cases like n=0 and negative values.\n- Optimize the function for performance with large n.\n- Include documentation and examples for user understanding.\n- Test the function with a variety of inputs to ensure reliability.\nWe will implement a function named find_lucas that calculates the nth Lucas number using an iterative approach for efficiency. The function will handle edge cases such as n=0 by returning the first Lucas number, and for negative n, it will return a specific error message indicating invalid input. This approach ensures both performance and robustness.\n", "requirement analysis:\nThe function should accurately compute the Lucas number for any integer n, including handling edge cases such as n=0 and negative values. Performance optimization is crucial for handling large values of n efficiently.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Graceful handling of edge cases\n- Performance optimization for large inputs\n- User-friendly error messages for invalid inputs\n- Documentation for function usage\nWe will implement a function named find_lucas that calculates the n-th Lucas number using an iterative approach to ensure performance optimization for large inputs. The function will handle edge cases such as n=0 and negative values by returning specific results or error messages. We will use Python's built-in capabilities without additional libraries to keep the implementation simple and efficient.\n", "requirement analysis:\nThe function must accurately compute the Lucas number for any integer n, including handling cases where n is 0 or negative. Performance optimization is crucial for large values of n.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Graceful handling of edge cases\n- Performance optimization for large inputs\n- User-friendly error messages\n- Documentation for educational purposes\nWe will implement a function to calculate the Lucas number using a recursive approach with memoization to optimize performance for large inputs. The function will handle edge cases such as when n is 0 or negative by returning specific values or error messages. We will use the functools library for memoization.\n", "requirement analysis:\nThe function must accurately compute the Lucas number for any integer n, including handling edge cases such as n=0 or negative values. Performance optimization is crucial for large n values.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Handling of edge cases like n=0 or negative values\n- Performance optimization for large n values\n- User-friendly error messages for invalid inputs\n- Documentation for function usage\nWe will implement the Lucas number calculation using a recursive approach with memoization to optimize performance for large n values. The function will handle edge cases by returning specific values for n=0 and n<0. We will use the functools library for memoization to improve efficiency.\n", "requirement analysis:\nThe function must accurately compute the Lucas number for any integer n, including handling edge cases such as n=0 or negative values. Performance optimization is crucial for large inputs.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Handling of edge cases like n=0 or negative\n- Performance optimization for large n\n- User-friendly error messages for invalid inputs\n- Documentation for function usage\nWe will implement a function named find_lucas that calculates the n-th Lucas number using an iterative approach for efficiency. The function will handle edge cases such as n=0 by returning the first Lucas number, and for negative n, it will return an error message indicating invalid input. This approach ensures both accuracy and performance optimization for large inputs.\n", "requirement analysis:\nThe function should accurately compute the Lucas number for any integer n, including handling edge cases like n=0 or negative values. It should be optimized for performance, especially for large values of n.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Handling of edge cases such as n=0 or negative\n- Performance optimization for large n\n- User-friendly error messages for invalid inputs\n- Documentation for function usage\nWe will implement a function named find_lucas that calculates the n-th Lucas number using an iterative approach for efficiency. This approach will handle edge cases such as n=0 by returning the first Lucas number, and for negative n, it will return an error message. The function will be optimized for performance to handle large values of n efficiently.\n", "requirement analysis:\nThe function should accurately compute the Lucas number for any integer n, including handling edge cases such as n=0 or negative values. Performance optimization is crucial for handling large inputs efficiently.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Handling of edge cases like n=0 or negative values\n- Performance optimization for large inputs\n- User-friendly error messages for invalid inputs\n- Documentation for function usage\nWe will implement a function to calculate the Lucas number using a recursive approach with memoization to optimize performance for large inputs. The function will handle edge cases such as n=0 or negative values by returning appropriate results or error messages. We will use the functools library for memoization.\n", "requirement analysis:\nThe function must accurately compute the Lucas number for any integer n, including handling special cases where n is 0 or negative. Performance optimization is crucial for handling large n values.\nrequirement pool:\n- Implement the main function to calculate Lucas numbers.\n- Ensure the function handles n=0 and negative n values correctly.\n- Optimize the function for performance with large n values.\n- Include documentation and examples for user guidance.\n- Test the function with a variety of inputs to ensure reliability.\nWe will implement a function to calculate the Lucas number using an iterative approach for optimal performance. This approach will handle edge cases such as n=0 by returning the first Lucas number, and for negative n, we will return None or a specific message indicating invalid input. We will use Python's built-in capabilities without additional libraries to keep the solution simple and efficient.\n", "requirement analysis:\nThe function must accurately compute the Lucas number for any integer n, including handling edge cases such as n=0 or negative values. Performance optimization is crucial for handling large inputs efficiently.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Handling of edge cases like n=0 or negative values\n- Performance optimization for large inputs\n- User-friendly error messages for invalid inputs\n- Documentation for function usage\nWe will implement the find_lucas function using a simple iterative approach to calculate the Lucas numbers efficiently. This approach will handle edge cases such as n=0 or negative values by returning predefined values or error messages. For performance optimization, we will use memoization to store previously calculated Lucas numbers, which will speed up the calculation for large inputs.\n", "requirement analysis:\nThe function must accurately compute the Lucas number for any integer n, including handling edge cases such as n=0 or negative values. Performance optimization is crucial for handling large inputs efficiently.\nrequirement pool:\n- Accurate calculation of Lucas numbers\n- Handling of edge cases (n=0, negative values)\n- Performance optimization for large n\n- User-friendly error messages for invalid inputs\n- Documentation for function usage\nWe will implement a function named find_lucas that calculates the n-th Lucas number using an iterative approach to ensure performance optimization for large inputs. The function will handle edge cases such as n=0 or negative values by returning specific results or error messages. We will use Python's built-in capabilities without additional libraries to keep the implementation simple and efficient.\n"], "test": ["def check(find_lucas):\n\tassert find_lucas(9) == 76", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(11) == 199", "def check(find_lucas):\n\tassert find_lucas(10) == 123", "def check(find_lucas):\n\tassert find_lucas(6) == 18", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(10) == 123", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(13) == 521", "def check(find_lucas):\n\tassert find_lucas(12) == 322", "def check(find_lucas):\n\tassert find_lucas(11) == 199", "def check(find_lucas):\n\tassert find_lucas(12) == 322", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(9) == 76", "def check(find_lucas):\n\tassert find_lucas(6) == 18", "def check(find_lucas):\n\tassert find_lucas(10) == 123", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(13) == 521", "def check(find_lucas):\n\tassert find_lucas(14) == 843", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(9) == 76", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(6) == 18", "def check(find_lucas):\n\tassert find_lucas(14) == 843", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(1) == 1", "def check(find_lucas):\n\tassert find_lucas(9) == 76", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(1) == 1", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(1) == 1", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(1) == 1", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(1) == 1", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(6) == 18", "def check(find_lucas):\n\tassert find_lucas(2) == 3", "def check(find_lucas):\n\tassert find_lucas(2) == 3", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(2) == 3", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(2) == 3", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(9) == 76", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(2) == 3", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(2) == 3", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(1) == 1", "def check(find_lucas):\n\tassert find_lucas(6) == 18", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(2) == 3", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(3) == 4", "def check(find_lucas):\n\tassert find_lucas(1) == 1", "def check(find_lucas):\n\tassert find_lucas(4) == 7", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(5) == 11", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(6) == 18", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(7) == 29", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(8) == 47", "def check(find_lucas):\n\tassert find_lucas(4) == 7"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\n\ndef find_lucas(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Lucas number.\n\n    Parameters:\n    n (int): The index of the Lucas number to calculate.\n\n    Returns:\n    int: The n-th Lucas number.\n\n    Raises:\n    ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The index n must be a non-negative integer.\")\n\n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n\n    # Iterative calculation for n >= 2\n    previous, current = 2, 1\n    for _ in range(2, n + 1):\n        previous, current = current, previous + current\n\n    return current\n", "passed": true, "pass": true, "pass_num": 10, "round": 934, "mutate_method": "rephrase_one", "parent_index": 348}
