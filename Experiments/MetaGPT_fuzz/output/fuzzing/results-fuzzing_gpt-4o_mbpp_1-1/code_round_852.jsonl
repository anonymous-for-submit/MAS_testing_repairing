{"source_file": "Benchmark Questions Verification V2.ipynb", "task_id": 573, "prompt": "Write a python function to calculate the product of the unique numbers in a given list. Make sure to handle edge cases where the list might be empty or contain non-numeric values.", "code": "def unique_product(list_data):\n    temp = list(set(list_data))\n    p = 1\n    for i in temp:\n        p *= i\n    return p", "test_imports": [], "test_list": ["assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000", "assert unique_product([1, 2, 3, 1,]) == 6", "assert unique_product([7, 8, 9, 0, 1, 1]) == 0", "assert unique_product([8, 17, 29, 43, 17, 49, 55, 45]) == 20567269800", "assert unique_product([5, 25, 28, 35, 23, 48, 55, 37]) == 275213400000", "assert unique_product([8, 21, 31, 36, 18, 45, 57, 35]) == 302971233600", "assert unique_product([11, 22, 30, 41, 17, 55, 60, 40]) == 667949040000", "assert unique_product([9, 15, 31, 44, 23, 55, 56, 45]) == 587001492000", "assert unique_product([9, 16, 26, 44, 24, 55, 64, 42]) == 584509685760", "assert unique_product([11, 17, 31, 41, 22, 54, 64, 36]) == 650558075904", "assert unique_product([8, 18, 34, 44, 20, 50, 59, 42]) == 533820672000", "assert unique_product([14, 19, 35, 44, 17, 45, 63, 42]) == 829189191600", "assert unique_product([12, 16, 27, 43, 22, 54, 61, 35]) == 565389538560", "assert unique_product([6, 22, 25, 39, 21, 51, 64, 39]) == 8821612800", "assert unique_product([9, 17, 29, 38, 22, 50, 59, 44]) == 481471293600", "assert unique_product([8, 16, 26, 40, 22, 55, 62, 41]) == 409453158400", "assert unique_product([11, 25, 30, 44, 15, 48, 58, 39]) == 591196320000", "assert unique_product([14, 21, 26, 36, 24, 52, 58, 40]) == 796756746240", "assert unique_product([10, 22, 25, 37, 21, 49, 64, 42]) == 562871232000", "assert unique_product([12, 19, 33, 41, 23, 50, 64, 37]) == 840063628800", "assert unique_product([8, 15, 28, 38, 25, 51, 55, 40]) == 358142400000", "assert unique_product([13, 19, 34, 40, 18, 54, 55, 43]) == 772206177600", "assert unique_product([9, 23, 31, 42, 18, 51, 62, 45]) == 690284647080", "assert unique_product([10, 23, 26, 42, 19, 46, 63, 35]) == 484028017200", "assert unique_product([13, 15, 29, 39, 24, 55, 59, 42]) == 721393873200", "assert unique_product([13, 24, 34, 43, 20, 48, 57, 43]) == 24960199680", "assert unique_product([6, 18, 34, 35, 25, 49, 57, 43]) == 385878087000", "assert unique_product([14, 20, 30, 44, 16, 48, 59, 44]) == 16747315200", "assert unique_product([14, 18, 25, 43, 15, 52, 55, 38]) == 441621180000", "assert unique_product([14, 25, 32, 45, 19, 46, 62, 41]) == 1119740832000", "assert unique_product([9, 16, 31, 37, 18, 52, 59, 41]) == 373970742912", "assert unique_product([8, 24, 34, 45, 19, 50, 64, 44]) == 785866752000", "assert unique_product([14, 24, 33, 44, 19, 55, 63, 41]) == 1316881177920", "assert unique_product([5, 21, 27, 36, 22, 55, 62, 37]) == 283292024400", "assert unique_product([12, 23, 34, 38, 21, 50, 59, 35]) == 773180604000", "assert unique_product([11, 25, 35, 41, 18, 50, 61, 39]) == 844931587500", "assert unique_product([6, 2, 1, 1]) == 12", "assert unique_product([3, 6, 1, 5]) == 90", "assert unique_product([2, 4, 1, 3]) == 24", "assert unique_product([6, 5, 2, 3]) == 180", "assert unique_product([5, 4, 1, 1]) == 20", "assert unique_product([2, 1, 3, 3]) == 6", "assert unique_product([5, 6, 7, 1]) == 210", "assert unique_product([3, 3, 3, 6]) == 18", "assert unique_product([4, 3, 4, 6]) == 72", "assert unique_product([6, 4, 6, 5]) == 120", "assert unique_product([3, 1, 6, 1]) == 18", "assert unique_product([6, 7, 5, 2]) == 420", "assert unique_product([2, 3, 7, 1]) == 42", "assert unique_product([5, 1, 1, 6]) == 30", "assert unique_product([3, 4, 3, 1]) == 12", "assert unique_product([4, 4, 1, 5]) == 20", "assert unique_product([2, 1, 2, 6]) == 12", "assert unique_product([1, 4, 2, 4]) == 8", "assert unique_product([3, 4, 8, 6]) == 576", "assert unique_product([3, 7, 3, 2]) == 42", "assert unique_product([4, 6, 5, 4]) == 120", "assert unique_product([4, 5, 7, 2]) == 280", "assert unique_product([1, 1, 5, 5]) == 5", "assert unique_product([3, 3, 3, 6]) == 18", "assert unique_product([6, 6, 3, 1]) == 18", "assert unique_product([4, 2, 5, 1]) == 40", "assert unique_product([2, 2, 3, 1]) == 6", "assert unique_product([6, 5, 4, 5]) == 120", "assert unique_product([5, 3, 2, 2]) == 30", "assert unique_product([4, 5, 4, 5]) == 20", "assert unique_product([4, 7, 1, 2]) == 56", "assert unique_product([3, 3, 3, 3]) == 3", "assert unique_product([1, 7, 3, 4]) == 84", "assert unique_product([5, 13, 11, 4, 2, 6]) == 34320", "assert unique_product([2, 7, 9, 1, 2, 4]) == 504", "assert unique_product([3, 13, 7, 1, 3, 2]) == 546", "assert unique_product([11, 8, 10, 3, 1, 4]) == 10560", "assert unique_product([4, 5, 9, 3, 4, 5]) == 540", "assert unique_product([9, 12, 5, 5, 4, 5]) == 2160", "assert unique_product([12, 4, 10, 1, 4, 2]) == 960", "assert unique_product([6, 9, 13, 1, 3, 4]) == 8424", "assert unique_product([2, 3, 6, 5, 1, 3]) == 180", "assert unique_product([4, 6, 14, 2, 2, 1]) == 672", "assert unique_product([6, 9, 12, 4, 3, 6]) == 7776", "assert unique_product([10, 6, 4, 5, 5, 2]) == 2400", "assert unique_product([4, 9, 4, 2, 4, 4]) == 72", "assert unique_product([6, 10, 8, 1, 5, 4]) == 9600", "assert unique_product([2, 4, 10, 2, 3, 1]) == 240", "assert unique_product([6, 9, 10, 2, 4, 6]) == 4320", "assert unique_product([10, 9, 12, 5, 4, 1]) == 21600", "assert unique_product([12, 6, 4, 1, 5, 1]) == 1440", "assert unique_product([8, 3, 4, 1, 5, 1]) == 480", "assert unique_product([3, 10, 8, 3, 1, 1]) == 240", "assert unique_product([7, 13, 14, 2, 2, 6]) == 15288", "assert unique_product([8, 7, 4, 4, 1, 5]) == 1120", "assert unique_product([2, 4, 10, 4, 6, 3]) == 1440", "assert unique_product([8, 6, 6, 2, 4, 2]) == 384", "assert unique_product([9, 9, 12, 5, 3, 1]) == 1620", "assert unique_product([9, 13, 5, 4, 2, 5]) == 4680", "assert unique_product([2, 7, 4, 4, 2, 4]) == 56", "assert unique_product([4, 10, 8, 3, 5, 5]) == 4800", "assert unique_product([5, 4, 11, 3, 4, 1]) == 660", "assert unique_product([12, 8, 4, 4, 6, 4]) == 2304", "assert unique_product([11, 10, 10, 2, 2, 3]) == 660", "assert unique_product([12, 9, 11, 1, 4, 2]) == 9504", "assert unique_product([5, 6, 4, 3, 5, 6]) == 360"], "entry_point": "unique_product", "repair_prompt": ["Write a python function unique_product to calculate the product of the unique numbers in a given list. Make sure to handle edge cases where the list might be empty or contain non-numeric values.\nunique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000\n"], "completions": ["from typing import List\n## main.py\n\nimport math\nfrom typing import List, Union\n\ndef unique_product(numbers: List[Union[int, float]]) -> int:\n    \"\"\"Calculate the product of unique numeric values in the list.\n\n    This function filters out non-numeric values and calculates the product\n    of unique numeric values. If the list is empty or contains no numeric\n    values, it returns 1.\n\n    Args:\n        numbers (List[Union[int, float]]): A list containing numeric and/or non-numeric values.\n\n    Returns:\n        int: The product of unique numeric values. Returns 1 if the list is empty or contains no numeric values.\n    \"\"\"\n    # Filter out non-numeric values and convert to a set to ensure uniqueness\n    unique_numbers = {num for num in numbers if isinstance(num, (int, float))}\n    \n    # Calculate the product of unique numbers\n    if unique_numbers:\n        return math.prod(unique_numbers)\n    else:\n        return 1\n", "from typing import List\n## main.py\n\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n    \n    Parameters:\n    numbers (list): A list containing numeric and non-numeric values.\n    \n    Returns:\n    int: The product of unique numeric values. Returns 1 if the list is empty or contains no numeric values.\n    \"\"\"\n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n    \n    # Extract unique numbers using set\n    unique_numbers = set(numeric_values)\n    \n    # Calculate product using math.prod\n    if unique_numbers:\n        product = math.prod(unique_numbers)\n    else:\n        product = 1\n    \n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List, Union\n\ndef unique_product(numbers: List[Union[int, float]]) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n\n    Parameters:\n    numbers (list): A list containing numeric and non-numeric values.\n\n    Returns:\n    int: The product of unique numeric values. Returns 1 for an empty list or if no numeric values are present.\n    \"\"\"\n    # Filter out non-numeric values and convert to a set to get unique values\n    unique_numbers = {num for num in numbers if isinstance(num, (int, float))}\n    \n    # If there are no unique numeric values, return 1\n    if not unique_numbers:\n        return 1\n    \n    # Calculate the product of unique numbers\n    product = math.prod(unique_numbers)\n    \n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List, Union\n\ndef unique_product(numbers: List[Union[int, float]]) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n\n    Args:\n        numbers (List[Union[int, float]]): A list containing numeric and non-numeric values.\n\n    Returns:\n        int: The product of unique numeric values. Returns 1 for empty list or if no numeric values are present.\n    \"\"\"\n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n\n    # Extract unique numbers using set\n    unique_numbers = set(numeric_values)\n\n    # Calculate product using math.prod\n    if unique_numbers:\n        product = math.prod(unique_numbers)\n    else:\n        product = 1\n\n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n\n    Parameters:\n    numbers (list): A list containing numeric and/or non-numeric values.\n\n    Returns:\n    int: The product of unique numeric values. Returns 1 for an empty list or if no numeric values are present.\n    \"\"\"\n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n    \n    # Extract unique numbers\n    unique_numbers = set(numeric_values)\n    \n    # Calculate the product of unique numbers\n    if not unique_numbers:\n        return 1\n    \n    product = math.prod(unique_numbers)\n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List, Union\n\ndef unique_product(numbers: List[Union[int, float]]) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n\n    Parameters:\n    numbers (list): A list containing numeric and non-numeric values.\n\n    Returns:\n    int: The product of unique numeric values. Returns 1 if the list is empty or contains no numeric values.\n    \"\"\"\n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n\n    # Convert list to set to ensure uniqueness\n    unique_numbers = set(numeric_values)\n\n    # Calculate the product of unique numbers\n    if not unique_numbers:\n        return 1\n\n    product = 1\n    for number in unique_numbers:\n        product *= number\n\n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List\n\ndef unique_product(numbers: List) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n\n    Parameters:\n    numbers (list): A list containing numeric and non-numeric values.\n\n    Returns:\n    int: The product of unique numeric values. Returns 1 if the list is empty or contains no numeric values.\n    \"\"\"\n    def is_numeric(value) -> bool:\n        \"\"\"Check if the value is a numeric type.\"\"\"\n        return isinstance(value, (int, float))\n\n    # Filter out non-numeric values\n    numeric_values = filter(is_numeric, numbers)\n    \n    # Convert to set to ensure uniqueness\n    unique_values = set(numeric_values)\n    \n    # Calculate the product of unique numeric values\n    if not unique_values:\n        return 1\n    \n    return math.prod(unique_values)\n", "from typing import List\n## main.py\n\nimport math\n\ndef unique_product(numbers: list) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n\n    Parameters:\n    numbers (list): A list containing numeric and non-numeric values.\n\n    Returns:\n    int: The product of unique numeric values. Returns 1 for an empty list or if no numeric values are present.\n    \"\"\"\n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n    \n    # Extract unique numbers using set\n    unique_numbers = set(numeric_values)\n    \n    # Calculate the product of unique numbers\n    if unique_numbers:\n        product = math.prod(unique_numbers)\n    else:\n        product = 1\n    \n    return product\n", "from typing import List\n## main.py\n\nimport math\nfrom typing import List, Union\n\ndef unique_product(numbers: List[Union[int, float]]) -> int:\n    \"\"\"\n    Calculate the product of unique numeric values in the list.\n\n    Args:\n        numbers (List[Union[int, float]]): A list containing numeric and non-numeric values.\n\n    Returns:\n        int: The product of unique numeric values. Returns 1 for empty list or if no numeric values are present.\n    \"\"\"\n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n\n    # Extract unique numbers using set\n    unique_numbers = set(numeric_values)\n\n    # Calculate product using math.prod\n    if unique_numbers:\n        product = math.prod(unique_numbers)\n    else:\n        product = 1\n\n    return product\n", "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> float:\n    '''\n    Calculate the product of unique numeric values in the list.\n    \n    Parameters:\n    numbers (list): A list containing numeric and non-numeric values.\n    \n    Returns:\n    float: The product of unique numeric values.\n    \n    Raises:\n    ValueError: If the input is not a list.\n    '''\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n    \n    # Extract unique values using set\n    unique_values = set(numeric_values)\n    \n    # Calculate product using math.prod\n    product = math.prod(unique_values)\n    \n    return product\n"], "plans": ["requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, handling edge cases such as empty lists and non-numeric values. It should provide clear error messages for invalid inputs and perform well with large datasets.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers.\n- Handle edge cases such as empty lists and non-numeric values.\n- Optimize the function for performance with large lists.\n- Provide informative error messages for invalid inputs.\n- Ensure compatibility with Python's built-in data types.\nWe will implement a function named `unique_product` that calculates the product of unique numbers in a list. The function will handle edge cases such as empty lists and non-numeric values by ignoring non-numeric values and returning 1 for an empty list. We will use Python's built-in set to filter unique numbers and the `math.prod` function for efficient product calculation. This approach ensures high performance and usability without the need for additional libraries.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, handling edge cases such as empty lists and non-numeric values. It should provide clear error messages for invalid inputs and maintain performance with large datasets.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers.\n- Handle edge cases such as empty lists and non-numeric values.\n- Optimize the function for performance with large datasets.\n- Provide informative error messages for invalid inputs.\n- Ensure the function is easy to use and integrate into other projects.\nWe will implement a function named `unique_product` that calculates the product of unique numbers in a list. The function will handle edge cases such as empty lists and non-numeric values by ignoring non-numeric values and returning 1 for an empty list. We will use Python's built-in set to filter unique numbers and the math library to compute the product efficiently.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers, handle empty lists, and ignore non-numeric values. It should be optimized for performance and usability.\nrequirement pool:\n- Implement unique product calculation\n- Handle empty list edge case\n- Ignore non-numeric values\n- Optimize for large lists\n- Provide user feedback for invalid inputs\nWe will implement a function named `unique_product` that calculates the product of unique numeric values in a list. The function will handle edge cases such as empty lists and non-numeric values by ignoring non-numeric entries. We will use Python's built-in set to filter unique values and the math library to compute the product efficiently.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list, handling edge cases such as empty lists and non-numeric values. It should prioritize performance and error handling.\nrequirement pool:\n- Accurate calculation of unique product\n- Handle empty list gracefully\n- Ignore non-numeric values\n- Optimize for large lists\n- Provide user-friendly error messages\nWe will use Python's built-in set to efficiently find unique elements and the math.prod function to calculate the product of these unique numbers. The function will handle edge cases by checking for empty lists and filtering out non-numeric values.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers, handle empty lists, and ignore non-numeric values. It should be optimized for performance and error handling.\nrequirement pool:\n- Implement unique_product function to calculate product of unique numbers\n- Ensure function handles empty lists without errors\n- Ignore non-numeric values in the list\n- Optimize performance for large lists\n- Provide clear error messages for invalid inputs\nWe will implement the unique_product function using Python's built-in set to filter out unique numbers and the math.prod function to calculate the product. This approach ensures efficient handling of unique elements and leverages Python's capabilities for performance. We will handle edge cases by checking for empty lists and filtering out non-numeric values using isinstance checks.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers in a list, ensuring it handles empty lists and non-numeric values without errors. The focus should be on optimizing performance while maintaining accuracy.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers\n- Ensure the function handles empty lists gracefully\n- Ignore non-numeric values in the list\n- Optimize performance for large lists\n- Provide detailed error messages for invalid inputs\nWe will implement a function named `unique_product` that calculates the product of unique numeric values in a list. The function will handle edge cases such as empty lists and non-numeric values by ignoring non-numeric entries and returning 1 for an empty list. We will use Python's built-in set to ensure uniqueness and the math library for efficient multiplication.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers, handle empty lists, and ignore non-numeric values. It should be optimized for performance and error handling.\nrequirement pool:\n- Accurate calculation of unique product\n- Graceful handling of edge cases\n- Optimization for large lists\n- Ignoring non-numeric values\n- User-friendly error messages\nWe will use Python's built-in set to filter out unique numbers and the math.prod function to calculate the product of these unique numbers. We will handle edge cases by checking if the list is empty and filtering out non-numeric values using a helper function.\n", "requirement analysis:\nThe function should efficiently compute the product of unique numbers, handle empty lists, and ignore non-numeric values. It should be optimized for performance and usability.\nrequirement pool:\n- Implement unique_product function\n- Handle empty list edge case\n- Ignore non-numeric values\n- Optimize for large lists\n- Ensure compatibility with Python 3.x\nWe will implement the unique_product function using Python's built-in set to filter out unique numbers and the math.prod function to calculate the product. This approach ensures efficiency and simplicity. We will handle edge cases by checking for empty lists and filtering out non-numeric values using isinstance checks.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list, handling edge cases such as empty lists and non-numeric values. It should be optimized for performance and error handling.\nrequirement pool:\n- Implement unique product calculation\n- Handle empty list edge case\n- Ignore non-numeric values\n- Optimize performance for large lists\n- Provide user-friendly error messages\nWe will use Python's built-in set to efficiently find unique elements and the math.prod function to calculate the product of these unique numbers. We will handle edge cases by checking for empty lists and filtering out non-numeric values before processing.\n", "requirement analysis:\nThe function should efficiently calculate the product of unique numbers in a list, handling edge cases such as empty lists and non-numeric values. It should provide clear error messages for invalid inputs and perform well with large datasets.\nrequirement pool:\n- Implement the main function to calculate the product of unique numbers\n- Handle edge cases like empty lists and non-numeric values\n- Optimize performance for large lists\n- Provide clear error messages for invalid inputs\n- Ensure compatibility with different Python versions\nWe will implement a function using Python's built-in set to filter out unique numeric values and then use the math.prod function to calculate the product of these values. We will handle edge cases by checking for empty lists and filtering out non-numeric values. For invalid inputs, we will raise clear error messages.\n"], "test": ["def check(unique_product):\n\tassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000", "def check(unique_product):\n\tassert unique_product([1, 2, 3, 1,]) == 6", "def check(unique_product):\n\tassert unique_product([7, 8, 9, 0, 1, 1]) == 0", "def check(unique_product):\n\tassert unique_product([8, 17, 29, 43, 17, 49, 55, 45]) == 20567269800", "def check(unique_product):\n\tassert unique_product([5, 25, 28, 35, 23, 48, 55, 37]) == 275213400000", "def check(unique_product):\n\tassert unique_product([8, 21, 31, 36, 18, 45, 57, 35]) == 302971233600", "def check(unique_product):\n\tassert unique_product([11, 22, 30, 41, 17, 55, 60, 40]) == 667949040000", "def check(unique_product):\n\tassert unique_product([9, 15, 31, 44, 23, 55, 56, 45]) == 587001492000", "def check(unique_product):\n\tassert unique_product([9, 16, 26, 44, 24, 55, 64, 42]) == 584509685760", "def check(unique_product):\n\tassert unique_product([11, 17, 31, 41, 22, 54, 64, 36]) == 650558075904", "def check(unique_product):\n\tassert unique_product([8, 18, 34, 44, 20, 50, 59, 42]) == 533820672000", "def check(unique_product):\n\tassert unique_product([14, 19, 35, 44, 17, 45, 63, 42]) == 829189191600", "def check(unique_product):\n\tassert unique_product([12, 16, 27, 43, 22, 54, 61, 35]) == 565389538560", "def check(unique_product):\n\tassert unique_product([6, 22, 25, 39, 21, 51, 64, 39]) == 8821612800", "def check(unique_product):\n\tassert unique_product([9, 17, 29, 38, 22, 50, 59, 44]) == 481471293600", "def check(unique_product):\n\tassert unique_product([8, 16, 26, 40, 22, 55, 62, 41]) == 409453158400", "def check(unique_product):\n\tassert unique_product([11, 25, 30, 44, 15, 48, 58, 39]) == 591196320000", "def check(unique_product):\n\tassert unique_product([14, 21, 26, 36, 24, 52, 58, 40]) == 796756746240", "def check(unique_product):\n\tassert unique_product([10, 22, 25, 37, 21, 49, 64, 42]) == 562871232000", "def check(unique_product):\n\tassert unique_product([12, 19, 33, 41, 23, 50, 64, 37]) == 840063628800", "def check(unique_product):\n\tassert unique_product([8, 15, 28, 38, 25, 51, 55, 40]) == 358142400000", "def check(unique_product):\n\tassert unique_product([13, 19, 34, 40, 18, 54, 55, 43]) == 772206177600", "def check(unique_product):\n\tassert unique_product([9, 23, 31, 42, 18, 51, 62, 45]) == 690284647080", "def check(unique_product):\n\tassert unique_product([10, 23, 26, 42, 19, 46, 63, 35]) == 484028017200", "def check(unique_product):\n\tassert unique_product([13, 15, 29, 39, 24, 55, 59, 42]) == 721393873200", "def check(unique_product):\n\tassert unique_product([13, 24, 34, 43, 20, 48, 57, 43]) == 24960199680", "def check(unique_product):\n\tassert unique_product([6, 18, 34, 35, 25, 49, 57, 43]) == 385878087000", "def check(unique_product):\n\tassert unique_product([14, 20, 30, 44, 16, 48, 59, 44]) == 16747315200", "def check(unique_product):\n\tassert unique_product([14, 18, 25, 43, 15, 52, 55, 38]) == 441621180000", "def check(unique_product):\n\tassert unique_product([14, 25, 32, 45, 19, 46, 62, 41]) == 1119740832000", "def check(unique_product):\n\tassert unique_product([9, 16, 31, 37, 18, 52, 59, 41]) == 373970742912", "def check(unique_product):\n\tassert unique_product([8, 24, 34, 45, 19, 50, 64, 44]) == 785866752000", "def check(unique_product):\n\tassert unique_product([14, 24, 33, 44, 19, 55, 63, 41]) == 1316881177920", "def check(unique_product):\n\tassert unique_product([5, 21, 27, 36, 22, 55, 62, 37]) == 283292024400", "def check(unique_product):\n\tassert unique_product([12, 23, 34, 38, 21, 50, 59, 35]) == 773180604000", "def check(unique_product):\n\tassert unique_product([11, 25, 35, 41, 18, 50, 61, 39]) == 844931587500", "def check(unique_product):\n\tassert unique_product([6, 2, 1, 1]) == 12", "def check(unique_product):\n\tassert unique_product([3, 6, 1, 5]) == 90", "def check(unique_product):\n\tassert unique_product([2, 4, 1, 3]) == 24", "def check(unique_product):\n\tassert unique_product([6, 5, 2, 3]) == 180", "def check(unique_product):\n\tassert unique_product([5, 4, 1, 1]) == 20", "def check(unique_product):\n\tassert unique_product([2, 1, 3, 3]) == 6", "def check(unique_product):\n\tassert unique_product([5, 6, 7, 1]) == 210", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 6]) == 18", "def check(unique_product):\n\tassert unique_product([4, 3, 4, 6]) == 72", "def check(unique_product):\n\tassert unique_product([6, 4, 6, 5]) == 120", "def check(unique_product):\n\tassert unique_product([3, 1, 6, 1]) == 18", "def check(unique_product):\n\tassert unique_product([6, 7, 5, 2]) == 420", "def check(unique_product):\n\tassert unique_product([2, 3, 7, 1]) == 42", "def check(unique_product):\n\tassert unique_product([5, 1, 1, 6]) == 30", "def check(unique_product):\n\tassert unique_product([3, 4, 3, 1]) == 12", "def check(unique_product):\n\tassert unique_product([4, 4, 1, 5]) == 20", "def check(unique_product):\n\tassert unique_product([2, 1, 2, 6]) == 12", "def check(unique_product):\n\tassert unique_product([1, 4, 2, 4]) == 8", "def check(unique_product):\n\tassert unique_product([3, 4, 8, 6]) == 576", "def check(unique_product):\n\tassert unique_product([3, 7, 3, 2]) == 42", "def check(unique_product):\n\tassert unique_product([4, 6, 5, 4]) == 120", "def check(unique_product):\n\tassert unique_product([4, 5, 7, 2]) == 280", "def check(unique_product):\n\tassert unique_product([1, 1, 5, 5]) == 5", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 6]) == 18", "def check(unique_product):\n\tassert unique_product([6, 6, 3, 1]) == 18", "def check(unique_product):\n\tassert unique_product([4, 2, 5, 1]) == 40", "def check(unique_product):\n\tassert unique_product([2, 2, 3, 1]) == 6", "def check(unique_product):\n\tassert unique_product([6, 5, 4, 5]) == 120", "def check(unique_product):\n\tassert unique_product([5, 3, 2, 2]) == 30", "def check(unique_product):\n\tassert unique_product([4, 5, 4, 5]) == 20", "def check(unique_product):\n\tassert unique_product([4, 7, 1, 2]) == 56", "def check(unique_product):\n\tassert unique_product([3, 3, 3, 3]) == 3", "def check(unique_product):\n\tassert unique_product([1, 7, 3, 4]) == 84", "def check(unique_product):\n\tassert unique_product([5, 13, 11, 4, 2, 6]) == 34320", "def check(unique_product):\n\tassert unique_product([2, 7, 9, 1, 2, 4]) == 504", "def check(unique_product):\n\tassert unique_product([3, 13, 7, 1, 3, 2]) == 546", "def check(unique_product):\n\tassert unique_product([11, 8, 10, 3, 1, 4]) == 10560", "def check(unique_product):\n\tassert unique_product([4, 5, 9, 3, 4, 5]) == 540", "def check(unique_product):\n\tassert unique_product([9, 12, 5, 5, 4, 5]) == 2160", "def check(unique_product):\n\tassert unique_product([12, 4, 10, 1, 4, 2]) == 960", "def check(unique_product):\n\tassert unique_product([6, 9, 13, 1, 3, 4]) == 8424", "def check(unique_product):\n\tassert unique_product([2, 3, 6, 5, 1, 3]) == 180", "def check(unique_product):\n\tassert unique_product([4, 6, 14, 2, 2, 1]) == 672", "def check(unique_product):\n\tassert unique_product([6, 9, 12, 4, 3, 6]) == 7776", "def check(unique_product):\n\tassert unique_product([10, 6, 4, 5, 5, 2]) == 2400", "def check(unique_product):\n\tassert unique_product([4, 9, 4, 2, 4, 4]) == 72", "def check(unique_product):\n\tassert unique_product([6, 10, 8, 1, 5, 4]) == 9600", "def check(unique_product):\n\tassert unique_product([2, 4, 10, 2, 3, 1]) == 240", "def check(unique_product):\n\tassert unique_product([6, 9, 10, 2, 4, 6]) == 4320", "def check(unique_product):\n\tassert unique_product([10, 9, 12, 5, 4, 1]) == 21600", "def check(unique_product):\n\tassert unique_product([12, 6, 4, 1, 5, 1]) == 1440", "def check(unique_product):\n\tassert unique_product([8, 3, 4, 1, 5, 1]) == 480", "def check(unique_product):\n\tassert unique_product([3, 10, 8, 3, 1, 1]) == 240", "def check(unique_product):\n\tassert unique_product([7, 13, 14, 2, 2, 6]) == 15288", "def check(unique_product):\n\tassert unique_product([8, 7, 4, 4, 1, 5]) == 1120", "def check(unique_product):\n\tassert unique_product([2, 4, 10, 4, 6, 3]) == 1440", "def check(unique_product):\n\tassert unique_product([8, 6, 6, 2, 4, 2]) == 384", "def check(unique_product):\n\tassert unique_product([9, 9, 12, 5, 3, 1]) == 1620", "def check(unique_product):\n\tassert unique_product([9, 13, 5, 4, 2, 5]) == 4680", "def check(unique_product):\n\tassert unique_product([2, 7, 4, 4, 2, 4]) == 56", "def check(unique_product):\n\tassert unique_product([4, 10, 8, 3, 5, 5]) == 4800", "def check(unique_product):\n\tassert unique_product([5, 4, 11, 3, 4, 1]) == 660", "def check(unique_product):\n\tassert unique_product([12, 8, 4, 4, 6, 4]) == 2304", "def check(unique_product):\n\tassert unique_product([11, 10, 10, 2, 2, 3]) == 660", "def check(unique_product):\n\tassert unique_product([12, 9, 11, 1, 4, 2]) == 9504", "def check(unique_product):\n\tassert unique_product([5, 6, 4, 3, 5, 6]) == 360"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [102, 102, 102, 102, 102, 102, 102, 102, 102, 102], "completion": "from typing import List\n## main.py\nimport math\n\ndef unique_product(numbers: list) -> float:\n    '''\n    Calculate the product of unique numeric values in the list.\n    \n    Parameters:\n    numbers (list): A list containing numeric and non-numeric values.\n    \n    Returns:\n    float: The product of unique numeric values.\n    \n    Raises:\n    ValueError: If the input is not a list.\n    '''\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Filter out non-numeric values\n    numeric_values = [num for num in numbers if isinstance(num, (int, float))]\n    \n    # Extract unique values using set\n    unique_values = set(numeric_values)\n    \n    # Calculate product using math.prod\n    product = math.prod(unique_values)\n    \n    return product\n", "passed": true, "pass": true, "pass_num": 10, "round": 852, "mutate_method": "add_1_sentence_at_end", "parent_index": 283}
