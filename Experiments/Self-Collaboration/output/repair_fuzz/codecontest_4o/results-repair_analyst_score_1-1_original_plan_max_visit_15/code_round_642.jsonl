{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints. Aim for a solution that efficiently handles edge cases such as arrays with identical or progressively increasing values.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. In this context, it means sum divided by n, and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints. Aim for a solution that efficiently handles edge cases such as arrays with identical or progressively increasing values.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints. Aim for a solution that efficiently handles edge cases such as arrays with identical or progressively increasing values.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Edge case: n == 3\n        if n == 3:\n            results.append(0)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the pair (i, j) is valid\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        if n == 3:\n            if a[0] == a[1] == a[2]:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] + a[j] == total_sum - target_sum:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def find_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    target_sum = 2 * mean\n\n    # Use a dictionary to count occurrences of each element\n    from collections import defaultdict\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n\n    valid_pairs = 0\n\n    # Iterate over each element and find pairs\n    for i in range(n):\n        freq[a[i]] -= 1  # Decrease count of the current element\n        for j in range(i + 1, n):\n            freq[a[j]] -= 1  # Decrease count of the second element\n            if (a[i] + a[j]) == target_sum:\n                valid_pairs += 1\n            freq[a[j]] += 1  # Restore count of the second element\n        freq[a[i]] += 1  # Restore count of the current element\n\n    return valid_pairs\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(find_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        value_count = defaultdict(int)\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            value_count[value] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def find_valid_pairs(test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n\n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n\n        target_sum = int(target_sum)\n        count = 0\n        freq = {}\n\n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            # All elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current number from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def count_valid_pairs(n, array):\n    total_sum = sum(array)\n    mean = total_sum / n\n    count = 0\n    freq = {}\n\n    # Calculate the target sum for the remaining elements\n    target_sum = mean * (n - 2)\n\n    # Count frequency of each element\n    for num in array:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Iterate over each element to find valid pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements\n            remaining_sum = total_sum - array[i] - array[j]\n            if remaining_sum == target_sum:\n                count += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, array))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(1)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying gives: a[i] + a[j] == 2 * mean_k\n        \n        target_sum = 2 * mean_k\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if target_sum - value in value_count:\n                count += value_count[target_sum - value]\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    pair_count = {}\n\n    # Calculate the target sum for the remaining elements\n    target_sum = mean * (n - 2)\n\n    # Iterate over each element to find valid pairs\n    for i in range(n):\n        # Calculate the required sum of the two elements to be removed\n        required_sum = total_sum - target_sum - a[i]\n\n        # Check if there exists a previous element that can form a valid pair\n        if required_sum in pair_count:\n            count += pair_count[required_sum]\n\n        # Update the pair_count dictionary\n        if a[i] in pair_count:\n            pair_count[a[i]] += 1\n        else:\n            pair_count[a[i]] = 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # If all elements are the same, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == total_sum / n\n        # Simplifying gives: a[i] + a[j] == 2 * total_sum / n\n        \n        if total_sum * 2 % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = 2 * total_sum // n\n        count = 0\n        freq = {}\n        \n        for num in a:\n            # Check if the complement to reach target_sum exists in the hashmap\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            # Update the frequency map\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Edge case: n == 3\n        if n == 3:\n            results.append(0)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the pair (i, j) is valid\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing i and j.\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Implement efficient search techniques to find valid pairs without checking all possible pairs explicitly.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements in the array.\",\n    \"For each pair, check if their removal keeps the mean unchanged using optimized conditions.\",\n    \"Increment the counter for each valid pair found.\",\n    \"Output the counter value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array to check if the mean remains unchanged.\n\n    'sum of elements divided by the number of these elements'\n    Explanation: This is the formula for calculating the mean, which is central to solving the problem.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be considered simultaneously in terms of logic, but they are distinct operations. The optimization step is crucial and should be integrated into the pair-checking logic to ensure efficiency.\n\n# [edge case]\n    1. Input: [3, 3, 3, 3] = 6\n       Explanation: All elements are the same, so any pair removal will keep the mean unchanged.\n       \n    2. Input: [1, 2, 3] = 0\n       Explanation: No pair can be removed to keep the mean unchanged because the elements are distinct and small in number.\n       \n    3. Input: [5, 5, 5, 5, 5] = 10\n       Explanation: Similar to the first case, any pair removal will keep the mean unchanged due to identical elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when all elements are identical or when the array is very small.\n    ```python\n    if all(x == array[0] for x in array):\n        return (n * (n - 1)) // 2  # All pairs are valid\n    if n == 3:\n        return 0  # No valid pairs possible\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Edge case: n == 3\n        if n == 3:\n            results.append(0)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the pair (i, j) is valid\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Edge case: n == 3\n        if n == 3:\n            results.append(0)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the pair (i, j) is valid\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Sum all elements of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the number of checks needed for large arrays.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Parsing\",\n      \"action\": \"Read the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Initial Mean Calculation\",\n      \"action\": \"Calculate the sum of the array and derive the mean k.\"\n    },\n    {\n      \"step\": \"Pair Identification\",\n      \"action\": \"Iterate over all pairs of elements (i, j) and check if their removal keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Optimization\",\n      \"action\": \"Implement efficient algorithms to reduce the complexity of pair checking, possibly using hash maps or prefix sums.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"action\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct elements from the array such that their indices satisfy i < j.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Initial Mean Calculation\" and \"Pair Identification\" should be considered simultaneously. \n    Explanation: While iterating over pairs, the mean calculation should be used to check if the removal of the pair maintains the mean. This can be done by calculating the required sum of the remaining elements and checking if it matches the expected sum.\n\n# [edge case]\n    1. Input: 3\n       Array: [1, 1, 1]\n       Expected Output: 1\n       Explanation: Only one pair (1, 1) can be removed, and the mean remains unchanged.\n\n    2. Input: 4\n       Array: [0, 0, 0, 0]\n       Expected Output: 6\n       Explanation: Any pair of elements can be removed, and the mean remains unchanged.\n\n    3. Input: 5\n       Array: [1, 2, 3, 4, 5]\n       Expected Output: 0\n       Explanation: No pair of elements can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Special handling is required for arrays where all elements are the same or when the array size is minimal (n=3).\n\n    Example code for handling edge cases:\n    ```python\n    if n == 3:\n        return 1 if a[0] == a[1] == a[2] else 0\n    if all(x == a[0] for x in a):\n        return n * (n - 1) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        if n == 3:\n            if a[0] == a[1] == a[2]:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] + a[j] == total_sum - target_sum:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        if n == 3:\n            if a[0] == a[1] == a[2]:\n                results.append(1)\n            else:\n                results.append(0)\n            continue\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            value_count[value] = value_count.get(value, 0) + 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] + a[j] == total_sum - target_sum:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to reduce the number of checks needed.\",\n        \"Consider edge cases such as arrays with identical values or progressively increasing values.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements (i, j) with i < j:\",\n    \"Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"Check if the mean of the remaining elements equals the initial mean.\",\n    \"If valid, increment the counter.\",\n    \"Output the counter for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'sum divided by n': This is the formula for calculating the mean, where 'sum' is the total of all elements and 'n' is the number of elements.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating the sum and mean should be implemented simultaneously as they are directly related. \n    \"Sum all elements of the array\" and \"Divide the sum by the number of elements to get the mean\" can be done in one code block.\n\n# [edge case] \n    Test case with all identical elements: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all of them are equal, maintaining the mean.\n    \n    Test case with progressively increasing values: [1, 2, 3, 4, 5, 6, 7] = 3\n    Explanation: Pairs like (1, 7), (2, 6), and (3, 5) can be removed to maintain the mean.\n    \n    Test case with minimum elements: [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean as the array is too small to have any valid pair.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Consider using a hashmap to store the frequency of elements and their potential contribution to maintaining the mean after removal.\n    ```python\n    from collections import defaultdict\n\n    def find_valid_pairs(arr, mean):\n        freq = defaultdict(int)\n        for num in arr:\n            freq[num] += 1\n        \n        valid_pairs = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if (arr[i] + arr[j]) == 2 * mean:\n                    valid_pairs += 1\n        return valid_pairs\n    ```\n\nYES", "Round_0": {"code": "def find_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    target_sum = 2 * mean\n\n    # Use a dictionary to count occurrences of each element\n    from collections import defaultdict\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n\n    valid_pairs = 0\n\n    # Iterate over each element and find pairs\n    for i in range(n):\n        freq[a[i]] -= 1  # Decrease count of the current element\n        for j in range(i + 1, n):\n            freq[a[j]] -= 1  # Decrease count of the second element\n            if (a[i] + a[j]) == target_sum:\n                valid_pairs += 1\n            freq[a[j]] += 1  # Restore count of the second element\n        freq[a[i]] += 1  # Restore count of the current element\n\n    return valid_pairs\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(find_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to reduce the number of checks needed.\",\n        \"Consider edge cases such as arrays with identical values or progressively increasing values.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements (i, j) with i < j:\",\n    \"Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"Check if the mean of the remaining elements equals the initial mean.\",\n    \"If valid, increment the counter.\",\n    \"Output the counter for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This is the formula for calculating the mean of the array. In code, it can be implemented as `mean = sum(array) / len(array)`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the sum and mean should be implemented simultaneously as they are directly related. Additionally, the steps for iterating over pairs and checking the mean should be considered together to optimize the process.\n\n# [edge case]\n    Case 1: All elements are identical\n    Input: [8, 8, 8, 8]\n    Expected Output: 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n\n    Case 2: No valid pairs\n    Input: [50, 20, 10]\n    Expected Output: 0\n    Explanation: There is no way to delete two elements so the mean doesn't change.\n\n    Case 3: Progressive values\n    Input: [1, 2, 3, 4, 5, 6, 7]\n    Expected Output: 3\n    Explanation: Only specific pairs can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - For identical elements, a quick check can be added to count combinations.\n    - For progressive values, a mathematical approach can be used to reduce checks.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        value_count = defaultdict(int)\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            value_count[value] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Count pairs (i, j) such that a[i] + a[j] == target_sum\n        from collections import defaultdict\n        \n        count = 0\n        value_count = defaultdict(int)\n        \n        for value in a:\n            complement = target_sum - value\n            if complement in value_count:\n                count += value_count[complement]\n            value_count[value] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the number of checks needed for large arrays.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate the mean of the array\",\n      \"details\": \"For each test case, compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Find valid pairs of elements\",\n      \"details\": \"Iterate over all pairs of elements (i, j) and check if their removal keeps the mean unchanged. Use efficient methods to reduce complexity.\"\n    },\n    {\n      \"step\": \"Output the result\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this requirement, the mean must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': means we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step \"Find valid pairs of elements\" should be implemented simultaneously with the optimization step. Efficient methods such as prefix sums or hash maps can be used to reduce complexity when checking pairs.\n\n# [edge case] \n    Input: 3\n    3\n    1 1 1\n    Expected Output: 1\n    Explanation: Only one pair (1, 2) can be removed to maintain the mean since all elements are identical.\n    \n    Input: 4\n    10 10 10 10\n    Expected Output: 6\n    Explanation: Any pair can be removed since all elements are identical.\n    \n    Input: 5\n    1 2 3 4 5\n    Expected Output: 0\n    Explanation: No pair can be removed to maintain the mean as the elements are distinct and progressively increasing.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Use a hash map to store the frequency of each element and calculate potential pairs based on the difference needed to maintain the mean.\n\nYES", "Round_0": {"code": "def find_valid_pairs(test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n\n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n\n        target_sum = int(target_sum)\n        count = 0\n        freq = {}\n\n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the mathematical mean k of the original array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the time complexity of finding valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum of the array a\",\n      \"details\": \"Compute the sum of all elements in a to use in mean calculations.\"\n    },\n    {\n      \"step\": \"Iterate over possible pairs of elements\",\n      \"details\": \"For each pair (i, j) with i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n    },\n    {\n      \"step\": \"Check if the mean remains unchanged\",\n      \"details\": \"For each pair, check if the mean of the remaining elements equals the original mean k. If so, count the pair as valid.\"\n    },\n    {\n      \"step\": \"Optimize pair checking\",\n      \"details\": \"Use a hashmap or other data structure to efficiently find pairs that satisfy the condition, leveraging the equation derived from the mean condition.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    'equal': The mean of the remaining elements must be exactly equal to the original mean.\n\n# [code logic]\n    The steps \"Iterate over possible pairs of elements\" and \"Check if the mean remains unchanged\" should be implemented simultaneously. This can be done by iterating through the array and checking the condition for each pair in a single loop or nested loop structure.\n\n# [edge case] \n    1. Input: [4, 4, 4, 4] = 6\n       Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n    2. Input: [1, 1, 1, 1, 1] = 10\n       Explanation: Similar to the first case, all elements are identical, allowing any pair to be removed.\n    3. Input: [1, 2, 3, 4, 5] = 0\n       Explanation: No pair of elements can be removed to keep the mean unchanged because the elements are distinct and the mean changes with any removal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical, as this allows any pair to be removed. This can be handled by checking if all elements are the same initially.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2  # All pairs are valid\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            # All elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current number from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            # All elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current number from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to reduce the number of checks needed.\",\n        \"Consider edge cases such as arrays with identical values or progressively increasing values.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Iterate over all pairs of elements (i, j) to check if their removal maintains the mean.\",\n    \"Count and store the number of valid pairs for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be considered simultaneously for efficiency. Instead of recalculating the mean for each pair, use mathematical properties to determine valid pairs without exhaustive checking.\n\n# [edge case] \n    Test case with all identical elements, e.g., [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n    \n    Test case with no valid pairs, e.g., [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Test case with progressively increasing values, e.g., [1, 2, 3, 4, 5, 6, 7] = 3\n    Explanation: Only specific pairs can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Consider using a hashmap to store frequency of elements and mathematical properties to reduce checks.\n    Example code snippet:\n    ```python\n    from collections import defaultdict\n\n    def count_valid_pairs(n, array):\n        total_sum = sum(array)\n        mean = total_sum / n\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in array:\n            freq[num] += 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - array[i] - array[j]) / (n - 2) == mean:\n                    count += 1\n        \n        return count\n    ```\n\nYES", "Round_0": {"code": "def count_valid_pairs(n, array):\n    total_sum = sum(array)\n    mean = total_sum / n\n    count = 0\n    freq = {}\n\n    # Calculate the target sum for the remaining elements\n    target_sum = mean * (n - 2)\n\n    # Count frequency of each element\n    for num in array:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Iterate over each element to find valid pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the sum of the remaining elements\n            remaining_sum = total_sum - array[i] - array[j]\n            if remaining_sum == target_sum:\n                count += 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, array))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"requirement_analysis\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Calculate the initial mean of the array.\",\n        \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n      },\n      {\n        \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n        \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n      },\n      {\n        \"description\": \"Optimize the search for valid pairs.\",\n        \"details\": \"Use mathematical properties and efficient data structures to reduce the complexity of finding valid pairs.\"\n      }\n    ],\n    \"high_level_plan\": [\n      {\n        \"step\": \"Input Parsing\",\n        \"action\": \"Read the number of test cases and for each test case, read the number of elements and the array itself.\"\n      },\n      {\n        \"step\": \"Initial Mean Calculation\",\n        \"action\": \"For each test case, calculate the sum of the array and determine the mean k.\"\n      },\n      {\n        \"step\": \"Pair Identification\",\n        \"action\": \"Iterate over all pairs of elements (i, j) and check if their removal keeps the mean unchanged. Use efficient methods to avoid unnecessary calculations.\"\n      },\n      {\n        \"step\": \"Output Result\",\n        \"action\": \"For each test case, output the number of valid pairs found.\"\n      }\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is used to determine if removing two elements from the array keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count the number of valid pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Initial Mean Calculation\" and \"Pair Identification\" should be considered simultaneously. \n    Explanation: While iterating over pairs to check if their removal maintains the mean, we can use the initial mean calculation to quickly determine if a pair is valid without recalculating the mean for each pair.\n\n# [edge case]\n    1. Input: 3 1 1 1\n       Output: 1\n       Explanation: With only three elements, removing any two will leave one element, which trivially maintains the mean.\n    2. Input: 4 0 0 0 0\n       Output: 6\n       Explanation: All elements are zero, so any pair removal will maintain the mean of zero.\n    3. Input: 5 10 10 10 10 10\n       Output: 10\n       Explanation: All elements are the same, so any pair removal will maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are the same or when the array size is minimal (n=3).\n    ```python\n    if n == 3:\n        return 1\n    if all(x == a[0] for x in a):\n        return n * (n - 1) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(1)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying gives: a[i] + a[j] == 2 * mean_k\n        \n        target_sum = 2 * mean_k\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if target_sum - value in value_count:\n                count += value_count[target_sum - value]\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(1)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying gives: a[i] + a[j] == 2 * mean_k\n        \n        target_sum = 2 * mean_k\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if target_sum - value in value_count:\n                count += value_count[target_sum - value]\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for unchanged mean.\",\n        \"Implement efficient search techniques to handle large arrays.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Iterate over all pairs of elements to check if their removal keeps the mean unchanged.\",\n    \"Count and store the number of valid pairs for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it refers to the average value of the array elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and iterating over pairs to check the mean should be considered simultaneously. Specifically, the calculation of the mean and checking pairs can be optimized by using mathematical properties to avoid recalculating the mean for each pair.\n\n# [edge case]\n    Test case with all identical elements: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains unchanged.\n    \n    Test case with progressively increasing values: [1, 2, 3, 4, 5, 6, 7] = 3\n    Explanation: Only specific pairs can be removed to keep the mean unchanged, such as (1, 7), (2, 6), and (3, 5).\n    \n    Test case with minimum elements: [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged due to the small size and large differences between elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Implement a mathematical approach to check if removing two elements keeps the mean unchanged without recalculating the mean for each pair.\n    ```python\n    def count_valid_pairs(n, a):\n        total_sum = sum(a)\n        mean = total_sum / n\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean:\n                    count += 1\n        return count\n    ```\n\nYES", "Round_0": {"code": "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    pair_count = {}\n\n    # Calculate the target sum for the remaining elements\n    target_sum = mean * (n - 2)\n\n    # Iterate over each element to find valid pairs\n    for i in range(n):\n        # Calculate the required sum of the two elements to be removed\n        required_sum = total_sum - target_sum - a[i]\n\n        # Check if there exists a previous element that can form a valid pair\n        if required_sum in pair_count:\n            count += pair_count[required_sum]\n\n        # Update the pair_count dictionary\n        if a[i] in pair_count:\n            pair_count[a[i]] += 1\n        else:\n            pair_count[a[i]] = 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations to reduce the problem to checking a condition involving sums and differences, allowing for efficient pair counting.\"\n    },\n    {\n      \"description\": \"Handle multiple test cases efficiently.\",\n      \"details\": \"Iterate over each test case, apply the solution, and store the results for output.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  1. Read the integer n and the array a of n integers.\",\n    \"  2. Calculate the sum of the array a to determine the mean k.\",\n    \"  3. Use a hashmap or dictionary to count occurrences of each element in a.\",\n    \"  4. Iterate over each element a[i] and calculate the required value to pair with it to maintain the mean.\",\n    \"  5. Use the hashmap to efficiently count valid pairs (i, j) that satisfy the condition.\",\n    \"  6. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    'still equal': This means that after removing the two elements, the mean of the remaining elements should be the same as the original mean.\n\n# [code logic]\n    Steps 3 and 4 in the high-level plan should be considered simultaneously. \n    \"Use a hashmap or dictionary to count occurrences of each element in a.\"\n    \"Iterate over each element a[i] and calculate the required value to pair with it to maintain the mean.\"\n    These steps can be combined by iterating through the array once, using the hashmap to check for valid pairs efficiently.\n\n# [edge case] \n    Test case: [3, 3, 3, 3] = 6\n    Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n    \n    Test case: [1, 2, 3] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged because the array is too small to have a valid pair.\n    \n    Test case: [1, 1, 1, 1, 1] = 10\n    Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are the same.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2  # Combination of n elements taken 2 at a time\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            # All elements are the same, any pair can be removed\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying gives: a[i] + a[j] == 2 * mean_k\n        \n        target_sum = 2 * mean_k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            # Check if the complement to reach target_sum exists in the hashmap\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            # Update the frequency map\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # If all elements are the same, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == total_sum / n\n        # Simplifying gives: a[i] + a[j] == 2 * total_sum / n\n        \n        if total_sum * 2 % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = 2 * total_sum // n\n        count = 0\n        freq = {}\n        \n        for num in a:\n            # Check if the complement to reach target_sum exists in the hashmap\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            # Update the frequency map\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing i and j.\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Implement efficient search techniques to find valid pairs without checking all possible pairs explicitly.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements in the array.\",\n    \"For each pair, check if their removal keeps the mean unchanged using optimized conditions.\",\n    \"Increment the counter for each valid pair found.\",\n    \"Output the counter value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: This refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: This means that precisely two elements must be removed from the array to check if the mean remains unchanged.\n\n    'sum of elements divided by the number of these elements'\n    Explanation: This is the formula for calculating the mean, which is central to solving the problem.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be considered simultaneously in terms of logic, but they are distinct operations. The optimization step is crucial and should be integrated into the pair-checking logic to ensure efficiency.\n\n# [edge case]\n    1. Input: [3, 3, 3, 3] = 6\n       Explanation: All elements are the same, so any pair removal will keep the mean unchanged.\n       \n    2. Input: [1, 2, 3] = 0\n       Explanation: No pair can be removed to keep the mean unchanged because the elements are distinct and small in number.\n       \n    3. Input: [5, 5, 5, 5, 5] = 10\n       Explanation: Similar to the first case, any pair removal will keep the mean unchanged due to identical elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when all elements are identical or when the array is very small.\n    ```python\n    if all(x == array[0] for x in array):\n        return (n * (n - 1)) // 2  # All pairs are valid\n    if n == 3:\n        return 0  # No valid pairs possible\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Edge case: n == 3\n        if n == 3:\n            results.append(0)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the pair (i, j) is valid\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Edge case: n == 3\n        if n == 3:\n            results.append(0)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            freq[a[i]] -= 1\n            for j in range(i + 1, n):\n                freq[a[j]] -= 1\n                \n                # Check if the pair (i, j) is valid\n                if total_sum - a[i] - a[j] == target_sum:\n                    count += 1\n                \n                freq[a[j]] += 1\n            freq[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [false, true, false, false, true, true, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 642, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints. Aim for a solution that efficiently handles edge cases such as arrays with identical or progressively increasing values.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 241}
