{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements. Clarify any assumptions you make while working through the problem to avoid overlooking subtle details.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. In other words, the mean is the sum divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements. Clarify any assumptions you make while working through the problem to avoid overlooking subtle details.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements. Clarify any assumptions you make while working through the problem to avoid overlooking subtle details.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        count = 0\n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        \n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                if remaining_mean == k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * 2 / n\n        count = 0\n        freq = {}\n\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs\n        count = 0\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        for num in a:\n            freq[num] -= 1\n            target = 2 * k - num\n            if target in freq:\n                count += freq[target]\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        k = total_sum / n\n        target_sum = 2 * k\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # To find pairs (i, j) such that removing them keeps the mean the same\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives us:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there exists a pair (num, x) such that num + x = target_sum\n            # This means x = target_sum - num\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives us:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current number from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # If all elements are identical, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # Count pairs that satisfy the condition\n        count = 0\n        pair_count = defaultdict(int)\n        \n        for num in a:\n            pair_count[num] += 1\n        \n        for num in a:\n            target = 2 * total_sum / n - num\n            if target in pair_count:\n                count += pair_count[target]\n            pair_count[num] -= 1\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        \n        # Use a dictionary to count occurrences of each element\n        count = {}\n        valid_pairs = 0\n        \n        for number in a:\n            # Check if there is a complement that can form the target_sum\n            complement = target_sum - number\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Update the count of the current number\n            if number in count:\n                count[number] += 1\n            else:\n                count[number] = 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    # We need to find pairs (i, j) such that:\n    # (total_sum - a[i] - a[j]) / (n - 2) == mean\n    # Simplifying the condition:\n    # total_sum - a[i] - a[j] == mean * (n - 2)\n    # a[i] + a[j] == total_sum - mean * (n - 2)\n    target_sum = total_sum - mean * (n - 2)\n    \n    # Use a dictionary to count occurrences of each element\n    from collections import defaultdict\n    freq = defaultdict(int)\n    \n    for num in a:\n        freq[num] += 1\n    \n    for i in range(n):\n        freq[a[i]] -= 1  # Remove current element from frequency count\n        complement = target_sum - a[i]\n        if complement in freq:\n            count += freq[complement]\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        count = 0\n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        \n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                if remaining_mean == k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k for each test case.\",\n      \"details\": \"Compute the sum of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over all pairs of elements in the array.\",\n      \"details\": \"For each pair (i, j) with i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n    },\n    {\n      \"step\": \"Check if the mean remains unchanged.\",\n      \"details\": \"For each pair, check if the mean of the remaining elements equals the initial mean k.\"\n    },\n    {\n      \"step\": \"Count valid pairs.\",\n      \"details\": \"Keep a count of pairs (i, j) that satisfy the condition and store the result for each test case.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    'equal': This means that the mean of the remaining elements after removing two should be the same as the original mean.\n\n# [code logic]\n    The steps \"Iterate over all pairs of elements in the array\" and \"Check if the mean remains unchanged\" should be implemented simultaneously. This can be done by iterating through the array with nested loops to form pairs and checking the condition in the same loop.\n\n# [edge case] \n    Test case with all identical elements, e.g., [5, 5, 5, 5] = 6\n    Explanation: Any pair of elements can be removed, and the mean will remain the same.\n    \n    Test case with no possible pairs, e.g., [1, 2, 3] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n    \n    Test case with large numbers, e.g., [10^9, 10^9, 10^9, 10^9] = 6\n    Explanation: Similar to the first edge case, any pair can be removed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        count = 0\n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        \n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                if remaining_mean == k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 95)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        count = 0\n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        \n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                if remaining_mean == k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and constraints to reduce the number of checks needed, especially for arrays with duplicates or identical elements.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate initial mean\",\n      \"details\": \"For each test case, compute the sum of the array and calculate the mean k.\"\n    },\n    {\n      \"step\": \"Find valid pairs\",\n      \"details\": \"Iterate over all pairs of elements (i, j) and check if their removal keeps the mean unchanged. Use efficient methods to handle constraints and edge cases.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'sum divided by n': This is the formula for calculating the mean, where 'sum' is the total of all elements and 'n' is the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate initial mean\" and \"Find valid pairs\" should be considered simultaneously. After calculating the mean, the search for valid pairs can be optimized by considering mathematical properties, such as checking if the sum of the two elements equals twice the mean times the number of elements minus the sum of the array.\n\n# [edge case]\n    Input: [4, 8, 8, 8, 8]\n    Output: 6\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    \n    Input: [3, 50, 20, 10]\n    Output: 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Input: [5, 1, 4, 7, 3, 5]\n    Output: 2\n    Explanation: Removing elements at positions 1 and 3 or positions 4 and 5 maintains the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - Use a hashmap to store the frequency of each element and check pairs based on the sum condition.\n    - Consider special cases where all elements are identical or where the array has duplicates.\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * 2 / n\n        count = 0\n        freq = {}\n\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n\n        results.append(count)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and constraints to reduce the number of checks needed, especially for arrays with duplicates or identical elements.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate the mean of the array\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over pairs of elements\",\n      \"details\": \"For each pair (i, j) where i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n    },\n    {\n      \"step\": \"Check mean condition\",\n      \"details\": \"Verify if the mean of the remaining elements equals the initial mean k.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"Maintain a count of pairs that satisfy the mean condition.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean is used to determine if removing two elements from the array keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over pairs of elements\" and \"Check mean condition\" should be implemented simultaneously. This can be done by iterating through the array to form pairs and checking the mean condition within the same loop to optimize performance.\n\n# [edge case]\n    1. Input: [4, 4, 4, 4] = 6\n       Explanation: All elements are the same, so any pair of elements can be removed without changing the mean.\n    2. Input: [1, 1, 1, 1, 1] = 10\n       Explanation: Similar to the first case, all elements are identical, allowing any pair to be removed.\n    3. Input: [1, 2, 3, 4, 5] = 0\n       Explanation: No pair of elements can be removed to maintain the mean, as the elements are distinct and the mean changes with any removal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical, as this allows any pair to be removed. This can be optimized by checking if all elements are the same initially and calculating the number of pairs directly.\n    \n    ```python\n    if all(x == array[0] for x in array):\n        return (n * (n - 1)) // 2  # Combination of n elements taken 2 at a time\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Count pairs\n        count = 0\n        from collections import defaultdict\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        for num in a:\n            freq[num] -= 1\n            target = 2 * k - num\n            if target in freq:\n                count += freq[target]\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For the mean to remain the same after removing two elements a[i] and a[j], the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if the sum of these two elements equals 2 * k. If so, they can be removed while maintaining the mean.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as arrays with duplicates or all identical elements.\",\n      \"details\": \"Consider scenarios where all elements are the same or there are multiple identical elements, which may affect the number of valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over all pairs of elements\",\n      \"details\": \"For each pair (i, j) with i < j, check if a[i] + a[j] equals 2 * k.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"Maintain a count of pairs (i, j) that satisfy the condition a[i] + a[j] = 2 * k.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum of elements divided by the number of these elements': This describes the calculation of the mean, which is implemented in code as `sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over all pairs of elements\" should be considered simultaneously. \n    Explanation: While iterating over pairs, we can calculate the sum of the pair and check against `2 * k` in the same loop to optimize performance.\n\n# [edge case]\n    Case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    \n    Case 2: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean, as the mean changes with any removal.\n    \n    Case 3: [1, 1, 1, 1, 1] = 10\n    Explanation: All elements are identical, allowing any pair to be removed without affecting the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if `a[i] + a[j] = 2 * k` will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        k = total_sum / n\n        target_sum = 2 * k\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider arrays with duplicate elements or all identical elements, and ensure the solution efficiently handles large constraints.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate the mean of the array.\",\n      \"details\": \"For each test case, compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over pairs of elements.\",\n      \"details\": \"For each test case, iterate over all pairs of elements (i, j) with i < j and check if their removal keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Count valid pairs.\",\n      \"details\": \"Maintain a count of pairs (i, j) that satisfy the condition of maintaining the mean after removal.\"\n    },\n    {\n      \"step\": \"Output results.\",\n      \"details\": \"For each test case, output the count of valid pairs.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all possible pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean of the array\" and \"Iterate over pairs of elements\" should be considered simultaneously. \n    Explanation: While iterating over pairs, we need to check if removing them maintains the mean, which requires the mean to be calculated beforehand.\n\n# [edge case] \n    1. Input: [4, 4, 4, 4] = 6\n       Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    2. Input: [1, 1, 1, 1, 1] = 10\n       Explanation: Similar to the first case, all elements are identical, allowing any pair to be removed.\n    3. Input: [1, 2, 3, 4, 5] = 0\n       Explanation: No pair of elements can be removed to maintain the mean, as the elements are distinct and the mean changes with any removal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, we need to handle cases where all elements are identical, as any pair can be removed in such cases.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2  # All pairs are valid\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean k.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the complexity of finding valid pairs.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where the array has duplicates.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum of the array a.\",\n      \"details\": \"Compute the sum of all elements in a to determine the initial mean k.\"\n    },\n    {\n      \"step\": \"Iterate over all possible pairs (i, j) with i < j.\",\n      \"details\": \"For each pair, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n    },\n    {\n      \"step\": \"Check if the mean of the remaining elements equals k.\",\n      \"details\": \"Verify if the mean of the remaining elements (n-2) is equal to the initial mean k.\"\n    },\n    {\n      \"step\": \"Count valid pairs.\",\n      \"details\": \"Maintain a count of pairs (i, j) that satisfy the condition.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by summing all elements in a set and dividing by the number of elements. In this requirement, it is used to determine if removing two elements from the array maintains the same mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that precisely two elements must be removed from the array.\n    'number of pairs of positions [i, j] (i < j)': This specifies that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over all possible pairs (i, j) with i < j\" and \"Check if the mean of the remaining elements equals k\" should be implemented simultaneously. This can be done by iterating through the array with nested loops to form pairs and checking the condition within the same loop.\n\n# [edge case]\n    Case 1: All elements are identical, e.g., [8, 8, 8, 8]\n    Expected output: 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n\n    Case 2: No valid pairs, e.g., [50, 20, 10]\n    Expected output: 0\n    Explanation: There is no way to delete two elements so the mean doesn't change.\n\n    Case 3: Array with duplicates, e.g., [1, 4, 7, 3, 5]\n    Expected output: 2\n    Explanation: It is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - For identical elements, a quick check can be added to count combinations directly.\n    - For arrays with no valid pairs, ensure the logic correctly identifies and returns 0.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # To find pairs (i, j) such that removing them keeps the mean the same\n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives us:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count the number of valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there exists a pair (num, x) such that num + x = target_sum\n            # This means x = target_sum - num\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Increment the count of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"steps\": [\n        \"Sum all elements of the array a.\",\n        \"Divide the sum by n to get the mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (a[i], a[j]), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals k.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Consider edge cases such as arrays with identical elements or duplicates.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following:\",\n    \"Read the integer n and the array a.\",\n    \"Calculate the initial mean k of the array a.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of indices (i, j) with i < j:\",\n    \"Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"Check if the mean of the remaining elements equals k.\",\n    \"If the condition is satisfied, increment the counter.\",\n    \"Output the counter for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by summing all elements and dividing by the number of elements. In this problem, it is used to determine if removing two elements from the array keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This specifies that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the sum of the remaining elements after removing a[i] and a[j]\" and \"Check if the mean of the remaining elements equals k\" should be implemented simultaneously. This can be done by iterating over pairs of indices and checking the condition in one code block.\n\n# [edge case]\n    Case 1: All elements are identical, e.g., [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains unchanged.\n    \n    Case 2: No valid pairs, e.g., [50, 20, 10] = 0\n    Explanation: There is no way to delete two elements so the mean doesn't change.\n    \n    Case 3: Array with distinct elements, e.g., [1, 4, 7, 3, 5] = 2\n    Explanation: It is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - For arrays with identical elements, we can directly calculate the number of pairs using combinatorial logic.\n    - For arrays with distinct elements, we need to check each pair and calculate the mean.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives us:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each number\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current number from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"requirement_analysis\": {\n    \"subproblems\": [\n      {\n        \"description\": \"Calculate the initial mean of the array.\",\n        \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n      },\n      {\n        \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n        \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n      },\n      {\n        \"description\": \"Handle edge cases efficiently.\",\n        \"details\": \"Consider cases where all elements are identical or where there are duplicates, ensuring the solution is optimized for large inputs.\"\n      }\n    ],\n    \"high_level_plan\": [\n      {\n        \"step\": \"Read input data.\",\n        \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n      },\n      {\n        \"step\": \"Calculate the mean of the array.\",\n        \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n      },\n      {\n        \"step\": \"Iterate over pairs of elements.\",\n        \"details\": \"For each pair (i, j) where i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n      },\n      {\n        \"step\": \"Check mean condition.\",\n        \"details\": \"Verify if the mean of the remaining elements equals the initial mean k.\"\n      },\n      {\n        \"step\": \"Count valid pairs.\",\n        \"details\": \"Maintain a count of pairs that satisfy the mean condition.\"\n      },\n      {\n        \"step\": \"Output the result for each test case.\",\n        \"details\": \"Print the count of valid pairs for each test case.\"\n      }\n    ]\n  }\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. It represents the average value of the array.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This specifies that we are looking for pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over pairs of elements\" and \"Check mean condition\" should be implemented simultaneously. This can be done by iterating through all pairs and checking the mean condition within the same loop.\n\n# [edge case] \n    Case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    \n    Case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged because the elements are too varied.\n    \n    Case 3: [1, 1, 1, 1, 1] = 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for arrays with identical elements or large inputs.\n    Example code for handling identical elements:\n    ```python\n    if all(x == a[0] for x in a):\n        return comb(n, 2)  # Return the combination count of pairs\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # If all elements are identical, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # Count pairs that satisfy the condition\n        count = 0\n        pair_count = defaultdict(int)\n        \n        for num in a:\n            pair_count[num] += 1\n        \n        for num in a:\n            target = 2 * mean - num\n            if target in pair_count:\n                count += pair_count[target]\n            pair_count[num] -= 1\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # If all elements are identical, any pair can be removed\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # Count pairs that satisfy the condition\n        count = 0\n        pair_count = defaultdict(int)\n        \n        for num in a:\n            pair_count[num] += 1\n        \n        for num in a:\n            target = 2 * total_sum / n - num\n            if target in pair_count:\n                count += pair_count[target]\n            pair_count[num] -= 1\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For the mean to remain the same after removing two elements a[i] and a[j], the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if the sum of these two elements equals 2 * k. If so, they can be removed while maintaining the mean.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as arrays with duplicates or all identical elements.\",\n      \"details\": \"Consider scenarios where all elements are the same or there are multiple identical elements, which may affect the number of valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over all pairs of elements\",\n      \"details\": \"For each pair (i, j) with i < j, check if a[i] + a[j] equals 2 * k.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"Maintain a count of pairs (i, j) that satisfy the condition a[i] + a[j] = 2 * k.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean must remain the same after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum of elements divided by the number of these elements': This describes the calculation of the mean, which is implemented in code as `sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over all pairs of elements\" should be considered simultaneously. \n    This can be done by calculating the mean once and then iterating over pairs to check the condition in a single loop.\n\n# [edge case]\n    Test case: [8, 8, 8, 8] = 6\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n    \n    Test case: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean, as the mean changes with any removal.\n    \n    Test case: [1, 1, 1, 1, 1] = 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    ```python\n    if all(x == a[0] for x in a):\n        return comb(n, 2)  # Return the number of ways to choose 2 elements from n\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            # If all elements are the same, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        \n        # Use a dictionary to count occurrences of each element\n        count = {}\n        valid_pairs = 0\n        \n        for number in a:\n            # Check if there is a complement that can form the target_sum\n            complement = target_sum - number\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Update the count of the current number\n            if number in count:\n                count[number] += 1\n            else:\n                count[number] = 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations to avoid checking all pairs explicitly, leveraging properties of sums and means.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases with duplicate elements, all identical elements, and minimal array size constraints.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k for each test case.\",\n      \"details\": \"Compute the sum of the array and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Iterate over possible pairs of elements to remove.\",\n      \"details\": \"For each pair (i, j) with i < j, check if removing a[i] and a[j] keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"step\": \"Use mathematical properties to optimize pair checking.\",\n      \"details\": \"Derive a condition based on the sum of the array and the elements to be removed to quickly verify if the mean remains unchanged.\"\n    },\n    {\n      \"step\": \"Count and store the number of valid pairs for each test case.\",\n      \"details\": \"Maintain a counter for each test case to track the number of valid pairs found.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by summing all elements and dividing by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that precisely two elements must be removed from the array.\n    'number of pairs of positions [i, j] (i < j)': This refers to counting pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over possible pairs of elements to remove\" and \"Use mathematical properties to optimize pair checking\" should be considered simultaneously. This can be done by deriving a mathematical condition to check pairs efficiently within a single loop structure.\n\n# [edge case]\n    Input: [4, 8, 8, 8, 8]\n    Expected Output: 6\n    Explanation: All elements are identical, so any pair removal will maintain the mean.\n    \n    Input: [3, 50, 20, 10]\n    Expected Output: 0\n    Explanation: No pair can be removed to maintain the mean.\n    \n    Input: [5, 1, 4, 7, 3, 5]\n    Expected Output: 2\n    Explanation: Removing pairs (1, 3) or (4, 5) maintains the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should include a mathematical condition to check if removing two elements maintains the mean:\n    ```python\n    def count_valid_pairs(n, a):\n        total_sum = sum(a)\n        mean = total_sum / n\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (total_sum - a[i] - a[j]) / (n - 2) == mean:\n                    count += 1\n        return count\n    ```\n\nYES", "Round_0": {"code": "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    # We need to find pairs (i, j) such that:\n    # (total_sum - a[i] - a[j]) / (n - 2) == mean\n    # Simplifying the condition:\n    # total_sum - a[i] - a[j] == mean * (n - 2)\n    # a[i] + a[j] == total_sum - mean * (n - 2)\n    target_sum = total_sum - mean * (n - 2)\n    \n    # Use a dictionary to count occurrences of each element\n    from collections import defaultdict\n    freq = defaultdict(int)\n    \n    for num in a:\n        freq[num] += 1\n    \n    for i in range(n):\n        freq[a[i]] -= 1  # Remove current element from frequency count\n        complement = target_sum - a[i]\n        if complement in freq:\n            count += freq[complement]\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where all elements are identical or where there are duplicates.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k for each test case.\",\n      \"details\": \"Compute the sum of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over all pairs of elements in the array.\",\n      \"details\": \"For each pair (i, j) with i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\"\n    },\n    {\n      \"step\": \"Check if the mean remains unchanged.\",\n      \"details\": \"For each pair, check if the mean of the remaining elements equals the initial mean k.\"\n    },\n    {\n      \"step\": \"Count valid pairs.\",\n      \"details\": \"Keep a count of pairs (i, j) that satisfy the condition and store the result for each test case.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the count of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean (or average) of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the mean of the array elements before and after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    'equal': This means that the mean of the remaining elements after removing two should be the same as the original mean.\n\n# [code logic]\n    The steps \"Iterate over all pairs of elements in the array\" and \"Check if the mean remains unchanged\" should be implemented simultaneously. This can be done by iterating through the array with nested loops to form pairs and checking the condition in the same loop.\n\n# [edge case] \n    Test case with all identical elements, e.g., [5, 5, 5, 5] = 6\n    Explanation: Any pair of elements can be removed, and the mean will remain the same.\n    \n    Test case with no possible pairs, e.g., [1, 2, 3] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n    \n    Test case with large numbers, e.g., [10^9, 10^9, 10^9, 10^9] = 6\n    Explanation: Similar to the first edge case, any pair can be removed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        count = 0\n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        \n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                if remaining_mean == k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 95)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        # Edge case: all elements are identical\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        count = 0\n        # Use a dictionary to count occurrences of each element\n        element_count = {}\n        \n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Iterate over pairs\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                remaining_mean = remaining_sum / (n - 2)\n                \n                if remaining_mean == k:\n                    count += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [true, true, true, true, false, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 294, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution. Consider edge cases where the array might have duplicates or all identical elements. Clarify any assumptions you make while working through the problem to avoid overlooking subtle details.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 171}
