{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i. This topic is represented by an integer from 1 to n. It also has a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems, each with a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, meaning no two tasks share the same topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        topic_difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            topic_difficulty_count[(a_i, b_i)] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = sum(calculate_combinations(count) for count in topic_count.values())\n        invalid_difficulty_combinations = sum(calculate_combinations(count) for count in difficulty_count.values())\n        invalid_topic_difficulty_combinations = sum(calculate_combinations(count) for count in topic_difficulty_count.values())\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_same_topic = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        invalid_same_difficulty = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Calculate invalid combinations where all three problems have the same topic and difficulty\n        invalid_same_topic_and_difficulty = 0\n        \n        for a_i, b_i in problems:\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_same_topic_and_difficulty += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_same_topic - invalid_same_difficulty + invalid_same_topic_and_difficulty\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                same_topic_combinations += comb(count, 3)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                same_difficulty_combinations += comb(count, 3)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_topic_difficulty_combinations = 0\n        for a_i, b_i in problems:\n            same_topic_difficulty_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Calculate valid combinations\n        valid_combinations = total_combinations - same_topic_combinations - same_difficulty_combinations + same_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways where neither condition is satisfied\n        neither_ways = 0\n        for a_i, b_i in problems:\n            neither_ways += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Calculate the number of ways satisfying at least one condition\n        valid_ways = total_ways - neither_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            problems.append((a_i, b_i))\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Calculate invalid ways\n        invalid_ways = 0\n        \n        for a_i, b_i in problems:\n            # For each problem, calculate the number of invalid combinations\n            # that include this problem and two others with the same topic or difficulty\n            invalid_ways += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid ways are total ways minus invalid ways\n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import Counter\n\ndef calculate_valid_selections(n, problems):\n    if n < 3:\n        return 0\n    \n    # Calculate total combinations\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count frequencies of topics and difficulties\n    topics = [problem[0] for problem in problems]\n    difficulties = [problem[1] for problem in problems]\n    \n    topic_count = Counter(topics)\n    difficulty_count = Counter(difficulties)\n    \n    # Calculate invalid combinations\n    invalid_combinations = sum(f * (f - 1) * (f - 2) // 6 for f in topic_count.values() if f >= 3)\n    invalid_combinations += sum(f * (f - 1) * (f - 2) // 6 for f in difficulty_count.values() if f >= 3)\n    \n    # Calculate over-counted combinations where both topic and difficulty are the same\n    over_counted_combinations = 0\n    for a, b in problems:\n        over_counted_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n    \n    # Calculate valid combinations\n    valid_combinations = total_combinations - invalid_combinations + over_counted_combinations\n    \n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            problems.append((a_i, b_i))\n            index += 2\n        \n        result = calculate_valid_selections(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = {}\n        difficulties = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topics:\n                topics[a] = 0\n            if b not in difficulties:\n                difficulties[b] = 0\n            \n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        topic_difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            topic_difficulty_count[(a_i, b_i)] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = sum(calculate_combinations(count) for count in topic_count.values())\n        invalid_difficulty_combinations = sum(calculate_combinations(count) for count in difficulty_count.values())\n        invalid_topic_difficulty_combinations = sum(calculate_combinations(count) for count in topic_difficulty_count.values())\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n for the number of problems, followed by n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"Count the number of problems for each topic. For each topic with at least 3 problems, calculate the number of ways to choose 3 problems with the same topic using C(count, 3).\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"Count the number of problems for each difficulty. For each difficulty with at least 3 problems, calculate the number of ways to choose 3 problems with the same difficulty using C(count, 3).\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are not different.\",\n      \"details\": \"For each pair of topic and difficulty, count the number of problems with that specific topic and difficulty. If there are at least 3 such problems, calculate the number of ways to choose 3 problems with the same topic and difficulty using C(count, 3).\"\n    },\n    {\n      \"description\": \"Calculate the number of valid problem sets for each test case.\",\n      \"details\": \"Subtract the number of invalid sets (where all topics or all difficulties are the same) from the total number of sets. Add back the sets where both topics and difficulties are the same, as they were subtracted twice.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using the combination formula\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics' and 'difficulties'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria are based on these attributes. The goal is to select problems such that either all topics or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select precisely three problems for the problem set.\n    'at least one of two conditions': means that the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the number of ways to select problems with non-unique topics and non-unique difficulties should be considered simultaneously. This is because both calculations are needed to determine the invalid sets, which are then used to find the valid sets.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one way to select all three problems, and they satisfy both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 4\n       Explanation: All combinations of three problems satisfy at least one condition.\n    3. n = 5, problems = [(1, 1), (1, 2), (1, 3), (2, 1), (3, 1)] = 10\n       Explanation: All combinations of three problems satisfy at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the total combinations and subtracting invalid ones will handle these cases correctly.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        topic_difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            topic_difficulty_count[(a_i, b_i)] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = sum(calculate_combinations(count) for count in topic_count.values())\n        invalid_difficulty_combinations = sum(calculate_combinations(count) for count in difficulty_count.values())\n        invalid_topic_difficulty_combinations = sum(calculate_combinations(count) for count in topic_difficulty_count.values())\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        topic_difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            topic_difficulty_count[(a_i, b_i)] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = sum(calculate_combinations(count) for count in topic_count.values())\n        invalid_difficulty_combinations = sum(calculate_combinations(count) for count in difficulty_count.values())\n        invalid_topic_difficulty_combinations = sum(calculate_combinations(count) for count in topic_difficulty_count.values())\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same topic or all have the same difficulty.\",\n      \"output\": \"The number of invalid combinations where all three problems have the same topic or difficulty.\"\n    },\n    {\n      \"description\": \"Subtract the invalid combinations from the total combinations to get the number of valid combinations that satisfy at least one of the conditions.\",\n      \"output\": \"The number of valid ways to select three problems for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of ways to choose three problems using combinatorial mathematics (n choose 3).\",\n    \"For each test case, count the occurrences of each topic and each difficulty.\",\n    \"Calculate the number of invalid combinations where all three problems have the same topic or the same difficulty using the counts from the previous step.\",\n    \"Subtract the invalid combinations from the total combinations to get the valid combinations for each test case.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic' and 'difficulty'\n    Explanation: Each problem has a unique topic and difficulty, represented by integers. The selection criteria involve ensuring diversity in either topics or difficulties among the selected problems.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': We need to select exactly three problems from the given set.\n    'number of ways': This refers to calculating combinations, specifically the number of valid combinations of three problems that meet the criteria.\n\n# [degree adverb]\n    'different': This indicates that the selected problems must have different topics or difficulties.\n\n# [code logic]\n    The steps related to calculating total combinations and invalid combinations should be considered simultaneously. Specifically:\n    - Calculate total combinations using combinatorial mathematics (n choose 3).\n    - Count occurrences of each topic and difficulty.\n    - Calculate invalid combinations where all three problems have the same topic or difficulty.\n    These steps can be implemented in a single function that processes each test case.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with all topics and difficulties the same:\n    Input: 3\n           1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: No valid way to select three problems as they do not satisfy either condition.\n\n    Test case with maximum diversity:\n    Input: 3\n           1 2\n           2 3\n           3 1\n    Output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating combinations and subtracting invalid ones will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial mathematics to calculate the total number of combinations of three problems from n problems, which is C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid combinations where neither condition is satisfied.\",\n      \"steps\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"Calculate the number of combinations where all three problems have the same topic.\",\n        \"Calculate the number of combinations where all three problems have the same difficulty.\",\n        \"Calculate the number of combinations where all three problems have the same topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations where at least one condition is satisfied.\",\n      \"steps\": [\n        \"Subtract the number of invalid combinations from the total number of combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Print the number of valid combinations for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems from n problems using combinatorial mathematics.\",\n    \"For each test case, calculate the number of invalid combinations where neither condition is satisfied by counting the number of problems for each topic and difficulty.\",\n    \"Subtract the number of invalid combinations from the total number of combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems', 'topics', 'difficulties', 'combinations'\n    Explanation: The requirement involves selecting problems based on their topics and difficulties. The core task is to find combinations of problems that meet specific criteria regarding these attributes.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select combinations of three problems.\n    'at least one of two conditions': This means that the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are well-structured, but the calculation of invalid combinations (where neither condition is satisfied) should be considered simultaneously when counting combinations for the same topic and difficulty. This can be done in a single loop or function that checks both conditions.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one combination is possible, and it satisfies both conditions.\n    2. n = 3, problems = [(1, 1), (1, 2), (1, 3)] = 0\n       Explanation: All problems have the same topic, so no valid combination exists.\n    3. n = 4, problems = [(1, 1), (2, 2), (3, 3), (4, 4)] = 4\n       Explanation: All combinations of three problems satisfy at least one condition.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3, as the logic for larger n might not directly apply.\n    ```python\n    if n == 3:\n        # Directly check the conditions for the three problems\n        if (problems[0][0] != problems[1][0] or problems[0][0] != problems[2][0] or problems[1][0] != problems[2][0]) or \\\n           (problems[0][1] != problems[1][1] or problems[0][1] != problems[2][1] or problems[1][1] != problems[2][1]):\n            return 1\n        else:\n            return 0\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the number of problems and their respective topics and difficulties.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases, where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems, calculated using combinatorial mathematics (n choose 3).\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all three have the same topic.\",\n      \"output\": \"The number of combinations of three problems with the same topic for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all three have the same difficulty.\",\n      \"output\": \"The number of combinations of three problems with the same difficulty for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all three have the same topic and the same difficulty.\",\n      \"output\": \"The number of combinations of three problems with the same topic and difficulty for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, compute the number of valid combinations by subtracting invalid combinations (same topic or same difficulty) from the total combinations.\",\n      \"output\": \"The number of valid combinations of three problems for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of combinations of three problems using combinatorial mathematics.\",\n    \"For each test case, count the occurrences of each topic and each difficulty.\",\n    \"Calculate the number of invalid combinations where all three problems have the same topic.\",\n    \"Calculate the number of invalid combinations where all three problems have the same difficulty.\",\n    \"Calculate the number of invalid combinations where all three problems have the same topic and difficulty.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n \nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems', 'topics', 'difficulties'\n    Explanation: The requirement involves selecting problems based on their topics and difficulties. Each problem has a unique combination of topic and difficulty, and the goal is to select three problems such that either their topics or difficulties are all different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select precisely three problems from the list.\n    'at least one of two conditions': This means that the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to calculating invalid combinations (same topic, same difficulty, and both) should be considered simultaneously to ensure that the invalid combinations are correctly subtracted from the total combinations.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: All problems have different topics and difficulties, so there is exactly one valid combination.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No combination of three problems can satisfy the condition since there are only two unique topics and difficulties.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All problems have different topics and difficulties, allowing for multiple valid combinations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating total combinations and subtracting invalid ones will handle these cases correctly.\n\nNO", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_same_topic = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        invalid_same_difficulty = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Calculate invalid combinations where all three problems have the same topic and difficulty\n        invalid_same_topic_and_difficulty = 0\n        \n        for a_i, b_i in problems:\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_same_topic_and_difficulty += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_same_topic - invalid_same_difficulty + invalid_same_topic_and_difficulty\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 100)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_same_topic = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        invalid_same_difficulty = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Calculate invalid combinations where all three problems have the same topic and difficulty\n        invalid_same_topic_and_difficulty = 0\n        \n        for a_i, b_i in problems:\n            if topics[a_i] >= 2 and difficulties[b_i] >= 2:\n                invalid_same_topic_and_difficulty += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_same_topic - invalid_same_difficulty + invalid_same_topic_and_difficulty\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases, where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given problems.\",\n      \"output\": \"The total number of combinations of three problems for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all topics are different.\",\n      \"output\": \"The number of valid combinations of three problems with different topics for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all difficulties are different.\",\n      \"output\": \"The number of valid combinations of three problems with different difficulties for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems that do not satisfy either condition (all topics different or all difficulties different).\",\n      \"output\": \"The number of invalid combinations of three problems for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, subtract the number of invalid combinations from the total combinations to get the number of valid combinations.\",\n      \"output\": \"The number of valid ways to select three problems for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of combinations of three problems.\",\n    \"For each test case, calculate the number of combinations with all different topics.\",\n    \"For each test case, calculate the number of combinations with all different difficulties.\",\n    \"For each test case, calculate the number of invalid combinations that do not satisfy either condition.\",\n    \"Subtract the number of invalid combinations from the total combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics' and 'difficulties'\n    Explanation: Each problem has a topic and a difficulty, both represented by integers. The requirement is to select three problems such that either all topics are different or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select combinations of three problems from the given set.\n    'at least one of two conditions': This means that the selected problems must satisfy at least one of the conditions (different topics or different difficulties).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating combinations with different topics and different difficulties can be implemented simultaneously. Specifically, steps 3 and 4 can be combined into a single loop that checks both conditions for each combination of problems.\n\n# [edge case] \n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: There is only one way to select three problems, and it satisfies both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No combination of three problems can satisfy either condition.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3, as the logic for larger n might not directly apply.\n    ```python\n    if n == 3:\n        # Directly check if the only combination satisfies the conditions\n        if (problems[0][0] != problems[1][0] != problems[2][0]) or (problems[0][1] != problems[1][1] != problems[2][1]):\n            return 1\n        else:\n            return 0\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                same_topic_combinations += comb(count, 3)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                same_difficulty_combinations += comb(count, 3)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_topic_difficulty_combinations = 0\n        for a_i, b_i in problems:\n            same_topic_difficulty_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Calculate valid combinations\n        valid_combinations = total_combinations - same_topic_combinations - same_difficulty_combinations + same_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 108)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                same_topic_combinations += comb(count, 3)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                same_difficulty_combinations += comb(count, 3)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_topic_difficulty_combinations = 0\n        for a_i, b_i in problems:\n            same_topic_difficulty_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Calculate valid combinations\n        valid_combinations = total_combinations - same_topic_combinations - same_difficulty_combinations + same_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": [\n        \"Use combinatorial logic to calculate the number of ways to choose 3 problems from n, which is C(n, 3) = n * (n-1) * (n-2) / 6.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are different.\",\n      \"details\": [\n        \"Count the frequency of each topic.\",\n        \"Use combinatorial logic to calculate the number of ways to choose 3 different topics.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are different.\",\n      \"details\": [\n        \"Count the frequency of each difficulty.\",\n        \"Use combinatorial logic to calculate the number of ways to choose 3 different difficulties.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that satisfy at least one of the conditions.\",\n      \"details\": [\n        \"Subtract the number of ways where neither condition is satisfied from the total number of ways to select 3 problems.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems from n problems.\",\n    \"For each test case, calculate the number of ways to select three problems where all topics are different.\",\n    \"For each test case, calculate the number of ways to select three problems where all difficulties are different.\",\n    \"For each test case, calculate the number of ways to select three problems that satisfy at least one of the conditions.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic': Refers to the subject matter of a problem, represented by an integer from 1 to n.\n    'difficulty': Refers to the level of challenge of a problem, represented by an integer from 1 to n.\n    'different': Indicates that the selected problems must have distinct topics or difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': Means that we need to select precisely three problems.\n    'at least one': Means that the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the number of ways to select three problems where all topics are different and where all difficulties are different can be implemented simultaneously. This can be done by iterating through the list of problems once to count frequencies and then applying combinatorial logic to both topics and difficulties.\n\n# [edge case]\n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n    \n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 0\n    Explanation: No way to select three problems that satisfy either condition.\n    \n    Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where neither condition is satisfied.\n    This can be done by calculating the number of ways where neither condition is satisfied and subtracting it from the total number of ways to select three problems.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways where all topics are different\n        topic_ways = 0\n        for count in topics.values():\n            if count >= 3:\n                topic_ways += comb(count, 3)\n        \n        # Ways where all difficulties are different\n        difficulty_ways = 0\n        for count in difficulties.values():\n            if count >= 3:\n                difficulty_ways += comb(count, 3)\n        \n        # Ways where neither condition is satisfied\n        neither_ways = 0\n        for a_i, b_i in problems:\n            neither_ways += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Calculate the number of ways satisfying at least one condition\n        valid_ways = total_ways - neither_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways where neither condition is satisfied\n        neither_ways = 0\n        for a_i, b_i in problems:\n            neither_ways += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Calculate the number of ways satisfying at least one condition\n        valid_ways = total_ways - neither_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": [\n        \"Use combinatorial mathematics to calculate the number of ways to choose 3 problems from n, which is given by the combination formula C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where all three problems have the same topic or the same difficulty.\",\n      \"details\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"For each topic, calculate the number of ways to choose 3 problems with the same topic using C(count_topic, 3).\",\n        \"For each difficulty, calculate the number of ways to choose 3 problems with the same difficulty using C(count_difficulty, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid selections by subtracting invalid selections from total selections.\",\n      \"details\": [\n        \"Subtract the number of invalid selections from the total number of selections to get the number of valid selections.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of valid selections for each test case.\",\n      \"details\": [\n        \"Print the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial mathematics.\",\n    \"Count the number of problems for each topic and difficulty.\",\n    \"Calculate the number of invalid selections where all three problems have the same topic or the same difficulty.\",\n    \"Subtract the number of invalid selections from the total number of selections to get the number of valid selections.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either different topics or different difficulties, or both. This means that for a valid selection, at least one of these criteria must be met.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This indicates that we need to select precisely three problems from the given set.\n    'number of ways': This refers to calculating combinations, specifically using combinatorial mathematics to determine how many different sets of three problems can be formed.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to counting invalid selections for topics and difficulties should be considered simultaneously. Specifically:\n    - \"Count the number of problems for each topic and difficulty.\"\n    - \"Calculate the number of ways to choose 3 problems with the same topic using C(count_topic, 3).\"\n    - \"Calculate the number of ways to choose 3 problems with the same difficulty using C(count_difficulty, 3).\"\n    These steps can be implemented in a single loop that iterates over the problems to count occurrences and calculate invalid combinations.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected output: 1\n    Explanation: Only one way to select three problems, and they all have different topics and difficulties.\n\n    Test case with all problems having the same topic:\n    Input: 4\n           1 1\n           1 2\n           1 3\n           1 4\n    Expected output: 0\n    Explanation: No valid selection since all problems have the same topic.\n\n    Test case with all problems having the same difficulty:\n    Input: 4\n           1 1\n           2 1\n           3 1\n           4 1\n    Expected output: 0\n    Explanation: No valid selection since all problems have the same difficulty.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all problems have the same topic or difficulty.\n    Code for handling the edge case:\n    ```python\n    if count_topic == n or count_difficulty == n:\n        return 0\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            problems.append((a_i, b_i))\n        \n        # Total ways to choose 3 problems\n        total_ways = comb(n, 3)\n        \n        # Calculate invalid ways\n        invalid_ways = 0\n        \n        for a_i, b_i in problems:\n            # For each problem, calculate the number of invalid combinations\n            # that include this problem and two others with the same topic or difficulty\n            invalid_ways += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid ways are total ways minus invalid ways\n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of problems.\",\n        \"For each problem, read the integers a_i and b_i representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial formula to calculate the total number of ways to choose 3 problems from n: C(n, 3) = n * (n - 1) * (n - 2) / 6.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where all topics or all difficulties are the same.\",\n      \"steps\": [\n        \"Count the frequency of each topic and each difficulty.\",\n        \"For each topic with frequency f, calculate the number of ways to choose 3 problems with the same topic: C(f, 3).\",\n        \"For each difficulty with frequency f, calculate the number of ways to choose 3 problems with the same difficulty: C(f, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid selections.\",\n      \"steps\": [\n        \"Subtract the number of invalid selections from the total number of ways to select 3 problems.\",\n        \"Ensure to add back the over-counted selections where both topics and difficulties are the same.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Print the number of valid selections for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems.\",\n    \"Count the frequency of each topic and difficulty to determine invalid selections.\",\n    \"Calculate the number of valid selections by subtracting invalid selections from the total.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either different topics or different difficulties, or both. This is crucial for determining valid combinations of problems.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means we need to select precisely three problems for the problemset.\n    'at least one': means that the selected problems must satisfy at least one of the conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the total number of ways to select three problems and counting invalid selections should be considered simultaneously. Specifically, while calculating the total combinations, invalid selections should be subtracted in the same logical block to ensure accurate results.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with all problems having the same topic:\n    Input: 4\n           1 1\n           1 2\n           1 3\n           1 4\n    Expected output: 0\n    Explanation: No valid selection as all topics are the same.\n\n    Test case with all problems having the same difficulty:\n    Input: 4\n           1 1\n           2 1\n           3 1\n           4 1\n    Expected output: 0\n    Explanation: No valid selection as all difficulties are the same.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that when counting invalid selections, we correctly handle cases where all topics or all difficulties are the same.\n    ```\n    if n < 3:\n        print(0)\n    else:\n        # Calculate total combinations\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Count frequencies of topics and difficulties\n        topic_count = Counter(topics)\n        difficulty_count = Counter(difficulties)\n        \n        # Calculate invalid combinations\n        invalid_combinations = sum(f * (f - 1) * (f - 2) // 6 for f in topic_count.values())\n        invalid_combinations += sum(f * (", "Round_0": {"code": "import sys\nfrom collections import Counter\n\ndef calculate_valid_selections(n, problems):\n    if n < 3:\n        return 0\n    \n    # Calculate total combinations\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count frequencies of topics and difficulties\n    topics = [problem[0] for problem in problems]\n    difficulties = [problem[1] for problem in problems]\n    \n    topic_count = Counter(topics)\n    difficulty_count = Counter(difficulties)\n    \n    # Calculate invalid combinations\n    invalid_combinations = sum(f * (f - 1) * (f - 2) // 6 for f in topic_count.values() if f >= 3)\n    invalid_combinations += sum(f * (f - 1) * (f - 2) // 6 for f in difficulty_count.values() if f >= 3)\n    \n    # Calculate valid combinations\n    valid_combinations = total_combinations - invalid_combinations\n    \n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            problems.append((a_i, b_i))\n            index += 2\n        \n        result = calculate_valid_selections(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 92)"}, "Round_1": {"code": "import sys\nfrom collections import Counter\n\ndef calculate_valid_selections(n, problems):\n    if n < 3:\n        return 0\n    \n    # Calculate total combinations\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count frequencies of topics and difficulties\n    topics = [problem[0] for problem in problems]\n    difficulties = [problem[1] for problem in problems]\n    \n    topic_count = Counter(topics)\n    difficulty_count = Counter(difficulties)\n    \n    # Calculate invalid combinations\n    invalid_combinations = sum(f * (f - 1) * (f - 2) // 6 for f in topic_count.values() if f >= 3)\n    invalid_combinations += sum(f * (f - 1) * (f - 2) // 6 for f in difficulty_count.values() if f >= 3)\n    \n    # Calculate over-counted combinations where both topic and difficulty are the same\n    over_counted_combinations = 0\n    for a, b in problems:\n        over_counted_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n    \n    # Calculate valid combinations\n    valid_combinations = total_combinations - invalid_combinations + over_counted_combinations\n    \n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            problems.append((a_i, b_i))\n            index += 2\n        \n        result = calculate_valid_selections(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial mathematics to calculate the total number of combinations of three problems from n problems, which is C(n, 3) = n * (n - 1) * (n - 2) / 6.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid combinations where neither condition is satisfied.\",\n      \"steps\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"For each topic, calculate the number of ways to select three problems with the same topic.\",\n        \"For each difficulty, calculate the number of ways to select three problems with the same difficulty.\",\n        \"Subtract the number of invalid combinations from the total number of combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of valid combinations for each test case.\",\n      \"steps\": [\n        \"For each test case, output the number of valid combinations calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems from n problems using combinatorial mathematics.\",\n    \"For each test case, calculate the number of invalid combinations where neither condition is satisfied by counting problems with the same topic and difficulty.\",\n    \"Subtract the number of invalid combinations from the total number of combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic' and 'difficulty'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria are based on these attributes. The goal is to select problems such that either all topics or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems for the problemset.\n    'number of ways': refers to calculating the different combinations possible to select the problems.\n    'at least one': means that the selection must satisfy at least one of the given conditions (topics or difficulties being different).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating the total number of combinations and invalid combinations should be considered simultaneously. \n    Explanation: Calculating the total combinations and invalid combinations are interdependent processes. We need to first calculate the total combinations and then subtract the invalid ones to get the valid combinations.\n\n# [edge case] \n    Test case with minimum n = 3:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems, and it satisfies both conditions.\n\n    Test case with all problems having the same topic:\n    Input: 3\n           1 2\n           1 3\n           1 4\n    Output: 0\n    Explanation: No valid combinations as all topics are the same.\n\n    Test case with all problems having the same difficulty:\n    Input: 3\n           1 1\n           2 1\n           3 1\n    Output: 0\n    Explanation: No valid combinations as all difficulties are the same.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: We need to ensure that the logic correctly handles cases where all topics or difficulties are the same, resulting in zero valid combinations.\n    Code for handling the edge case:\n    ```python\n    if n < 3:\n        print(0)\n    else:\n        # Calculate total combinations and subtract invalid ones\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        # Logic to calculate invalid combinations based on topics and difficulties\n        # Subtract invalid_combinations from total_combinations\n    ```\n\n", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = {}\n        difficulties = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topics:\n                topics[a] = 0\n            if b not in difficulties:\n                difficulties[b] = 0\n            \n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains a list of problems with their respective topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same topic or all have the same difficulty.\",\n      \"output\": \"The number of invalid combinations where all three problems have the same topic or difficulty.\"\n    },\n    {\n      \"description\": \"Subtract the number of invalid combinations from the total combinations to get the number of valid combinations for each test case.\",\n      \"output\": \"The number of valid ways to select three problems for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format, separating the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to choose three problems using the combination formula C(n, 3).\",\n    \"For each test case, count the occurrences of each topic and each difficulty among the problems.\",\n    \"Calculate the number of invalid combinations where all three problems have the same topic or the same difficulty using the counts from the previous step.\",\n    \"Subtract the number of invalid combinations from the total combinations to get the number of valid combinations for each test case.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics' and 'difficulties'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria for the problemset are based on these attributes. The goal is to select problems such that either all topics or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select precisely three problems from the list.\n    'at least one of two conditions': This means that the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to calculate the total combinations and subtract invalid combinations should be considered simultaneously. Specifically, after calculating the total combinations, the invalid combinations should be subtracted immediately to get the valid combinations for each test case.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: There is only one way to select all three problems, and they satisfy both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: Any selection of three problems will have either the same topic or the same difficulty.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All problems have different topics and difficulties, so all combinations are valid.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating total combinations and subtracting invalid ones will handle these cases correctly.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n for the number of problems, followed by n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"Count the number of problems for each topic. For each topic with at least 3 problems, calculate the number of ways to choose 3 problems with the same topic using C(count, 3).\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"Count the number of problems for each difficulty. For each difficulty with at least 3 problems, calculate the number of ways to choose 3 problems with the same difficulty using C(count, 3).\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are not different.\",\n      \"details\": \"For each pair of topic and difficulty, count the number of problems with that specific topic and difficulty. If there are at least 3 such problems, calculate the number of ways to choose 3 problems with the same topic and difficulty using C(count, 3).\"\n    },\n    {\n      \"description\": \"Calculate the number of valid problem sets for each test case.\",\n      \"details\": \"Subtract the number of invalid sets (where all topics or all difficulties are the same) from the total number of sets. Add back the sets where both topics and difficulties are the same, as they were subtracted twice.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using the combination formula\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics' and 'difficulties'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria are based on these attributes. The goal is to select problems such that either all topics or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select precisely three problems for the problem set.\n    'at least one of two conditions': means that the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the number of ways to select problems with non-unique topics and non-unique difficulties should be considered simultaneously. This is because both calculations are needed to determine the invalid sets, which are then used to find the valid sets.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one way to select all three problems, and they satisfy both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 4\n       Explanation: All combinations of three problems satisfy at least one condition.\n    3. n = 5, problems = [(1, 1), (1, 2), (1, 3), (2, 1), (3, 1)] = 10\n       Explanation: All combinations of three problems satisfy at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the total combinations and subtracting invalid ones will handle these cases correctly.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        topic_difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            topic_difficulty_count[(a_i, b_i)] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = sum(calculate_combinations(count) for count in topic_count.values())\n        invalid_difficulty_combinations = sum(calculate_combinations(count) for count in difficulty_count.values())\n        invalid_topic_difficulty_combinations = sum(calculate_combinations(count) for count in topic_difficulty_count.values())\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        topic_difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            topic_difficulty_count[(a_i, b_i)] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = sum(calculate_combinations(count) for count in topic_count.values())\n        invalid_difficulty_combinations = sum(calculate_combinations(count) for count in difficulty_count.values())\n        invalid_topic_difficulty_combinations = sum(calculate_combinations(count) for count in topic_difficulty_count.values())\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_topic_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [false, false, false, false, true, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 98, "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 27}
