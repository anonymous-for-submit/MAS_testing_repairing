{"name": "1594_D. The Number of Imposters", "description": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "tags": ["constructive algorithms", "dfs and similar", "dp", "dsu", "graphs"], "difficulty": 10, "id": 1594, "sample_io": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}], "test_list": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n9\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n10 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n9\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n1 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n4 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n10 0\n", "output": ["4\n3\n-1\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n3\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n2\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n5\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 3 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["-1\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n15 0\n", "output": ["2\n4\n1\n-1\n15\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n6 0\n", "output": ["2\n3\n1\n-1\n6\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n6\n-1\n2\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n2\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n5 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n4\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n3\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n6\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n2\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n1\n-1\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n1\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n-1\n1\n-1\n7\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n-1\n1\n-1\n5\n"]}, {"input": "5\n8 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["7\n4\n2\n-1\n2\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["5\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 4 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n4\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n3\n-1\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["3\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n5\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n1 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n2 2 crewmate\n1 2 imposter\n2 0\n", "output": ["2\n4\n1\n2\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n8\n-1\n2\n5\n"]}, {"input": "5\n10 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["9\n8\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n2\n5\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n-1\n2\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 1 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n-1\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 2 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n-1\n5\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n1\n2\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n2\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n3 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 3 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 5 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n3 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n3 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n7 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 3 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n1 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 1 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}], "task_id": "codecontest/54", "repair_prompt": ["Assist Theofanis in determining the maximum impostor count amongst other Cypriot participants, or conclude that the statements are inconsistent (see notes for additional details).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Assist Theofanis in determining the maximum impostor count. He needs to assess this amongst other Cypriot participants, or conclude that the statements are inconsistent (see notes for additional details).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Assist Theofanis in determining the maximum impostor count amongst other Cypriot participants, or conclude that the statements are inconsistent (see notes for additional details).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        is_consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, 'imposter' if role == 'imposter' else 'crewmate'))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        type = [-1] * (n + 1)  # -1: unknown, 0: crewmate, 1: imposter\n        \n        def find(x):\n            if parent[x] != x:\n                original_parent = parent[x]\n                parent[x] = find(parent[x])\n                type[x] = type[x] ^ type[original_parent]\n            return parent[x]\n        \n        def union(x, y, relation):\n            root_x = find(x)\n            root_y = find(y)\n            \n            if root_x == root_y:\n                if type[x] ^ type[y] != relation:\n                    return False\n                return True\n            \n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n                type[root_y] = type[x] ^ type[y] ^ relation\n            elif rank[root_x] < rank[root_y]:\n                parent[root_x] = root_y\n                type[root_x] = type[x] ^ type[y] ^ relation\n            else:\n                parent[root_y] = root_x\n                type[root_y] = type[x] ^ type[y] ^ relation\n                rank[root_x] += 1\n            \n            return True\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            relation = 1 if c == \"imposter\" else 0\n            \n            if not union(i, j, relation):\n                contradiction = True\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = 0\n            visited = [False] * (n + 1)\n            \n            for i in range(1, n + 1):\n                root = find(i)\n                if not visited[root]:\n                    visited[root] = True\n                    count_crewmate = sum(type[j] == 0 for j in range(1, n +\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        is_consistent = True\n        max_imposters = 0\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        return False, 0, 0\n                    continue\n                \n                color[node] = col\n                if col == 1:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    queue.append((neighbor, col ^ relation))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                consistent, imposters, crewmates = bfs(player)\n                if not consistent:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        is_bipartite = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_color = {start: 0}\n            imposters_count = [0, 0]\n            \n            while queue:\n                node, col = queue.popleft()\n                imposters_count[col] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col ^ relation\n                    if neighbor in local_color:\n                        if local_color[neighbor] != expected_color:\n                            return False, 0\n                    else:\n                        local_color[neighbor] = expected_color\n                        queue.append((neighbor, expected_color))\n            \n            return True, max(imposters_count)\n        \n        total_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                is_bipartite, max_imposters = bfs(player)\n                if not is_bipartite:\n                    total_imposters = -1\n                    break\n                total_imposters += max_imposters\n        \n        results.append(total_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        consistent = True\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    consistent = False\n                    break\n                max_imposters += result\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # No comments, all can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        # Graph to store relationships\n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        # To store the color of each node, -1 means unvisited\n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, col = queue.popleft()\n                count[col] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        consistent = True\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    consistent = False\n                    break\n                max_imposters += result\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def dfs(node, col):\n            if node in color:\n                return color[node] == col\n            color[node] = col\n            for neighbor, relation in graph[node]:\n                if relation == 'imposter':\n                    if not dfs(neighbor, 1 - col):\n                        return False\n                else:  # relation == 'crewmate'\n                    if not dfs(neighbor, col):\n                        return False\n            return True\n        \n        is_consistent = True\n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                count = [0, 0]\n                stack = [(player, 0)]\n                while stack:\n                    node, col = stack.pop()\n                    if node in color:\n                        if color[node] != col:\n                            is_consistent = False\n                            break\n                        continue\n                    color[node] = col\n                    count[col] += 1\n                    for neighbor, relation in graph[node]:\n                        if relation == 'imposter':\n                            stack.append((neighbor, 1 - col))\n                        else:  # relation == 'crewmate'\n                            stack.append((neighbor, col))\n                if not is_consistent:\n                    break\n                max_imposters += max(count)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # (node, role) where role 0 = imposter, 1 = crewmate\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return False, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 0:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 1 - role))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                is_consistent, imposters, crewmates = bfs(player)\n                if not is_consistent:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.color = [-1] * n  # -1 means uncolored, 0 and 1 are two different colors\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.color[u] == self.color[v] and relation == \"imposter\":\n                return False\n            if self.color[u] != self.color[v] and relation == \"crewmate\":\n                return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] ^ (relation == \"imposter\")\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] ^ (relation == \"imposter\")\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] ^ (relation == \"imposter\")\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n\n        uf = UnionFind(n + 1)  # +1 because players are 1-indexed\n\n        contradiction = False\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            index += 1\n\n            if uf.color[i] == -1:\n                uf.color[i] = 0  # Arbitrarily color the first node\n\n            if uf.color[j] == -1:\n                uf.color[j] = uf.color[i] ^ (c == \"imposter\")\n\n            if\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        is_consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, 'imposter' if role == 'imposter' else 'crewmate'))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by m lines of comments in the format 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph where each player is a node and each comment is an edge with a label (imposter or crewmate).\",\n      \"details\": \"Create a graph representation for each test case where nodes represent players and edges represent comments between players with labels indicating the relationship.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"details\": \"Use a graph traversal technique (e.g., DFS or BFS) to check for contradictions. If a contradiction is found, mark the test case as inconsistent.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters for each consistent test case.\",\n      \"details\": \"For each connected component in the graph, determine the maximum number of imposters by considering possible assignments of roles (imposter or crewmate) to nodes, ensuring no contradictions.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters if consistent, otherwise output -1 if contradictions are found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store results for each test case.\",\n    \"For each test case, parse the input to extract n, m, and the list of comments.\",\n    \"Construct a graph where nodes are players and edges are comments with labels.\",\n    \"Perform a graph traversal to detect contradictions. If a contradiction is found, append -1 to the results list.\",\n    \"If no contradictions are found, calculate the maximum number of imposters using a strategy to maximize imposters in each connected component.\",\n    \"Append the calculated maximum number of imposters to the results list.\",\n    \"After processing all test cases, output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter count'\n    Explanation: The requirement is to determine the maximum number of imposters among the players based on the comments provided. An imposter is a player who is lying about the identity of other players.\n\n    'contradict'\n    Explanation: A contradiction occurs when the comments about players are inconsistent, meaning they cannot logically coexist. For example, if one player claims another is an imposter, but that player claims the first is a crewmate, it creates a logical inconsistency.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This refers to finding the highest number of imposters that can be assigned without contradictions. In code, this involves maximizing the count of imposters in each connected component of the graph.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the largest possible number of imposters. In code, this involves calculating the maximum number of imposters that can be assigned to players without contradictions.\n\n# [code logic]\n    The steps related to graph construction and contradiction detection should be implemented simultaneously. Specifically:\n    - \"Construct a graph where nodes are players and edges are comments with labels.\"\n    - \"Perform a graph traversal to detect contradictions.\"\n    These can be done in a single traversal of the graph where nodes are assigned roles and checked for contradictions.\n\n# [edge case]\n    Test case with no comments: \n    Input: 5 0\n    Expected output: 5\n    Explanation: With no comments, all players can be imposters since there are no contradictions.\n\n    Test case with contradictory comments:\n    Input: 2 2\n    1 2 imposter\n    2 1 crewmate\n    Expected output: -1\n    Explanation: The comments contradict each other, so the output should be -1.\n\n    Test case with all players as crewmates:\n    Input: 3 3\n    1 2 crewmate\n    2 3 crewmate\n    1 3 crewmate\n    Expected output: 0\n    Explanation: All players are crewmates, so no imposters can be assigned.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case with no comments, initialize the imposter count to n.\n    - For detecting contradictions, implement a graph traversal that checks for logical inconsistencies.\n    ```python\n    def", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        is_consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, 'imposter' if role == 'imposter' else 'crewmate'))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 157)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        is_consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, 'imposter' if role == 'imposter' else 'crewmate'))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each of the m comments, read the integers i, j and the string c representing the comment structure.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or identify contradictions in comments.\",\n      \"steps\": [\n        \"Initialize data structures to represent players and their relationships based on comments.\",\n        \"For each comment, update the relationship between players i and j based on the comment c.\",\n        \"Check for contradictions in comments by verifying consistency in relationships.\",\n        \"Calculate the maximum number of imposters if no contradictions are found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if contradictions are found, output -1.\",\n        \"Otherwise, output the maximum number of imposters calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"For each test case, build a graph or data structure to represent player relationships based on comments.\",\n    \"Check for contradictions in the comments using the graph or data structure.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate', 'contradiction'\n    Explanation: The core concept revolves around determining the maximum number of imposters among players based on comments. An 'imposter' is a player who is lying, while a 'crewmate' is telling the truth. A 'contradiction' occurs when comments about the same players are inconsistent, making it impossible to determine the imposters.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of imposters that can be logically deduced from the comments without contradictions.\n    Implementation: This involves iterating through possible configurations and ensuring no contradictions exist, then counting the imposters.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the largest possible number of imposters.\n    Implementation: Use a method to explore all possible configurations and select the one with the highest count of imposters.\n\n# [code logic]\n    The steps related to checking for contradictions and calculating the maximum number of imposters should be implemented simultaneously. This can be done by iterating through the comments and updating relationships while checking for contradictions in a single pass.\n\n# [edge case]\n    1. Test case with no comments (e.g., 5 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n       Explanation: The comments contradict each other, so it's impossible to determine imposters.\n    3. Test case with all players as crewmates (e.g., 3 2 with comments \"1 2 crewmate\" and \"2 3 crewmate\") = 0\n       Explanation: If all comments indicate crewmates, then no imposters can be deduced.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a graph or union-find structure to track relationships and detect contradictions.\n    - Use a depth-first search (DFS) or breadth-first search (BFS) to explore possible configurations and count imposters.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        # Union-Find with additional information for contradiction detection\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        type = [-1] * (n + 1)  # -1: unknown, 0: crewmate, 1: imposter\n        \n        def find(x):\n            if parent[x] != x:\n                original_parent = parent[x]\n                parent[x] = find(parent[x])\n                type[x] = type[x] ^ type[original_parent]\n            return parent[x]\n        \n        def union(x, y, relation):\n            root_x = find(x)\n            root_y = find(y)\n            \n            if root_x == root_y:\n                if type[x] ^ type[y] != relation:\n                    return False\n                return True\n            \n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n                type[root_y] = type[x] ^ type[y] ^ relation\n            elif rank[root_x] < rank[root_y]:\n                parent[root_x] = root_y\n                type[root_x] = type[x] ^ type[y] ^ relation\n            else:\n                parent[root_y] = root_x\n                type[root_y] = type[x] ^ type[y] ^ relation\n                rank[root_x] += 1\n            \n            return True\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            relation = 1 if c == \"imposter\" else 0\n            \n            if not union(i, j, relation):\n                contradiction = True\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = 0\n            visited = [False] * (n + 1)\n            \n            for i in range(1, n + 1):\n                root = find(i)\n                if not visited[root]:\n                    visited[root] = True\n                    count_crewmate = sum(type[j]", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 75)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        type = [-1] * (n + 1)  # -1: unknown, 0: crewmate, 1: imposter\n        \n        def find(x):\n            if parent[x] != x:\n                original_parent = parent[x]\n                parent[x] = find(parent[x])\n                type[x] = type[x] ^ type[original_parent]\n            return parent[x]\n        \n        def union(x, y, relation):\n            root_x = find(x)\n            root_y = find(y)\n            \n            if root_x == root_y:\n                if type[x] ^ type[y] != relation:\n                    return False\n                return True\n            \n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n                type[root_y] = type[x] ^ type[y] ^ relation\n            elif rank[root_x] < rank[root_y]:\n                parent[root_x] = root_y\n                type[root_x] = type[x] ^ type[y] ^ relation\n            else:\n                parent[root_y] = root_x\n                type[root_y] = type[x] ^ type[y] ^ relation\n                rank[root_x] += 1\n            \n            return True\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            relation = 1 if c == \"imposter\" else 0\n            \n            if not union(i, j, relation):\n                contradiction = True\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = 0\n            visited = [False] * (n + 1)\n            \n            for i in range(1, n + 1):\n                root = find(i)\n                if not visited[root]:\n                    visited[root] = True\n                    count_crewmate = sum(type[j] == 0 for j in range(1, n +"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, players, comments, and the details of each comment.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each comment, read integers i, j and string c representing the players involved and the type of comment.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or identify contradictions in comments.\",\n      \"steps\": [\n        \"Model the problem as a graph where players are nodes and comments are edges with labels 'imposter' or 'crewmate'.\",\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n        \"Check for contradictions during traversal: if a node needs to be colored differently than expected, mark the test case as inconsistent.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters for consistent test cases.\",\n      \"steps\": [\n        \"For each connected component of the graph, calculate the maximum number of imposters by considering both possible colorings.\",\n        \"Sum the maximum imposters from all components to get the result for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters or -1 if the comments are inconsistent.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"For each test case, construct a graph based on players and comments.\",\n    \"Attempt to color the graph using a two-coloring method to identify imposters and crewmates.\",\n    \"Detect contradictions during graph coloring and mark inconsistent test cases.\",\n    \"Calculate the maximum number of imposters for consistent test cases.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the context of the problem, 'imposter' and 'crewmate' are labels used to describe the relationship between players. An 'imposter' is someone who is not truthful, while a 'crewmate' is truthful. The goal is to determine the maximum number of imposters based on the comments provided.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters'\n    Explanation: This phrase indicates that we need to find the highest count of players labeled as imposters based on the comments, without contradictions. In code, this involves calculating the maximum imposters in each connected component of the graph.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The term 'maximum' refers to the highest possible count of imposters that can be determined from the comments without contradictions. In code, this is implemented by evaluating both possible colorings of each graph component and choosing the one with the higher imposter count.\n\n# [code logic]\n    The steps related to graph traversal and contradiction detection should be implemented simultaneously.\n    \"Model the problem as a graph where players are nodes and comments are edges with labels 'imposter' or 'crewmate'.\",\n    \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n    \"Check for contradictions during traversal: if a node needs to be colored differently than expected, mark the test case as inconsistent.\"\n    These steps can be implemented in a single traversal function that colors the graph and checks for contradictions.\n\n# [edge case]\n    Test case with no comments: \n    Input: 5 0\n    Expected output: 5\n    Explanation: With no comments, all players can be imposters, so the maximum number of imposters is equal to the number of players.\n\n    Test case with contradictory comments:\n    Input: 2 2\n    1 2 imposter\n    2 1 crewmate\n    Expected output: -1\n    Explanation: The comments contradict each other, so the output should be -1.\n\n    Test case with all players as crewmates:\n    Input: 3 3\n    1 2 crewmate\n    2 3 crewmate\n    1 3 crewmate\n    Expected output: 0\n    Explanation: All players", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        is_consistent = True\n        max_imposters = 0\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        return False, 0, 0\n                    continue\n                \n                color[node] = col\n                if col == 1:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    queue.append((neighbor, col ^ relation))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                consistent, imposters, crewmates = bfs(player)\n                if not consistent:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 111)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        is_consistent = True\n        max_imposters = 0\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        return False, 0, 0\n                    continue\n                \n                color[node] = col\n                if col == 1:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    queue.append((neighbor, col ^ relation))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                consistent, imposters, crewmates = bfs(player)\n                if not consistent:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by m comments of the form 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph problem.\",\n      \"details\": \"Consider each player as a node in a graph. Each comment 'i j c' represents an edge between nodes i and j with a label 'c' indicating the relationship (imposter or crewmate).\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments.\",\n      \"details\": \"Use a graph traversal technique (e.g., DFS or BFS) to check for contradictions. If a contradiction is found, mark the test case as inconsistent and output -1.\"\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters.\",\n      \"details\": \"For each connected component of the graph, calculate the maximum number of imposters by considering two scenarios: starting with a node as an imposter or as a crewmate. Use a bipartite graph coloring approach to ensure no contradictions.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters or -1 if contradictions are found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read n and m, then read the m comments.\",\n    \"Construct a graph where nodes represent players and edges represent comments.\",\n    \"Traverse the graph to detect contradictions using a bipartite graph coloring approach.\",\n    \"For each connected component, calculate the maximum number of imposters by considering both possible colorings.\",\n    \"Output the maximum number of imposters for each test case, or -1 if a contradiction is detected.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maximum impostor count'\n    Explanation: The requirement is to find the highest possible number of impostors among the players based on the given comments, while ensuring no contradictions arise.\n\n    'contradict'\n    Explanation: A contradiction occurs when the comments about players' roles conflict, making it impossible to determine a consistent set of impostors and crewmates.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This indicates the need to find the largest count of impostors that can be logically deduced from the comments without contradictions. In code, this involves calculating the maximum impostors in each connected component of the graph.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This requires finding the largest number of impostors possible, which can be implemented by evaluating both possible colorings of a bipartite graph and choosing the one with the higher impostor count.\n\n# [code logic]\n    The steps related to graph construction and contradiction detection should be implemented simultaneously. Specifically:\n    - \"Construct a graph where nodes represent players and edges represent comments.\"\n    - \"Traverse the graph to detect contradictions using a bipartite graph coloring approach.\"\n    These can be done in a single traversal of the graph using DFS or BFS to both build the graph and check for contradictions.\n\n# [edge case]\n    Test case with no comments (e.g., n = 5, m = 0) = 5\n    Explanation: With no comments, there are no contradictions, and all players can be impostors.\n\n    Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n    Explanation: The comments directly contradict each other, making it impossible to determine roles consistently.\n\n    Test case with all players commenting each other as impostors (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 3\n    Explanation: If all players claim each other are impostors, the maximum impostor count is equal to the number of players, assuming no contradictions arise.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that:\n    - If m = 0, return n as all players can be impostors.\n    - Implement a check for direct contradictions during graph traversal.\n    ```python\n    if m == 0:\n        print(n)\n    else", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        is_bipartite = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_color = {start: 0}\n            imposters_count = [0, 0]\n            \n            while queue:\n                node, col = queue.popleft()\n                imposters_count[col] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col ^ relation\n                    if neighbor in local_color:\n                        if local_color[neighbor] != expected_color:\n                            return False, 0\n                    else:\n                        local_color[neighbor] = expected_color\n                        queue.append((neighbor, expected_color))\n            \n            return True, max(imposters_count)\n        \n        total_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                is_bipartite, max_imposters = bfs(player)\n                if not is_bipartite:\n                    total_imposters = -1\n                    break\n                total_imposters += max_imposters\n        \n        results.append(total_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by m lines of comments in the format 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph where each player is a node and each comment is an edge with a label (imposter or crewmate).\",\n      \"details\": \"Create a graph representation for each test case where nodes represent players and edges represent comments between players with labels indicating the relationship.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"details\": \"Use a graph traversal method (e.g., DFS or BFS) to check for contradictions. If a contradiction is found, mark the test case as inconsistent.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters for each consistent test case.\",\n      \"details\": \"For each connected component in the graph, determine the maximum number of imposters by considering possible configurations of imposters and crewmates.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters if consistent, otherwise output -1 if contradictions are found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse the number of test cases.\",\n    \"For each test case, construct a graph based on the players and comments.\",\n    \"Traverse the graph to detect any contradictions in the comments.\",\n    \"If no contradictions are found, calculate the maximum number of imposters possible.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if inconsistent.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate', 'contradict'\n    Explanation: The core concepts revolve around determining the roles of players (imposter or crewmate) based on comments. A contradiction occurs when comments about the roles are inconsistent, making it impossible to determine the roles logically.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters': This means we need to find the highest count of players that can be imposters without contradictions.\n    Implementation: This can be implemented by exploring all possible configurations of imposters and crewmates in the graph and selecting the one with the highest number of imposters.\n\n# [degree adverb] \n    'maximum': This indicates the need to find the largest possible number of imposters.\n    Implementation: Use a graph traversal to explore configurations and keep track of the maximum number of imposters found.\n\n# [code logic]\n    The steps for detecting contradictions and calculating the maximum number of imposters should be considered simultaneously. \n    Implementation: While traversing the graph to detect contradictions, also calculate possible configurations of imposters and crewmates.\n\n# [edge case] \n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to determine roles logically.\n    \n    Test case with all players as crewmates (e.g., 3 2 with comments \"1 2 crewmate\" and \"2 3 crewmate\") = 0\n    Explanation: If all comments indicate crewmates, the maximum number of imposters is zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a check for no comments to directly return the number of players as imposters.\n    - Implement logic to detect contradictions during graph traversal.\n    - Handle cases where all players can be crewmates.\n\n```python\ndef handle_edge_cases(n, m, comments):\n    if m == 0:\n        return n\n    # Implement graph traversal to detect contradictions\n    # and calculate maximum imposters\n    # (other code)\n```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 157)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"For each test case, represent the players and their relationships based on comments using a graph structure.\",\n      \"details\": \"Use nodes to represent players and edges to represent comments. Each edge will have a label indicating whether the relationship is 'imposter' or 'crewmate'.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"details\": \"Implement a method to traverse the graph and check for inconsistencies in the comments. If a contradiction is found, mark the test case as inconsistent.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters for each test case without contradictions.\",\n      \"details\": \"Use a graph traversal technique (e.g., DFS or BFS) to determine the maximum number of imposters by considering the constraints given by the comments.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters or -1 if contradictions are found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels 'imposter' or 'crewmate'.\",\n    \"Implement a function to traverse the graph and detect any contradictions in the comments.\",\n    \"If no contradictions are found, calculate the maximum number of imposters using graph traversal techniques.\",\n    \"Output the calculated maximum number of imposters for each test case, or -1 if contradictions are detected.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the context of the problem, 'imposter' and 'crewmate' are labels used to describe the relationship between players. An 'imposter' is someone who is deceitful, while a 'crewmate' is truthful. These labels are used to determine the possible roles of players based on comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters'\n    Explanation: This phrase indicates that we need to find the highest number of players that can be classified as imposters without contradictions in the comments. This involves analyzing the graph structure to maximize the count of imposters.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The term 'maximum' refers to the largest possible count of imposters that can be determined from the given comments without any contradictions. In code, this can be implemented by traversing the graph and counting the imposters while ensuring consistency.\n\n# [code logic]\n    The steps related to graph construction and contradiction detection should be implemented simultaneously. Specifically, while constructing the graph, we can simultaneously check for contradictions by ensuring that no two connected nodes have conflicting labels ('imposter' vs 'crewmate').\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: If there are no comments, all players can potentially be imposters, as there are no constraints or contradictions.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to determine a consistent set of imposters.\n    \n    Test case with all players labeled as crewmates (e.g., 3 2 with comments \"1 2 crewmate\" and \"2 3 crewmate\") = 0\n    Explanation: If all players are labeled as crewmates, none can be imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to implement logic to detect contradictions during graph traversal and handle cases with no comments.\n    ```python\n    def detect_contradictions(graph):\n        # Implement logic to traverse the graph and detect contradictions\n        pass\n\n    def calculate_maximum_imposters(graph):\n        # Implement logic to calculate the maximum imposters without", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        consistent = True\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    consistent = False\n                    break\n                max_imposters += result\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 113)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        visited = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            visited[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = role ^ relation\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = expected_role\n                        count[expected_role] += 1\n                        queue.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        consistent = True\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    consistent = False\n                    break\n                max_imposters += result\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m from the first line, representing the number of players and comments respectively.\",\n        \"For each of the next m lines, read the integers i, j and the string c, representing a comment about players i and j.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or identify contradictions in comments.\",\n      \"steps\": [\n        \"Initialize a data structure to represent relationships between players based on comments.\",\n        \"For each comment, update the data structure to reflect the relationship (imposter or crewmate) between players i and j.\",\n        \"Check for contradictions in the comments. If a contradiction is found, mark the test case as inconsistent.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters for consistent test cases.\",\n      \"steps\": [\n        \"For consistent test cases, use the data structure to determine the maximum number of imposters possible.\",\n        \"Implement a strategy to maximize imposters while ensuring no contradictions arise.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if contradictions are found, output -1.\",\n        \"Otherwise, output the maximum number of imposters calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, player counts, and comments.\",\n    \"For each test case, build a relationship graph based on comments.\",\n    \"Detect contradictions in the graph and mark inconsistent test cases.\",\n    \"For consistent test cases, calculate the maximum number of imposters using graph traversal or coloring techniques.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: These terms are used to describe the roles of players in the game. An 'imposter' is a player who is pretending to be a crewmate but is actually working against the team. A 'crewmate' is a player who is genuinely part of the team and working towards the team's goals. The task is to determine the maximum number of imposters based on the comments provided.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters': This means we need to find the highest count of players that can be imposters without contradicting the given comments.\n    'contradict': This indicates a situation where the comments about players are inconsistent, making it impossible to determine the roles without conflict.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the largest possible number of imposters that can be determined from the comments without any contradictions.\n\n# [code logic]\n    The steps related to checking for contradictions and calculating the maximum number of imposters should be considered simultaneously. Specifically:\n    - \"Check for contradictions in the comments. If a contradiction is found, mark the test case as inconsistent.\"\n    - \"For consistent test cases, use the data structure to determine the maximum number of imposters possible.\"\n    These steps can be implemented together by traversing the relationship graph and using a coloring technique to ensure no contradictions while maximizing imposters.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players except Theofanis can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to determine roles without conflict.\n    3. Test case with all players being crewmates (e.g., 1 2 crewmate, 2 3 crewmate, 3 4 crewmate) = 0\n       Explanation: If all comments indicate players are crewmates, then no imposters can be determined.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case with no comments, we can directly return n as the number of imposters", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            # No comments, all can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        # Graph to store relationships\n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        # To store the color of each node, -1 means unvisited\n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue:\n                node, col = queue.popleft()\n                count[col] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1  # Contradiction found\n            \n            return max(count)\n        \n        max_imposters = 0\n        consistent = True\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    consistent = False\n                    break\n                max_imposters += result\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where players are nodes and comments are edges with labels indicating 'imposter' or 'crewmate'.\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Implement a method to detect contradictions in the comments by checking for inconsistencies in the graph (e.g., using a union-find data structure or graph coloring).\",\n      \"output\": \"A boolean indicating whether the comments are consistent or not for each test case.\"\n    },\n    {\n      \"description\": \"If the comments are consistent, calculate the maximum number of imposters possible by exploring the graph and determining the largest set of nodes that can be imposters.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    },\n    {\n      \"description\": \"Output the result for each test case: the maximum number of imposters or -1 if the comments are inconsistent.\",\n      \"output\": \"A list of results corresponding to each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels 'imposter' or 'crewmate'.\",\n    \"Check the graph for contradictions using a suitable method (e.g., union-find or graph coloring).\",\n    \"If no contradictions are found, calculate the maximum number of imposters by exploring the graph.\",\n    \"Store the result for each test case: either the maximum number of imposters or -1 if contradictions are found.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the context of the problem, \"imposter\" and \"crewmate\" are labels used to describe the relationship between players based on comments. An \"imposter\" is someone who is not truthful, while a \"crewmate\" is truthful. The task is to determine the maximum number of imposters based on these comments or identify contradictions.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This indicates that we need to find the highest count of imposters that can be logically deduced from the comments without contradictions.\n    Implementation: This can be implemented by exploring the graph to find the largest set of nodes that can be imposters.\n\n# [degree adverb]\n    'maximum': This refers to the largest possible count of imposters that can be determined from the comments.\n    Implementation: This can be implemented by using graph traversal techniques to explore all possible configurations and determine the largest valid set of imposters.\n\n# [code logic]\n    The steps related to graph construction and contradiction checking should be implemented simultaneously. Specifically:\n    - Constructing the graph and checking for contradictions can be done in a single pass using a union-find data structure or graph coloring to ensure consistency as edges are added.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, so the output should be -1.\n    3. Test case with all players being crewmates (e.g., 1 2 crewmate, 2 3 crewmate, 3 1 crewmate) = 0\n       Explanation: If all players are crewmates, then no imposters can exist, so the output should be 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case with no comments, simply return the number of players as imposters.\n    - For contradictory comments, use a union-find or graph coloring method to detect and handle contradictions.\n    - For cases where all players are crewmates, ensure the logic correctly identifies that no", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def dfs(node, col):\n            if node in color:\n                return color[node] == col\n            color[node] = col\n            for neighbor, relation in graph[node]:\n                if relation == 'imposter':\n                    if not dfs(neighbor, 1 - col):\n                        return False\n                else:  # relation == 'crewmate'\n                    if not dfs(neighbor, col):\n                        return False\n            return True\n        \n        is_consistent = True\n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                count = [0, 0]\n                stack = [(player, 0)]\n                while stack:\n                    node, col = stack.pop()\n                    if node in color:\n                        if color[node] != col:\n                            is_consistent = False\n                            break\n                        continue\n                    color[node] = col\n                    count[col] += 1\n                    for neighbor, relation in graph[node]:\n                        if relation == 'imposter':\n                            stack.append((neighbor, 1 - col))\n                        else:  # relation == 'crewmate'\n                            stack.append((neighbor, col))\n                if not is_consistent:\n                    break\n                max_imposters += max(count)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def dfs(node, col):\n            if node in color:\n                return color[node] == col\n            color[node] = col\n            for neighbor, relation in graph[node]:\n                if relation == 'imposter':\n                    if not dfs(neighbor, 1 - col):\n                        return False\n                else:  # relation == 'crewmate'\n                    if not dfs(neighbor, col):\n                        return False\n            return True\n        \n        is_consistent = True\n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                count = [0, 0]\n                stack = [(player, 0)]\n                while stack:\n                    node, col = stack.pop()\n                    if node in color:\n                        if color[node] != col:\n                            is_consistent = False\n                            break\n                        continue\n                    color[node] = col\n                    count[col] += 1\n                    for neighbor, relation in graph[node]:\n                        if relation == 'imposter':\n                            stack.append((neighbor, 1 - col))\n                        else:  # relation == 'crewmate'\n                            stack.append((neighbor, col))\n                if not is_consistent:\n                    break\n                max_imposters += max(count)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by m lines of comments in the format 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph where each player is a node and each comment is an edge with a label (imposter or crewmate).\",\n      \"details\": \"Create a graph representation for each test case where nodes represent players and edges represent comments between players with labels indicating the relationship.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"details\": \"Use a graph traversal method (e.g., DFS or BFS) to check for contradictions in the comments. If a contradiction is found, mark the test case as inconsistent.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters for each consistent test case.\",\n      \"details\": \"For each connected component in the graph, determine the maximum number of imposters by considering possible assignments of roles (imposter or crewmate) to nodes that satisfy all comments.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters if consistent, otherwise output -1 if contradictions are found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse the number of test cases.\",\n    \"For each test case, construct a graph based on the players and comments.\",\n    \"Traverse the graph to detect any contradictions in the comments.\",\n    \"If no contradictions are found, calculate the maximum number of imposters possible.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if inconsistent.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the context of the problem, \"imposter\" and \"crewmate\" are roles assigned to players. Comments between players indicate whether one player believes another is an imposter or a crewmate. The goal is to determine the maximum number of imposters possible without contradictions.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters': This means we need to find the highest count of players that can be imposters without any contradictions in the comments.\n    'if the comments contradict each other': This indicates a situation where the statements about roles are inconsistent, leading to an impossible scenario.\n\n# [degree adverb]\n    'maximum': This refers to finding the largest possible number of imposters that can be assigned without contradictions.\n    Implementation: This can be achieved by exploring all possible role assignments and selecting the one with the highest number of imposters.\n\n# [code logic]\n    The steps \"Traverse the graph to detect any contradictions in the comments\" and \"If no contradictions are found, calculate the maximum number of imposters possible\" should be implemented simultaneously. This can be done by performing a graph traversal (e.g., DFS or BFS) that simultaneously checks for contradictions and calculates the maximum imposters.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with a single contradiction (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The contradiction makes it impossible to assign roles consistently.\n    3. Test case with all players as crewmates (e.g., 1 2 crewmate, 2 3 crewmate, 3 1 crewmate) = 0\n       Explanation: If all players are crewmates, no imposters can exist.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to handle cases where there are no comments by defaulting to all players being imposters.\n    - We also need to ensure that contradictions are detected during graph traversal.\n\n    Example code for handling contradictions:\n    ```python\n    def detect_contradictions_and_calculate_max_imposters(graph):\n        # Initialize", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # (node, role) where role 0 = imposter, 1 = crewmate\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return False, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 0:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 1 - role))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                is_consistent, imposters, crewmates = bfs(player)\n                if not is_consistent:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # (node, role) where role 0 = imposter, 1 = crewmate\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return False, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 0:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 1 - role))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                is_consistent, imposters, crewmates = bfs(player)\n                if not is_consistent:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the relationships between players based on the comments. Use a graph or similar data structure where nodes represent players and edges represent the relationship (imposter or crewmate).\",\n      \"output\": \"A graph or equivalent data structure representing player relationships for each test case.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case. A contradiction occurs if there is a logical inconsistency in the relationships (e.g., a player is both an imposter and a crewmate).\",\n      \"output\": \"A boolean indicating whether a contradiction exists for each test case.\"\n    },\n    {\n      \"description\": \"If no contradictions are found, determine the maximum number of imposters possible for each test case. This involves analyzing the graph to find the largest set of players that can be imposters without contradicting the comments.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph or similar data structure to represent player relationships based on the comments.\",\n    \"Check the graph for contradictions. If a contradiction is found, mark the test case as inconsistent.\",\n    \"If no contradictions are found, analyze the graph to determine the maximum number of imposters possible.\",\n    \"Output the result for each test case: the maximum number of imposters or -1 if a contradiction is detected.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter', 'crewmate'\n    Explanation: In the context of the game, an \"imposter\" is a player who is pretending to be a crewmate but is actually working against the team. A \"crewmate\" is a player who is genuinely part of the team and is working towards the team's goals. The comments in the test cases describe relationships between players, indicating whether one player is an imposter or a crewmate relative to another.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters'\n    Explanation: This phrase indicates that the goal is to find the largest number of players that can be classified as imposters without any contradictions in the comments. In code, this involves analyzing the graph of player relationships to find the largest set of imposters.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The term \"maximum\" refers to the largest possible count of imposters that can be determined from the given comments without contradictions. In code, this involves finding the largest subset of players that can be imposters.\n\n# [code logic]\n    The steps related to constructing the graph and checking for contradictions should be implemented simultaneously. Specifically, while constructing the graph, you can immediately check for contradictions as you add each comment. This can be done using a union-find data structure or similar approach to efficiently manage and check relationships.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: If there are no comments, there are no contradictions, and all players can potentially be imposters.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, so the output should be -1.\n    \n    Test case with all players being imposters (e.g., 3 2 with comments \"1 2 imposter\" and \"2 3 imposter\") = 3\n    Explanation: There are no contradictions, and all players can be imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Implement a union-find data structure to efficiently manage player relationships and detect contradictions.\n    ```python\n    class UnionFind:\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n", "Round_0": {"code": "def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.color = [-1] * n  # -1 means uncolored, 0 and 1 are two different colors\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.color[u] == self.color[v] and relation == \"imposter\":\n                return False\n            if self.color[u] != self.color[v] and relation == \"crewmate\":\n                return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] ^ (relation == \"imposter\")\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] ^ (relation == \"imposter\")\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] ^ (relation == \"imposter\")\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n\n        uf = UnionFind(n + 1)  # +1 because players are 1-indexed\n\n        contradiction = False\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            index += 1\n\n            if uf.color[i] == -1:\n                uf.color[i] = 0  # Arbitrarily color the first node\n\n            if uf.color[j] == -1:\n                uf.color[j] = uf.color[i] ^ (c == \"imposter\")\n\n            if", "report": "The compilation output of the preceding code is: unindent does not match any outer indentation level (<string>, line 6)"}, "Round_1": {"code": "def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.color = [-1] * n  # -1 means uncolored, 0 and 1 are two different colors\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, relation):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            # Check for contradiction\n            if self.color[u] == self.color[v] and relation == \"imposter\":\n                return False\n            if self.color[u] != self.color[v] and relation == \"crewmate\":\n                return False\n            return True\n\n        # Union by rank\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] ^ (relation == \"imposter\")\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] ^ (relation == \"imposter\")\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] ^ (relation == \"imposter\")\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n\n        uf = UnionFind(n + 1)  # +1 because players are 1-indexed\n\n        contradiction = False\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            index += 1\n\n            if uf.color[i] == -1:\n                uf.color[i] = 0  # Arbitrarily color the first node\n\n            if uf.color[j] == -1:\n                uf.color[j] = uf.color[i] ^ (c == \"imposter\")\n\n            if"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by m lines of comments in the format 'i j c'.\"\n    },\n    {\n      \"description\": \"Model the problem as a graph where each player is a node and each comment is an edge with a label (imposter or crewmate).\",\n      \"details\": \"Create a graph representation for each test case where nodes represent players and edges represent comments between players with labels indicating the relationship.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"details\": \"Use a graph traversal technique (e.g., DFS or BFS) to check for contradictions. If a contradiction is found, mark the test case as inconsistent.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters for each consistent test case.\",\n      \"details\": \"For each connected component in the graph, determine the maximum number of imposters by considering possible assignments of roles (imposter or crewmate) to nodes, ensuring no contradictions.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters if consistent, otherwise output -1 if contradictions are found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store results for each test case.\",\n    \"For each test case, parse the input to extract n, m, and the list of comments.\",\n    \"Construct a graph where nodes are players and edges are comments with labels.\",\n    \"Perform a graph traversal to detect contradictions. If a contradiction is found, append -1 to the results list.\",\n    \"If no contradictions are found, calculate the maximum number of imposters using a strategy to maximize imposters in each connected component.\",\n    \"Append the calculated maximum number of imposters to the results list.\",\n    \"After processing all test cases, output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter count'\n    Explanation: The requirement is to determine the maximum number of imposters among the players based on the comments provided. An imposter is a player who is lying about the identity of other players.\n\n    'contradict'\n    Explanation: A contradiction occurs when the comments about players are inconsistent, meaning they cannot logically coexist. For example, if one player claims another is an imposter, but that player claims the first is a crewmate, it creates a logical inconsistency.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This refers to finding the highest number of imposters that can be assigned without contradictions. In code, this involves maximizing the count of imposters in each connected component of the graph.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the largest possible number of imposters. In code, this involves calculating the maximum number of imposters that can be assigned to players without contradictions.\n\n# [code logic]\n    The steps related to graph construction and contradiction detection should be implemented simultaneously. Specifically:\n    - \"Construct a graph where nodes are players and edges are comments with labels.\"\n    - \"Perform a graph traversal to detect contradictions.\"\n    These can be done in a single traversal of the graph where nodes are assigned roles and checked for contradictions.\n\n# [edge case]\n    Test case with no comments: \n    Input: 5 0\n    Expected output: 5\n    Explanation: With no comments, all players can be imposters since there are no contradictions.\n\n    Test case with contradictory comments:\n    Input: 2 2\n    1 2 imposter\n    2 1 crewmate\n    Expected output: -1\n    Explanation: The comments contradict each other, so the output should be -1.\n\n    Test case with all players as crewmates:\n    Input: 3 3\n    1 2 crewmate\n    2 3 crewmate\n    1 3 crewmate\n    Expected output: 0\n    Explanation: All players are crewmates, so no imposters can be assigned.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For the case with no comments, initialize the imposter count to n.\n    - For detecting contradictions, implement a graph traversal that checks for logical inconsistencies.\n    ```python\n    def", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        is_consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, 'imposter' if role == 'imposter' else 'crewmate'))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 157)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        visited = {}\n        max_imposters = 0\n        is_consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if node in visited:\n                    if visited[node] != role:\n                        return -1, 0, 0\n                    continue\n                \n                visited[node] = role\n                if role == 'imposter':\n                    imposters_count += 1\n                else:\n                    crewmates_count += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 'crewmate' if role == 'imposter' else 'imposter'))\n                    else:\n                        queue.append((neighbor, 'imposter' if role == 'imposter' else 'crewmate'))\n            \n            return 1, imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if player not in visited:\n                status, imposters, crewmates = bfs(player)\n                if status == -1:\n                    is_consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [true, false, true, false, false, true, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 569, "prompt": "Assist Theofanis in determining the maximum impostor count amongst other Cypriot participants, or conclude that the statements are inconsistent (see notes for additional details).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 244}
