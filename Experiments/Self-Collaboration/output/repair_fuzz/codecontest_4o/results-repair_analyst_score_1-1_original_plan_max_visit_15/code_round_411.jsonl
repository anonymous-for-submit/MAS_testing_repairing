{"name": "1594_D. The Number of Imposters", "description": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "tags": ["constructive algorithms", "dfs and similar", "dp", "dsu", "graphs"], "difficulty": 10, "id": 1594, "sample_io": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}], "test_list": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n9\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n10 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n9\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n1 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n4 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n10 0\n", "output": ["4\n3\n-1\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n3\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n2\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n5\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 3 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["-1\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n15 0\n", "output": ["2\n4\n1\n-1\n15\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n6 0\n", "output": ["2\n3\n1\n-1\n6\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n6\n-1\n2\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n2\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n5 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n4\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n3\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n6\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n2\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n1\n-1\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n1\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n-1\n1\n-1\n7\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n-1\n1\n-1\n5\n"]}, {"input": "5\n8 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["7\n4\n2\n-1\n2\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["5\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 4 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n4\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n3\n-1\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["3\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n5\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n1 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n2 2 crewmate\n1 2 imposter\n2 0\n", "output": ["2\n4\n1\n2\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n8\n-1\n2\n5\n"]}, {"input": "5\n10 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["9\n8\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n2\n5\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n-1\n2\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 1 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n-1\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 2 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n-1\n5\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n1\n2\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n2\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n3 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 3 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 5 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n3 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n3 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n7 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 3 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n1 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 1 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}], "task_id": "codecontest/54", "repair_prompt": ["Theofanis began engaging in the new online game dubbed \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis determine the largest possible number of imposters among all the other Cypriot players, or find out if the comments are inconsistent with each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Theofanis began engaging in the new online game dubbed \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. It is crucial to recognize that each role strictly adheres to these principles. The game revolves around the challenge of discerning truth from lies based on these statements.\n\nHelp Theofanis determine the largest possible number of imposters among all the other Cypriot players, or find out if the comments are inconsistent with each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Theofanis began engaging in the new online game dubbed \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players who are numbered from 1 to n as they all have the same name.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis determine the largest possible number of imposters among all the other Cypriot players, or find out if the comments are inconsistent with each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if roles[node] == -1:\n                    roles[node] = role\n                    if role == 1:\n                        local_imposters += 1\n                    else:\n                        local_crewmates += 1\n                elif roles[node] != role:\n                    return -1, -1\n                \n                for neighbor, edge_role in graph[node]:\n                    if roles[neighbor] == -1:\n                        queue.append((neighbor, role ^ edge_role))\n                    elif roles[neighbor] != (role ^ edge_role):\n                        return -1, -1\n            \n            return local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, crewmates = bfs(player)\n                if imposters == -1:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "completions": ["import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        comments = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            comments[i].append((j, c))\n            comments[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)  # -1: unassigned, 0: crewmate, 1: imposter\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                current = queue.popleft()\n                current_role = roles[current]\n                count[current_role] += 1\n                \n                for neighbor, role in comments[current]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if expected_role == current_role else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if expected_role == current_role else current_role):\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        is_consistent = True\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal is_consistent\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue and is_consistent:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = current_role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        is_consistent = False\n                        return\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                max_imposters += bfs(player)\n                if not is_consistent:\n                    break\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = {}\n        contradiction = False\n        \n        def dfs(player, role):\n            nonlocal contradiction\n            if player in roles:\n                if roles[player] != role:\n                    contradiction = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == 'crewmate':\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 'imposter' if role == 'crewmate' else 'crewmate')\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 'crewmate')\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = sum(1 for role in roles.values() if role == 'imposter')\n            results.append(imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = {}\n        contradiction = False\n        \n        def dfs(player, role):\n            nonlocal contradiction\n            if player in roles:\n                if roles[player] != role:\n                    contradiction = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == \"crewmate\":\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 1 - role)\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 0)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = sum(1 for role in roles.values() if role == 1)\n            results.append(imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            # No comments, all can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n                    elif color[neighbor] != expected_color:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result, total = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def find_max_imposters(test_cases):\n    results = []\n    \n    for n, m, comments in test_cases:\n        if m == 0:\n            results.append(n)\n            continue\n        \n        # Initialize graph and visited status\n        graph = {i: [] for i in range(1, n + 1)}\n        for i, j, c in comments:\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        visited = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        is_consistent = True\n        max_imposters = 0\n        \n        def dfs(node, role):\n            nonlocal is_consistent\n            stack = [(node, role)]\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while stack and is_consistent:\n                current, current_role = stack.pop()\n                \n                if visited[current] == -1:\n                    visited[current] = current_role\n                    if current_role == 1:\n                        imposters_count += 1\n                    else:\n                        crewmates_count += 1\n                elif visited[current] != current_role:\n                    is_consistent = False\n                    return 0, 0\n                \n                for neighbor, comment in graph[current]:\n                    if comment == 'imposter':\n                        expected_role = 1 - current_role\n                    else:\n                        expected_role = current_role\n                    \n                    if visited[neighbor] == -1:\n                        stack.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        is_consistent = False\n                        return 0, 0\n            \n            return imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                imp, crew = dfs(player, 0)\n                if not is_consistent:\n                    break\n                max_imposters += max(imp, crew)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = {}\n        contradiction_detected = False\n        \n        def dfs(player, role):\n            nonlocal contradiction_detected\n            if player in roles:\n                if roles[player] != role:\n                    contradiction_detected = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == 'crewmate':\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 1 - role)\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 0)\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            imposters_count = sum(1 for role in roles.values() if role == 1)\n            results.append(imposters_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        # Graph to store the relationships\n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        # To store the role of each player: 0 for crewmate, 1 for imposter, -1 for unassigned\n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # Count of crewmates and imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = current_role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1, -1  # Contradiction found\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, total = bfs(player)\n                if imposters == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += imposters\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # start with crewmate\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if roles[node] != -1:\n                    if roles[node] != role:\n                        return False, 0, 0\n                    continue\n                \n                roles[node] = role\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 1 - role))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                is_consistent, imposters, crewmates = bfs(player)\n                if not is_consistent:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if roles[node] == -1:\n                    roles[node] = role\n                    if role == 1:\n                        local_imposters += 1\n                    else:\n                        local_crewmates += 1\n                elif roles[node] != role:\n                    return -1, -1\n                \n                for neighbor, edge_role in graph[node]:\n                    if roles[neighbor] == -1:\n                        queue.append((neighbor, role ^ edge_role))\n                    elif roles[neighbor] != (role ^ edge_role):\n                        return -1, -1\n            \n            return local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, crewmates = bfs(player)\n                if imposters == -1:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the number of players and the number of comments respectively.\",\n        \"For each test case, read m lines of comments, each containing two integers i, j and a string c.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where each player is a node and each comment is an edge with a label indicating the role.\",\n      \"steps\": [\n        \"Create a graph representation for each test case where nodes represent players and edges represent comments.\",\n        \"Label edges with the role indicated in the comment (either 'imposter' or 'crewmate').\"\n      ]\n    },\n    {\n      \"description\": \"Determine the consistency of comments and calculate the maximum number of imposters.\",\n      \"steps\": [\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players based on comments.\",\n        \"Check for contradictions during traversal: if a contradiction is found, mark the test case as inconsistent.\",\n        \"If no contradictions are found, calculate the maximum number of imposters by considering possible role assignments.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if comments are consistent, output the maximum number of imposters.\",\n        \"If comments are inconsistent, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, construct a graph representation of players and comments.\",\n    \"Use graph traversal to assign roles and check for contradictions.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters based on the comments made by players.\n\n# [phrase showing quantity relationship]\n    'largest possible number': This means we need to find the maximum count of imposters that can exist without contradictions in the comments.\n    'at least': This phrase is not explicitly in the requirement but is implied in the logic of determining roles based on comments.\n\n# [degree adverb]\n    'largest': This refers to finding the maximum number of imposters possible given the constraints of the comments.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction checking should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players based on comments.\"\n    - \"Check for contradictions during traversal: if a contradiction is found, mark the test case as inconsistent.\"\n    These steps can be combined in a single traversal function that assigns roles and checks for contradictions in one pass.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no constraints, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to assign roles consistently.\n    3. Test case with all comments consistent (e.g., 1 2 imposter, 2 3 crewmate, 3 1 imposter) = 2\n       Explanation: The comments can be resolved without contradiction, allowing for a maximum of 2 imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to handle cases with no comments and check for contradictions during graph traversal.\n    ```python\n    def handle_edge_cases(n, m, comments):\n        if m == 0:\n            return n  # All can be imposters if no comments\n        # Implement graph traversal with contradiction checking\n        # If contradiction found, return -1\n        # Otherwise, calculate maximum imposters\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if roles[node] == -1:\n                    roles[node] = role\n                    if role == 1:\n                        local_imposters += 1\n                    else:\n                        local_crewmates += 1\n                elif roles[node] != role:\n                    return -1, -1\n                \n                for neighbor, edge_role in graph[node]:\n                    if roles[neighbor] == -1:\n                        queue.append((neighbor, role ^ edge_role))\n                    elif roles[neighbor] != (role ^ edge_role):\n                        return -1, -1\n            \n            return local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, crewmates = bfs(player)\n                if imposters == -1:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Determine the consistency of the comments by checking for contradictions in the graph. Use a graph traversal method to assign roles to players and detect contradictions.\",\n      \"output\": \"A boolean indicating whether the comments are consistent or not for each test case.\"\n    },\n    {\n      \"description\": \"If the comments are consistent, calculate the maximum number of imposters possible by exploring all valid role assignments.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into structured test cases.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels indicating roles.\",\n    \"Perform a graph traversal (e.g., DFS or BFS) to attempt to assign roles to each player, checking for contradictions in the process.\",\n    \"If a contradiction is found during traversal, mark the test case as inconsistent and output -1.\",\n    \"If no contradiction is found, calculate the maximum number of imposters by considering all possible valid role assignments.\",\n    \"Output the result for each test case, either the maximum number of imposters or -1 if inconsistent.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradiction': Occurs when comments from players lead to logical inconsistencies in role assignments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': Refers to finding the largest count of imposters that can be assigned without contradictions.\n\n# [degree adverb]\n    'largest': In this context, it means finding the highest number of imposters possible given the constraints.\n\n# [code logic]\n    The steps related to graph traversal and contradiction checking should be implemented simultaneously. Specifically:\n    - \"Perform a graph traversal (e.g., DFS or BFS) to attempt to assign roles to each player, checking for contradictions in the process.\"\n    This can be done in a single traversal where roles are assigned and contradictions are checked concurrently.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles consistently.\n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters as there are no contradictions in the comments.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    ```python\n    def detect_contradictions(graph):\n        # Implement graph traversal to assign roles and check for contradictions\n        for node in graph:\n            if not assign_roles(node):\n                return -1\n        return calculate_maximum_imposters(graph)\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        comments = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            comments[i].append((j, c))\n            comments[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)  # -1: unassigned, 0: crewmate, 1: imposter\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                current = queue.popleft()\n                current_role = roles[current]\n                count[current_role] += 1\n                \n                for neighbor, role in comments[current]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if expected_role == current_role else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if expected_role == current_role else current_role):\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 67)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        comments = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            comments[i].append((j, c))\n            comments[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        roles = [-1] * (n + 1)  # -1: unassigned, 0: crewmate, 1: imposter\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # count[0]: crewmates, count[1]: imposters\n            \n            while queue:\n                current = queue.popleft()\n                current_role = roles[current]\n                count[current_role] += 1\n                \n                for neighbor, role in comments[current]:\n                    expected_role = 0 if role == 'crewmate' else 1\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = 1 - current_role if expected_role == current_role else current_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != (1 - current_role if expected_role == current_role else current_role):\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, model the problem as a graph where each player is a node and each comment is an edge with a label indicating the role (imposter or crewmate).\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Implement a method to check for contradictions in the comments by attempting to assign roles to players. Use a graph traversal technique (e.g., DFS or BFS) to propagate role assignments and detect inconsistencies.\",\n      \"output\": \"A boolean indicating whether the comments are consistent or not for each test case.\"\n    },\n    {\n      \"description\": \"If the comments are consistent, calculate the maximum number of imposters by exploring all possible valid role assignments.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with labels indicating roles.\",\n    \"Traverse the graph to assign roles to players, checking for contradictions in the process.\",\n    \"If a contradiction is found, mark the test case as inconsistent and output -1.\",\n    \"If no contradiction is found, determine the maximum number of imposters by exploring valid role assignments.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradiction': Occurs when statements about roles conflict, making it impossible to assign roles consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': Refers to finding the largest number of imposters that can be assigned without contradictions.\n    'exactly one role': Each player must be assigned either the role of imposter or crewmate, not both.\n\n# [degree adverb]\n    'largest': Refers to the highest number of imposters that can be assigned without contradictions.\n\n# [code logic]\n    The steps related to graph traversal and role assignment should be implemented simultaneously. Specifically:\n    - \"Traverse the graph to assign roles to players, checking for contradictions in the process.\"\n    - \"If no contradiction is found, determine the maximum number of imposters by exploring valid role assignments.\"\n    These can be implemented using a single graph traversal method (e.g., DFS or BFS) that both checks for contradictions and calculates the maximum imposters.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, and all players can be imposters.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles consistently.\n    Test case with all players claiming others are imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters since there are no contradictions in the comments.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    ```python\n    def detect_contradictions(graph):\n        # Implement graph traversal to detect contradictions\n        # Return True if contradictions are found, otherwise False\n\n    def calculate_maximum_imposters(graph):\n        # Implement logic to calculate maximum imposters if no contradictions are found\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        is_consistent = True\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal is_consistent\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue and is_consistent:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = current_role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        is_consistent = False\n                        return\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                max_imposters += bfs(player)\n                if not is_consistent:\n                    break\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 103)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        is_consistent = True\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal is_consistent\n            queue = deque([start])\n            roles[start] = 0\n            count = [0, 0]  # count[0] for crewmates, count[1] for imposters\n            \n            while queue and is_consistent:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = current_role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        is_consistent = False\n                        return\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                max_imposters += bfs(player)\n                if not is_consistent:\n                    break\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the comments themselves.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each test case, read m comments of the form 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and identify contradictions.\",\n      \"steps\": [\n        \"Initialize a data structure to track the role of each player (imposter or crewmate).\",\n        \"For each comment 'i j c', update the roles based on the statement made by player i about player j.\",\n        \"Check for contradictions in the comments, where a player is both claimed to be an imposter and a crewmate by different players.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters or identify contradictions.\",\n      \"steps\": [\n        \"If no contradictions are found, calculate the maximum number of imposters by considering possible role assignments.\",\n        \"If contradictions are found, return -1 for that test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, number of players, and comments.\",\n    \"For each test case, initialize a data structure to track player roles.\",\n    \"Process each comment to update player roles and check for contradictions.\",\n    \"For each test case, determine the maximum number of imposters or identify contradictions.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, imposters always lie, and crewmates always tell the truth. Each player has exactly one role, either imposter or crewmate. The challenge is to determine the maximum number of imposters based on the comments, or identify contradictions.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This refers to finding the largest number of players that can be imposters without contradictions in the comments. In code, this involves checking all possible role assignments and ensuring consistency.\n\n# [degree adverb]\n    'largest possible number'\n    Explanation: This means finding the highest count of imposters that can be assigned without contradictions. In code, this involves iterating through possible role assignments and maximizing the count of imposters.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially, but within the second subproblem, the steps of updating roles and checking for contradictions should be considered simultaneously. This can be done using a data structure (like a graph or union-find) to track roles and detect contradictions as comments are processed.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to assign roles consistently.\n    \n    Test case with all players claimed as crewmates (e.g., 3 3 with comments \"1 2 crewmate\", \"2 3 crewmate\", \"1 3 crewmate\") = 0\n    Explanation: If all players are claimed as crewmates, none can be imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    Code for handling contradictions:\n    ```python\n    def detect_contradictions(comments):\n        roles = {}\n        for i, j, c in comments:\n            if i not in roles:\n                roles[i] = {}\n            if j not in roles:\n                roles[j] = {}\n            if c == 'imposter':\n                roles[i][j] = 'lie'\n            else:\n                roles[i][", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = {}\n        contradiction = False\n        \n        def dfs(player, role):\n            nonlocal contradiction\n            if player in roles:\n                if roles[player] != role:\n                    contradiction = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == 'crewmate':\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 'imposter' if role == 'crewmate' else 'crewmate')\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 'crewmate')\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = sum(1 for role in roles.values() if role == 'imposter')\n            results.append(imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = {}\n        contradiction = False\n        \n        def dfs(player, role):\n            nonlocal contradiction\n            if player in roles:\n                if roles[player] != role:\n                    contradiction = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == 'crewmate':\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 'imposter' if role == 'crewmate' else 'crewmate')\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 'crewmate')\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = sum(1 for role in roles.values() if role == 'imposter')\n            results.append(imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read integers n and m, representing the number of players and comments respectively.\",\n        \"For each test case, read m lines of comments, each containing two integers i, j and a string c.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and identify contradictions.\",\n      \"steps\": [\n        \"For each test case, initialize a data structure to track the role of each player.\",\n        \"Iterate through each comment and update the roles of players based on the comment.\",\n        \"Check for contradictions in the comments, where a player is both claimed to be a crewmate and an imposter by different players.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters or identify contradictions.\",\n      \"steps\": [\n        \"For each test case, if no contradictions are found, calculate the maximum number of imposters by considering the possible role assignments.\",\n        \"If contradictions are found, mark the test case as inconsistent and prepare to output -1.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the maximum number of imposters if no contradictions are found.\",\n        \"Output -1 if the test case contains contradictions.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, number of players, number of comments, and the comments themselves.\",\n    \"For each test case, analyze the comments to determine possible roles of players and check for contradictions.\",\n    \"Calculate the maximum number of imposters for each test case, or identify contradictions.\",\n    \"Output the results for each test case, either the maximum number of imposters or -1 for contradictions.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies.\n    'crewmate': A player who always tells the truth.\n    'contradiction': A situation where comments conflict, making it impossible to assign roles consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': Refers to finding the largest count of imposters that can be assigned without contradictions.\n    Implementation: Use logic to maximize the number of imposters while ensuring no contradictions in comments.\n\n# [degree adverb]\n    'largest': Refers to the highest number of imposters that can be assigned.\n    Implementation: Use algorithms to explore role assignments and maximize imposters count.\n\n# [code logic]\n    Steps related to parsing input and analyzing comments should be implemented simultaneously:\n    - \"Iterate through each comment and update the roles of players based on the comment.\"\n    - \"Check for contradictions in the comments.\"\n    These can be done in a single loop where each comment is processed and checked for contradictions immediately.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, all players can be imposters.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making consistent role assignment impossible.\n    Test case with multiple comments for the same pair (e.g., 3 5 with comments \"1 2 imposter\", \"1 2 imposter\", \"3 2 crewmate\", \"3 2 crewmate\", \"1 3 imposter\") = 2\n    Explanation: Despite repeated comments, roles can be assigned without contradiction.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement logic to detect contradictions in comments.\n    - Use a data structure (e.g., graph or union-find) to manage role assignments and detect cycles or contradictions.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = {}\n        contradiction = False\n        \n        def dfs(player, role):\n            nonlocal contradiction\n            if player in roles:\n                if roles[player] != role:\n                    contradiction = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == \"crewmate\":\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 1 - role)\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 0)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = sum(1 for role in roles.values() if role == 1)\n            results.append(imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = {}\n        contradiction = False\n        \n        def dfs(player, role):\n            nonlocal contradiction\n            if player in roles:\n                if roles[player] != role:\n                    contradiction = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == \"crewmate\":\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 1 - role)\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 0)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            imposters = sum(1 for role in roles.values() if role == 1)\n            results.append(imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments respectively.\",\n        \"For each test case, read m comments of the form 'i j c' where i and j are player indices and c is the role (either 'imposter' or 'crewmate').\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using graph theory where players are nodes and comments are edges with labels indicating roles.\",\n      \"steps\": [\n        \"For each test case, create a graph with n nodes representing players.\",\n        \"Add edges between nodes based on comments, with labels indicating the role ('imposter' or 'crewmate').\"\n      ]\n    },\n    {\n      \"description\": \"Determine the consistency of comments and calculate the maximum number of imposters.\",\n      \"steps\": [\n        \"Use a graph coloring approach to assign roles to players, ensuring consistency with comments.\",\n        \"Check for contradictions in comments by attempting to color the graph using two colors (representing 'imposter' and 'crewmate').\",\n        \"If a contradiction is found, mark the test case as inconsistent and return -1.\",\n        \"If no contradiction is found, calculate the maximum number of imposters by counting nodes colored as 'imposter'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, player counts, comment counts, and comments.\",\n    \"For each test case, construct a graph representing players and comments.\",\n    \"Attempt to color the graph using two colors to represent roles, checking for contradictions.\",\n    \"For consistent graphs, calculate and output the maximum number of imposters.\",\n    \"For inconsistent graphs, output -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, imposters always lie, and crewmates always tell the truth. The task is to determine the maximum number of imposters based on the comments made by players, or identify if the comments are inconsistent.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This indicates that we need to find the largest number of imposters that can be assigned without contradictions.\n    'contradict': This means that if the comments lead to a logical inconsistency, the output should be -1.\n\n# [degree adverb] \n    'largest': This refers to finding the maximum number of imposters possible given the constraints of the comments.\n\n# [code logic]\n    The steps in the plan related to graph coloring should be implemented simultaneously. Specifically:\n    - \"Use a graph coloring approach to assign roles to players, ensuring consistency with comments.\"\n    - \"Check for contradictions in comments by attempting to color the graph using two colors (representing 'imposter' and 'crewmate').\"\n    These steps can be implemented in a single code block using a graph traversal algorithm like DFS or BFS to attempt coloring and check for contradictions.\n\n# [edge case] \n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no constraints, so all players can be imposters.\n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, so the output should be -1.\n    Test case with consistent comments but all players are crewmates (e.g., 3 2 with comments \"1 2 crewmate\" and \"2 3 crewmate\") = 0\n    Explanation: If all comments indicate crewmates and are consistent, the maximum number of imposters is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For no comments, simply return the number of players.\n    - For contradictory comments, implement a check during graph coloring to detect contradictions.\n    ```python\n    def handle_no_comments(n):\n        return n\n\n    def detect_contradictions(graph):\n        # Implement graph coloring and contradiction detection logic\n        pass\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            # No comments, all can be imposters\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n                    elif color[neighbor] != expected_color:\n                        return -1, 0\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result, total = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible roles of players based on comments.\",\n      \"details\": \"Use a graph-based approach where each player is a node and comments are edges with labels indicating the role (imposter or crewmate).\"\n    },\n    {\n      \"description\": \"Detect contradictions in comments for each test case.\",\n      \"details\": \"Implement a mechanism to check for logical inconsistencies in the comments, such as conflicting statements about the same player.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters possible for each test case.\",\n      \"details\": \"Based on the graph structure, determine the maximum number of imposters by considering valid configurations of roles.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the maximum number of imposters or -1 if contradictions are found.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract test cases, number of players, and comments.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent comments with roles.\",\n    \"Implement a function to check for contradictions in the graph by analyzing the comments.\",\n    \"Use a graph traversal or coloring algorithm to determine the maximum number of imposters possible without contradictions.\",\n    \"Output the results for each test case, either the maximum number of imposters or -1 if contradictions exist.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters based on the comments made by players.\n\n# [phrase showing quantity relationship]\n    'largest possible number': This means we need to find the maximum count of imposters that can exist without contradictions in the comments.\n\n# [degree adverb]\n    'largest': This refers to finding the maximum number of imposters possible.\n\n# [code logic]\n    The steps related to constructing the graph and checking for contradictions should be implemented simultaneously. Specifically:\n    - Constructing the graph and checking for contradictions can be done in a single traversal of the comments, where each comment is processed to update the graph and check for any immediate contradictions.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with a single contradictory comment (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, so the output should be -1.\n    3. Test case with all players claiming each other as imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 3\n       Explanation: All players can be imposters since their claims are consistent with everyone lying.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions.\n    - Implement a graph coloring or union-find algorithm to detect contradictions and determine the maximum number of imposters.\n    ```python\n    def find_max_imposters(test_cases):\n        results = []\n        for n, m, comments in test_cases:\n            if m == 0:\n                results.append(n)\n                continue\n            \n            # Initialize graph and visited status\n            graph = {i: [] for i in range(1, n + 1)}\n            for i, j, c in comments:\n                graph[i].append((j, c))\n                graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            \n            # Use a BFS/DFS to", "Round_0": {"code": "def find_max_imposters(test_cases):\n    results = []\n    \n    for n, m, comments in test_cases:\n        if m == 0:\n            results.append(n)\n            continue\n        \n        # Initialize graph and visited status\n        graph = {i: [] for i in range(1, n + 1)}\n        for i, j, c in comments:\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n        \n        visited = [-1] * (n + 1)  # -1 means unvisited, 0 means crewmate, 1 means imposter\n        is_consistent = True\n        max_imposters = 0\n        \n        def dfs(node, role):\n            nonlocal is_consistent\n            stack = [(node, role)]\n            imposters_count = 0\n            crewmates_count = 0\n            \n            while stack and is_consistent:\n                current, current_role = stack.pop()\n                \n                if visited[current] == -1:\n                    visited[current] = current_role\n                    if current_role == 1:\n                        imposters_count += 1\n                    else:\n                        crewmates_count += 1\n                elif visited[current] != current_role:\n                    is_consistent = False\n                    return 0, 0\n                \n                for neighbor, comment in graph[current]:\n                    if comment == 'imposter':\n                        expected_role = 1 - current_role\n                    else:\n                        expected_role = current_role\n                    \n                    if visited[neighbor] == -1:\n                        stack.append((neighbor, expected_role))\n                    elif visited[neighbor] != expected_role:\n                        is_consistent = False\n                        return 0, 0\n            \n            return imposters_count, crewmates_count\n        \n        for player in range(1, n + 1):\n            if visited[player] == -1:\n                imp, crew = dfs(player, 0)\n                if not is_consistent:\n                    break\n                max_imposters += max(imp, crew)\n        \n        if is_consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read integers n and m, representing the number of players and comments respectively.\",\n        \"For each of the m comments, read the integers i, j and the string c, representing the comment structure.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the roles of players based on comments and check for contradictions.\",\n      \"steps\": [\n        \"Initialize a data structure to store the role information for each player.\",\n        \"Iterate through each comment and update the role information based on the comment.\",\n        \"Check for contradictions in the comments, where a player is both claimed to be an imposter and a crewmate.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible number of imposters or detect inconsistencies.\",\n      \"steps\": [\n        \"If contradictions are found, mark the test case as inconsistent and prepare to output -1.\",\n        \"If no contradictions are found, calculate the maximum number of imposters by analyzing the role information.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Iterate through the results of each test case.\",\n        \"Print the maximum number of imposters or -1 if the test case is inconsistent.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, player counts, and comments.\",\n    \"For each test case, analyze the comments to determine player roles and check for contradictions.\",\n    \"Calculate the maximum number of imposters or detect inconsistencies.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter': A player who always lies about the role of other players.\n    'crewmate': A player who always tells the truth about the role of other players.\n    'contradiction': Occurs when comments about roles conflict, making it impossible to determine roles consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': Refers to finding the largest count of imposters that can be deduced from the comments without contradictions.\n\n# [degree adverb]\n    'largest': Refers to the highest number of imposters that can be determined from the comments.\n\n# [code logic]\n    The steps in the subproblem \"Determine the roles of players based on comments and check for contradictions\" should be implemented simultaneously. Specifically, while iterating through each comment, the role information should be updated and checked for contradictions in the same loop to ensure consistency.\n\n# [edge case]\n    Test case with no comments (e.g., n = 5, m = 0) = 5\n    Explanation: With no comments, all players can be imposters, as there are no contradictions.\n    \n    Test case with contradictory comments (e.g., \"1 2 imposter\", \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to determine roles consistently.\n    \n    Test case with all players claiming each other as imposters (e.g., \"1 2 imposter\", \"2 3 imposter\", \"3 1 imposter\") = 3\n    Explanation: All players can be imposters as there are no contradictions in the claims.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly to detect contradictions.\n        if contradiction_detected:\n            results.append(-1)\n        else:\n            results.append(max_imposters_count)\n        (other code)\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = {}\n        contradiction_detected = False\n        \n        def dfs(player, role):\n            nonlocal contradiction_detected\n            if player in roles:\n                if roles[player] != role:\n                    contradiction_detected = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == 'crewmate':\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 1 - role)\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 0)\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            imposters_count = sum(1 for role in roles.values() if role == 1)\n            results.append(imposters_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        roles = {}\n        contradiction_detected = False\n        \n        def dfs(player, role):\n            nonlocal contradiction_detected\n            if player in roles:\n                if roles[player] != role:\n                    contradiction_detected = True\n                return\n            roles[player] = role\n            for neighbor, comment in graph[player]:\n                if comment == 'crewmate':\n                    dfs(neighbor, role)\n                else:\n                    dfs(neighbor, 1 - role)\n        \n        for player in range(1, n + 1):\n            if player not in roles:\n                dfs(player, 0)\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            imposters_count = sum(1 for role in roles.values() if role == 1)\n            results.append(imposters_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"goal\": \"Organize the input data into a structured format for processing.\"\n    },\n    {\n      \"description\": \"For each test case, determine the possible roles (imposter or crewmate) for each player based on the comments.\",\n      \"goal\": \"Assign roles to players while checking for contradictions in the comments.\"\n    },\n    {\n      \"description\": \"Identify contradictions in the comments for each test case.\",\n      \"goal\": \"Detect if the comments are inconsistent, which would make it impossible to assign roles without contradiction.\"\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters possible for each test case if no contradictions are found.\",\n      \"goal\": \"Determine the largest possible number of imposters based on the valid role assignments.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read and parse the input data.\",\n      \"details\": \"Extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\"\n    },\n    {\n      \"step\": \"Process each test case individually.\",\n      \"details\": \"For each test case, attempt to assign roles to players based on the comments.\"\n    },\n    {\n      \"step\": \"Check for contradictions in the comments.\",\n      \"details\": \"If a contradiction is found, mark the test case as inconsistent and prepare to output -1.\"\n    },\n    {\n      \"step\": \"Calculate the maximum number of imposters.\",\n      \"details\": \"If no contradictions are found, determine the maximum number of imposters possible and store the result.\"\n    },\n    {\n      \"step\": \"Output the results for all test cases.\",\n      \"details\": \"Print the maximum number of imposters for each test case, or -1 if the comments are inconsistent.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters based on the comments made by players.\n\n# [phrase showing quantity relationship]\n    'largest possible number': This means we need to find the maximum count of imposters that can be assigned without contradictions.\n    'distinct integers': This indicates that the players i and j in the comments are different from each other.\n\n# [degree adverb]\n    'largest': This refers to finding the maximum number of imposters possible without contradictions.\n\n# [code logic]\n    The steps \"Check for contradictions in the comments\" and \"Calculate the maximum number of imposters\" should be considered simultaneously. This is because while assigning roles, we need to continuously check for contradictions and simultaneously calculate the potential number of imposters.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments contradict each other, making it impossible to assign roles without contradiction.\n    3. Test case with all players claiming others as imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: A possible configuration is that two players are imposters and one is a crewmate, which satisfies the conditions without contradiction.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a graph-based approach to model the relationships and use a two-coloring technique to detect contradictions and calculate the maximum number of imposters.\n    - Use a union-find or DFS/BFS approach to manage the role assignments and contradiction checks.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        # Graph to store the relationships\n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        # To store the role of each player: 0 for crewmate, 1 for imposter, -1 for unassigned\n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # Count of crewmates and imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = current_role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1, -1  # Contradiction found\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, total = bfs(player)\n                if imposters == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += imposters\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 103)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        # Graph to store the relationships\n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        # To store the role of each player: 0 for crewmate, 1 for imposter, -1 for unassigned\n        roles = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([start])\n            roles[start] = 0  # Start with crewmate\n            count = [0, 0]  # Count of crewmates and imposters\n            \n            while queue:\n                node = queue.popleft()\n                current_role = roles[node]\n                count[current_role] += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_role = current_role ^ relation\n                    if roles[neighbor] == -1:\n                        roles[neighbor] = expected_role\n                        queue.append(neighbor)\n                    elif roles[neighbor] != expected_role:\n                        return -1, -1  # Contradiction found\n            \n            return max(count), sum(count)\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, total = bfs(player)\n                if imposters == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += imposters\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each test case, read m comments of the form 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where each player is a node and each comment is an edge with a label indicating the role.\",\n      \"steps\": [\n        \"Create a graph representation for each test case.\",\n        \"Add nodes for each player.\",\n        \"Add edges between nodes based on comments, with labels indicating 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the consistency of comments and calculate the maximum number of imposters.\",\n      \"steps\": [\n        \"For each test case, attempt to assign roles to players such that all comments are consistent.\",\n        \"Use a graph traversal technique (e.g., DFS or BFS) to check for contradictions.\",\n        \"If a contradiction is found, mark the test case as inconsistent.\",\n        \"If no contradiction is found, calculate the maximum number of imposters by considering possible role assignments.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if comments are consistent, output the maximum number of imposters.\",\n        \"If comments are inconsistent, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, number of players, comments, and their structure.\",\n    \"Model each test case as a graph with nodes representing players and edges representing comments.\",\n    \"Use graph traversal to check for contradictions and determine possible role assignments.\",\n    \"Calculate the maximum number of imposters for consistent test cases.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the largest possible number of imposters or identify if the comments are inconsistent.\n\n# [phrase showing quantity relationship]\n    'largest possible number': This means we need to find the maximum count of imposters that can exist without causing contradictions in the comments.\n\n# [degree adverb] \n    'largest': This refers to finding the maximum number of imposters possible given the constraints of the comments.\n\n# [code logic]\n    The steps in the plan related to graph modeling and checking for contradictions should be implemented simultaneously. Specifically:\n    - \"Add nodes for each player.\"\n    - \"Add edges between nodes based on comments, with labels indicating 'imposter' or 'crewmate'.\"\n    - \"Use a graph traversal technique (e.g., DFS or BFS) to check for contradictions.\"\n    These steps can be combined into a single graph traversal function that builds the graph and checks for contradictions in one pass.\n\n# [edge case] \n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no constraints, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to assign roles without inconsistency.\n    3. Test case with all players claiming others are imposters (e.g., 1 2 imposter, 2 3 imposter, 3 1 imposter) = 2\n       Explanation: A cycle of accusations can be resolved by having two imposters and one crewmate, maximizing imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to handle cases with no comments and contradictory comments:\n    ```python\n    def handle_edge_cases(n, m, comments):\n        if m == 0:\n            return n\n        # Implement graph traversal to detect contradictions\n        # If contradiction is found, return -1\n        # Otherwise, calculate maximum imposters\n    ```\n\nYES", "Round_0": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # start with crewmate\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if roles[node] != -1:\n                    if roles[node] != role:\n                        return False, 0, 0\n                    continue\n                \n                roles[node] = role\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 1 - role))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                is_consistent, imposters, crewmates = bfs(player)\n                if not is_consistent:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 160)"}, "Round_1": {"code": "def solve_among_them():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        roles = [-1] * (n + 1)  # -1: unvisited, 0: crewmate, 1: imposter\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])  # start with crewmate\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if roles[node] != -1:\n                    if roles[node] != role:\n                        return False, 0, 0\n                    continue\n                \n                roles[node] = role\n                if role == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, comment in graph[node]:\n                    if comment == 'imposter':\n                        queue.append((neighbor, 1 - role))\n                    else:\n                        queue.append((neighbor, role))\n            \n            return True, local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                is_consistent, imposters, crewmates = bfs(player)\n                if not is_consistent:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\nsolve_among_them()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the number of players and the number of comments respectively.\",\n        \"For each test case, read m lines of comments, each containing two integers i, j and a string c.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where each player is a node and each comment is an edge with a label indicating the role.\",\n      \"steps\": [\n        \"Create a graph representation for each test case where nodes represent players and edges represent comments.\",\n        \"Label edges with the role indicated in the comment (either 'imposter' or 'crewmate').\"\n      ]\n    },\n    {\n      \"description\": \"Determine the consistency of comments and calculate the maximum number of imposters.\",\n      \"steps\": [\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players based on comments.\",\n        \"Check for contradictions during traversal: if a contradiction is found, mark the test case as inconsistent.\",\n        \"If no contradictions are found, calculate the maximum number of imposters by considering possible role assignments.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if comments are consistent, output the maximum number of imposters.\",\n        \"If comments are inconsistent, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, construct a graph representation of players and comments.\",\n    \"Use graph traversal to assign roles and check for contradictions.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposter' and 'crewmate'\n    Explanation: In the game, an imposter always lies, and a crewmate always tells the truth. The task is to determine the maximum number of imposters based on the comments made by players.\n\n# [phrase showing quantity relationship]\n    'largest possible number': This means we need to find the maximum count of imposters that can exist without contradictions in the comments.\n    'at least': This phrase is not explicitly in the requirement but is implied in the logic of determining roles based on comments.\n\n# [degree adverb]\n    'largest': This refers to finding the maximum number of imposters possible given the constraints of the comments.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction checking should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to assign roles to players based on comments.\"\n    - \"Check for contradictions during traversal: if a contradiction is found, mark the test case as inconsistent.\"\n    These steps can be combined in a single traversal function that assigns roles and checks for contradictions in one pass.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no constraints, so all players can be imposters.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to assign roles consistently.\n    3. Test case with all comments consistent (e.g., 1 2 imposter, 2 3 crewmate, 3 1 imposter) = 2\n       Explanation: The comments can be resolved without contradiction, allowing for a maximum of 2 imposters.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to handle cases with no comments and check for contradictions during graph traversal.\n    ```python\n    def handle_edge_cases(n, m, comments):\n        if m == 0:\n            return n  # All can be imposters if no comments\n        # Implement graph traversal with contradiction checking\n        # If contradiction found, return -1\n        # Otherwise, calculate maximum imposters\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            if c == 'imposter':\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n            index += 1\n        \n        roles = [-1] * (n + 1)\n        max_imposters = 0\n        consistent = True\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, role = queue.popleft()\n                \n                if roles[node] == -1:\n                    roles[node] = role\n                    if role == 1:\n                        local_imposters += 1\n                    else:\n                        local_crewmates += 1\n                elif roles[node] != role:\n                    return -1, -1\n                \n                for neighbor, edge_role in graph[node]:\n                    if roles[neighbor] == -1:\n                        queue.append((neighbor, role ^ edge_role))\n                    elif roles[neighbor] != (role ^ edge_role):\n                        return -1, -1\n            \n            return local_imposters, local_crewmates\n        \n        for player in range(1, n + 1):\n            if roles[player] == -1:\n                imposters, crewmates = bfs(player)\n                if imposters == -1:\n                    consistent = False\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if consistent:\n            results.append(max_imposters)\n        else:\n            results.append(-1)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 411, "prompt": "Theofanis began engaging in the new online game dubbed \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis determine the largest possible number of imposters among all the other Cypriot players, or find out if the comments are inconsistent with each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 22}
