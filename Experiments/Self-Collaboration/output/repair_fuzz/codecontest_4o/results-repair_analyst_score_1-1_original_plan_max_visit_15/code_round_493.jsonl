{"name": "1594_D. The Number of Imposters", "description": "Theofanis started playing the new online game called \"Among them\". However, he always plays with Cypriot players, and they all have the same name: \"Andreas\" (the most common name in Cyprus).\n\nIn each game, Theofanis plays with n other players. Since they all have the same name, they are numbered from 1 to n.\n\nThe players write m comments in the chat. A comment has the structure of \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate). The comment means that player i said that player j has the role c.\n\nAn imposter always lies, and a crewmate always tells the truth. \n\nHelp Theofanis find the maximum possible number of imposters among all the other Cypriot players, or determine that the comments contradict each other (see the notes for further explanation).\n\nNote that each player has exactly one role: either imposter or crewmate.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "tags": ["constructive algorithms", "dfs and similar", "dp", "dsu", "graphs"], "difficulty": 10, "id": 1594, "sample_io": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}], "test_list": [{"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n9\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n10 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n9\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n1 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n4 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n10 0\n", "output": ["4\n3\n-1\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n3\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n2\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n5\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n-1\n2\n9\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 3 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["-1\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n15 0\n", "output": ["2\n4\n1\n-1\n15\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n6 0\n", "output": ["2\n3\n1\n-1\n6\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n6\n-1\n2\n7\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n2\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n5 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n4\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n3\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n4 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n7 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n6\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n2\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n2\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n-1\n1\n-1\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n1\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["4\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n-1\n1\n-1\n7\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n3\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n-1\n1\n-1\n5\n"]}, {"input": "5\n8 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["7\n4\n2\n-1\n2\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["5\n4\n1\n2\n13\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 4 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n4\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n3\n-1\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["3\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n10 0\n", "output": ["2\n4\n2\n-1\n10\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n5\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n2 0\n", "output": ["2\n4\n-1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n1 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n2 2 crewmate\n1 2 imposter\n2 0\n", "output": ["2\n4\n1\n2\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n8\n-1\n2\n5\n"]}, {"input": "5\n10 2\n1 2 imposter\n4 2 crewmate\n10 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["9\n8\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n2\n5\n"]}, {"input": "5\n6 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["5\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n-1\n2\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 1 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n-1\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n-1\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 2 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n-1\n5\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n-1\n1\n2\n5\n"]}, {"input": "5\n4 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["3\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n2\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n2\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n3 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n-1\n2\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 3 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n1 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 4 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n5\n1\n-1\n2\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 4 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n4 5 crewmate\n3 5 imposter\n3 1 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 3 imposter\n3 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 1 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n8 0\n", "output": ["2\n4\n1\n-1\n8\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n2 5 crewmate\n2 5 crewmate\n3 4 imposter\n3 1 imposter\n3 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n5\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 4 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n4\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n3 4 imposter\n4 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n9 0\n", "output": ["2\n4\n-1\n2\n9\n"]}, {"input": "5\n3 2\n1 2 imposter\n3 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n4\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n4 2\n1 4 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 1 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n3\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 4 crewmate\n3 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n7 2\n1 2 imposter\n2 1 crewmate\n10 5\n1 2 imposter\n1 1 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["-1\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 1 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n1 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n7 0\n", "output": ["4\n-1\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 5 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 1 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 1 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n4 5 crewmate\n1 4 imposter\n2 1 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n2 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n5 0\n", "output": ["2\n3\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n4 3 crewmate\n2 3 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 1 imposter\n1 2 imposter\n1 2 crewmate\n1 2 crewmate\n1 3 imposter\n3 0\n", "output": ["2\n-1\n1\n-1\n3\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n3 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n2 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n2\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 1 crewmate\n5 4\n1 2 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["-1\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 3 imposter\n2 2 imposter\n3 1 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n-1\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n3 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n1 1 crewmate\n2 4 imposter\n1 4 imposter\n5 2\n1 2 imposter\n2 1 crewmate\n6 5\n1 2 imposter\n1 2 imposter\n3 1 crewmate\n3 2 crewmate\n1 5 imposter\n5 0\n", "output": ["2\n4\n-1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n3 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n6 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 3 imposter\n7 0\n", "output": ["2\n4\n1\n-1\n7\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n2 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n2 2 crewmate\n3 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 1 crewmate\n2 5 crewmate\n2 5 imposter\n3 5 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n2 2 crewmate\n1 2 imposter\n5 0\n", "output": ["2\n4\n1\n-1\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 3 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 2 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n1 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 2 imposter\n4 0\n", "output": ["2\n4\n-1\n2\n4\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 2 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n4 5\n1 3 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n", "output": ["2\n-1\n1\n-1\n5\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n6 4\n1 3 crewmate\n2 5 crewmate\n2 3 imposter\n1 4 imposter\n2 2\n1 2 imposter\n2 2 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n1 2 crewmate\n3 2 crewmate\n2 3 imposter\n2 0\n", "output": ["4\n4\n1\n-1\n2\n"]}, {"input": "5\n5 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 4 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n4 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 3 crewmate\n1 3 imposter\n5 0\n", "output": ["4\n3\n-1\n2\n5\n"]}, {"input": "5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 5 crewmate\n2 5 crewmate\n1 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n2 2 crewmate\n1 3 imposter\n13 0\n", "output": ["2\n4\n-1\n2\n13\n"]}], "task_id": "codecontest/54", "repair_prompt": ["Assist Theofanis in determining the maximum number of impostors among the other participants from Cyprus, or deduce that the remarks contradict one another (refer to the notes for further information).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Assist Theofanis in determining the maximum number of impostors among the other participants from Cyprus. Alternatively, deduce that the remarks contradict one another. (Refer to the notes for further information.)\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Assist Theofanis in determining the maximum number of impostors among the other participants from Cyprus, or deduce that the remarks contradict one another (refer to the notes for further information).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.color = [-1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, same):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            return self.color[u] == self.color[v] if same else self.color[u] != self.color[v]\n\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] if same else 1 - self.color[v]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if uf.color[i] == -1:\n                uf.color[i] = 0\n            if uf.color[j] == -1:\n                uf.color[j] = 0\n            \n            if c == \"imposter\":\n                if not uf.union(i, j, False):\n                    contradiction = True\n                    break\n            elif c == \"crewmate\":\n                if not uf.union(i, j, True):\n                    contradiction = True\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            max_im\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                if node in color:\n                    if color[node] != col:\n                        return -1, -1\n                    continue\n                \n                color[node] = col\n                if col == 1:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    queue.append((neighbor, col ^ relation))\n            \n            return local_imposters, local_crewmates\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                imposters, crewmates = bfs(player)\n                if imposters == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def detect_contradictions_and_count_imposters(n, comments):\n    from collections import defaultdict, deque\n\n    # Initialize graph and color map\n    graph = defaultdict(list)\n    color = {}\n\n    # Build graph\n    for i, j, c in comments:\n        graph[i].append((j, c))\n        graph[j].append((i, c))\n\n    def bfs(start):\n        queue = deque([(start, 0)])  # Start coloring with 0 (imposter)\n        local_color = {}\n        local_color[start] = 0\n        imposter_count = 0\n        crewmate_count = 0\n\n        while queue:\n            node, current_color = queue.popleft()\n            if current_color == 0:\n                imposter_count += 1\n            else:\n                crewmate_count += 1\n\n            for neighbor, relation in graph[node]:\n                expected_color = current_color if relation == 'crewmate' else 1 - current_color\n                if neighbor in local_color:\n                    if local_color[neighbor] != expected_color:\n                        return -1, 0  # Contradiction found\n                else:\n                    local_color[neighbor] = expected_color\n                    queue.append((neighbor, expected_color))\n\n        return max(imposter_count, crewmate_count), 1\n\n    total_imposters = 0\n    visited = set()\n\n    for player in range(1, n + 1):\n        if player not in visited:\n            if player in graph:\n                result, valid = bfs(player)\n                if valid == -1:\n                    return -1\n                total_imposters += result\n            else:\n                total_imposters += 1  # No comments, can be an imposter\n\n    return total_imposters\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        comments = []\n\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            comments.append((i, j, c))\n            index += 1\n\n        result = detect_contradictions_and_count_imposters(n, comments)\n        results\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            color[start] = 'imposter'\n            imposter_count = 0\n            crewmate_count = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                if col == 'imposter':\n                    imposter_count += 1\n                else:\n                    crewmate_count += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = 'imposter' if relation == 'crewmate' else 'crewmate'\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1, 0, 0\n                    else:\n                        color[neighbor] = expected_color\n                        queue.append((neighbor, expected_color))\n            \n            return 0, imposter_count, crewmate_count\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                contradiction, imposter_count, crewmate_count = bfs(player)\n                if contradiction == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += max(imposter_count, crewmate_count)\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color if relation == 'crewmate' else 1 - current_color\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            color[start] = 'imposter'\n            count = {'imposter': 0, 'crewmate': 0}\n            count['imposter'] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = 'crewmate' if relation == 'imposter' else 'imposter'\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n            \n            return max(count['imposter'], count['crewmate'])\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        contradiction = False\n        max_impostors = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([start])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n                    elif color[neighbor] != expected_color:\n                        contradiction = True\n                        return 0\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:\n                max_impostors += bfs(player)\n                if contradiction:\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_impostors)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        contradiction = True\n                        return 0\n                else:\n                    color[node] = col\n                    if col == 1:\n                        local_imposters += 1\n                    else:\n                        local_crewmates += 1\n                    \n                    for neighbor, relation in graph[node]:\n                        queue.append((neighbor, col ^ relation))\n            \n            return max(local_imposters, local_crewmates)\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                max_imposters += bfs(player)\n                if contradiction:\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        contradiction_detected = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        return -1, 0, 0\n                    continue\n                \n                color[node] = col\n                if col == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 1 - col))\n                    else:\n                        queue.append((neighbor, col))\n            \n            return 0, local_imposters, local_crewmates\n        \n        total_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction_detected = True\n                    break\n                total_imposters += max(imposters, crewmates)\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            results.append(total_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.color = [-1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, same):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            return self.color[u] == self.color[v] if same else self.color[u] != self.color[v]\n\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] if same else 1 - self.color[v]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if uf.color[i] == -1:\n                uf.color[i] = 0\n            if uf.color[j] == -1:\n                uf.color[j] = 0\n            \n            if c == \"imposter\":\n                if not uf.union(i, j, False):\n                    contradiction = True\n                    break\n            elif c == \"crewmate\":\n                if not uf.union(i, j, True):\n                    contradiction = True\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            max_im\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the number of players and the number of comments.\",\n        \"For each of the next m lines, read the integers i, j, and the string c, representing a comment about the relationship between players i and j.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem as a graph where players are nodes and comments are edges with labels.\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"For each comment, add an edge between nodes i and j with a label indicating 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"steps\": [\n        \"Use a union-find or disjoint set data structure to manage groups of players.\",\n        \"For each comment, check if adding the comment creates a contradiction based on existing group information.\",\n        \"If a contradiction is found, mark the test case as having a contradiction.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters possible for each test case without contradictions.\",\n      \"steps\": [\n        \"For each connected component in the graph, attempt to assign roles (imposter or crewmate) to maximize imposters.\",\n        \"Use a bipartite graph check to ensure no contradictions arise within the component.\",\n        \"Calculate the maximum number of imposters by considering both possible role assignments for each component.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was detected, output -1.\",\n        \"Otherwise, output the calculated maximum number of imposters.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, construct a graph based on the comments.\",\n    \"Use a union-find structure to detect contradictions in the comments.\",\n    \"For each non-contradictory test case, determine the maximum number of imposters using a bipartite graph approach.\",\n    \"Output the results for each test case.\"\n  ]\n\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors': refers to players who are not truthful and are trying to deceive others.\n    'contradict': refers to comments that conflict with each other, making it impossible to determine the roles of players consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': means finding the highest count of impostors that can be deduced without contradictions.\n    'number of test cases': refers to the total count of scenarios to be evaluated.\n    'number of players': refers to the count of participants excluding Theofanis.\n    'number of comments': refers to the count of remarks made by players.\n\n# [degree adverb]\n    'maximum': means the highest possible count of impostors that can be deduced without contradictions.\n\n# [code logic]\n    The steps related to parsing input and constructing the graph should be implemented simultaneously as they are part of the input processing phase. Specifically:\n    - \"Read the integer t, the number of test cases.\"\n    - \"For each test case, read the integers n and m, representing the number of players and the number of comments.\"\n    - \"For each of the next m lines, read the integers i, j, and the string c, representing a comment about the relationship between players i and j.\"\n    These can be done in a single loop that processes the input data.\n\n# [edge case]\n    Test case with no comments (e.g., n = 5, m = 0) = 5\n    Explanation: With no comments, all players can be impostors as there are no contradictions.\n    Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n    Explanation: The comments directly contradict each other, making it impossible to determine roles consistently.\n    Test case with all players commenting as impostors (e.g., 1 2 imposter, 2 3 imposter, 3 4 imposter) = 4\n    Explanation: If all comments are consistent and indicate impostors, the maximum number of impostors is the number of players.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions and handling cases with no comments.\n    - Implement a check for contradictions using union-find or disjoint set data structure.\n    - Handle cases with no comments by defaulting to all players being impostors.\n\nYES", "Round_0": {"code": "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.color = [-1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, same):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            return self.color[u] == self.color[v] if same else self.color[u] != self.color[v]\n\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] if same else 1 - self.color[v]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if uf.color[i] == -1:\n                uf.color[i] = 0\n            if uf.color[j] == -1:\n                uf.color[j] = 0\n            \n            if c == \"imposter\":\n                if not uf.union(i, j, False):\n                    contradiction = True\n                    break\n            elif c == \"crewmate\":\n                if not uf.union(i, j, True):\n                    contradiction = True\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            max_im", "report": "The compilation output of the preceding code is: unindent does not match any outer indentation level (<string>, line 6)"}, "Round_1": {"code": "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.color = [-1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, same):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            return self.color[u] == self.color[v] if same else self.color[u] != self.color[v]\n\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] if same else 1 - self.color[v]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if uf.color[i] == -1:\n                uf.color[i] = 0\n            if uf.color[j] == -1:\n                uf.color[j] = 0\n            \n            if c == \"imposter\":\n                if not uf.union(i, j, False):\n                    contradiction = True\n                    break\n            elif c == \"crewmate\":\n                if not uf.union(i, j, True):\n                    contradiction = True\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            max_im"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m from the first line, representing the number of players and comments respectively.\",\n        \"For each of the next m lines, read the integers i, j and the string c, representing a comment about players i and j.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments.\",\n      \"steps\": [\n        \"Model the problem as a graph where each player is a node and each comment is an edge with a label (imposter or crewmate).\",\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors (imposter and crewmate) based on the comments.\",\n        \"If a contradiction is detected during traversal (i.e., a node needs to be colored both imposter and crewmate), mark the test case as having a contradiction.\",\n        \"If no contradiction is detected, count the maximum number of nodes colored as imposters.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters determined.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a graph based on the comments and attempt to color it using a graph traversal algorithm.\",\n    \"Detect contradictions during the graph traversal and determine the maximum number of imposters if no contradictions are found.\",\n    \"Output the results for each test case, either the maximum number of imposters or -1 if contradictions exist.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposters' and 'crewmates'\n    Explanation: In the context of the problem, imposters and crewmates are two distinct roles assigned to players. The comments describe relationships between players, indicating whether one player considers another an imposter or a crewmate.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters'\n    Explanation: This phrase indicates that the goal is to find the highest number of players that can be classified as imposters without contradictions in the comments.\n    Implementation: This can be achieved by traversing the graph and counting the nodes that can be consistently labeled as imposters.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The term 'maximum' refers to the largest possible count of imposters that can be determined from the comments without contradictions.\n    Implementation: Use a graph traversal algorithm to ensure the largest subset of nodes can be labeled as imposters.\n\n# [code logic]\n    The steps related to graph traversal and contradiction detection should be implemented simultaneously.\n    Explanation: The graph traversal to color nodes and detect contradictions should be done in a single pass using DFS or BFS, as both tasks are inherently linked.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: If there are no comments, all players can be considered imposters since there are no contradictions.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, making it impossible to consistently label players, resulting in -1.\n    \n    Test case with all players labeled as crewmates (e.g., 3 3 with comments \"1 2 crewmate\", \"2 3 crewmate\", \"1 3 crewmate\") = 0\n    Explanation: If all players are labeled as crewmates, none can be imposters, resulting in 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Special handling is required for cases with no comments and contradictory comments.\n    Code for handling edge cases:\n    ```python\n    if m == 0:\n        print(n)\n    elif contradiction_detected:\n        print(-1)\n    else:\n        # Continue with normal logic to count imposters\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                if node in color:\n                    if color[node] != col:\n                        return -1, -1\n                    continue\n                \n                color[node] = col\n                if col == 1:\n                    local_imposters += 1\n                else:\n                    local_crewmates += 1\n                \n                for neighbor, relation in graph[node]:\n                    queue.append((neighbor, col ^ relation))\n            \n            return local_imposters, local_crewmates\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                imposters, crewmates = bfs(player)\n                if imposters == -1:\n                    contradiction = True\n                    break\n                max_imposters += max(imposters, crewmates)\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m from the first line, representing the number of players and comments respectively.\",\n        \"For each of the next m lines, read the integers i, j and the string c, representing a comment about players i and j.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels.\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"For each comment, add an edge between nodes i and j with the label 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Detect contradictions in comments using graph traversal techniques.\",\n      \"steps\": [\n        \"Use a graph traversal method (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n        \"If a contradiction is found during traversal (i.e., a node needs to be colored both 'imposter' and 'crewmate'), mark the test case as having a contradiction.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum number of imposters if no contradictions are found.\",\n      \"steps\": [\n        \"For each connected component of the graph, determine the maximum number of nodes that can be colored as 'imposter'.\",\n        \"Sum the maximum number of imposters for all components to get the result for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was detected, output -1.\",\n        \"Otherwise, output the calculated maximum number of imposters.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"Model the problem using a graph with nodes as players and edges as comments.\",\n    \"Use graph traversal to detect contradictions in comments.\",\n    \"Calculate the maximum number of imposters for each test case if no contradictions are found.\",\n    \"Output the results for each test case\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors' and 'crewmates'\n    Explanation: In the context of the problem, players can either be impostors or crewmates. Comments made by players about each other help determine their roles. The goal is to find the maximum number of impostors or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This phrase indicates that we need to find the highest count of impostors possible given the constraints of the comments. In code, this involves calculating the maximum number of nodes that can be labeled as 'imposter' without contradictions.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to finding the largest possible number of impostors. In code, this is implemented by evaluating all possible configurations and selecting the one with the highest count of impostors.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, and they should be executed in sequence to ensure correct processing of the input and determination of the output.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, and all players can be impostors.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to determine roles without conflict.\n    3. Test case with a single player and no comments (e.g., n = 1, m = 0) = 1\n       Explanation: With only one player and no comments, the player can be an impostor.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using graph traversal to detect contradictions and calculate the maximum number of impostors will naturally handle these cases.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 102)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = col ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n                    elif color[neighbor] != expected_color:\n                        return -1\n            \n            return max(count)\n        \n        max_imposters = 0\n        contradiction = False\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players, number of comments, and the list of comments.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m from the first line, representing the number of players and comments respectively.\",\n        \"For the next m lines, read the comments in the format 'i j c', where i and j are player indices and c is either 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments for each test case.\",\n      \"steps\": [\n        \"Model the problem as a graph where each player is a node and each comment is an edge with a label ('imposter' or 'crewmate').\",\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n        \"If a contradiction is detected during traversal (i.e., a node needs to be colored differently than previously determined), mark the test case as having a contradiction.\",\n        \"If no contradiction is found, count the number of nodes colored as 'imposter' to determine the maximum number of imposters.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters determined from the graph coloring.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, construct a graph based on the comments.\",\n    \"Attempt to color the graph using two colors to represent 'imposter' and 'crewmate'.\",\n    \"Detect contradictions during graph coloring and determine the maximum number of imposters.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'imposters' and 'crewmates'\n    Explanation: In the context of the problem, imposters are players who are not truthful, while crewmates are players who are truthful. The comments made by players can be used to deduce the roles of other players.\n\n# [phrase showing quantity relationship]\n    'maximum possible number of imposters'\n    Explanation: This phrase indicates that we need to find the highest number of players that can be classified as imposters without contradictions in the comments.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This means we need to find the largest possible count of imposters that can be deduced from the comments without any contradictions.\n\n# [code logic]\n    The steps related to graph traversal and contradiction detection should be implemented simultaneously. Specifically, while traversing the graph, we should check for contradictions and color the nodes accordingly. This can be done using a single DFS or BFS traversal where we attempt to color the graph and detect contradictions in one pass.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: If there are no comments, all players can be considered imposters since there are no contradictions.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, so the output should be -1.\n    \n    Test case with all players commenting as imposters (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"1 3 imposter\") = 3\n    Explanation: All players can be imposters since there are no contradictions in the comments.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to contradiction detection.\n    ```python\n    def detect_contradictions_and_count_imposters(n, comments):\n        # Initialize graph and color map\n        graph = {i: [] for i in range(1, n+1)}\n        color = {}\n        \n        # Build graph\n        for i, j, c in comments:\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n        \n        def dfs(node, current_color):\n            if node in color:\n                return color[node] == current_color\n            color[node] = current", "Round_0": {"code": "def detect_contradictions_and_count_imposters(n, comments):\n    from collections import defaultdict, deque\n\n    # Initialize graph and color map\n    graph = defaultdict(list)\n    color = {}\n\n    # Build graph\n    for i, j, c in comments:\n        graph[i].append((j, c))\n        graph[j].append((i, c))\n\n    def bfs(start):\n        queue = deque([(start, 0)])  # Start coloring with 0 (imposter)\n        local_color = {}\n        local_color[start] = 0\n        imposter_count = 0\n        crewmate_count = 0\n\n        while queue:\n            node, current_color = queue.popleft()\n            if current_color == 0:\n                imposter_count += 1\n            else:\n                crewmate_count += 1\n\n            for neighbor, relation in graph[node]:\n                expected_color = current_color if relation == 'crewmate' else 1 - current_color\n                if neighbor in local_color:\n                    if local_color[neighbor] != expected_color:\n                        return -1, 0  # Contradiction found\n                else:\n                    local_color[neighbor] = expected_color\n                    queue.append((neighbor, expected_color))\n\n        return max(imposter_count, crewmate_count), 1\n\n    total_imposters = 0\n    visited = set()\n\n    for player in range(1, n + 1):\n        if player not in visited:\n            if player in graph:\n                result, valid = bfs(player)\n                if valid == -1:\n                    return -1\n                total_imposters += result\n            else:\n                total_imposters += 1  # No comments, can be an imposter\n\n    return total_imposters\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        comments = []\n\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            comments.append((i, j, c))\n            index += 1\n\n        result = detect_contradictions_and_count_imposters(n, comments)\n        results", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, players, comments, and the details of each comment.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each comment, read integers i, j and string c representing the players involved and the type of comment.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments.\",\n      \"steps\": [\n        \"Model the problem as a graph where players are nodes and comments are edges with labels 'imposter' or 'crewmate'.\",\n        \"Use a graph traversal technique (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n        \"During traversal, check for contradictions: if a node is already colored and a new edge suggests a different color, mark the test case as contradictory.\",\n        \"If no contradictions are found, count the maximum number of nodes colored as 'imposter'.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction is detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters determined.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"For each test case, construct a graph based on players and comments.\",\n    \"Attempt to color the graph using a two-coloring method to identify imposters and crewmates.\",\n    \"Detect contradictions during the coloring process.\",\n    \"Output the maximum number of imposters or -1 if contradictions are found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors', 'crewmates', 'contradict'\n    Explanation: The problem revolves around identifying impostors among players based on comments. 'Impostors' are players who are not truthful, while 'crewmates' are truthful. A contradiction occurs when comments about the same players conflict, making it impossible to determine roles consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of impostors that can be logically deduced from the comments without contradictions.\n    'at least': Not explicitly mentioned, but implied in ensuring that the number of impostors is maximized without contradiction.\n\n# [degree adverb]\n    'maximum': Refers to finding the largest possible number of impostors that can be identified without contradictions.\n\n# [code logic]\n    The steps in the plan related to graph traversal and contradiction detection should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal technique (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\"\n    - \"During traversal, check for contradictions: if a node is already colored and a new edge suggests a different color, mark the test case as contradictory.\"\n    These steps should be part of the same traversal logic to efficiently detect contradictions while attempting to color the graph.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be impostors.\n    2. Test case with a single contradictory comment (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: The comments directly contradict each other, making it impossible to determine roles.\n    3. Test case with all players as crewmates (e.g., 1 2 crewmate, 2 3 crewmate, 3 1 crewmate) = 0\n       Explanation: If all players are crewmates, no impostors can be identified.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, handle cases with no comments by defaulting to all players as impostors.\n    - Implement logic to detect direct contradictions during graph traversal.\n    ```python\n    if m == 0:\n        return", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            color[start] = 'imposter'\n            imposter_count = 0\n            crewmate_count = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                if col == 'imposter':\n                    imposter_count += 1\n                else:\n                    crewmate_count += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = 'imposter' if relation == 'crewmate' else 'crewmate'\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1, 0, 0\n                    else:\n                        color[neighbor] = expected_color\n                        queue.append((neighbor, expected_color))\n            \n            return 0, imposter_count, crewmate_count\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                contradiction, imposter_count, crewmate_count = bfs(player)\n                if contradiction == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += max(imposter_count, crewmate_count)\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            color[start] = 'imposter'\n            imposter_count = 0\n            crewmate_count = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                if col == 'imposter':\n                    imposter_count += 1\n                else:\n                    crewmate_count += 1\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = 'imposter' if relation == 'crewmate' else 'crewmate'\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1, 0, 0\n                    else:\n                        color[neighbor] = expected_color\n                        queue.append((neighbor, expected_color))\n            \n            return 0, imposter_count, crewmate_count\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                contradiction, imposter_count, crewmate_count = bfs(player)\n                if contradiction == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += max(imposter_count, crewmate_count)\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t from the first line representing the number of test cases.\",\n        \"For each test case, read the integers n and m representing the number of players and comments.\",\n        \"For each of the next m lines, read the comments in the format 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments for each test case.\",\n      \"steps\": [\n        \"Model the problem as a graph where players are nodes and comments are edges with labels 'imposter' or 'crewmate'.\",\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n        \"During traversal, check for contradictions: if a node is already colored and a new comment contradicts the existing color, mark the test case as contradictory.\",\n        \"If no contradictions are found, count the maximum number of nodes colored as 'imposter'.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction is detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters determined.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"For each test case, construct a graph based on players and comments.\",\n    \"Attempt to color the graph using a two-coloring method to identify imposters and crewmates.\",\n    \"Detect contradictions during graph traversal and handle them appropriately.\",\n    \"Output the maximum number of imposters or -1 if contradictions are found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors' and 'crewmates'\n    Explanation: In the context of the problem, impostors are players who are falsely claiming to be crewmates, while crewmates are players who are truthful. The goal is to determine the maximum number of impostors based on the comments provided.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This phrase indicates that we need to find the highest count of impostors that can be deduced from the comments without contradictions.\n    Implementation: This can be achieved by traversing the graph and counting the nodes labeled as 'imposter'.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The term 'maximum' refers to the largest number of impostors that can be identified without any contradictions in the comments.\n    Implementation: Use a graph traversal algorithm to ensure the largest possible count of impostors is calculated.\n\n# [code logic]\n    The steps related to graph traversal and contradiction detection should be implemented simultaneously.\n    Explanation: While traversing the graph, we should simultaneously check for contradictions and count impostors. This can be done using a single traversal loop where nodes are colored and contradictions are checked.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: If there are no comments, all players can be impostors since there are no contradictions.\n    Test case with contradictory comments (e.g., 2 2 with comments '1 2 imposter' and '2 1 crewmate') = -1\n    Explanation: Contradictory comments lead to an impossible situation, hence the output should be -1.\n    Test case with all players claiming others as impostors (e.g., 3 3 with comments '1 2 imposter', '2 3 imposter', '3 1 imposter') = 3\n    Explanation: If all players claim others as impostors without contradiction, all can be impostors.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    if m == 0:\n        print(n)\n    else:\n        # Implement graph traversal and contradiction detection logic\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color if relation == 'crewmate' else 1 - current_color\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 154)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, 'crewmate' if c == 'imposter' else 'imposter'))\n            index += 1\n        \n        color = {}\n        contradiction = False\n        \n        def bfs(start):\n            queue = deque([start])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color if relation == 'crewmate' else 1 - current_color\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n            \n            return max(count)\n        \n        max_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    contradiction = True\n                    break\n                max_imposters += result\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, players, comments, and the details of each comment.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each of the m comments, read the integers i, j and string c representing the players involved and the type of comment.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters or detect contradictions in comments.\",\n      \"steps\": [\n        \"Model the problem as a graph where players are nodes and comments are edges with labels 'imposter' or 'crewmate'.\",\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n        \"Detect contradictions by checking if any adjacent nodes have the same color when they should be different based on the comments.\",\n        \"Calculate the maximum number of imposters by counting nodes colored as 'imposter'.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction is detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"For each test case, construct a graph based on players and comments.\",\n    \"Attempt to color the graph using a two-coloring method to represent 'imposter' and 'crewmate'.\",\n    \"Detect contradictions during the coloring process.\",\n    \"Calculate the maximum number of imposters if no contradictions are found.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors' and 'crewmates'\n    Explanation: In the context of the problem, players can either be impostors or crewmates. Comments between players indicate whether one player thinks another is an impostor or a crewmate. The goal is to determine the maximum number of impostors or identify contradictions in the comments.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This refers to finding the highest count of impostors that can be deduced from the comments without contradictions. In code, this involves counting nodes in a graph that can be colored as 'imposter' without conflict.\n    'contradict each other'\n    Explanation: This means that the comments provide conflicting information that cannot be resolved logically. In code, this is detected when a graph coloring attempt fails due to conflicting constraints.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This indicates the need to find the largest possible number of impostors. In code, this involves maximizing the count of nodes colored as 'imposter' in a valid graph coloring.\n\n# [code logic]\n    The steps related to graph traversal and contradiction detection should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\"\n    - \"Detect contradictions by checking if any adjacent nodes have the same color when they should be different based on the comments.\"\n    These steps can be combined in a single traversal function that attempts to color the graph and checks for contradictions as it proceeds.\n\n# [edge case]\n    Test case with no comments (e.g., n = 5, m = 0) = 5\n    Explanation: With no comments, there are no constraints, so all players can be impostors.\n    Test case with a single contradictory comment (e.g., 1 2 imposter, 2 1 crewmate) = -1\n    Explanation: The comments directly contradict each other, leading to an unsolvable situation.\n    Test case with all players claiming each other as crewmates (e.g., 1 2 crewmate, 2 3 crewmate, 3 1 crewmate) = 0\n    Explanation: If all players claim each other as crewmates, the maximum number of impostors is zero.\n\n# [extra code for edge case]\n    We need extra code", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            color[start] = 'imposter'\n            count = {'imposter': 0, 'crewmate': 0}\n            count['imposter'] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = 'crewmate' if relation == 'imposter' else 'imposter'\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n            \n            return max(count['imposter'], count['crewmate'])\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 144)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        \n        def bfs(start):\n            queue = deque([(start, 'imposter')])\n            color[start] = 'imposter'\n            count = {'imposter': 0, 'crewmate': 0}\n            count['imposter'] += 1\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = 'crewmate' if relation == 'imposter' else 'imposter'\n                    \n                    if neighbor in color:\n                        if color[neighbor] != expected_color:\n                            return -1\n                    else:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append((neighbor, expected_color))\n            \n            return max(count['imposter'], count['crewmate'])\n        \n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in color:\n                result = bfs(player)\n                if result == -1:\n                    max_imposters = -1\n                    break\n                max_imposters += result\n        \n        results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t from the first line representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each of the next m lines, read the comments in the format 'i j c'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of impostors or detect contradictions in comments.\",\n      \"steps\": [\n        \"Model the problem as a graph where players are nodes and comments are edges with labels 'imposter' or 'crewmate'.\",\n        \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\",\n        \"During traversal, check for contradictions: if a node is already colored and a comment contradicts the current coloring, mark the test case as contradictory.\",\n        \"If no contradictions are found, count the maximum number of nodes colored as 'imposter'.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction is detected, output -1.\",\n        \"Otherwise, output the maximum number of impostors determined.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize data structures to store players and comments for each test case.\",\n    \"Iterate over each test case to parse input and build the graph representation.\",\n    \"For each test case, attempt to color the graph and detect contradictions using graph traversal.\",\n    \"Store the result for each test case based on the presence of contradictions or the maximum impostor count.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors', 'crewmates', 'contradict'\n    Explanation: The problem revolves around identifying impostors among players based on comments. An impostor is a player who is not truthful, while a crewmate is truthful. Contradictory comments occur when statements about the same players conflict, making it impossible to determine roles consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': This means we need to find the highest count of impostors that can be logically deduced from the comments without contradictions.\n\n# [degree adverb] \n    'maximum': This indicates that we need to find the largest possible number of impostors that can be identified without contradictions.\n\n# [code logic]\n    The steps related to graph traversal and contradiction detection should be implemented simultaneously. Specifically:\n    - \"Use a graph traversal algorithm (e.g., DFS or BFS) to attempt to color the graph with two colors representing 'imposter' and 'crewmate'.\"\n    - \"During traversal, check for contradictions: if a node is already colored and a comment contradicts the current coloring, mark the test case as contradictory.\"\n    These steps can be combined in a single traversal loop where nodes are colored and contradictions are checked concurrently.\n\n# [edge case] \n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, so all players can be impostors.\n    2. Test case with a single contradictory comment (e.g., n = 2, m = 2, comments: \"1 2 imposter\", \"2 1 crewmate\") = -1\n       Explanation: The comments directly contradict each other, making it impossible to determine roles.\n    3. Test case with all players as crewmates (e.g., n = 3, m = 2, comments: \"1 2 crewmate\", \"2 3 crewmate\") = 0\n       Explanation: If all comments indicate crewmates, the maximum number of impostors is zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, handle cases with no comments by defaulting to all players as impostors.\n    - Implement logic to detect direct contradictions during graph traversal.\n    ```python\n    if m == 0:\n        return n  # All players", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = [-1] * (n + 1)\n        contradiction = False\n        max_impostors = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([start])\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            \n            while queue:\n                node = queue.popleft()\n                current_color = color[node]\n                \n                for neighbor, relation in graph[node]:\n                    expected_color = current_color ^ relation\n                    if color[neighbor] == -1:\n                        color[neighbor] = expected_color\n                        count[expected_color] += 1\n                        queue.append(neighbor)\n                    elif color[neighbor] != expected_color:\n                        contradiction = True\n                        return 0\n            \n            return max(count)\n        \n        for player in range(1, n + 1):\n            if color[player] == -1:\n                max_impostors += bfs(player)\n                if contradiction:\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_impostors)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of players, number of comments, and the comments themselves.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, represent the players and their relationships based on the comments using a graph structure where nodes represent players and edges represent the comments.\",\n      \"output\": \"A graph representation for each test case.\"\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case by checking for inconsistencies in the graph (e.g., a player being both an imposter and a crewmate).\",\n      \"output\": \"A boolean indicating whether a contradiction exists for each test case.\"\n    },\n    {\n      \"description\": \"If no contradictions are found, determine the maximum number of imposters by analyzing the graph structure, possibly using a graph coloring or bipartite graph approach.\",\n      \"output\": \"The maximum number of imposters for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, construct a graph where nodes represent players and edges represent the comments.\",\n    \"Check the graph for contradictions by ensuring no player is labeled inconsistently.\",\n    \"If a contradiction is found, output -1 for that test case.\",\n    \"If no contradiction is found, use graph analysis techniques to determine the maximum number of imposters.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors' and 'crewmates'\n    Explanation: In the context of the problem, players can either be impostors or crewmates. Comments from players indicate relationships between them, where one player claims another is either an impostor or a crewmate. The task is to determine the maximum number of impostors or identify contradictions in these claims.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This refers to finding the highest count of impostors that can be deduced from the comments without contradictions. In code, this can be implemented by analyzing the graph structure to maximize the impostor count while ensuring consistency.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This indicates the need to find the largest possible number of impostors. In code, this can be implemented by using graph algorithms to explore all possible configurations and select the one with the highest impostor count.\n\n# [code logic]\n    The steps related to graph construction and contradiction detection should be implemented simultaneously. Specifically:\n    - Constructing the graph and checking for contradictions can be done in a single pass as comments are processed. This involves adding edges and checking for inconsistencies in player roles.\n\n# [edge case]\n    1. Test case with no comments (e.g., n = 5, m = 0) = 5\n       Explanation: With no comments, there are no contradictions, and all players can be impostors.\n    2. Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n       Explanation: Direct contradiction in comments leads to an output of -1.\n    3. Test case with a single player and no comments (e.g., n = 1, m = 0) = 1\n       Explanation: With only one player and no comments, the player can be an impostor.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, handle cases with no comments and direct contradictions:\n    ```python\n    if m == 0:\n        return n  # All players can be impostors if there are no comments\n    # Implement logic to detect direct contradictions\n    for comment in comments:\n        if contradiction_detected(comment):\n            return -1\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        contradiction = True\n                        return\n                else:\n                    color[node] = col\n                    if col == 1:\n                        local_imposters += 1\n                    else:\n                        local_crewmates += 1\n                    \n                    for neighbor, relation in graph[node]:\n                        queue.append((neighbor, col ^ relation))\n            \n            return max(local_imposters, local_crewmates)\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                max_imposters += bfs(player)\n                if contradiction:\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: unsupported operand type(s) for +=: 'int' and 'NoneType'"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if c == \"imposter\":\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n            else:\n                graph[i].append((j, 0))\n                graph[j].append((i, 0))\n        \n        color = {}\n        contradiction = False\n        max_imposters = 0\n        \n        def bfs(start):\n            nonlocal contradiction\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        contradiction = True\n                        return 0\n                else:\n                    color[node] = col\n                    if col == 1:\n                        local_imposters += 1\n                    else:\n                        local_crewmates += 1\n                    \n                    for neighbor, relation in graph[node]:\n                        queue.append((neighbor, col ^ relation))\n            \n            return max(local_imposters, local_crewmates)\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                max_imposters += bfs(player)\n                if contradiction:\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            results.append(max_imposters)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of players and comments.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read integers n and m representing the number of players and comments.\",\n        \"For each of the m comments, read the integers i, j and the string c.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem using a graph where players are nodes and comments are edges with labels indicating 'imposter' or 'crewmate'.\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"Add edges between nodes based on comments, labeling them as 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Detect contradictions in comments for each test case.\",\n      \"steps\": [\n        \"For each pair of players (i, j), check if there are conflicting comments ('imposter' and 'crewmate').\",\n        \"If a contradiction is found, mark the test case as invalid and prepare to output -1.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters possible without contradictions.\",\n      \"steps\": [\n        \"Use a graph traversal technique (e.g., DFS or BFS) to explore possible configurations of imposters and crewmates.\",\n        \"Track the number of imposters in each valid configuration.\",\n        \"Select the configuration with the maximum number of imposters.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if contradictions were detected, output -1.\",\n        \"Otherwise, output the maximum number of imposters found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases, players, and comments.\",\n    \"Model the problem using a graph with nodes and labeled edges.\",\n    \"Check for contradictions in comments for each test case.\",\n    \"Use graph traversal to find the maximum number of imposters possible.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors' and 'crewmates'\n    Explanation: In the context of the game, impostors are players who are pretending to be crewmates, while crewmates are genuine players. The task is to determine the maximum number of impostors based on comments made by players.\n\n# [phrase showing quantity relationship]\n    'maximum possible number'\n    Explanation: This indicates that we need to find the highest count of impostors that can be deduced from the comments without contradictions. In code, this can be implemented by exploring all possible configurations and selecting the one with the highest impostor count.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This means we need to find the largest possible number of impostors. In code, this can be implemented by keeping track of the highest count of impostors found during the graph traversal.\n\n# [code logic]\n    The steps related to detecting contradictions and determining the maximum number of impostors should be considered simultaneously. Specifically, while traversing the graph to find configurations, contradictions should be checked in the same process to ensure valid configurations are considered.\n\n# [edge case]\n    Test case with no comments (e.g., 5 0) = 5\n    Explanation: With no comments, there are no contradictions, and all players can be impostors.\n    \n    Test case with contradictory comments (e.g., 2 2 with comments \"1 2 imposter\" and \"2 1 crewmate\") = -1\n    Explanation: The comments contradict each other, so the output should be -1.\n    \n    Test case with all players commenting as impostors (e.g., 3 3 with comments \"1 2 imposter\", \"2 3 imposter\", \"1 3 imposter\") = 3\n    Explanation: All players can be impostors as there are no contradictions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that when there are no comments, all players can be impostors, and when contradictions are detected, the output should be -1.\n    ```python\n    if m == 0:\n        print(n)\n    elif contradiction_detected:\n        print(-1)\n    else:\n        # logic to find maximum impostors\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        contradiction_detected = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        return -1, 0, 0\n                    continue\n                \n                color[node] = col\n                if col == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 1 - col))\n                    else:\n                        queue.append((neighbor, col))\n            \n            return 0, local_imposters, local_crewmates\n        \n        total_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction_detected = True\n                    break\n                total_imposters += max(imposters, crewmates)\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            results.append(total_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        \n        if m == 0:\n            results.append(n)\n            continue\n        \n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        for _ in range(m):\n            i, j, c = data[index].split()\n            i, j = int(i), int(j)\n            graph[i].append((j, c))\n            graph[j].append((i, c))\n            index += 1\n        \n        color = {}\n        contradiction_detected = False\n        \n        def bfs(start):\n            queue = deque([(start, 0)])\n            local_imposters = 0\n            local_crewmates = 0\n            \n            while queue:\n                node, col = queue.popleft()\n                \n                if node in color:\n                    if color[node] != col:\n                        return -1, 0, 0\n                    continue\n                \n                color[node] = col\n                if col == 0:\n                    local_crewmates += 1\n                else:\n                    local_imposters += 1\n                \n                for neighbor, relation in graph[node]:\n                    if relation == 'imposter':\n                        queue.append((neighbor, 1 - col))\n                    else:\n                        queue.append((neighbor, col))\n            \n            return 0, local_imposters, local_crewmates\n        \n        total_imposters = 0\n        \n        for player in range(1, n + 1):\n            if player not in color:\n                result, imposters, crewmates = bfs(player)\n                if result == -1:\n                    contradiction_detected = True\n                    break\n                total_imposters += max(imposters, crewmates)\n        \n        if contradiction_detected:\n            results.append(-1)\n        else:\n            results.append(total_imposters)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the number of players and the number of comments.\",\n        \"For each of the next m lines, read the integers i, j, and the string c, representing a comment about the relationship between players i and j.\"\n      ]\n    },\n    {\n      \"description\": \"Model the problem as a graph where players are nodes and comments are edges with labels.\",\n      \"steps\": [\n        \"Create a graph representation where each player is a node.\",\n        \"For each comment, add an edge between nodes i and j with a label indicating 'imposter' or 'crewmate'.\"\n      ]\n    },\n    {\n      \"description\": \"Detect contradictions in the comments for each test case.\",\n      \"steps\": [\n        \"Use a union-find or disjoint set data structure to manage groups of players.\",\n        \"For each comment, check if adding the comment creates a contradiction based on existing group information.\",\n        \"If a contradiction is found, mark the test case as having a contradiction.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum number of imposters possible for each test case without contradictions.\",\n      \"steps\": [\n        \"For each connected component in the graph, attempt to assign roles (imposter or crewmate) to maximize imposters.\",\n        \"Use a bipartite graph check to ensure no contradictions arise within the component.\",\n        \"Calculate the maximum number of imposters by considering both possible role assignments for each component.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if a contradiction was detected, output -1.\",\n        \"Otherwise, output the calculated maximum number of imposters.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and comments.\",\n    \"For each test case, construct a graph based on the comments.\",\n    \"Use a union-find structure to detect contradictions in the comments.\",\n    \"For each non-contradictory test case, determine the maximum number of imposters using a bipartite graph approach.\",\n    \"Output the results for each test case.\"\n  ]\n\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'impostors': refers to players who are not truthful and are trying to deceive others.\n    'contradict': refers to comments that conflict with each other, making it impossible to determine the roles of players consistently.\n\n# [phrase showing quantity relationship]\n    'maximum possible number': means finding the highest count of impostors that can be deduced without contradictions.\n    'number of test cases': refers to the total count of scenarios to be evaluated.\n    'number of players': refers to the count of participants excluding Theofanis.\n    'number of comments': refers to the count of remarks made by players.\n\n# [degree adverb]\n    'maximum': means the highest possible count of impostors that can be deduced without contradictions.\n\n# [code logic]\n    The steps related to parsing input and constructing the graph should be implemented simultaneously as they are part of the input processing phase. Specifically:\n    - \"Read the integer t, the number of test cases.\"\n    - \"For each test case, read the integers n and m, representing the number of players and the number of comments.\"\n    - \"For each of the next m lines, read the integers i, j, and the string c, representing a comment about the relationship between players i and j.\"\n    These can be done in a single loop that processes the input data.\n\n# [edge case]\n    Test case with no comments (e.g., n = 5, m = 0) = 5\n    Explanation: With no comments, all players can be impostors as there are no contradictions.\n    Test case with contradictory comments (e.g., 1 2 imposter, 2 1 crewmate) = -1\n    Explanation: The comments directly contradict each other, making it impossible to determine roles consistently.\n    Test case with all players commenting as impostors (e.g., 1 2 imposter, 2 3 imposter, 3 4 imposter) = 4\n    Explanation: If all comments are consistent and indicate impostors, the maximum number of impostors is the number of players.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly for detecting contradictions and handling cases with no comments.\n    - Implement a check for contradictions using union-find or disjoint set data structure.\n    - Handle cases with no comments by defaulting to all players being impostors.\n\nYES", "Round_0": {"code": "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.color = [-1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, same):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            return self.color[u] == self.color[v] if same else self.color[u] != self.color[v]\n\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] if same else 1 - self.color[v]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if uf.color[i] == -1:\n                uf.color[i] = 0\n            if uf.color[j] == -1:\n                uf.color[j] = 0\n            \n            if c == \"imposter\":\n                if not uf.union(i, j, False):\n                    contradiction = True\n                    break\n            elif c == \"crewmate\":\n                if not uf.union(i, j, True):\n                    contradiction = True\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            max_im", "report": "The compilation output of the preceding code is: unindent does not match any outer indentation level (<string>, line 6)"}, "Round_1": {"code": "def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n        self.color = [-1] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v, same):\n        root_u = self.find(u)\n        root_v = self.find(v)\n\n        if root_u == root_v:\n            return self.color[u] == self.color[v] if same else self.color[u] != self.color[v]\n\n        if self.rank[root_u] > self.rank[root_v]:\n            self.parent[root_v] = root_u\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n        elif self.rank[root_u] < self.rank[root_v]:\n            self.parent[root_u] = root_v\n            self.color[root_u] = self.color[v] if same else 1 - self.color[v]\n        else:\n            self.parent[root_v] = root_u\n            self.rank[root_u] += 1\n            self.color[root_v] = self.color[u] if same else 1 - self.color[u]\n\n        return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        uf = UnionFind(n + 1)\n        \n        contradiction = False\n        \n        for _ in range(m):\n            i = int(data[index])\n            j = int(data[index + 1])\n            c = data[index + 2]\n            index += 3\n            \n            if uf.color[i] == -1:\n                uf.color[i] = 0\n            if uf.color[j] == -1:\n                uf.color[j] = 0\n            \n            if c == \"imposter\":\n                if not uf.union(i, j, False):\n                    contradiction = True\n                    break\n            elif c == \"crewmate\":\n                if not uf.union(i, j, True):\n                    contradiction = True\n                    break\n        \n        if contradiction:\n            results.append(-1)\n        else:\n            max_im"}}], "scores": [], "pass_results": [false, false, true, false, false, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 493, "prompt": "Assist Theofanis in determining the maximum number of impostors among the other participants from Cyprus, or deduce that the remarks contradict one another (refer to the notes for further information).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of each test case follows.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 2 \u22c5 10^5; 0 \u2264 m \u2264 5 \u22c5 10^5) \u2014 the number of players except Theofanis and the number of comments.\n\nEach of the next m lines contains a comment made by the players of the structure \"i j c\" where i and j are two distinct integers and c is a string (1 \u2264 i, j \u2264 n; i \u2260 j; c is either imposter or crewmate).\n\nThere can be multiple comments for the same pair of (i, j).\n\nIt is guaranteed that the sum of all n does not exceed 2 \u22c5 10^5 and the sum of all m does not exceed 5 \u22c5 10^5.\n\nOutput\n\nFor each test case, print one integer \u2014 the maximum possible number of imposters. If the comments contradict each other, print -1.\n\nExample\n\nInput\n\n\n5\n3 2\n1 2 imposter\n2 3 crewmate\n5 4\n1 3 crewmate\n2 5 crewmate\n2 4 imposter\n3 4 imposter\n2 2\n1 2 imposter\n2 1 crewmate\n3 5\n1 2 imposter\n1 2 imposter\n3 2 crewmate\n3 2 crewmate\n1 3 imposter\n5 0\n\n\nOutput\n\n\n2\n4\n-1\n2\n5\n\nNote\n\nIn the first test case, imposters can be Andreas 2 and 3.\n\nIn the second test case, imposters can be Andreas 1, 2, 3 and 5.\n\nIn the third test case, comments contradict each other. This is because player 1 says that player 2 is an imposter, and player 2 says that player 1 is a crewmate. If player 1 is a crewmate, then he must be telling the truth, so player 2 must be an imposter. But if player 2 is an imposter then he must be lying, so player 1 can't be a crewmate. Contradiction.", "mutate_method": "condense_two2one", "save_node": true, "parent_index": 244}
