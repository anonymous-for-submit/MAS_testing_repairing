{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "repair_prompt": ["CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The blocks located at the edges of the rectangle need to be obsidian, which forms a boundary along the vertical sides.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns. It is not the same as having b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Consider various dimensions of rectangle A to determine if a portal can be created efficiently.\n\nTaking into account the variety of potential locations for portals within the rectangle is crucial for minimizing the number of operations needed.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The blocks located at the edges of the rectangle need to be obsidian. This forms a boundary along the vertical sides.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns. It is not the same as having b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Consider various dimensions of rectangle A to determine if a portal can be created efficiently.\n\nTaking into account the variety of potential locations for portals within the rectangle is crucial. This is important for minimizing the number of operations needed.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks; each block of the rectangle is an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The blocks located at the edges of the rectangle need to be obsidian, which forms a boundary along the vertical sides.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the there must be a rows and b columns, which is not the same as having b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Taking into account the variety of potential locations for portals within the rectangle is crucial for minimizing the number of operations needed.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Try all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(start_row, start_row + a):\n                            if x == start_row or x == start_row + a - 1:\n                                # Top and bottom rows\n                                for y in range(start_col + 1, start_col + b - 1):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right columns\n                                if grid[x][start_col] != '1':\n                                    operations += 1\n                                if grid[x][start_col + b - 1] != '1':\n                                    operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check vertical boundaries\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] == '0':\n                                operations += 1\n                            if grid[start_row + x][start_col + b - 1] == '0':\n                                operations += 1\n                        \n                        # Check horizontal boundaries\n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] == '0':\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + y] == '0':\n                                operations += 1\n                        \n                        # Check inner blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] == '1':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(n, m, grid):\n    min_operations = float('inf')\n    \n    # Iterate over all possible sub-rectangles of size a \u00d7 b\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            # Iterate over all possible top-left corners of the sub-rectangle\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    operations = 0\n                    \n                    # Check vertical boundaries\n                    for x in range(1, a - 1):\n                        if grid[i + x][j] != '1':  # Left boundary\n                            operations += 1\n                        if grid[i + x][j + b - 1] != '1':  # Right boundary\n                            operations += 1\n                    \n                    # Check horizontal boundaries\n                    for y in range(1, b - 1):\n                        if grid[i][j + y] != '1':  # Top boundary\n                            operations += 1\n                        if grid[i + a - 1][j + y] != '1':  # Bottom boundary\n                            operations += 1\n                    \n                    # Check inner blocks\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[i + x][j + y] != '0':\n                                operations += 1\n                    \n                    # Update minimum operations\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(n, m, grid):\n    # Function to calculate the number of operations needed to transform a sub-rectangle into a portal\n    def calculate_operations(x, y, a, b):\n        operations = 0\n        # Check the vertical boundaries\n        for i in range(1, a - 1):\n            if grid[x + i][y] != '1':\n                operations += 1\n            if grid[x + i][y + b - 1] != '1':\n                operations += 1\n        # Check the horizontal boundaries\n        for j in range(1, b - 1):\n            if grid[x][y + j] != '1':\n                operations += 1\n            if grid[x + a - 1][y + j] != '1':\n                operations += 1\n        # Check the inner area\n        for i in range(1, a - 1):\n            for j in range(1, b - 1):\n                if grid[x + i][y + j] != '0':\n                    operations += 1\n        return operations\n\n    min_operations = float('inf')\n    # Iterate over all possible top-left corners of sub-rectangles\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    operations = calculate_operations(i, j, a, b)\n                    min_operations = min(min_operations, operations)\n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Check all sub-rectangles of size a x b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        # If no valid portal found, return -1\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(t,\nmain()", "def calculate_operations(n, m, grid):\n    # Initialize a large number for minimum operations\n    min_operations = float('inf')\n    \n    # Iterate over all possible top-left corners of sub-rectangles\n    for start_row in range(n):\n        for start_col in range(m):\n            # Iterate over all possible dimensions a and b\n            for a in range(5, n - start_row + 1):\n                for b in range(4, m - start_col + 1):\n                    # Calculate operations needed for this sub-rectangle\n                    operations = 0\n                    \n                    # Check vertical boundaries\n                    for x in range(1, a - 1):\n                        if grid[start_row + x][start_col] != '1':\n                            operations += 1\n                        if grid[start_row + x][start_col + b - 1] != '1':\n                            operations += 1\n                    \n                    # Check horizontal boundaries\n                    for y in range(1, b - 1):\n                        if grid[start_row][start_col + y] != '1':\n                            operations += 1\n                        if grid[start_row + a - 1][start_col + y] != '1':\n                            operations += 1\n                    \n                    # Check inner blocks\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[start_row + x][start_col + y] != '0':\n                                operations += 1\n                    \n                    # Update minimum operations\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = calculate_operations(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check sub-rectangle of size 5x4\n                operations = 0\n                \n                # Check vertical boundaries\n                for i in range(1, 4):\n                    if grid[start_row + i][start_col] == '0':\n                        operations += 1\n                    if grid[start_row + i][start_col + 3] == '0':\n                        operations += 1\n                \n                # Check horizontal boundaries\n                for j in range(1, 3):\n                    if grid[start_row][start_col + j] == '0':\n                        operations += 1\n                    if grid[start_row + 4][start_col + j] == '0':\n                        operations += 1\n                \n                # Check interior blocks\n                for i in range(1, 4):\n                    for j in range(1, 3):\n                        if grid[start_row + i][start_col + j] == '1':\n                            operations += 1\n                \n                # Update minimum operations\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Edge block\n                                    if (i == 0 and (j == 0 or j == b - 1)) or (i == a - 1 and (j == 0 or j == b - 1)):\n                                        # Corner block, can be any type\n                                        continue\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Interior block\n                                    if current_block == '1':\n                                        operations += 1\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] != '1':\n                                operations += 1\n                            if grid[start_row + x][start_col + b - 1] != '1':\n                                operations += 1\n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + y] != '1':\n                                operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate operations needed for sub-rectangle of size 5x4\n                operations = 0\n                \n                # Check the boundary conditions\n                for i in range(1, 4):\n                    if grid[start_row + i][start_col] != '1':\n                        operations += 1\n                    if grid[start_row + i][start_col + 3] != '1':\n                        operations += 1\n                \n                for j in range(1, 3):\n                    if grid[start_row][start_col + j] != '1':\n                        operations += 1\n                    if grid[start_row + 4][start_col + j] != '1':\n                        operations += 1\n                \n                # Check the interior conditions\n                for i in range(1, 4):\n                    for j in range(1, 3):\n                        if grid[start_row + i][start_col + j] != '0':\n                            operations += 1\n                \n                # Update the minimum operations needed\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Try all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(start_row, start_row + a):\n                            if x == start_row or x == start_row + a - 1:\n                                # Top and bottom rows\n                                for y in range(start_col + 1, start_col + b - 1):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right columns\n                                if grid[x][start_col] != '1':\n                                    operations += 1\n                                if grid[x][start_col + b - 1] != '1':\n                                    operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the boundary conditions for obsidian blocks and the interior conditions for empty blocks.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required to satisfy the portal conditions for each sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all sub-rectangles.\",\n      \"details\": \"Compare the operation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases, dimensions, and block configurations.\",\n      \"details\": \"Read and store the input data for processing.\"\n    },\n    {\n      \"step\": \"Iterate over each test case and process the rectangle.\",\n      \"details\": \"For each test case, perform the following operations.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\",\n      \"details\": \"Use nested loops to iterate over potential top-left corners and dimensions.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal.\",\n      \"details\": \"Verify the portal conditions and calculate the required operations.\"\n    },\n    {\n      \"step\": \"Track the minimum number of operations needed for each test case.\",\n      \"details\": \"Store and update the minimum operation count for each test case.\"\n    },\n    {\n      \"step\": \"Output the minimum number of operations for each test case.\",\n      \"details\": \"Print the results for all test cases in the required format.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where the operations will be performed. It consists of n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions regarding the placement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: Changing a block from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means ensuring any sub-rectangle considered has these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the lowest operation count found.\n\n# [code logic]\n    Steps 3 and 4 should be implemented simultaneously:\n    \"Generate all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle\" and \"For each sub-rectangle, check if it can be transformed into a portal\" can be combined. As you generate each sub-rectangle, you can immediately check if it meets the portal conditions and calculate the operations needed.\n\n# [edge case]\n    1. n = 5, m = 4, all blocks are obsidian (1)\n       Expected output: 0\n       Explanation: The entire rectangle already satisfies the portal conditions, so no operations are needed.\n\n    2. n = 5, m = 4, all blocks are empty (0)\n       Expected output: 12\n       Explanation: All boundary blocks need to be changed to obsidian, requiring 12 operations.\n\n    3. n = 6, m = 5, with a mix of obsidian and empty blocks such that no portal can be formed without changes.\n       Expected output: Depends on the specific configuration, but should be calculated based on the minimum operations needed to form a valid portal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the code correctly identifies when no operations are needed (e.g., when the entire rectangle already forms a portal) and calculates the correct number of operations for various configurations.\n    \n    Example code snippet for handling edge cases:\n    ```python\n    def", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Try all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(start_row, start_row + a):\n                            if x == start_row or x == start_row + a - 1:\n                                # Top and bottom rows\n                                for y in range(start_col + 1, start_col + b - 1):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right columns\n                                if grid[x][start_col] != '1':\n                                    operations += 1\n                                if grid[x][start_col + b - 1] != '1':\n                                    operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify potential sub-rectangles within the given rectangle A that can be transformed into a portal.\",\n      \"details\": \"Iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle A, where a \u2265 5 and b \u2265 4.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n      \"details\": \"For each sub-rectangle, count the number of changes needed to satisfy the portal conditions: vertical and horizontal boundaries of obsidian blocks, and inner blocks as empty.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all potential sub-rectangles.\",\n      \"details\": \"Compare the operation counts for all sub-rectangles and select the minimum value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse Input\",\n      \"description\": \"Read the number of test cases, and for each test case, read the dimensions n and m, followed by the n lines of m characters representing the rectangle A.\"\n    },\n    {\n      \"step\": \"Iterate Over Sub-rectangles\",\n      \"description\": \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the rectangle A, ensuring a \u2265 5 and b \u2265 4.\"\n    },\n    {\n      \"step\": \"Calculate Operations for Each Sub-rectangle\",\n      \"description\": \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal by checking and modifying the boundary and inner blocks as required.\"\n    },\n    {\n      \"step\": \"Find Minimum Operations\",\n      \"description\": \"Track the minimum number of operations needed across all sub-rectangles for each test case.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"description\": \"Output the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle within the given rectangle A that meets specific conditions regarding its boundaries and inner blocks. The portal must have vertical and horizontal boundaries of obsidian blocks, with inner blocks being empty, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: This indicates that the dimensions of the portal must be at least 5 rows and 4 columns. In code, this can be implemented by iterating over sub-rectangles with dimensions satisfying these conditions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to find the minimum number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the smallest number of operations required across all possible sub-rectangles.\n\n# [code logic]\n    The steps \"Iterate Over Sub-rectangles\" and \"Calculate Operations for Each Sub-rectangle\" should be implemented simultaneously. This can be done by iterating over possible sub-rectangles and calculating the required operations in the same loop.\n\n# [edge case]\n    Case 1: A rectangle with all blocks already forming a portal.\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as the rectangle already forms a portal.\n\n    Case 2: A rectangle with minimum dimensions but no obsidian blocks.\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All boundary blocks need to be changed to obsidian, requiring 12 operations.\n\n    Case 3: A rectangle with dimensions larger than required but no portal possible.\n    Input: \n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: 16\n    Explanation: The minimum operations needed to form a portal in any sub-rectangle of size 5x4.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check vertical boundaries\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] == '0':\n                                operations += 1\n                            if grid[start_row + x][start_col + b - 1] == '0':\n                                operations += 1\n                        \n                        # Check horizontal boundaries\n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] == '0':\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + y] == '0':\n                                operations += 1\n                        \n                        # Check inner blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] == '1':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify potential portal locations\",\n      \"description\": \"Iterate over all possible sub-rectangles of size a \u00d7 b within the given rectangle A, where a \u2265 5 and b \u2265 4.\"\n    },\n    {\n      \"subproblem\": \"Check portal conditions\",\n      \"description\": \"For each potential portal location, verify if it satisfies the portal conditions: vertical and horizontal boundaries must be obsidian blocks, and the inner blocks must be empty.\"\n    },\n    {\n      \"subproblem\": \"Calculate operations needed\",\n      \"description\": \"For each sub-rectangle that does not satisfy the portal conditions, calculate the number of operations needed to convert it into a portal.\"\n    },\n    {\n      \"subproblem\": \"Determine minimum operations\",\n      \"description\": \"Track the minimum number of operations required across all potential portal locations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse input\",\n      \"description\": \"Read the number of test cases, and for each test case, read the dimensions of rectangle A and its block configuration.\"\n    },\n    {\n      \"step\": \"Iterate over test cases\",\n      \"description\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Iterate over potential portal locations\",\n      \"description\": \"For each sub-rectangle of size a \u00d7 b within rectangle A, check if it can be a portal.\"\n    },\n    {\n      \"step\": \"Verify portal conditions\",\n      \"description\": \"Check if the current sub-rectangle satisfies the portal conditions. If not, calculate the number of operations needed to convert it.\"\n    },\n    {\n      \"step\": \"Track minimum operations\",\n      \"description\": \"Update the minimum number of operations required for the current test case.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"description\": \"After processing all test cases, output the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b within the given rectangle A, where a \u2265 5 and b \u2265 4. The portal must have specific conditions: vertical and horizontal boundaries must be obsidian blocks, and the inner blocks must be empty, with corners being any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means that the dimensions of the portal must be at least 5 rows and 4 columns.\n    '1 < x < a': This indicates that the vertical boundaries are defined for rows between the first and last row.\n    '1 < y < b': This indicates that the horizontal boundaries are defined for columns between the first and last column.\n\n# [degree adverb] \n    'minimum': This refers to finding the least number of operations needed to convert a sub-rectangle into a portal.\n\n# [code logic]\n    The steps \"Iterate over potential portal locations\" and \"Verify portal conditions\" should be implemented simultaneously. This can be done by iterating over all possible sub-rectangles and checking the portal conditions in the same loop to efficiently calculate the operations needed.\n\n# [edge case] \n    1. A rectangle that is already a portal: If the input rectangle already satisfies the portal conditions, the expected output is 0 operations.\n    Explanation: No changes are needed if the rectangle is already a portal.\n    \n    2. A rectangle with the minimum size of 5x4 but all blocks are the opposite of what is needed: The expected output is the total number of blocks minus the corners.\n    Explanation: All blocks except the corners need to be changed to satisfy the portal conditions.\n    \n    3. A rectangle with dimensions larger than 5x4 but with no possible portal: The expected output is the minimum operations needed to convert any sub-rectangle into a portal.\n    Explanation: The algorithm should find the sub-rectangle that requires the fewest changes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the rectangle is already a portal or where no portal can be formed without changes.\n    ```python\n    def is_portal(sub_rect):\n        # Check if the sub-rectangle is already a portal\n        # Implement logic to verify portal conditions\n        pass\n\n    def calculate_operations(sub_rect):\n        # Calculate the number of operations needed to convert sub-rectangle into a portal", "Round_0": {"code": "def min_operations_to_portal(n, m, grid):\n    min_operations = float('inf')\n    \n    # Iterate over all possible sub-rectangles of size a \u00d7 b\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            # Iterate over all possible top-left corners of the sub-rectangle\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    operations = 0\n                    \n                    # Check vertical boundaries\n                    for x in range(1, a - 1):\n                        if grid[i + x][j] != '1':  # Left boundary\n                            operations += 1\n                        if grid[i + x][j + b - 1] != '1':  # Right boundary\n                            operations += 1\n                    \n                    # Check horizontal boundaries\n                    for y in range(1, b - 1):\n                        if grid[i][j + y] != '1':  # Top boundary\n                            operations += 1\n                        if grid[i + a - 1][j + y] != '1':  # Bottom boundary\n                            operations += 1\n                    \n                    # Check inner blocks\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[i + x][j + y] != '0':\n                                operations += 1\n                    \n                    # Update minimum operations\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles within A and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"For each sub-rectangle, verify if it meets the portal conditions and calculate the number of operations needed to transform it into a portal.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum number of operations needed for each test case.\",\n      \"details\": \"For each test case, determine the sub-rectangle that requires the least number of operations to become a portal.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input data.\",\n      \"details\": \"Read the number of test cases, dimensions of rectangle A, and the block configuration for each test case.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a \u00d7 b.\",\n      \"details\": \"For each possible top-left corner in rectangle A, generate sub-rectangles of size a \u00d7 b.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal conditions.\",\n      \"details\": \"Check if each sub-rectangle meets the portal conditions and calculate the number of operations needed.\"\n    },\n    {\n      \"step\": \"Determine the minimum operations for the test case.\",\n      \"details\": \"Find the sub-rectangle that requires the least number of operations to become a portal and store the result.\"\n    },\n    {\n      \"step\": \"Output the results for all test cases.\",\n      \"details\": \"Print the minimum number of operations needed for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b within the given rectangle A that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: This indicates that the dimensions of the portal must be at least 5 rows and 4 columns. In code, this can be implemented by ensuring that any sub-rectangle considered has dimensions that meet these minimum requirements.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to find the sub-rectangle that requires the least number of operations to become a portal. In code, this involves keeping track of the number of operations for each sub-rectangle and selecting the one with the smallest count.\n\n# [code logic]\n    The steps \"Generate all possible sub-rectangles of size a \u00d7 b\" and \"Evaluate each sub-rectangle for portal conditions\" should be implemented simultaneously. This can be done by iterating over possible top-left corners and immediately checking if the sub-rectangle meets portal conditions and calculating operations needed.\n\n# [edge case]\n    Input: 5 4\n           1111\n           1111\n           1111\n           1111\n           1111\n    Output: 0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Input: 5 4\n           0000\n           0000\n           0000\n           0000\n           0000\n    Output: 12\n    Explanation: All blocks need to be changed to meet the portal conditions.\n\n    Input: 6 5\n           11111\n           10001\n           10001\n           10001\n           10001\n           11111\n    Output: 0\n    Explanation: The rectangle already meets the portal conditions, so no operations are needed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def is_portal(sub_rect):\n        # Check if sub_rect meets portal conditions\n        # Return number of operations needed\n\n    def min_operations(rectangle, n, m):\n        min_ops = float('inf')\n        for i in range(n - 4):\n            for j in range(m - 3):\n                sub_rect =", "Round_0": {"code": "def min_operations_to_portal(n, m, grid):\n    # Function to calculate the number of operations needed to transform a sub-rectangle into a portal\n    def calculate_operations(x, y, a, b):\n        operations = 0\n        # Check the vertical boundaries\n        for i in range(1, a - 1):\n            if grid[x + i][y] != '1':\n                operations += 1\n            if grid[x + i][y + b - 1] != '1':\n                operations += 1\n        # Check the horizontal boundaries\n        for j in range(1, b - 1):\n            if grid[x][y + j] != '1':\n                operations += 1\n            if grid[x + a - 1][y + j] != '1':\n                operations += 1\n        # Check the inner area\n        for i in range(1, a - 1):\n            for j in range(1, b - 1):\n                if grid[x + i][y + j] != '0':\n                    operations += 1\n        return operations\n\n    min_operations = float('inf')\n    # Iterate over all possible top-left corners of sub-rectangles\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    operations = calculate_operations(i, j, a, b)\n                    min_operations = min(min_operations, operations)\n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configuration for each rectangle.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read integers n and m representing the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the block configuration of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle A.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the bounds of n \u00d7 m.\",\n        \"For each top-left corner, check if a sub-rectangle of size a \u00d7 b can fit within the bounds of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Evaluate each sub-rectangle to determine the number of operations needed to transform it into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the boundary conditions for obsidian blocks as specified in the requirement.\",\n        \"Count the number of operations needed to convert the current configuration into a portal configuration.\",\n        \"Keep track of the minimum number of operations required across all sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"steps\": [\n        \"For each test case, output the minimum number of operations needed to create at least one portal.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, dimensions, and block configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the given rectangle.\",\n    \"Evaluate each sub-rectangle to determine the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can either be an obsidian block or an empty block. The dimensions n and m specify the number of rows and columns, respectively.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific conditions, including having a boundary of obsidian blocks and an interior of empty blocks, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: This specifies the minimum size requirements for the portal. In code, this means that when iterating over possible sub-rectangles, only those with dimensions at least 5 rows and 4 columns should be considered.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This refers to finding the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the least number of changes required across all possible sub-rectangles.\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, ensuring that the process of identifying and transforming sub-rectangles is clear and sequential.\n\n# [edge case]\n    1. A rectangle that is already a portal: \n       Input: \n       ```\n       1\n       5 4\n       1111\n       1001\n       1001\n       1001\n       1111\n       ```\n       Expected Output: 0\n       Explanation: The rectangle is already a portal, so no operations are needed.\n\n    2. A rectangle with no possible portal due to size constraints:\n       Input:\n       ```\n       1\n       4 3\n       111\n       101\n       101\n       111\n       ```\n       Expected Output: -1 or some indication of impossibility\n       Explanation: The rectangle is too small to form a portal, as it does not meet the minimum size requirements.\n\n    3. A rectangle with all blocks the same type:\n       Input:\n       ```\n       1\n       5 4\n       0000\n       0000\n       0000\n       0000\n       0000\n       ```\n       Expected Output: 12\n       Explanation: All blocks need to be changed to", "Round_0": {"code": "def min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Check all sub-rectangles of size a x b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        # If no valid portal found, return -1\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(t,", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 67)"}, "Round_1": {"code": "def min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Check all sub-rectangles of size a x b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        # If no valid portal found, return -1\n        if min_operations == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(t,"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the dimensions of each rectangle along with their block configurations.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the rectangle A.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle A that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within A.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of A.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each candidate sub-rectangle, check the current configuration of blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions: vertical and horizontal boundaries of obsidian blocks, and inner blocks as empty.\",\n        \"Consider the flexibility of corner blocks which can be any type.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all possible sub-rectangles for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum number of operations needed among all candidate sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each rectangle.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the given rectangle.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b within the given rectangle A that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': These conditions specify the minimum dimensions for a sub-rectangle to be considered a portal. In code, this can be implemented by iterating over possible sub-rectangles and checking if their dimensions meet these criteria.\n    'sum of n over all test cases does not exceed 400': This indicates a constraint on the total number of rows across all test cases, ensuring efficient processing within these limits.\n    'sum of m over all test cases does not exceed 400': Similar to the constraint on n, this ensures the total number of columns across all test cases is manageable.\n\n# [degree adverb]\n    'minimum': The goal is to find the least number of operations needed to transform a sub-rectangle into a portal. In code, this involves tracking the smallest count of operations required across all candidate sub-rectangles.\n\n# [code logic]\n    The steps in the plan are sequential and do not require simultaneous implementation. Each step builds upon the previous one, from parsing input to calculating operations and determining the minimum.\n\n# [edge case]\n    Edge case 1: A rectangle with dimensions exactly 5 \u00d7 4, filled entirely with empty blocks.\n    Expected output: The number of operations needed to transform it into a portal, which would involve changing the necessary boundary blocks to obsidian.\n    Explanation: Since the rectangle is the smallest possible portal size, the operations will focus on changing the boundary blocks.\n\n    Edge case 2: A rectangle with dimensions larger than 5 \u00d7 4, but with all blocks already in the portal configuration.\n    Expected output: 0\n    Explanation: No operations are needed as the rectangle already satisfies the portal conditions.\n\n    Edge case 3: A rectangle with dimensions larger than 5 \u00d7 4, but with all blocks as obsidian.\n    Expected output: The number of operations needed to change the inner blocks to empty while maintaining the boundary conditions.\n    Explanation: The operations will focus on changing the inner blocks to empty while ensuring the boundary remains obsidian.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def calculate_operations(sub_rectangle):\n        # Initialize operation count", "Round_0": {"code": "def calculate_operations(n, m, grid):\n    # Initialize a large number for minimum operations\n    min_operations = float('inf')\n    \n    # Iterate over all possible top-left corners of sub-rectangles\n    for start_row in range(n):\n        for start_col in range(m):\n            # Iterate over all possible dimensions a and b\n            for a in range(5, n - start_row + 1):\n                for b in range(4, m - start_col + 1):\n                    # Calculate operations needed for this sub-rectangle\n                    operations = 0\n                    \n                    # Check vertical boundaries\n                    for x in range(1, a - 1):\n                        if grid[start_row + x][start_col] != '1':\n                            operations += 1\n                        if grid[start_row + x][start_col + b - 1] != '1':\n                            operations += 1\n                    \n                    # Check horizontal boundaries\n                    for y in range(1, b - 1):\n                        if grid[start_row][start_col + y] != '1':\n                            operations += 1\n                        if grid[start_row + a - 1][start_col + y] != '1':\n                            operations += 1\n                    \n                    # Check inner blocks\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[start_row + x][start_col + y] != '0':\n                                operations += 1\n                    \n                    # Update minimum operations\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = calculate_operations(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the boundary conditions for obsidian blocks and ensure the interior blocks are empty.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required to meet the portal conditions for each sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all sub-rectangles.\",\n      \"details\": \"Compare the operation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases and the dimensions and contents of each rectangle A.\",\n      \"details\": \"Read and store the input data for processing.\"\n    },\n    {\n      \"step\": \"Iterate over each test case and rectangle A.\",\n      \"details\": \"Process each test case independently.\"\n    },\n    {\n      \"step\": \"For each rectangle A, iterate over all possible sub-rectangles of size a \u00d7 b.\",\n      \"details\": \"Use nested loops to explore all potential sub-rectangle positions.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal and calculate the required operations.\",\n      \"details\": \"Apply the portal conditions and count necessary changes.\"\n    },\n    {\n      \"step\": \"Track the minimum number of operations needed for each test case.\",\n      \"details\": \"Store and update the minimum operation count as sub-rectangles are evaluated.\"\n    },\n    {\n      \"step\": \"Output the minimum number of operations for each test case.\",\n      \"details\": \"Print the results in the required format.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where the operations will be performed. It consists of n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific conditions, including having obsidian blocks on the edges and empty blocks inside, except for the corners.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. This can be implemented by ensuring any sub-rectangle considered has these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. This can be implemented by keeping track of the lowest operation count found.\n\n# [code logic]\n    The steps \"For each sub-rectangle, check if it can be transformed into a portal and calculate the required operations\" and \"Track the minimum number of operations needed for each test case\" should be implemented simultaneously. This can be done by evaluating each sub-rectangle and updating the minimum operation count in a single loop.\n\n# [edge case]\n    1. Input: 5 4\n       1111\n       1111\n       1111\n       1111\n       1111\n       Output: 0\n       Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    2. Input: 5 4\n       0000\n       0000\n       0000\n       0000\n       0000\n       Output: 12\n       Explanation: All edge blocks need to be converted to obsidian, requiring 12 operations.\n\n    3. Input: 6 5\n       11111\n       10001\n       10001\n       10001\n       10001\n       11111\n       Output: 0\n       Explanation: The rectangle is already a portal, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through sub-rectangles and calculating the minimum operations will naturally handle these cases.\n\nNO", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check sub-rectangle of size 5x4\n                operations = 0\n                \n                # Check vertical boundaries\n                for i in range(1, 4):\n                    if grid[start_row + i][start_col] == '0':\n                        operations += 1\n                    if grid[start_row + i][start_col + 3] == '0':\n                        operations += 1\n                \n                # Check horizontal boundaries\n                for j in range(1, 3):\n                    if grid[start_row][start_col + j] == '0':\n                        operations += 1\n                    if grid[start_row + 4][start_col + j] == '0':\n                        operations += 1\n                \n                # Check interior blocks\n                for i in range(1, 4):\n                    for j in range(1, 3):\n                        if grid[start_row + i][start_col + j] == '1':\n                            operations += 1\n                \n                # Update minimum operations\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"For each sub-rectangle, verify the conditions for being a portal and calculate the number of operations needed to transform it.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum number of operations needed.\",\n      \"details\": \"Compare the number of operations for all possible sub-rectangles and find the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input.\",\n      \"details\": \"Read the number of test cases, dimensions of rectangle A, and the block configuration for each test case.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a \u00d7 b.\",\n      \"details\": \"For each possible top-left corner, generate sub-rectangles and check if they can be transformed into a portal.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle.\",\n      \"details\": \"For each sub-rectangle, calculate the number of operations needed to satisfy portal conditions.\"\n    },\n    {\n      \"step\": \"Determine the minimum operations for each test case.\",\n      \"details\": \"Track the minimum number of operations required to form a portal for each test case.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b that meets specific conditions regarding the placement of obsidian and empty blocks. The conditions include having obsidian blocks on the vertical and horizontal edges, with the interior being empty, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: This specifies the minimum dimensions for the portal. In code, this means we need to iterate over sub-rectangles that are at least 5 rows and 4 columns in size.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This refers to finding the least number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the smallest number of operations across all possible sub-rectangles.\n\n# [code logic]\n    The steps \"Generate all possible sub-rectangles of size a \u00d7 b\" and \"Evaluate each sub-rectangle\" should be implemented simultaneously. This can be done by iterating over each possible top-left corner of a sub-rectangle and immediately checking if it can be transformed into a portal, calculating the operations needed.\n\n# [edge case]\n    1. Input: 1, 5 4, 1111, 1111, 1111, 1111, 1111\n       Output: 0\n       Explanation: The entire rectangle is already a portal, so no operations are needed.\n    2. Input: 1, 5 4, 0000, 0000, 0000, 0000, 0000\n       Output: 12\n       Explanation: All edges need to be converted to obsidian, requiring 12 operations.\n    3. Input: 1, 6 5, 11111, 10001, 10001, 10001, 10001, 11111\n       Output: 0\n       Explanation: The rectangle is already a portal, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating the minimum operations will naturally handle these cases.\n\nNO", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Edge block\n                                    if (i == 0 and (j == 0 or j == b - 1)) or (i == a - 1 and (j == 0 or j == b - 1)):\n                                        # Corner block, can be any type\n                                        continue\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Interior block\n                                    if current_block == '1':\n                                        operations += 1\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid of blocks.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the n \u00d7 m grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the n \u00d7 m grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the boundary conditions for obsidian blocks and count the number of changes needed.\",\n        \"Check the interior conditions for empty blocks and count the number of changes needed.\",\n        \"Sum the changes to get the total number of operations for the sub-rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all possible sub-rectangles for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum number of operations found across all sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle with specific conditions on block types.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For all 1 < x < a': Indicates a range for x within the rectangle.\n    'For all 1 < x < b': Indicates a range for x within the rectangle.\n    'For all 1 < x < a, 1 < y < b': Indicates a range for both x and y within the rectangle.\n\n# [degree adverb]\n    'minimum': The least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    Steps in subproblem 2 and subproblem 3 should be considered simultaneously:\n    - While iterating over possible sub-rectangles, calculate the number of operations needed to transform each into a portal in the same loop. This can be done by checking boundary and interior conditions in one pass.\n\n# [edge case]\n    Case 1: n = 5, m = 4, grid = ['1111', '1111', '1111', '1111', '1111']\n    Expected output: 0\n    Explanation: The entire grid is already a portal, no operations needed.\n    \n    Case 2: n = 5, m = 4, grid = ['0000', '0000', '0000', '0000', '0000']\n    Expected output: 12\n    Explanation: All blocks need to be changed to form a portal.\n    \n    Case 3: n = 6, m = 5, grid = ['11111', '10001', '10001', '10001', '10001', '11111']\n    Expected output: 0\n    Explanation: The grid already satisfies the portal conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will naturally handle these cases.\n\nNO", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] != '1':\n                                operations += 1\n                            if grid[start_row + x][start_col + b - 1] != '1':\n                                operations += 1\n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + y] != '1':\n                                operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the boundary conditions for obsidian blocks and ensure the interior blocks are empty.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required to meet the portal conditions for each sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all sub-rectangles.\",\n      \"details\": \"Compare the operation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configurations.\",\n      \"details\": \"Read and store the input data for processing.\"\n    },\n    {\n      \"step\": \"Iterate over each test case and process the corresponding rectangle.\",\n      \"details\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\",\n      \"details\": \"Use nested loops to identify all potential sub-rectangle positions.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal and calculate the required operations.\",\n      \"details\": \"Apply the portal conditions and count necessary changes for each sub-rectangle.\"\n    },\n    {\n      \"step\": \"Track the minimum number of operations needed to form a portal for each test case.\",\n      \"details\": \"Store and update the minimum operation count as sub-rectangles are evaluated.\"\n    },\n    {\n      \"step\": \"Output the minimum number of operations for each test case.\",\n      \"details\": \"Print the results for all test cases in the specified format.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n    'obsidian block'\n    Explanation: An obsidian block is represented by '1' in the input, and it must form the boundary of the portal.\n\n    'empty block'\n    Explanation: An empty block is represented by '0' in the input, and it must fill the interior of the portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. This means any sub-rectangle considered must meet these minimum size requirements.\n    Implementation: Ensure that any sub-rectangle considered has dimensions that satisfy these inequalities.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest number of operations required to transform a sub-rectangle into a portal.\n    Implementation: Track the number of operations for each sub-rectangle and update the minimum value found.\n\n# [code logic]\n    Steps 3 and 4 should be implemented simultaneously.\n    \"Generate all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle\" and \"For each sub-rectangle, check if it can be transformed into a portal and calculate the required operations\" can be combined into a single nested loop structure that iterates over possible sub-rectangle positions and evaluates them in one go.\n\n# [edge case]\n    Case 1: n = 5, m = 4, all blocks are obsidian (1)\n    Expected output: 12\n    Explanation: The entire rectangle needs to be transformed into a portal, requiring changes to the interior blocks.\n\n    Case 2: n = 5, m = 4, all blocks are empty (0)\n    Expected output: 12\n    Explanation: The boundary blocks need to be transformed into obsidian, requiring changes to the edges.\n\n    Case 3: n = 5, m = 4, alternating blocks (checkerboard pattern)\n    Expected output: 12\n    Explanation: Regardless of the initial pattern, transforming into a portal requires a consistent boundary and empty interior.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate operations needed for sub-rectangle of size 5x4\n                operations = 0\n                \n                # Check the boundary conditions\n                for i in range(1, 4):\n                    if grid[start_row + i][start_col] != '1':\n                        operations += 1\n                    if grid[start_row + i][start_col + 3] != '1':\n                        operations += 1\n                \n                for j in range(1, 3):\n                    if grid[start_row][start_col + j] != '1':\n                        operations += 1\n                    if grid[start_row + 4][start_col + j] != '1':\n                        operations += 1\n                \n                # Check the interior conditions\n                for i in range(1, 4):\n                    for j in range(1, 3):\n                        if grid[start_row + i][start_col + j] != '0':\n                            operations += 1\n                \n                # Update the minimum operations needed\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle satisfies the portal conditions.\",\n      \"details\": \"Verify the boundary conditions for obsidian blocks and the interior conditions for empty blocks.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of changes required to satisfy the portal conditions for each sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of operations across all sub-rectangles.\",\n      \"details\": \"Compare the operation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases, dimensions, and block configurations.\",\n      \"details\": \"Read and store the input data for processing.\"\n    },\n    {\n      \"step\": \"Iterate over each test case and process the rectangle.\",\n      \"details\": \"For each test case, perform the following operations.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\",\n      \"details\": \"Use nested loops to iterate over potential top-left corners and dimensions.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal.\",\n      \"details\": \"Verify the portal conditions and calculate the required operations.\"\n    },\n    {\n      \"step\": \"Track the minimum number of operations needed for each test case.\",\n      \"details\": \"Store and update the minimum operation count for each test case.\"\n    },\n    {\n      \"step\": \"Output the minimum number of operations for each test case.\",\n      \"details\": \"Print the results for all test cases in the required format.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where the operations will be performed. It consists of n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions regarding the placement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: Changing a block from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means ensuring any sub-rectangle considered has these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the lowest operation count found.\n\n# [code logic]\n    Steps 3 and 4 should be implemented simultaneously:\n    \"Generate all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle\" and \"For each sub-rectangle, check if it can be transformed into a portal\" can be combined. As you generate each sub-rectangle, you can immediately check if it meets the portal conditions and calculate the operations needed.\n\n# [edge case]\n    1. n = 5, m = 4, all blocks are obsidian (1)\n       Expected output: 0\n       Explanation: The entire rectangle already satisfies the portal conditions, so no operations are needed.\n\n    2. n = 5, m = 4, all blocks are empty (0)\n       Expected output: 12\n       Explanation: All boundary blocks need to be changed to obsidian, requiring 12 operations.\n\n    3. n = 6, m = 5, with a mix of obsidian and empty blocks such that no portal can be formed without changes.\n       Expected output: Depends on the specific configuration, but should be calculated based on the minimum operations needed to form a valid portal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the code correctly identifies when no operations are needed (e.g., when the entire rectangle already forms a portal) and calculates the correct number of operations for various configurations.\n    \n    Example code snippet for handling edge cases:\n    ```python\n    def", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Try all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the boundary conditions\n                        for x in range(start_row, start_row + a):\n                            if x == start_row or x == start_row + a - 1:\n                                # Top and bottom rows\n                                for y in range(start_col + 1, start_col + b - 1):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right columns\n                                if grid[x][start_col] != '1':\n                                    operations += 1\n                                if grid[x][start_col + b - 1] != '1':\n                                    operations += 1\n                        \n                        # Check the interior conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, true, true, false, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 341, "prompt": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The blocks located at the edges of the rectangle need to be obsidian, which forms a boundary along the vertical sides.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns. It is not the same as having b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Consider various dimensions of rectangle A to determine if a portal can be created efficiently.\n\nTaking into account the variety of potential locations for portals within the rectangle is crucial for minimizing the number of operations needed.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 177}
