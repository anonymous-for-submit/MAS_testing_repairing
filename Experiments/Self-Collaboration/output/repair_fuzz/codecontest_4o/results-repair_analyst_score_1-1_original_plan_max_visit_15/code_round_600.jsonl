{"name": "1586_B. Omkar and Heavenly Tree", "description": "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. \n\nA tree with n nodes is an connected undirected graph with n nodes and n-1 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree: \n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c. \n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "tags": ["brute force", "constructive algorithms", "trees"], "difficulty": 8, "id": 1586, "sample_io": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "test_list": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n6 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n7 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n6 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n7 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n4 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n7 4\n1 1 3\n3 2 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n8 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 7 4\n13 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 2\n5 7 10\n4 5 4\n6 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 1 4\n3 6 0\n5 5 7\n5 5 4\n8 3\n2 2 -1\n6 2 4\n3 4 10\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 1 2\n10 2 5\n6 6 7\n6 5 4\n5 3\n1 1 0\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 2 20\n6 3 4\n9 0\n0 1 1\n4 3 4\n2 4 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n"]}, {"input": "2\n11 4\n-1 4 1\n3 7 5\n5 2 22\n2 5 1\n10 1\n2 2 1\n5 1 3\n4 2 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 5\n5 6 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 0 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n23 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 0\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n13 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n24 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n2 1\n2 3\n2 4\n"]}, {"input": "2\n21 4\n1 2 3\n4 1 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 13\n3 14\n3 15\n3 16\n3 17\n3 18\n3 19\n3 20\n3 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n4 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n"]}, {"input": "2\n9 4\n2 2 6\n3 4 10\n-1 6 7\n6 5 4\n8 3\n1 4 0\n1 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 2 1\n3 1 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n9 4\n1 4 3\n3 4 17\n5 6 12\n8 5 8\n9 3\n1 1 0\n3 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n"]}, {"input": "2\n9 4\n1 4 3\n3 1 17\n5 6 12\n8 5 15\n5 3\n1 1 0\n3 3 7\n3 5 7\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 1 1\n3 7 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n27 4\n1 3 3\n4 2 2\n5 7 10\n4 9 4\n6 0\n1 2 -1\n2 6 4\n4 1 8\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 27\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 2 22\n2 1 4\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 1 22\n2 5 1\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n9 4\n-1 4 1\n0 7 9\n5 2 22\n2 5 1\n10 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 7\n5 1 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 -1 12\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n2 13\n2 14\n2 15\n2 16\n2 17\n2 18\n2 19\n2 20\n2 21\n2 22\n2 23\n2 24\n2 25\n2 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n0 4 2\n1 10 9\n5 2 22\n2 5 1\n19 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n"]}, {"input": "2\n24 4\n1 4 3\n1 4 7\n5 6 17\n1 13 4\n6 0\n1 3 0\n2 1 4\n7 -1 21\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n7 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 3\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 12\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n0 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 6 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 5\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 7\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n8 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n4 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 4\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n5 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n4 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 -1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 0\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n12 4\n1 2 6\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n2 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 1\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 18\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 3 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "task_id": "codecontest/37", "repair_prompt": ["Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree, but Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. A tree with n nodes is a connected undirected graph with n nodes and n-1 edges, and for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree: \n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n), and it signifies that node b cannot lie on the simple path between node a and node c. Can you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions, and it can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree, but Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. A tree with n nodes is a connected undirected graph with n nodes and n-1 edges. In this type of graph, for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once. \n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n), and it signifies that node b cannot lie on the simple path between node a and node c. Can you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions, and it can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree, but Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. A tree with n nodes is a connected undirected graph with n nodes and n-1 edges, providing exactly one simple path between them for any two nodes, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree: \n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n), and it signifies that node b cannot lie on the simple path between node a and node c. Can you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions, and it can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def construct_tree(n, restrictions):\n    # Initialize a list to store the edges of the tree\n    edges = []\n    \n    # Find a node that is not involved as node b in any restriction\n    involved_as_b = set(b for _, b, _ in restrictions)\n    root = next(i for i in range(1, n + 1) if i not in involved_as_b)\n    \n    # Connect the root to all other nodes\n    for i in range(1, n + 1):\n        if i != root:\n            edges.append((root, i))\n    \n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose a node that is not in the middle of any restriction\n        # A simple strategy is to choose a node that is not b in any (a, b, c) restriction\n        # We can use node 1 as the root and connect it to all other nodes\n        \n        # Find a node that is not b in any restriction\n        b_set = set(b for _, b, _ in restrictions)\n        root = 1\n        while root in b_set:\n            root += 1\n        \n        # Construct the tree\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def construct_tree(n, restrictions):\n    # Initialize the tree with a simple star structure\n    # Connect all nodes to node 1\n    edges = [(1, i) for i in range(2, n + 1)]\n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # We can choose any node that is not a middle node in any restriction as the root\n        # Let's use a simple strategy: choose node 1 as the root if possible\n        # Otherwise, choose the first node that is not a middle node in any restriction\n        \n        middle_nodes = set(b for _, b, _ in restrictions)\n        \n        root = 1\n        if root in middle_nodes:\n            for i in range(1, n + 1):\n                if i not in middle_nodes:\n                    root = i\n                    break\n        \n        # Construct the tree\n        # Connect the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose any node as the root.\n        # Let's choose a node that is not restricted as a middle node in any restriction.\n        # This will ensure that the node can be connected to all other nodes.\n        \n        # Find a node that is not in the middle of any restriction\n        restricted_nodes = set(b for a, b, c in restrictions)\n        \n        # Choose a node that is not restricted as the root\n        root = next(i for i in range(1, n + 1) if i not in restricted_nodes)\n        \n        # Create the tree by connecting the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose a node that is not in the middle of any restriction\n        # We can use a simple strategy: choose a node that is not b in any (a, b, c)\n        # This node can be the root of a star-like tree\n        \n        # Find a node that is not b in any restriction\n        b_set = set(b for _, b, _ in restrictions)\n        root = next(i for i in range(1, n + 1) if i not in b_set)\n        \n        # Construct the tree with the chosen root\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def construct_tree(n, restrictions):\n    # Strategy: Connect all nodes to a central node (node 1) to form a star-like structure.\n    # This ensures that no node lies on the path between any two other nodes.\n    edges = []\n    for i in range(2, n + 1):\n        edges.append((1, i))\n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a root node and connect all other nodes to it\n        # This ensures no node lies on the path between any two other nodes\n        root = 1\n        edges = []\n        \n        for node in range(2, n + 1):\n            edges.append((root, node))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose a root and connect all other nodes to it\n        # We will choose node 1 as the root and connect all other nodes to it\n        # This simple strategy works because the problem guarantees a solution exists\n        # and the restrictions can be satisfied by choosing a suitable root.\n        \n        # Find a node that is not involved in any restriction as node b\n        # If such a node exists, use it as the root, otherwise use node 1\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = 1\n        for i in range(1, n + 1):\n            if i not in restricted_nodes:\n                root = i\n                break\n        \n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a root node and connect all other nodes to it\n        # This will ensure that no node b is on the path between any two other nodes a and c\n        # because the path will always go through the root node.\n        \n        # Choose node 1 as the root\n        root = 1\n        edges = []\n        \n        for node in range(2, n + 1):\n            edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def construct_tree(n, restrictions):\n    # Initialize a list to store the edges of the tree\n    edges = []\n    \n    # Find a node that is not involved as node b in any restriction\n    involved_as_b = set(b for _, b, _ in restrictions)\n    root = next(i for i in range(1, n + 1) if i not in involved_as_b)\n    \n    # Connect the root to all other nodes\n    for i in range(1, n + 1):\n        if i != root:\n            edges.append((root, i))\n    \n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Initialize a list to store the edges of the tree.\",\n        \"Select a root node and ensure it is not involved in any restriction as node b.\",\n        \"Iteratively add edges between nodes ensuring that no restriction is violated.\",\n        \"Use a strategy to connect nodes such that node b is never on the path between node a and node c.\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node (b) cannot lie on the simple path between two other nodes (a and c).\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates that the tree must have exactly n-1 edges to be a valid tree with n nodes.\n    '1 \u2264 m < n': This means the number of restrictions is always less than the number of nodes.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to constructing the tree should be considered simultaneously:\n    - \"Select a root node and ensure it is not involved in any restriction as node b.\"\n    - \"Iteratively add edges between nodes ensuring that no restriction is violated.\"\n    - \"Use a strategy to connect nodes such that node b is never on the path between node a and node c.\"\n    These steps should be implemented in a cohesive manner to ensure the tree is constructed correctly without violating any restrictions.\n\n# [edge case]\n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between nodes 1 and 3. The tree can be constructed with edges 1-3 and 3-2.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected Output: 1 3, 3 4, 4 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 4 cannot be on the path between 3 and 1. The tree can be constructed with edges 1-3, 3-4, and 4-2.\n\n    Edge Case 3: n = 5, m = 1, restrictions = [(2, 3, 4)]\n    Expected Output: 1 2, 2 4, 4 5, 5 3\n    Explanation: Node 3 cannot be on the", "Round_0": {"code": "def construct_tree(n, restrictions):\n    # Initialize a list to store the edges of the tree\n    edges = []\n    \n    # Find a node that is not involved as node b in any restriction\n    involved_as_b = set(b for _, b, _ in restrictions)\n    root = next(i for i in range(1, n + 1) if i not in involved_as_b)\n    \n    # Connect the root to all other nodes\n    for i in range(1, n + 1):\n        if i != root:\n            edges.append((root, i))\n    \n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, and c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Initialize a list to store the edges of the tree.\",\n        \"Select a root node for the tree.\",\n        \"Iteratively add edges to the tree while ensuring that the restrictions are satisfied.\",\n        \"Use a strategy to ensure that node b does not lie on the path between nodes a and c for each restriction.\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n    'restriction': A condition that specifies that a certain node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates the relationship between the number of nodes and edges in a tree. For a tree with n nodes, there must be exactly n-1 edges.\n    '1 \u2264 m < n': This specifies that the number of restrictions is less than the number of nodes.\n\n# [degree adverb]\n    'heavenly': This implies that the tree should be constructed in a way that satisfies all given restrictions, making it optimal or ideal according to the problem's constraints.\n\n# [code logic]\n    The steps for parsing input and constructing the tree should be implemented simultaneously for efficiency. Specifically, while parsing the input, we can start constructing the tree by initializing data structures to store nodes and edges.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The tree must be constructed such that node 2 does not lie on the path between nodes 1 and 3.\n\n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: The tree must be constructed such that node 2 does not lie on the path between nodes 1 and 3, and node 1 does not lie on the path between nodes 3 and 4.\n\n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected output: 1 3, 3 4, 4 5, 5 2\n    Explanation: The tree must be constructed such that node 2 does not lie on the path between nodes 1 and 3, node 3 does not lie on the path between nodes 2 and 4, and node 4 does not lie on the path between", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose a node that is not in the middle of any restriction\n        # A simple strategy is to choose a node that is not b in any (a, b, c) restriction\n        # We can use node 1 as the root and connect it to all other nodes\n        \n        # Find a node that is not b in any restriction\n        b_set = set(b for _, b, _ in restrictions)\n        root = 1\n        while root in b_set:\n            root += 1\n        \n        # Construct the tree\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Initialize a list to store the edges of the tree.\",\n        \"Select a root node and construct the tree by adding edges while ensuring the restrictions are satisfied.\",\n        \"Use a strategy to ensure that node b does not lie on the simple path between nodes a and c for each restriction.\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n    \"For each test case, construct a tree with n nodes and n-1 edges that satisfies all m restrictions.\",\n    \"Output the edges of the constructed tree for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges. It has exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates that the tree must have exactly n-1 edges for n nodes.\n    '1 \u2264 m < n': This means the number of restrictions is at least 1 and less than the number of nodes.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the step \"Select a root node and construct the tree by adding edges while ensuring the restrictions are satisfied\" requires careful consideration of restrictions simultaneously. This involves checking each restriction while constructing the tree to ensure no invalid paths are created.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between 1 and 3, which is satisfied by directly connecting 1 to 3 and 3 to 2.\n\n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 1 cannot be on the path between 3 and 4. The tree structure satisfies both restrictions.\n\n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (4, 5, 1)]\n    Expected output: 1 3, 3 4, 4 5, 5 2\n    Explanation: The restrictions are satisfied by ensuring no restricted node lies on the specified paths.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that while constructing the tree, each restriction is checked to avoid placing the restricted node on the path", "Round_0": {"code": "def construct_tree(n, restrictions):\n    # Initialize the tree with a simple star structure\n    # Connect all nodes to node 1\n    edges = [(1, i) for i in range(2, n + 1)]\n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a node that can serve as the root of the tree. This node should not be part of any restriction as the middle node (b) to simplify the tree construction.\",\n      \"output\": \"A selected root node for each test case.\"\n    },\n    {\n      \"description\": \"Construct a tree by connecting nodes in a way that satisfies all restrictions. Start from the root node and ensure that no restricted node appears on the path between any two other nodes as specified in the restrictions.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree satisfying all restrictions.\"\n    },\n    {\n      \"description\": \"Output the constructed tree for each test case in the required format.\",\n      \"output\": \"Formatted output of edges for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, analyze the restrictions to determine a suitable root node that is not restricted as a middle node.\",\n    \"Using the selected root node, construct a tree by iteratively adding edges while ensuring that all restrictions are satisfied.\",\n    \"For each test case, output the list of edges that form the tree in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n    'restriction': A condition that specifies a node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates the relationship between nodes and edges in a tree, where the number of edges is always one less than the number of nodes.\n    '1 \u2264 m < n': This specifies the range for the number of restrictions, which is always less than the number of nodes.\n\n# [degree adverb]\n    'heavenly': This implies the tree should be constructed in a way that satisfies all given restrictions, making it optimal or ideal according to the problem's constraints.\n\n# [code logic]\n    The steps of parsing input and determining a suitable root node can be implemented simultaneously. Once the input is parsed, the root node can be selected based on the restrictions, which simplifies the tree construction process.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The tree must be constructed such that node 2 does not lie on the path between nodes 1 and 3.\n\n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: The tree must be constructed such that node 2 does not lie on the path between nodes 1 and 3, and node 1 does not lie on the path between nodes 3 and 4.\n\n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected output: 1 3, 3 5, 5 4, 4 2\n    Explanation: The tree must be constructed such that node 2 does not lie on the path between nodes 1 and 3, node 3 does not lie on the path between nodes 2 and 4, and node 4 does not lie on the path between nodes", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # We can choose any node that is not a middle node in any restriction as the root\n        # Let's use a simple strategy: choose node 1 as the root if possible\n        # Otherwise, choose the first node that is not a middle node in any restriction\n        \n        middle_nodes = set(b for _, b, _ in restrictions)\n        \n        root = 1\n        if root in middle_nodes:\n            for i in range(1, n + 1):\n                if i not in middle_nodes:\n                    root = i\n                    break\n        \n        # Construct the tree\n        # Connect the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 114)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # We can choose any node that is not a middle node in any restriction as the root\n        # Let's use a simple strategy: choose node 1 as the root if possible\n        # Otherwise, choose the first node that is not a middle node in any restriction\n        \n        middle_nodes = set(b for _, b, _ in restrictions)\n        \n        root = 1\n        if root in middle_nodes:\n            for i in range(1, n + 1):\n                if i not in middle_nodes:\n                    root = i\n                    break\n        \n        # Construct the tree\n        # Connect the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, and c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Initialize a list to store the edges of the tree.\",\n        \"Select a root node for the tree.\",\n        \"Iteratively add edges between nodes ensuring that the restrictions are satisfied.\",\n        \"Ensure that the tree remains connected and has n-1 edges.\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output the n-1 edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges. It ensures that there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges'\n    Explanation: This indicates that the tree must have exactly n-1 edges to be a valid tree with n nodes. In code, this means ensuring the final graph has exactly n-1 edges.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan for constructing the tree should be considered simultaneously:\n    - \"Initialize a list to store the edges of the tree.\"\n    - \"Select a root node for the tree.\"\n    - \"Iteratively add edges between nodes ensuring that the restrictions are satisfied.\"\n    - \"Ensure that the tree remains connected and has n-1 edges.\"\n    These steps should be implemented in a loop or recursive function that builds the tree while checking restrictions.\n\n# [edge case]\n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between 1 and 3, so we connect 1 to 3 and 3 to 2.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected Output: 1 3, 3 2, 3 4\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 1 cannot be on the path between 3 and 4. The tree can be constructed by connecting 1 to 3, 3 to 2, and 3 to 4.\n\n    Edge Case 3: n = 5, m = 0\n    Expected Output: 1 2, 2 3, 3 4, 4 5\n    Explanation: With no restrictions, a simple linear tree can be constructed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose any node as the root.\n        # Let's choose a node that is not restricted as a middle node in any restriction.\n        # This will ensure that the node can be connected to all other nodes.\n        \n        # Find a node that is not in the middle of any restriction\n        restricted_nodes = set(b for a, b, c in restrictions)\n        \n        # Choose a node that is not restricted as the root\n        root = next(i for i in range(1, n + 1) if i not in restricted_nodes)\n        \n        # Create the tree by connecting the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 95)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose any node as the root.\n        # Let's choose a node that is not restricted as a middle node in any restriction.\n        # This will ensure that the node can be connected to all other nodes.\n        \n        # Find a node that is not in the middle of any restriction\n        restricted_nodes = set(b for a, b, c in restrictions)\n        \n        # Choose a node that is not restricted as the root\n        root = next(i for i in range(1, n + 1) if i not in restricted_nodes)\n        \n        # Create the tree by connecting the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, and c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Initialize a list to store the edges of the tree.\",\n        \"Select a root node and construct a star-like tree structure initially.\",\n        \"Iteratively add edges between nodes ensuring that no restriction is violated.\",\n        \"Use a strategy to ensure that node b is not on the path between nodes a and c for each restriction.\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected undirected graph with n nodes and n-1 edges, providing exactly one simple path between any two nodes.\n    'restriction': A condition that specifies that a certain node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates the relationship between the number of nodes and edges in a tree, which is crucial for ensuring the structure is a tree.\n    '1 \u2264 m < n': This specifies the range for the number of restrictions, ensuring there are fewer restrictions than nodes.\n\n# [degree adverb]\n    'heavenly': This implies the tree should be constructed in a way that meets all restrictions, but does not directly affect the code logic.\n\n# [code logic]\n    The steps for constructing the tree should be considered simultaneously, especially when iteratively adding edges while ensuring no restriction is violated. This involves checking each restriction as edges are added to the tree.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The path between 1 and 3 does not include node 2, satisfying the restriction.\n\n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: The path between 1 and 3 does not include node 2, and the path between 3 and 1 does not include node 4.\n\n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected output: 1 3, 3 4, 4 5, 5 2\n    Explanation: Each restriction is satisfied by ensuring the specified node is not on the path between the other two nodes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that when adding edges, each restriction is checked to ensure the specified node is not on the path between the other two nodes. This might involve using a graph traversal algorithm to verify", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose a node that is not in the middle of any restriction\n        # We can use a simple strategy: choose a node that is not b in any (a, b, c)\n        # This node can be the root of a star-like tree\n        \n        # Find a node that is not b in any restriction\n        b_set = set(b for _, b, _ in restrictions)\n        root = next(i for i in range(1, n + 1) if i not in b_set)\n        \n        # Construct the tree with the chosen root\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify a strategy to construct a tree with n nodes that satisfies all given restrictions.\",\n      \"output\": \"A method to determine a valid tree structure for each test case.\"\n    },\n    {\n      \"description\": \"Implement a method to check if a proposed tree structure satisfies all the restrictions for a given test case.\",\n      \"output\": \"A function that verifies the validity of the tree against the restrictions.\"\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case in the required format.\",\n      \"output\": \"Formatted output of the tree edges for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format, separating the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a tree structure with n nodes and no edges.\",\n    \"Iterate over the restrictions and use a strategy to construct a tree that avoids placing the restricted node on the path between the specified nodes.\",\n    \"One possible strategy is to select a root node and ensure that no restricted node lies on the path between any two other nodes by carefully choosing parent-child relationships.\",\n    \"After constructing the tree, verify that it satisfies all restrictions by checking the paths between the specified nodes.\",\n    \"If the tree is valid, output the edges of the tree in the required format. If not, adjust the tree structure and re-verify.\",\n    \"Repeat the process for all test cases and ensure the output is correctly formatted for each.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, providing exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'more than': In the context of restrictions, it means that the node b cannot appear on the path between nodes a and c.\n    'exactly one': This refers to the property of a tree where there is exactly one simple path between any two nodes.\n\n# [degree adverb] \n    'heavenly': This is more of a thematic term rather than a technical one, indicating the tree should meet all restrictions.\n\n# [code logic]\n    The steps related to constructing the tree and verifying the restrictions should be considered simultaneously. Specifically, the steps:\n    - \"Iterate over the restrictions and use a strategy to construct a tree that avoids placing the restricted node on the path between the specified nodes.\"\n    - \"After constructing the tree, verify that it satisfies all restrictions by checking the paths between the specified nodes.\"\n    These steps should be integrated such that the tree is constructed with the restrictions in mind, and verification is part of the construction process.\n\n# [edge case] \n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between nodes 1 and 3. The tree 1-3-2 satisfies this.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected Output: 1 3, 3 4, 4 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 1 cannot be on the path between 3 and 4. The tree 1-3-4-2 satisfies these restrictions.\n\n    Edge Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected Output: 1 3, 3 4, 4", "Round_0": {"code": "def construct_tree(n, restrictions):\n    # Strategy: Connect all nodes to a central node (node 1) to form a star-like structure.\n    # This ensures that no node lies on the path between any two other nodes.\n    edges = []\n    for i in range(2, n + 1):\n        edges.append((1, i))\n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases, where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, determine a strategy to construct a tree that satisfies all the given restrictions.\",\n      \"output\": \"A method to construct a tree for each test case that adheres to the restrictions, ensuring that no restricted node lies on the simple path between the specified nodes.\"\n    },\n    {\n      \"description\": \"Implement a function to construct the tree using the strategy determined in the previous step.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree satisfying the restrictions.\"\n    },\n    {\n      \"description\": \"Format the output to match the required output format, which includes printing the edges for each test case.\",\n      \"output\": \"Formatted output for each test case, listing the edges of the constructed tree.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a data structure to represent the tree and track the nodes and edges.\",\n    \"Identify a root node and construct the tree by adding edges while ensuring that no restriction is violated.\",\n    \"Use a strategy such as depth-first search (DFS) or breadth-first search (BFS) to ensure that the tree is connected and satisfies all restrictions.\",\n    \"For each test case, output the list of edges that form the tree, ensuring the output format is correct.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: In graph theory, a tree is a connected undirected graph with no cycles. It has n nodes and n-1 edges, providing exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction in this context means that a specific node cannot be on the simple path between two other nodes in the tree.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges'\n    Explanation: This indicates that the tree must have exactly n-1 edges to connect n nodes without forming any cycles. In code, this can be implemented by ensuring the edge list has exactly n-1 entries.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the construction of the tree (steps 2 and 3) should be considered together. The strategy to construct the tree and the actual implementation of the tree construction are closely related and should be handled in a single code block to ensure the restrictions are respected.\n\n# [edge case]\n    1. Test case with the minimum number of nodes and restrictions:\n       Input: 3 1\n              1 2 3\n       Expected Output: \n       1 3\n       3 2\n       Explanation: With 3 nodes and 1 restriction, the tree can be constructed by connecting nodes 1 and 3, and then 3 and 2, ensuring node 2 is not on the path between 1 and 3.\n\n    2. Test case with a restriction that cannot be violated:\n       Input: 4 1\n              1 2 3\n       Expected Output:\n       1 3\n       3 4\n       4 2\n       Explanation: The tree is constructed such that node 2 is not on the path between 1 and 3.\n\n    3. Test case with multiple restrictions:\n       Input: 5 2\n              1 2 3\n              3 4 5\n       Expected Output:\n       1 3\n       3 5\n       5 4\n       4 2\n       Explanation: The tree is constructed to ensure node 2 is not on the path between 1 and 3, and node 4 is not on the path between 3 and 5.\n\n# [extra code for edge case]\n    We need", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a root node and connect all other nodes to it\n        # This ensures no node lies on the path between any two other nodes\n        root = 1\n        edges = []\n        \n        for node in range(2, n + 1):\n            edges.append((root, node))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 87)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a root node and connect all other nodes to it\n        # This ensures no node lies on the path between any two other nodes\n        root = 1\n        edges = []\n        \n        for node in range(2, n + 1):\n            edges.append((root, node))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions consisting of three integers a, b, and c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Initialize a list to store the edges of the tree.\",\n        \"Select a root node for the tree.\",\n        \"Iteratively add edges between nodes ensuring that the restrictions are satisfied.\",\n        \"Use a strategy to ensure that node b does not lie on the simple path between nodes a and c for each restriction.\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates that the tree must have exactly n-1 edges to be a valid tree with n nodes.\n    '1 \u2264 m < n': This indicates that the number of restrictions is always less than the number of nodes.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the step \"Iteratively add edges between nodes ensuring that the restrictions are satisfied,\" the logic to ensure that node b does not lie on the simple path between nodes a and c should be handled simultaneously as edges are added.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between 1 and 3, which is satisfied by directly connecting 1 to 3 and 3 to 2.\n\n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 1 cannot be on the path between 3 and 4. The tree structure satisfies both restrictions.\n\n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected output: 1 3, 3 4, 4 5, 5 2\n    Explanation: Each restriction is satisfied by ensuring the specified node is not on the path between the other two nodes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that when adding edges, the restrictions are checked, and alternative paths", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To construct a tree, we can choose a root and connect all other nodes to it\n        # We will choose node 1 as the root and connect all other nodes to it\n        # This simple strategy works because the problem guarantees a solution exists\n        # and the restrictions can be satisfied by choosing a suitable root.\n        \n        # Find a node that is not involved in any restriction as node b\n        # If such a node exists, use it as the root, otherwise use node 1\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = 1\n        for i in range(1, n + 1):\n            if i not in restricted_nodes:\n                root = i\n                break\n        \n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a strategy to construct a tree that satisfies all the given restrictions.\",\n      \"output\": \"A method or algorithm to determine the edges of the tree that meet the restrictions for each test case.\"\n    },\n    {\n      \"description\": \"Implement the tree construction algorithm to generate the edges of the tree for each test case.\",\n      \"output\": \"A list of edges for each test case that form a valid tree satisfying the restrictions.\"\n    },\n    {\n      \"description\": \"Format the output to match the required output format, ensuring that each test case's result is printed correctly.\",\n      \"output\": \"Formatted output for each test case, listing the edges of the tree.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and parse it to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize data structures to represent the nodes and potential edges of the tree.\",\n    \"Develop a strategy to construct the tree by iterating over the nodes and restrictions, ensuring that no restriction is violated. This may involve selecting a root node and connecting other nodes while checking restrictions.\",\n    \"Implement the tree construction logic, ensuring that the resulting graph is a valid tree (connected and acyclic) and satisfies all restrictions.\",\n    \"Store the resulting edges for each test case.\",\n    \"After processing all test cases, format the output to list the edges for each test case in the required format.\",\n    \"Print the formatted output.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a certain node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges'\n    Explanation: This indicates that the tree must have exactly n nodes and n-1 edges, which is a fundamental property of trees. In code, this means ensuring the graph remains connected and acyclic with exactly n-1 edges.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially, as each step builds upon the previous one. Parsing the input, constructing the tree, and formatting the output are distinct tasks that need to be completed in order.\n\n# [edge case]\n    Test case with minimum nodes and restrictions:\n    Input: 3 1\n           1 2 3\n    Expected Output: \n    1 3\n    3 2\n    Explanation: With 3 nodes and 1 restriction, the tree must be constructed such that node 2 is not on the path between nodes 1 and 3. The edges 1-3 and 3-2 satisfy this condition.\n\n    Test case with maximum nodes and minimum restrictions:\n    Input: 100000 1\n           1 2 3\n    Expected Output: \n    (Output should form a valid tree with 100000 nodes and 99999 edges, ensuring node 2 is not on the path between nodes 1 and 3)\n    Explanation: The tree must be constructed to satisfy the single restriction while maintaining the properties of a tree.\n\n    Test case with maximum nodes and maximum restrictions:\n    Input: 100000 99999\n           (99999 restrictions)\n    Expected Output: \n    (Output should form a valid tree with 100000 nodes and 99999 edges, satisfying all restrictions)\n    Explanation: The tree must be constructed to satisfy all restrictions while maintaining the properties of a tree.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that the tree construction logic checks each restriction and constructs the tree accordingly, possibly using a union-find data structure or similar to efficiently manage connectivity and restrictions.\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a root node and connect all other nodes to it\n        # This will ensure that no node b is on the path between any two other nodes a and c\n        # because the path will always go through the root node.\n        \n        # Choose node 1 as the root\n        root = 1\n        edges = []\n        \n        for node in range(2, n + 1):\n            edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 103)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a root node and connect all other nodes to it\n        # This will ensure that no node b is on the path between any two other nodes a and c\n        # because the path will always go through the root node.\n        \n        # Choose node 1 as the root\n        root = 1\n        edges = []\n        \n        for node in range(2, n + 1):\n            edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Initialize a list to store the edges of the tree.\",\n        \"Select a root node and ensure it is not involved in any restriction as node b.\",\n        \"Iteratively add edges between nodes ensuring that no restriction is violated.\",\n        \"Use a strategy to connect nodes such that node b is never on the path between node a and node c.\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node (b) cannot lie on the simple path between two other nodes (a and c).\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates that the tree must have exactly n-1 edges to be a valid tree with n nodes.\n    '1 \u2264 m < n': This means the number of restrictions is always less than the number of nodes.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to constructing the tree should be considered simultaneously:\n    - \"Select a root node and ensure it is not involved in any restriction as node b.\"\n    - \"Iteratively add edges between nodes ensuring that no restriction is violated.\"\n    - \"Use a strategy to connect nodes such that node b is never on the path between node a and node c.\"\n    These steps should be implemented in a cohesive manner to ensure the tree is constructed correctly without violating any restrictions.\n\n# [edge case]\n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between nodes 1 and 3. The tree can be constructed with edges 1-3 and 3-2.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected Output: 1 3, 3 4, 4 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 4 cannot be on the path between 3 and 1. The tree can be constructed with edges 1-3, 3-4, and 4-2.\n\n    Edge Case 3: n = 5, m = 1, restrictions = [(2, 3, 4)]\n    Expected Output: 1 2, 2 4, 4 5, 5 3\n    Explanation: Node 3 cannot be on the", "Round_0": {"code": "def construct_tree(n, restrictions):\n    # Initialize a list to store the edges of the tree\n    edges = []\n    \n    # Find a node that is not involved as node b in any restriction\n    involved_as_b = set(b for _, b, _ in restrictions)\n    root = next(i for i in range(1, n + 1) if i not in involved_as_b)\n    \n    # Connect the root to all other nodes\n    for i in range(1, n + 1):\n        if i != root:\n            edges.append((root, i))\n    \n    return edges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Construct the tree for this test case\n        edges = construct_tree(n, restrictions)\n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, false, true, true, false, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 600, "prompt": "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree, but Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. A tree with n nodes is a connected undirected graph with n nodes and n-1 edges, and for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree: \n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n), and it signifies that node b cannot lie on the simple path between node a and node c. Can you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions, and it can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 15}
