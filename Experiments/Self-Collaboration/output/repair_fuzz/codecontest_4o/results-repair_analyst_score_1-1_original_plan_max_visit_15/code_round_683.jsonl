{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases such as small board sizes or uniform direction cells.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side. It can move to the left, to the right, upwards, or downwards. \n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases such as small board sizes or uniform direction cells.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively. The robot can start its movement in any cell and moves to the adjacent square in the direction indicated on the current square in one move.   * If the robot moves beyond the edge of the board, it falls and breaks.   * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases such as small board sizes or uniform direction cells.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_row, start_col):\n        visited = set()\n        row, col = start_row, start_col\n        steps = 0\n        \n        while True:\n            if (row, col) in visited:\n                break\n            visited.add((row, col))\n            steps += 1\n            \n            direction = board[row][col]\n            d_row, d_col = direction_map[direction]\n            new_row, new_col = row + d_row, col + d_col\n            \n            if not (0 <= new_row < n and 0 <= new_col < m):\n                break\n            \n            row, col = new_row, new_col\n        \n        return steps\n\n    max_steps = 0\n    best_start = (1, 1)  # Default to the first cell (1-indexed)\n\n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)  # Convert to 1-indexed\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def simulate_robot(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    row, col = start_row, start_col\n    steps = 0\n\n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        steps += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n\n        if not (0 <= new_row < n and 0 <= new_col < m):\n            break\n\n        row, col = new_row, new_col\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_robot(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    steps = 0\n    row, col = start_row, start_col\n\n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        steps += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n\n        if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m:\n            break\n\n        row, col = new_row, new_col\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    max_moves = 0\n    best_start = (1, 1)\n\n    def move_from(r, c):\n        visited = set()\n        steps = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            steps += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        return steps\n\n    for i in range(n):\n        for j in range(m):\n            moves = move_from(i, j)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (i + 1, j + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        result = simulate_robot_movement(board, n, m)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0].strip())\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_robot(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n        \n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            moves += 1\n            \n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return moves\n    \n    max_moves = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_robot(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    best_start = (1, 1)\n    \n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            moves = 0\n            current_r, current_c = start_r, start_c\n            \n            while True:\n                if (current_r, current_c) in visited:\n                    break\n                if not (0 <= current_r < n and 0 <= current_c < m):\n                    break\n                \n                visited.add((current_r, current_c))\n                moves += 1\n                \n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                current_r += dr\n                current_c += dc\n            \n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    max_moves = 0\n    best_start = (1, 1)\n\n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n\n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n\n        return moves\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_start = (1, 1)\n        \n        for r in range(n):\n            for c in range(m):\n                visited = set()\n                x, y = r, c\n                moves = 0\n                \n                while (x, y) not in visited:\n                    visited.add((x, y))\n                    moves += 1\n                    direction = board[x][y]\n                    dx, dy = directions[direction]\n                    x, y = x + dx, y + dy\n                    \n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    best_start = (r + 1, c + 1)\n        \n        results.append(f\"{best_start[0]} {best_start[1]} {max_moves}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        steps = 0\n        \n        while (r, c) not in visited:\n            visited.add((r, c))\n            steps += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return steps\n    \n    max_steps = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot_movement(n, m, board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move(r, c, direction):\n        dr, dc = direction_map[direction]\n        return r + dr, c + dc\n\n    max_moves = 0\n    best_start = (1, 1)\n\n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                r, c = move(r, c, direction)\n\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_row, start_col):\n        visited = set()\n        row, col = start_row, start_col\n        steps = 0\n        \n        while True:\n            if (row, col) in visited:\n                break\n            visited.add((row, col))\n            steps += 1\n            \n            direction = board[row][col]\n            d_row, d_col = direction_map[direction]\n            new_row, new_col = row + d_row, col + d_col\n            \n            if not (0 <= new_row < n and 0 <= new_col < m):\n                break\n            \n            row, col = new_row, new_col\n        \n        return steps\n\n    max_steps = 0\n    best_start = (1, 1)  # Default to the first cell (1-indexed)\n\n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)  # Convert to 1-indexed\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the board (n and m).\",\n        \"Read the board configuration consisting of n lines with m characters each.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell and calculate the number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each cell on the board, simulate the robot's movement.\",\n        \"Track visited cells to detect cycles and prevent revisiting.\",\n        \"Count the number of moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"For each test case, iterate over each cell on the board.\",\n    \"Simulate the robot's movement from the current cell and count the moves.\",\n    \"Track visited cells to prevent cycles and breaking conditions.\",\n    \"Determine the starting cell with the maximum number of moves.\",\n    \"Output the optimal starting cell and the number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means we need to find the starting position that results in the highest number of moves before the robot breaks or stops. In code, this involves iterating over all possible starting positions and keeping track of the maximum number of moves achieved.\n\n# [degree adverb]\n    'maximum': This indicates that we are looking for the highest possible number of moves. In code, this can be implemented by maintaining a variable to store the maximum number of moves found and updating it whenever a higher number is encountered.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. Specifically, while simulating the robot's movement from each cell, we should also track visited cells to detect cycles and count the number of moves until the robot breaks or stops. This can be done in a single loop or function that handles both tasks.\n\n# [edge case]\n    1 1\n    R\n    = 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move before falling off the board.\n\n    2 2\n    LL\n    RR\n    = 1 1 2\n    Explanation: The robot can start at (1,1) and move left to (1,2), then fall off the board, making 2 moves.\n\n    3 3\n    RRR\n    LLL\n    UUU\n    = 1 1 3\n    Explanation: The robot can start at (1,1) and move right three times before falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking visited cells will naturally handle these scenarios. The edge cases are simply specific instances of the general problem, and the existing logic should be sufficient to address them.\n\nNO", "Round_0": {"code": "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_row, start_col):\n        visited = set()\n        row, col = start_row, start_col\n        steps = 0\n        \n        while True:\n            if (row, col) in visited:\n                break\n            visited.add((row, col))\n            steps += 1\n            \n            direction = board[row][col]\n            d_row, d_col = direction_map[direction]\n            new_row, new_col = row + d_row, col + d_col\n            \n            if not (0 <= new_row < n and 0 <= new_col < m):\n                break\n            \n            row, col = new_row, new_col\n        \n        return steps\n\n    max_steps = 0\n    best_start = (1, 1)  # Default to the first cell (1-indexed)\n\n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)  # Convert to 1-indexed\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"details\": \"Read the number of test cases. For each test case, read the dimensions of the board and the board itself, which consists of n lines of m characters each.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"For each cell on the board, simulate the robot's movement according to the direction specified in each cell. Track the number of moves made before the robot breaks or stops.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of moves.\",\n      \"details\": \"Compare the number of moves for each starting cell and identify the cell that results in the maximum number of moves. If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as small board sizes or uniform direction cells.\",\n      \"details\": \"Ensure that the simulation correctly handles boards with minimal dimensions and boards where all cells have the same direction.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a function to read and parse the input data.\",\n    \"For each test case, initialize a board and iterate over each cell to simulate the robot's movement.\",\n    \"Implement a function to simulate the robot's movement from a given starting cell, keeping track of visited cells to detect loops.\",\n    \"Store the number of moves for each starting cell and update the maximum moves and corresponding starting cell as needed.\",\n    \"After processing all cells for a test case, output the starting cell and the maximum number of moves.\",\n    \"Repeat the process for all test cases and ensure the output format matches the requirements.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it breaks or stops.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves simulating the robot's movement from each cell and counting the steps.\n\n# [degree adverb] \n    'maximum': The requirement is to find the starting cell that results in the highest number of moves.\n\n# [code logic]\n    The simulation of the robot's movement and tracking of visited cells should be implemented simultaneously. This involves moving the robot according to the direction in each cell and checking if it has visited a cell before or moved beyond the board's edge.\n\n# [edge case] \n    Edge Case 1: A board with all cells having the same direction, e.g., 'RRRR'\n    Expected Output: The robot will move in one direction until it falls off the board. The starting cell can be any cell in the first row, and the number of moves will be equal to the number of columns.\n\n    Edge Case 2: A board with minimal dimensions, e.g., 1x1 with 'R'\n    Expected Output: The robot will make one move and fall off the board. The starting cell is (1, 1), and the number of moves is 1.\n\n    Edge Case 3: A board with a loop, e.g., 'RU', 'DL'\n    Expected Output: The robot will move in a loop and break after visiting a cell twice. The starting cell can be any cell in the loop, and the number of moves will be equal to the number of unique cells in the loop.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        Implement a check for visited cells to detect loops and stop the robot's movement.\n        Implement boundary checks to stop the robot when it moves beyond the board's edge.\n\nYES", "Round_0": {"code": "def simulate_robot(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    row, col = start_row, start_col\n    steps = 0\n\n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        steps += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n\n        if not (0 <= new_row < n and 0 <= new_col < m):\n            break\n\n        row, col = new_row, new_col\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_robot(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions of the board, n and m.\",\n        \"Read the n lines of the board, each containing m characters.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each cell on the board, simulate the robot's movement starting from that cell.\",\n        \"Track the cells visited by the robot to detect cycles or when it moves out of bounds.\",\n        \"Count the number of successful moves made before the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the robot to make the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board details.\",\n    \"For each test case, iterate over each cell on the board to simulate the robot's movement.\",\n    \"Track visited cells to detect cycles and out-of-bounds movements.\",\n    \"Count the number of moves for each starting cell and determine the maximum.\",\n    \"Output the starting cell and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means finding the starting position that results in the highest number of moves before the robot breaks or stops. In code, this involves iterating over all possible starting positions and tracking the number of moves for each.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible number of moves. In code, this can be implemented by maintaining a variable to track the maximum number of moves encountered during the simulation.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. Specifically:\n    - \"Simulate the robot's movement starting from that cell.\"\n    - \"Track the cells visited by the robot to detect cycles or when it moves out of bounds.\"\n    These can be implemented in a single loop that handles both movement and cycle detection.\n\n# [edge case]\n    Edge Case 1: A board of size 1x1 with any direction, e.g., 'R'\n    Expected Output: 1 1 1\n    Explanation: The robot can only make one move before falling off the board.\n\n    Edge Case 2: A board where all cells point in the same direction, e.g., a 2x2 board with all 'R'\n    Expected Output: 1 1 2\n    Explanation: Starting from the top-left corner, the robot can move right twice before falling off.\n\n    Edge Case 3: A board with a cycle, e.g., a 2x2 board with 'RD', 'UR'\n    Expected Output: 1 1 4\n    Explanation: The robot can move in a cycle indefinitely, but since it revisits cells, it stops after 4 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases involving cycles and out-of-bounds movements.\n    - Use a set to track visited cells and detect cycles.\n    - Implement boundary checks to handle out-of-bounds movements.\n\n```python\ndef simulate_m", "Round_0": {"code": "def simulate_movement(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    steps = 0\n    row, col = start_row, start_col\n\n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        steps += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n\n        if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m:\n            break\n\n        row, col = new_row, new_col\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_best_start() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    steps = 0\n    row, col = start_row, start_col\n\n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        steps += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n\n        if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m:\n            break\n\n        row, col = new_row, new_col\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"details\": \"Read the input data, split it into individual test cases, and extract the values of n, m, and the board configuration for each test case.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"For each cell on the board, simulate the robot's movement according to the direction specified in the cell, keeping track of visited cells and the number of moves made until the robot breaks.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that results in the maximum number of moves.\",\n      \"details\": \"Compare the number of moves made from each starting cell and identify the cell that allows the robot to make the maximum number of moves before breaking.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as small board sizes or uniform direction cells.\",\n      \"details\": \"Ensure the program correctly handles boards with minimal dimensions and boards where all cells have the same direction.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n    \"For each test case, iterate over each cell on the board and simulate the robot's movement starting from that cell.\",\n    \"Track the number of moves made and visited cells to detect when the robot breaks.\",\n    \"Compare the results from all starting cells to find the one that results in the maximum number of moves.\",\n    \"Output the starting cell coordinates and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means we need to find the starting position that results in the highest number of moves before the robot breaks. In code, this involves tracking the number of moves from each starting position and comparing them to find the maximum.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the starting cell that results in the highest number of moves. In code, this can be implemented by maintaining a variable to track the maximum number of moves and updating it whenever a new maximum is found.\n\n# [code logic]\n    The steps of simulating the robot's movement and tracking the number of moves should be implemented simultaneously. This involves iterating over each cell, simulating the movement, and updating the count of moves in one cohesive block of code.\n\n# [edge case]\n    1 1\n    R\n    = 1 1 1\n    Explanation: With a single cell, the robot can only make one move before falling off the board.\n\n    2 2\n    RR\n    RR\n    = 1 1 1\n    Explanation: All cells direct the robot to move right, so starting from any cell results in the robot falling off the board after one move.\n\n    2 2\n    LU\n    DL\n    = 1 1 4\n    Explanation: The robot can move in a loop starting from (1,1), making 4 moves before revisiting a cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a check for when the robot revisits a cell to stop the simulation.\n    - Implement boundary checks to stop the robot when it moves off the board.\n\n```python\ndef simulate_robot_movement(board, n, m):\n    max_moves = 0\n    best_start = (1, 1)\n    \n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D", "Round_0": {"code": "def simulate_robot_movement(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    max_moves = 0\n    best_start = (1, 1)\n\n    def move_from(r, c):\n        visited = set()\n        steps = 0\n        while (r, c) not in visited:\n            visited.add((r, c))\n            steps += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        return steps\n\n    for i in range(n):\n        for j in range(m):\n            moves = move_from(i, j)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (i + 1, j + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        result = simulate_robot_movement(board, n, m)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions of the board, n and m.\",\n        \"Read the n lines that describe the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each starting cell on the board, simulate the robot's movement.\",\n        \"Track the cells visited by the robot to detect revisits.\",\n        \"Count the number of successful moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the robot to make the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"Handle ties by selecting any cell with the maximum moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board configurations.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, tracking visited cells and counting moves.\",\n    \"Determine the starting cell that results in the maximum number of moves.\",\n    \"Output the optimal starting cell and the corresponding number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions ('L', 'R', 'D', 'U') based on the symbol in the current cell. The goal is to maximize the number of moves before the robot breaks or stops.\n\n    'maximum number of steps'\n    Explanation: The robot should start from a cell that allows it to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves simulating the robot's movement from each cell and counting the moves.\n\n# [degree adverb] \n    'maximum': The requirement is to find the starting cell that results in the highest number of moves.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. This involves using a loop to simulate the movement and a data structure (like a set) to track visited cells.\n\n# [edge case] \n    Edge case 1: A board with uniform direction cells, e.g., all 'R'.\n    Expected output: The robot will move to the edge and break, resulting in a number of moves equal to the number of columns.\n    Explanation: The robot will move right until it falls off the board.\n\n    Edge case 2: A board with a single cell, e.g., 1x1 board with 'R'.\n    Expected output: 1 1 1\n    Explanation: The robot will move right and break immediately.\n\n    Edge case 3: A board with alternating directions, e.g., 'LRLRLR'.\n    Expected output: The robot will move back and forth, potentially revisiting cells, resulting in fewer moves.\n    Explanation: The robot will revisit cells and break due to revisits.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to revisiting cells and moving beyond the board edges.\n        (code for handling revisits and board edges)\n        Use a set to track visited cells and check if the next move is beyond the board boundaries.\n\nYES", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0].strip())\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_robot(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n        \n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            moves += 1\n            \n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return moves\n    \n    max_moves = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_robot(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_robot() missing 3 required positional arguments: 'n', 'm', and 'board'"}, "Round_1": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0].strip())\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        test_cases.append((n, m, board))\n    \n    return test_cases\n\ndef simulate_robot(n, m, board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n        \n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            moves += 1\n            \n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return moves\n    \n    max_moves = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, board in test_cases:\n        r, c, d = simulate_robot(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions of the board, n and m.\",\n        \"Read the n lines that describe the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each starting cell on the board, simulate the robot's movement.\",\n        \"Track the cells visited by the robot to detect revisits.\",\n        \"Count the number of successful moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"Handle ties by selecting any cell with the maximum moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board configurations.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, tracking visited cells and counting moves.\",\n    \"Determine the starting cell that results in the maximum number of moves.\",\n    \"Output the optimal starting cell and the corresponding number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left, right, down, and up, based on the symbol in the current cell. The goal is to maximize the number of moves before the robot breaks or stops.\n\n    'maximum number of steps'\n    Explanation: The robot should start from a cell that allows it to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves simulating the robot's movement from each cell and counting the moves.\n\n# [degree adverb]\n    'maximum': The requirement is to find the starting cell that allows the robot to make the greatest number of moves.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. This involves using a loop to simulate the movement and a data structure (like a set) to track visited cells.\n\n# [edge case]\n    Edge Case 1: A board with uniform direction cells, e.g., all 'R'.\n    Expected Output: The robot will move to the edge and break, resulting in a number of moves equal to the number of columns.\n    Explanation: The robot will move right until it falls off the board.\n\n    Edge Case 2: A board with a single cell, e.g., 1x1 with 'R'.\n    Expected Output: 1 1 1\n    Explanation: The robot will move right and break immediately, resulting in one move.\n\n    Edge Case 3: A board with alternating directions, e.g., 'LRLR'.\n    Expected Output: The robot will revisit cells quickly, resulting in fewer moves.\n    Explanation: The robot will move back and forth between two cells, breaking after revisiting.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to revisiting cells and moving beyond the board's edge.\n    Code for handling the edge case:\n    ```python\n    def simulate_robot(board, n, m):\n        max_moves = 0\n        best_start = (1, 1)\n        for r in range(n):\n            for c in range(m):\n                visited = set()\n                moves = 0\n                current_r, current_c = r, c\n                while True:\n                    if (current_r, current_c) in visited or not (0 <= current_r <", "Round_0": {"code": "def simulate_robot(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    best_start = (1, 1)\n    \n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            moves = 0\n            current_r, current_c = start_r, start_c\n            \n            while True:\n                if (current_r, current_c) in visited:\n                    break\n                if not (0 <= current_r < n and 0 <= current_c < m):\n                    break\n                \n                visited.add((current_r, current_c))\n                moves += 1\n                \n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                current_r += dr\n                current_c += dc\n            \n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"details\": \"Read the number of test cases. For each test case, read the dimensions of the board and the board itself, which consists of n lines of m characters each.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"For each cell on the board, simulate the robot's movement according to the direction specified in each cell. Track the number of moves until the robot either falls off the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of moves before the robot breaks.\",\n      \"details\": \"Compare the number of moves for each starting cell and identify the cell that results in the maximum number of moves. If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the dimensions of the board and the board itself.\",\n    \"  b. Initialize a variable to track the maximum number of moves and the corresponding starting cell.\",\n    \"  c. For each cell on the board, simulate the robot's movement:\",\n    \"     i. Track visited cells to detect cycles.\",\n    \"     ii. Count the number of moves until the robot breaks.\",\n    \"     iii. Update the maximum moves and starting cell if the current simulation results in more moves.\",\n    \"  d. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell. The goal is to maximize the number of moves before the robot breaks (either by falling off the board or revisiting a cell).\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking. This involves simulating the robot's movement from each cell and counting the steps until it breaks.\n    Implementation: Use a loop to simulate the robot's movement from each starting cell, tracking the number of moves until a break condition is met.\n\n# [degree adverb]\n    'maximum': The requirement is to find the starting cell that results in the highest number of moves.\n    Implementation: Keep track of the maximum number of moves encountered during the simulation and update it whenever a higher count is found.\n\n# [code logic]\n    The steps related to simulating the robot's movement (tracking visited cells, counting moves, updating maximum moves) should be implemented simultaneously within the simulation loop for each starting cell.\n\n# [edge case]\n    Edge Case 1: A board with uniform direction cells, e.g., all 'R'.\n    Expected Output: The robot will move off the board immediately from any starting cell, resulting in 1 move.\n    Explanation: Since all cells direct the robot to the right, it will fall off the board after the first move.\n\n    Edge Case 2: A board with a single cell, e.g., 'L'.\n    Expected Output: The robot will move off the board immediately, resulting in 1 move.\n    Explanation: With only one cell, any direction will cause the robot to fall off the board.\n\n    Edge Case 3: A board with a cycle, e.g., 'R', 'L' in a 1x2 board.\n    Expected Output: The robot will revisit a cell after 2 moves, resulting in a break.\n    Explanation: The robot moves right from the first cell, then left from the second cell, revisiting the first cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to cycles and small board sizes.\n    Code for handling cycles:\n    ```python\n    def simulate_robot(board, n, m):\n        max_moves = 0\n        best_start = (1, 1)\n        for r in range(n):\n            for", "Round_0": {"code": "def simulate_robot(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    max_moves = 0\n    best_start = (1, 1)\n\n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n\n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            moves += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n\n        return moves\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_robot(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the board (n and m).\",\n        \"Read the board configuration consisting of n lines with m characters each.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell and calculate the number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each cell on the board, initialize a visited set to track visited cells.\",\n        \"Simulate the robot's movement according to the direction indicated by the current cell.\",\n        \"Check if the robot moves beyond the board's edge or revisits a cell. If so, stop the simulation for that starting cell.\",\n        \"Count the number of successful moves for each starting cell.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"Store the coordinates of the starting cell and the maximum number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the coordinates of the starting cell and the maximum number of moves.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Simulate the robot's movement for each possible starting cell on the board.\",\n    \"Track the number of moves for each starting cell and identify the maximum.\",\n    \"Output the starting cell coordinates and maximum moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to find the starting cell that allows the robot to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves simulating the robot's movement from each cell and counting the steps until it breaks or revisits a cell.\n\n# [degree adverb] \n    'maximum': The requirement is to find the starting cell that results in the highest number of moves. This involves comparing the number of moves from each starting cell and selecting the one with the greatest count.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and counting moves should be implemented simultaneously. Specifically:\n    - \"Simulate the robot's movement according to the direction indicated by the current cell.\"\n    - \"Check if the robot moves beyond the board's edge or revisits a cell. If so, stop the simulation for that starting cell.\"\n    - \"Count the number of successful moves for each starting cell.\"\n    These can be implemented in a single loop that tracks the robot's position and checks conditions for breaking or stopping.\n\n# [edge case] \n    Edge Case 1: A board with uniform direction cells, e.g., all 'R'.\n    Expected Output: The robot will move to the edge and break, resulting in a number of moves equal to the number of columns.\n    Explanation: Starting from any cell, the robot will move right until it falls off the board.\n\n    Edge Case 2: A board with a single cell, e.g., 1x1 board with 'R'.\n    Expected Output: 1 1 1\n    Explanation: The robot will move right and break immediately, resulting in one move.\n\n    Edge Case 3: A board with alternating directions, e.g., 'LRLR' in a single row.\n    Expected Output: Starting from the first 'L', the robot will move left and break immediately, resulting in one move.\n    Explanation: The robot will move left from the first 'L' and break.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_start = (1, 1)\n        \n        for r in range(n):\n            for c in range(m):\n                visited = set()\n                x, y = r, c\n                moves = 0\n                \n                while (x, y) not in visited:\n                    visited.add((x, y))\n                    moves += 1\n                    direction = board[x][y]\n                    dx, dy = directions[direction]\n                    x, y = x + dx, y + dy\n                    \n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    best_start = (r + 1, c + 1)\n        \n        results.append(f\"{best_start[0]} {best_start[1]} {max_moves}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"details\": \"Read the number of test cases. For each test case, read the dimensions of the board and the board itself, which consists of n lines of m characters each.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"For each cell on the board, simulate the robot's movement according to the direction specified in each cell. Track the number of moves made before the robot breaks or stops.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of moves.\",\n      \"details\": \"Compare the number of moves for each starting cell and identify the cell that results in the maximum number of moves. If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as small board sizes or uniform direction cells.\",\n      \"details\": \"Ensure that the simulation correctly handles boards with minimal dimensions and boards where all cells have the same direction.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a function to read and parse the input data.\",\n    \"For each test case, initialize a board and iterate over each cell to simulate the robot's movement.\",\n    \"Implement a function to simulate the robot's movement from a given starting cell, tracking visited cells to detect loops.\",\n    \"Store the number of moves for each starting cell and update the maximum moves and corresponding starting cell as needed.\",\n    \"After processing all cells for a test case, output the starting cell coordinates and the maximum number of moves.\",\n    \"Repeat the process for all test cases and ensure the output format matches the requirements.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board. The goal is to maximize the number of moves before the robot breaks or stops.\n\n    'maximum number of steps'\n    Explanation: The task is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means finding the starting position that results in the highest count of moves before the robot breaks or stops. In code, this involves iterating over all possible starting positions and keeping track of the maximum number of moves achieved.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the starting cell that results in the highest number of moves. In code, this can be implemented by maintaining a variable to track the maximum number of moves and updating it whenever a new maximum is found.\n\n# [code logic]\n    The steps \"Simulate the robot's movement on the board starting from each cell\" and \"Determine the starting cell that allows the maximum number of moves\" should be implemented simultaneously. This can be done by iterating over each cell, simulating the movement, and updating the maximum moves in a single loop.\n\n# [edge case]\n    1 1\n    R\n    = 1 1 1\n    Explanation: The board is of size 1x1, so the robot can only make one move before falling off the board.\n\n    2 2\n    LL\n    LL\n    = 1 1 1\n    Explanation: All cells point left, so starting from any cell results in the robot moving off the board in one move.\n\n    2 2\n    RR\n    RR\n    = 1 2 1\n    Explanation: All cells point right, so starting from any cell results in the robot moving off the board in one move.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking the maximum number of moves will naturally handle these cases.\n\nNO", "Round_0": {"code": "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        steps = 0\n        \n        while (r, c) not in visited:\n            visited.add((r, c))\n            steps += 1\n            dr, dc = directions[board[r][c]]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return steps\n    \n    max_steps = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot_movement(n, m, board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions of the board, n and m.\",\n        \"Read the n lines that describe the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each starting cell on the board, simulate the robot's movement.\",\n        \"Track the cells visited by the robot to detect revisits.\",\n        \"Count the number of successful moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"If there are multiple cells with the same maximum number of moves, select any one of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board configurations.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, tracking the number of moves.\",\n    \"Identify the starting cell that results in the maximum number of moves.\",\n    \"Output the optimal starting cell and the corresponding number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions ('L', 'R', 'D', 'U') based on the symbol in the current cell. The goal is to maximize the number of moves before the robot breaks or stops.\n\n    'maximum number of steps'\n    Explanation: The robot should start from a cell that allows it to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves simulating the robot's path from each starting cell and counting the moves.\n\n# [degree adverb]\n    'maximum': The requirement is to find the starting cell that results in the highest number of moves. This involves comparing the move counts from different starting cells.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the cells visited should be implemented simultaneously. This involves:\n    - Simulating the robot's movement from each starting cell.\n    - Tracking visited cells to detect revisits.\n    - Counting successful moves until the robot breaks or stops.\n    This can be done using a loop to iterate over each cell and a set to track visited cells.\n\n# [edge case]\n    Edge Case 1: A board with uniform direction cells, e.g., all 'R'.\n    Expected Output: The robot will move to the edge and break, resulting in a move count equal to the number of columns.\n    Explanation: The robot will move right until it falls off the board.\n\n    Edge Case 2: A board with a single cell, e.g., 'R'.\n    Expected Output: 1 1 1\n    Explanation: The robot will move right and break immediately, resulting in one move.\n\n    Edge Case 3: A board with alternating directions, e.g., 'LRLR'.\n    Expected Output: The robot will revisit cells quickly, resulting in a low move count.\n    Explanation: The robot will move back and forth between cells, revisiting them.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to revisiting cells and moving beyond the board edge.\n    Code for handling edge cases:\n    ```python\n    def simulate_robot(board, n, m):\n        def move(r, c, direction):\n            if direction == 'L':\n                return r, c - 1\n            elif direction == 'R':\n                return r,", "Round_0": {"code": "def simulate_robot(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move(r, c, direction):\n        dr, dc = direction_map[direction]\n        return r + dr, c + dc\n\n    max_moves = 0\n    best_start = (1, 1)\n\n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                r, c = move(r, c, direction)\n\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the board (n and m).\",\n        \"Read the board configuration consisting of n lines with m characters each.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell and calculate the number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each cell on the board, simulate the robot's movement.\",\n        \"Track visited cells to detect cycles and prevent revisiting.\",\n        \"Count the number of moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"For each test case, iterate over each cell on the board.\",\n    \"Simulate the robot's movement from the current cell and count the moves.\",\n    \"Track visited cells to prevent cycles and breaking conditions.\",\n    \"Determine the starting cell with the maximum number of moves.\",\n    \"Output the optimal starting cell and the number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means we need to find the starting position that results in the highest number of moves before the robot breaks or stops. In code, this involves iterating over all possible starting positions and keeping track of the maximum number of moves achieved.\n\n# [degree adverb]\n    'maximum': This indicates that we are looking for the highest possible number of moves. In code, this can be implemented by maintaining a variable to store the maximum number of moves found and updating it whenever a higher number is encountered.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. Specifically, while simulating the robot's movement from each cell, we should also track visited cells to detect cycles and count the number of moves until the robot breaks or stops. This can be done in a single loop or function that handles both tasks.\n\n# [edge case]\n    1 1\n    R\n    = 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move before falling off the board.\n\n    2 2\n    LL\n    RR\n    = 1 1 2\n    Explanation: The robot can start at (1,1) and move left to (1,2), then fall off the board, making 2 moves.\n\n    3 3\n    RRR\n    LLL\n    UUU\n    = 1 1 3\n    Explanation: The robot can start at (1,1) and move right three times before falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking visited cells will naturally handle these scenarios. The edge cases are simply specific instances of the general problem, and the existing logic should be sufficient to address them.\n\nNO", "Round_0": {"code": "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_row, start_col):\n        visited = set()\n        row, col = start_row, start_col\n        steps = 0\n        \n        while True:\n            if (row, col) in visited:\n                break\n            visited.add((row, col))\n            steps += 1\n            \n            direction = board[row][col]\n            d_row, d_col = direction_map[direction]\n            new_row, new_col = row + d_row, col + d_col\n            \n            if not (0 <= new_row < n and 0 <= new_col < m):\n                break\n            \n            row, col = new_row, new_col\n        \n        return steps\n\n    max_steps = 0\n    best_start = (1, 1)  # Default to the first cell (1-indexed)\n\n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)  # Convert to 1-indexed\n\n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 683, "prompt": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases such as small board sizes or uniform direction cells.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 38}
