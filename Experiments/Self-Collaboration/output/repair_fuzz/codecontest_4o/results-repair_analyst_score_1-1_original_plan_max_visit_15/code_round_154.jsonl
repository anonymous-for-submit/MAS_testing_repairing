{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases where the board dimensions might be minimal or where all cells point towards the edge.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases where the board dimensions might be minimal or where all cells point towards the edge.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively. The robot can start its movement in any cell, moving to the adjacent square in the direction indicated on the current square in one move. * If the robot moves beyond the edge of the board, it falls and breaks. * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases where the board dimensions might be minimal or where all cells point towards the edge.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def simulate_robot_movement(board, n, m):\n    def move(r, c, direction):\n        if direction == 'L':\n            return r, c - 1\n        elif direction == 'R':\n            return r, c + 1\n        elif direction == 'U':\n            return r - 1, c\n        elif direction == 'D':\n            return r + 1, c\n\n    max_moves = 0\n    best_start = (1, 1)\n\n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n\n            while True:\n                if (r, c) in visited or r < 0 or r >= n or c < 0 or c >= m:\n                    break\n\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                r, c = move(r, c, direction)\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = simulate_robot_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_start = (1, 1)\n        \n        def simulate(r, c):\n            visited = set()\n            steps = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                steps += 1\n                direction = board[r][c]\n                dr, dc = directions[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return steps\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_start = (r + 1, c + 1)\n        \n        results.append(f\"{best_start[0]} {best_start[1]} {max_moves}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_row, start_col):\n    visited = set()\n    steps = 0\n    current_row, current_col = start_row, start_col\n    \n    while (current_row, current_col) not in visited:\n        visited.add((current_row, current_col))\n        steps += 1\n        \n        direction = board[current_row][current_col]\n        if direction == 'L':\n            current_col -= 1\n        elif direction == 'R':\n            current_col += 1\n        elif direction == 'U':\n            current_row -= 1\n        elif direction == 'D':\n            current_row += 1\n        \n        # Check if the robot falls off the board\n        if current_row < 0 or current_row >= n or current_col < 0 or current_col >= m:\n            break\n    \n    return steps\n\ndef find_best_starting_position(board, n, m):\n    max_steps = 0\n    best_position = (1, 1)  # Default to the first cell in 1-based index\n    \n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return best_position[0], best_position[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_starting_position(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef simulate_robot(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    row, col = start_row, start_col\n    moves = 0\n    \n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        moves += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n        \n        if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m:\n            break\n        \n        row, col = new_row, new_col\n    \n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_robot(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_robot(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    steps = 0\n    \n    while True:\n        if (r < 0 or r >= n or c < 0 or c >= m) or (r, c) in visited:\n            break\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r += dr\n        c += dc\n        steps += 1\n    \n    return steps\n\ndef find_best_starting_cell(board, n, m):\n    max_steps = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_starting_cell(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        steps = 0\n        \n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            steps += 1\n            \n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return steps\n\n    max_steps = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot_movement(n, m, board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    steps = 0\n\n    while True:\n        if (r, c) in visited:\n            break\n        visited.add((r, c))\n        steps += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        steps = 0\n        \n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            steps += 1\n            \n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return steps\n\n    max_steps = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot_movement(n, m, board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read dimensions\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement from a given start position\n        def simulate(start_r, start_c):\n            visited = set()\n            r, c = start_r, start_c\n            steps = 0\n            \n            while True:\n                if (r, c) in visited:\n                    break\n                visited.add((r, c))\n                steps += 1\n                \n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                \n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            \n            return steps\n        \n        max_steps = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for r in range(n):\n            for c in range(m):\n                steps = simulate(r, c)\n                if steps > max_steps:\n                    max_steps = steps\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_steps}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(board, n, m):\n    def move(r, c, direction):\n        if direction == 'L':\n            return r, c - 1\n        elif direction == 'R':\n            return r, c + 1\n        elif direction == 'U':\n            return r - 1, c\n        elif direction == 'D':\n            return r + 1, c\n\n    max_moves = 0\n    best_start = (1, 1)\n\n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n\n            while True:\n                if (r, c) in visited or r < 0 or r >= n or c < 0 or c >= m:\n                    break\n\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                r, c = move(r, c, direction)\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = simulate_robot_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"Implement a function to simulate the robot's movement based on the direction indicated in each cell, keeping track of visited cells and stopping conditions.\"\n    },\n    {\n      \"description\": \"Determine the maximum number of moves the robot can make before breaking or stopping.\",\n      \"details\": \"For each starting cell, calculate the number of moves until the robot either falls off the board or revisits a cell, and keep track of the maximum number of moves.\"\n    },\n    {\n      \"description\": \"Identify the starting cell that allows the maximum number of moves.\",\n      \"details\": \"Compare the results from all starting cells and select the one with the highest number of moves.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": \"Format the output to include the starting cell coordinates and the maximum number of moves for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract test cases, board dimensions, and configurations.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, tracking visited cells and move count.\",\n    \"Determine the maximum number of moves for each starting cell and identify the optimal starting cell.\",\n    \"Output the starting cell coordinates and maximum move count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions ('L', 'R', 'D', 'U') based on the symbol in the current cell. The goal is to maximize the number of moves before the robot breaks or stops.\n\n    'maximum number of steps'\n    Explanation: The robot should start from a cell that allows it to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves simulating the robot's movement from each cell and counting the moves.\n\n# [degree adverb] \n    'maximum': The robot should start from the cell that allows the highest number of moves.\n\n# [code logic]\n    The steps related to simulating the robot's movement and determining the maximum number of moves should be implemented simultaneously. Specifically, the simulation of movement and tracking of visited cells should occur in one code block to efficiently determine when the robot breaks or stops.\n\n# [edge case] \n    Test case with minimal board size (1x1) where the robot immediately breaks: \n    1 1\n    R\n    Expected output: 1 1 1\n    Explanation: The robot starts at the only cell and moves right, breaking immediately.\n\n    Test case where all cells point towards the edge:\n    2 2\n    RR\n    RR\n    Expected output: 1 1 2\n    Explanation: Starting from (1,1), the robot moves right twice and breaks.\n\n    Test case with a loop:\n    2 2\n    RD\n    UR\n    Expected output: 1 1 4\n    Explanation: Starting from (1,1), the robot moves right, down, left, up, and revisits (1,1), breaking.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell or moves beyond the board edge.\n        (code for handling the edge case)\n        def simulate_robot_movement(board, n, m):\n            def move(r, c, direction):\n                if direction == 'L':\n                    return r, c - 1\n                elif direction == 'R':\n                    return r, c + 1\n                elif direction == 'U':\n                    return r - 1, c\n                elif direction == 'D':\n                    return r + 1, c", "Round_0": {"code": "def simulate_robot_movement(board, n, m):\n    def move(r, c, direction):\n        if direction == 'L':\n            return r, c - 1\n        elif direction == 'R':\n            return r, c + 1\n        elif direction == 'U':\n            return r - 1, c\n        elif direction == 'D':\n            return r + 1, c\n\n    max_moves = 0\n    best_start = (1, 1)\n\n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n\n            while True:\n                if (r, c) in visited or r < 0 or r >= n or c < 0 or c >= m:\n                    break\n\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                r, c = move(r, c, direction)\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = simulate_robot_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m of the board.\",\n        \"Read the n lines of the board, each containing m characters ('L', 'R', 'D', 'U').\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell to determine the maximum number of moves before breaking.\",\n      \"steps\": [\n        \"For each cell on the board, simulate the robot's movement.\",\n        \"Track the cells visited to detect cycles or when the robot moves out of bounds.\",\n        \"Count the number of successful moves before the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the robot to make the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board details.\",\n    \"For each test case, initialize variables to track the maximum number of moves and the corresponding starting cell.\",\n    \"Simulate the robot's movement from each cell on the board, keeping track of visited cells to detect cycles.\",\n    \"Update the maximum number of moves and starting cell if a new maximum is found.\",\n    \"After evaluating all starting cells, output the optimal starting cell and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell. The goal is to maximize the number of moves before it breaks or stops.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves counting the number of successful moves from a starting cell until a cycle is detected or the robot moves out of bounds.\n\n# [degree adverb] \n    'maximum': The requirement is to find the starting cell that allows the robot to make the most moves before breaking or stopping.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. This involves using a loop to simulate movement and a data structure (like a set) to track visited cells to detect cycles.\n\n# [edge case] \n    Test case with minimal board size:\n    1 1\n    L\n    Output: 1 1 1\n    Explanation: The robot starts at the only cell and moves left, breaking immediately.\n\n    Test case where all cells point towards the edge:\n    2 2\n    RR\n    RR\n    Output: 1 1 2\n    Explanation: Starting at (1,1), the robot moves right twice and breaks.\n\n    Test case with a cycle:\n    2 2\n    RD\n    UR\n    Output: 1 1 4\n    Explanation: Starting at (1,1), the robot moves right, down, left, up, forming a cycle.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases involving cycles and out-of-bounds movement.\n        (code for handling cycles and out-of-bounds movement)\n        Use a set to track visited cells and check for cycles.\n        Implement boundary checks to detect when the robot moves out of bounds.\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        max_moves = 0\n        best_start = (1, 1)\n        \n        def simulate(r, c):\n            visited = set()\n            steps = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                steps += 1\n                direction = board[r][c]\n                dr, dc = directions[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return steps\n        \n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_start = (r + 1, c + 1)\n        \n        results.append(f\"{best_start[0]} {best_start[1]} {max_moves}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"Implement a function to simulate the robot's movement based on the direction indicated in each cell, keeping track of visited cells and steps taken.\"\n    },\n    {\n      \"description\": \"Determine the maximum number of steps the robot can take before breaking or stopping.\",\n      \"details\": \"For each starting cell, calculate the number of steps the robot can take and identify the starting cell that allows the maximum number of steps.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as minimal board dimensions and cells pointing towards the edge.\",\n      \"details\": \"Ensure the simulation correctly handles scenarios where the robot immediately falls off the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": \"Format the output to include the starting cell coordinates and the maximum number of steps for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract test cases, board dimensions, and configurations.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, tracking visited cells and counting steps.\",\n    \"Identify the starting cell that results in the maximum number of steps before the robot breaks or stops.\",\n    \"Handle edge cases to ensure robustness of the simulation.\",\n    \"Output the starting cell coordinates and maximum steps for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means finding the starting position that allows the robot to move the most times before stopping or breaking. In code, this involves iterating over all possible starting positions and simulating the robot's path to count steps.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible number of steps the robot can take from any starting position. In code, this involves keeping track of the highest step count encountered during simulations.\n\n# [code logic]\n    The steps related to simulating the robot's movement and determining the maximum number of steps should be implemented simultaneously. Specifically, the simulation of the robot's movement and the tracking of visited cells and step count should occur in the same loop or function to efficiently determine the maximum steps from each starting cell.\n\n# [edge case]\n    1 1\n    R\n    = 1 1 1\n    Explanation: The board is minimal with only one cell, and the robot can only make one move before falling off.\n\n    2 2\n    RR\n    LL\n    = 1 1 1\n    Explanation: The robot will immediately revisit a cell if it starts at (1,1) or (2,1), resulting in only one move.\n\n    2 2\n    DL\n    UR\n    = 1 1 4\n    Explanation: The robot can make a full loop starting from (1,1) before revisiting a cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the simulation correctly handles revisiting cells and falling off the board. This can be done by maintaining a set of visited cells and checking boundaries during the simulation.\n\n```python\ndef simulate_movement(board, start_row, start_col):\n    visited = set()\n    steps = 0\n    current_row, current_col = start_row, start_col\n    while (current_row, current_col) not in visited:\n        visited.add((", "Round_0": {"code": "def simulate_movement(board, n, m, start_row, start_col):\n    visited = set()\n    steps = 0\n    current_row, current_col = start_row, start_col\n    \n    while (current_row, current_col) not in visited:\n        visited.add((current_row, current_col))\n        steps += 1\n        \n        direction = board[current_row][current_col]\n        if direction == 'L':\n            current_col -= 1\n        elif direction == 'R':\n            current_col += 1\n        elif direction == 'U':\n            current_row -= 1\n        elif direction == 'D':\n            current_row += 1\n        \n        # Check if the robot falls off the board\n        if current_row < 0 or current_row >= n or current_col < 0 or current_col >= m:\n            break\n    \n    return steps\n\ndef find_best_starting_position(board, n, m):\n    max_steps = 0\n    best_position = (1, 1)  # Default to the first cell in 1-based index\n    \n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return best_position[0], best_position[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_starting_position(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_best_starting_position() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_row, start_col):\n    visited = set()\n    steps = 0\n    current_row, current_col = start_row, start_col\n    \n    while (current_row, current_col) not in visited:\n        visited.add((current_row, current_col))\n        steps += 1\n        \n        direction = board[current_row][current_col]\n        if direction == 'L':\n            current_col -= 1\n        elif direction == 'R':\n            current_col += 1\n        elif direction == 'U':\n            current_row -= 1\n        elif direction == 'D':\n            current_row += 1\n        \n        # Check if the robot falls off the board\n        if current_row < 0 or current_row >= n or current_col < 0 or current_col >= m:\n            break\n    \n    return steps\n\ndef find_best_starting_position(board, n, m):\n    max_steps = 0\n    best_position = (1, 1)  # Default to the first cell in 1-based index\n    \n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return best_position[0], best_position[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_starting_position(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions of the board, n and m.\",\n        \"Read the n lines that describe the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each starting cell on the board, simulate the robot's movement.\",\n        \"Track the cells visited by the robot to detect cycles.\",\n        \"Count the number of successful moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the robot to make the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"Store the row, column, and number of moves for the optimal starting cell.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board configurations.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, tracking visited cells and counting moves.\",\n    \"Determine the starting cell that results in the maximum number of moves.\",\n    \"Output the optimal starting cell and the corresponding number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means finding the starting position that results in the highest number of moves before the robot breaks or stops. In code, this involves iterating over all possible starting positions and simulating the robot's path to count the moves.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the starting cell that results in the highest number of moves. In code, this can be implemented by maintaining a variable to track the maximum number of moves and updating it whenever a new maximum is found.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. Specifically, the steps:\n    - \"For each starting cell on the board, simulate the robot's movement.\"\n    - \"Track the cells visited by the robot to detect cycles.\"\n    - \"Count the number of successful moves until the robot breaks or stops.\"\n    These can be implemented in a single function that handles the simulation, tracking, and counting in one loop.\n\n# [edge case]\n    Edge Case 1: A board with all cells pointing towards the edge.\n    Example: \n    ```\n    1 3\n    RRR\n    ```\n    Expected Output: 1 1 1\n    Explanation: The robot starts at (1,1) and immediately moves off the board.\n\n    Edge Case 2: A board with a cycle.\n    Example:\n    ```\n    2 2\n    RD\n    UL\n    ```\n    Expected Output: 1 1 4\n    Explanation: The robot can move in a cycle starting from (1,1) and make 4 moves before revisiting a cell.\n\n    Edge Case 3: Minimal board size.\n    Example:\n    ```\n    1 1\n    L\n    ```\n    Expected Output: 1 1 1\n    Explanation: The robot starts at (1,1) and immediately moves off the board.\n\n# [extra code for edge case]\n    We need extra code", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate_robot(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    row, col = start_row, start_col\n    moves = 0\n    \n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        moves += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n        \n        if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m:\n            break\n        \n        row, col = new_row, new_col\n    \n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_robot(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate_robot(board, n, m, start_row, start_col):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    row, col = start_row, start_col\n    moves = 0\n    \n    while True:\n        if (row, col) in visited:\n            break\n        visited.add((row, col))\n        moves += 1\n        direction = board[row][col]\n        d_row, d_col = directions[direction]\n        new_row, new_col = row + d_row, col + d_col\n        \n        if new_row < 0 or new_row >= n or new_col < 0 or new_col >= m:\n            break\n        \n        row, col = new_row, new_col\n    \n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_robot(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n    \n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each board.\",\n      \"details\": \"Read the number of test cases. For each test case, read the dimensions of the board (n, m) and the board itself, which consists of n lines of m characters ('L', 'R', 'D', 'U').\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"For each cell on the board, simulate the robot's movement according to the direction indicated by the cell. Track the number of moves until the robot either falls off the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of moves.\",\n      \"details\": \"For each test case, compare the number of moves from each starting cell and identify the cell that results in the maximum number of moves. If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the dimensions of the board and the board itself.\",\n    \"  b. Initialize a variable to track the maximum number of moves and the corresponding starting cell.\",\n    \"  c. For each cell on the board, simulate the robot's movement:\",\n    \"     i. Track visited cells to detect revisits.\",\n    \"     ii. Count the number of moves until the robot falls off the board or revisits a cell.\",\n    \"     iii. Update the maximum number of moves and starting cell if the current simulation results in more moves.\",\n    \"  d. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell. The goal is to maximize the number of moves before the robot either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping.\n    Implementation: Track the number of moves for each starting cell and update the maximum if a new starting cell results in more moves.\n\n# [degree adverb]\n    'maximum': Refers to the highest number of moves the robot can make from a starting cell.\n    Implementation: Use a variable to keep track of the maximum number of moves and update it during the simulation.\n\n# [code logic]\n    The steps related to simulating the robot's movement and tracking the maximum number of moves should be implemented simultaneously. Specifically, steps \"c. For each cell on the board, simulate the robot's movement\" and \"iii. Update the maximum number of moves and starting cell if the current simulation results in more moves\" should be in the same loop to efficiently track and update the maximum moves.\n\n# [edge case]\n    Edge Case 1: A board with all cells pointing towards the edge.\n    Example: \n    ```\n    1 3\n    RRR\n    ```\n    Expected Output: 1 1 1\n    Explanation: The robot will immediately fall off the board from any starting cell.\n\n    Edge Case 2: A board with minimal dimensions (1x1).\n    Example:\n    ```\n    1 1\n    L\n    ```\n    Expected Output: 1 1 1\n    Explanation: The robot will immediately fall off the board.\n\n    Edge Case 3: A board where all cells point to a loop.\n    Example:\n    ```\n    2 2\n    RD\n    UL\n    ```\n    Expected Output: 1 1 4\n    Explanation: The robot can move in a loop indefinitely, but since revisiting a cell breaks the robot, it will stop after 4 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell. This can be done by maintaining a set of visited cells during the simulation to detect revisits.\n    ```\n    visited = set()\n    while (r, c) not in visited", "Round_0": {"code": "def simulate_robot(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_robot(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_best_start() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_robot(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_start = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_robot(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (r + 1, c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the board (n and m).\",\n        \"Read the board configuration consisting of n lines with m characters each.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before breaking.\",\n      \"steps\": [\n        \"For each cell on the board, simulate the robot's movement starting from that cell.\",\n        \"Track visited cells to detect cycles and prevent revisiting.\",\n        \"Count the number of successful moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting cell.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize data structures to store board configurations and results.\",\n    \"Iterate over each test case to process the board.\",\n    \"For each cell on the board, simulate the robot's movement and track the number of moves.\",\n    \"Store the results for the cell with the maximum moves for each test case.\",\n    \"Output the results in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions ('L', 'R', 'D', 'U') based on the symbol in the current cell. The goal is to maximize the number of moves before the robot breaks or stops.\n\n    'maximum number of steps'\n    Explanation: The robot should start from a cell that allows it to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves finding the starting cell that results in the highest move count.\n\n# [degree adverb]\n    'maximum': The requirement is to find the starting cell that results in the greatest number of moves.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. This involves using a loop to simulate movement and a data structure (like a set) to track visited cells to detect cycles.\n\n# [edge case]\n    Edge Case 1: A board with minimal dimensions (1x1) and a direction pointing out of bounds.\n    Example: \n    ```\n    1 1\n    R\n    ```\n    Expected Output: `1 1 1`\n    Explanation: The robot moves once and falls off the board.\n\n    Edge Case 2: A board where all cells point towards the edge.\n    Example:\n    ```\n    2 2\n    RR\n    RR\n    ```\n    Expected Output: `1 1 2`\n    Explanation: Starting from (1,1), the robot moves right twice and falls off the board.\n\n    Edge Case 3: A board with a cycle.\n    Example:\n    ```\n    2 2\n    RD\n    UR\n    ```\n    Expected Output: `1 1 4`\n    Explanation: Starting from (1,1), the robot moves in a cycle and breaks after revisiting a cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases involving cycles and out-of-bounds movement.\n    ```\n    def simulate_movement(board, n, m):\n        def move(r, c, visited):\n            if (r < 0 or r >= n or c < 0 or c >= m) or (r, c) in visited:\n                return len(visited)\n            visited.add((r, c))\n            direction = board[r][c", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    steps = 0\n    \n    while True:\n        if (r < 0 or r >= n or c < 0 or c >= m) or (r, c) in visited:\n            break\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r += dr\n        c += dc\n        steps += 1\n    \n    return steps\n\ndef find_best_starting_cell(board, n, m):\n    max_steps = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_starting_cell(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_best_starting_cell() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    steps = 0\n    \n    while True:\n        if (r < 0 or r >= n or c < 0 or c >= m) or (r, c) in visited:\n            break\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r += dr\n        c += dc\n        steps += 1\n    \n    return steps\n\ndef find_best_starting_cell(board, n, m):\n    max_steps = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_starting_cell(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"Implement a function to simulate the robot's movement based on the direction indicated in each cell, keeping track of visited cells and stopping conditions.\"\n    },\n    {\n      \"description\": \"Determine the maximum number of moves for each starting cell.\",\n      \"details\": \"For each cell on the board, calculate the number of moves the robot can make before stopping or breaking, and store the results.\"\n    },\n    {\n      \"description\": \"Identify the starting cell that allows the maximum number of moves.\",\n      \"details\": \"Compare the results from all starting cells to find the cell that results in the maximum number of moves.\"\n    },\n    {\n      \"description\": \"Format the output according to the specified requirements.\",\n      \"details\": \"Output the row, column, and maximum number of moves for each test case in the required format.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract test cases, board dimensions, and configurations.\",\n    \"For each test case, iterate over each cell on the board as a potential starting point.\",\n    \"Simulate the robot's movement from the current starting cell, tracking visited cells and stopping conditions.\",\n    \"Calculate the number of moves for each starting cell and store the results.\",\n    \"Identify the starting cell with the maximum number of moves for each test case.\",\n    \"Output the results in the specified format for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means finding the starting position that results in the highest number of moves before the robot breaks or stops.\n    Implementation: Track the number of moves for each starting position and compare to find the maximum.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the starting cell that results in the highest number of moves.\n    Implementation: Use a variable to keep track of the maximum number of moves and update it whenever a new maximum is found.\n\n# [code logic]\n    The steps \"Simulate the robot's movement from the current starting cell\" and \"Calculate the number of moves for each starting cell\" should be implemented simultaneously. This can be done by simulating the movement and counting the moves in the same loop.\n\n# [edge case]\n    Edge Case 1: A board with all cells pointing towards the edge.\n    Example: \n    ```\n    1 3\n    RRR\n    ```\n    Expected Output: 1 1 1\n    Explanation: The robot will move off the board immediately from any starting position.\n\n    Edge Case 2: A board with minimal dimensions (1x1).\n    Example:\n    ```\n    1 1\n    L\n    ```\n    Expected Output: 1 1 1\n    Explanation: The robot will move off the board immediately.\n\n    Edge Case 3: A board where all cells point to themselves.\n    Example:\n    ```\n    2 2\n    LL\n    LL\n    ```\n    Expected Output: 1 1 1\n    Explanation: The robot will revisit the starting cell immediately.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking visited cells will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        steps = 0\n        \n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            steps += 1\n            \n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return steps\n\n    max_steps = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot_movement(n, m, board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the board (n and m).\",\n        \"Read the board configuration consisting of n lines with m characters each.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before breaking or stopping.\",\n      \"steps\": [\n        \"Initialize a data structure to track visited cells for each starting position.\",\n        \"For each cell on the board, simulate the robot's movement:\",\n        \"  - Start from the current cell.\",\n        \"  - Follow the direction indicated by the current cell.\",\n        \"  - Check if the robot moves beyond the board's edge or revisits a cell.\",\n        \"  - Count the number of successful moves.\",\n        \"Store the starting position and the number of moves if it exceeds the current maximum.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the optimal starting position for the robot to achieve the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting position.\",\n        \"Select the starting position with the highest number of moves.\",\n        \"If multiple positions yield the same maximum number of moves, select any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves for the optimal starting position.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Simulate the robot's movement for each starting position on the board.\",\n    \"Track the number of moves and identify the optimal starting position.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The requirement involves simulating the movement of a robot on a board based on directional commands ('L', 'R', 'D', 'U') and determining the starting position that allows the maximum number of moves before the robot breaks or stops.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means we need to find the starting position that allows the robot to make the most moves before breaking or stopping. In code, this involves tracking the number of moves from each starting position and comparing them to find the maximum.\n\n# [degree adverb]\n    'maximum': This indicates that we need to find the starting position that results in the highest number of moves. In code, this can be implemented by maintaining a variable to store the maximum number of moves found and updating it whenever a new maximum is encountered.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the maximum number of moves should be implemented simultaneously. Specifically, the steps:\n    - \"For each cell on the board, simulate the robot's movement\"\n    - \"Count the number of successful moves\"\n    - \"Store the starting position and the number of moves if it exceeds the current maximum\"\n    These steps can be implemented in a single loop that iterates over each cell, simulates the movement, and updates the maximum moves and starting position as needed.\n\n# [edge case]\n    1 1\n    R\n    = 1 1 1\n    Explanation: The board has only one cell, and the robot can make only one move before falling off the edge.\n\n    2 2\n    RR\n    RR\n    = 1 1 1\n    Explanation: All cells point to the right, leading the robot to fall off the edge after one move from any starting position.\n\n    2 2\n    LU\n    DL\n    = 1 1 4\n    Explanation: The robot can move in a loop starting from (1,1), making four moves before revisiting a cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell or moves beyond the board's edge. This can be done by maintaining a set of visited cells and checking if the robot revisits a cell or moves out of bounds during the simulation.\n    ```python\n    def simulate_movement(board, n, m):\n        max", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    steps = 0\n\n    while True:\n        if (r, c) in visited:\n            break\n        visited.add((r, c))\n        steps += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_best_start() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    steps = 0\n\n    while True:\n        if (r, c) in visited:\n            break\n        visited.add((r, c))\n        steps += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return steps\n\ndef find_best_start(board, n, m):\n    max_steps = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            steps = simulate_movement(board, n, m, r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the board (n and m).\",\n        \"Read the board configuration consisting of n lines with m characters each.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board to determine the maximum number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each cell on the board, simulate the robot's movement starting from that cell.\",\n        \"Track visited cells to detect cycles and prevent revisiting.\",\n        \"Count the number of successful moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"Store the coordinates of the starting cell and the maximum number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves.\",\n        \"Ensure the output format matches the requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"For each test case, iterate over all cells to simulate robot movements.\",\n    \"Track visited cells to prevent cycles and count successful moves.\",\n    \"Determine the starting cell with the maximum number of moves.\",\n    \"Output the results for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell. The goal is to maximize the number of moves before it either falls off the board or revisits a cell.\n\n    'maximum number of steps'\n    Explanation: The task is to find the starting cell that allows the robot to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means finding the starting position that results in the highest count of moves before the robot breaks or stops. In code, this involves iterating over all possible starting positions and tracking the number of moves for each.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible number of moves. In code, this can be implemented by maintaining a variable to track the maximum number of moves encountered during the simulation.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking visited cells should be implemented simultaneously. Specifically:\n    - \"For each cell on the board, simulate the robot's movement starting from that cell.\"\n    - \"Track visited cells to detect cycles and prevent revisiting.\"\n    - \"Count the number of successful moves until the robot breaks or stops.\"\n    These steps can be combined into a single function that handles the simulation and tracking logic.\n\n# [edge case]\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: The board is a single cell, and the robot can only make one move before falling off.\n\n    2 2\n    LL\n    RR\n    Output: 1 1 1\n    Explanation: Any starting position results in the robot moving off the board immediately.\n\n    3 3\n    RRR\n    DDD\n    LLL\n    Output: 1 1 3\n    Explanation: Starting from (1,1), the robot can move right three times before falling off.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking visited cells will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def simulate_robot_movement(n, m, board):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def move_robot(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        steps = 0\n        \n        while True:\n            if (r, c) in visited:\n                break\n            visited.add((r, c))\n            steps += 1\n            \n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return steps\n\n    max_steps = 0\n    best_start = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            steps = move_robot(r, c)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return best_start[0], best_start[1], max_steps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot_movement(n, m, board)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the board (n and m).\",\n        \"Read the board configuration consisting of n lines with m characters each.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell and calculate the number of moves before it breaks or stops.\",\n      \"steps\": [\n        \"For each cell on the board, simulate the robot's movement.\",\n        \"Track visited cells to detect cycles and prevent revisiting.\",\n        \"Count the number of successful moves until the robot breaks or stops.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the robot to make the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves for each starting cell.\",\n        \"Identify the cell with the maximum number of moves.\",\n        \"Store the coordinates of this cell and the number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the row, column, and maximum number of moves.\",\n        \"Ensure the output format matches the requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"For each test case, iterate over all cells on the board.\",\n    \"Simulate the robot's movement from each cell and track the number of moves.\",\n    \"Identify the starting cell with the maximum number of moves.\",\n    \"Output the results for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot moves according to the direction specified in each cell ('L', 'R', 'D', 'U') and can start from any cell on the board.\n\n    'maximum number of steps'\n    Explanation: The goal is to determine the starting cell that allows the robot to make the most moves before it either falls off the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': This means finding the starting position that results in the highest number of moves before the robot breaks or stops. In code, this involves iterating over all possible starting positions and simulating the robot's path to count the moves.\n\n# [degree adverb]\n    'maximum': This refers to the highest number of moves possible from any starting cell. In code, this involves keeping track of the highest move count encountered during the simulation.\n\n# [code logic]\n    The steps in the plan are well-structured, but the simulation of the robot's movement and tracking of visited cells should be implemented simultaneously. This involves:\n    - Simulating the robot's movement from each cell.\n    - Tracking visited cells to detect cycles.\n    - Counting moves until the robot breaks or stops.\n    These can be implemented in a single function that handles the movement logic and cycle detection.\n\n# [edge case]\n    Edge Case 1: A board with only one cell, e.g., 1x1 board with 'R'\n    Expected Output: 1 1 1\n    Explanation: The robot can only make one move before falling off the board.\n\n    Edge Case 2: A board where all cells point towards the edge, e.g., 2x2 board with 'RR', 'RR'\n    Expected Output: 1 1 2\n    Explanation: Starting from any cell, the robot will move right and then fall off the board.\n\n    Edge Case 3: A board with a cycle, e.g., 2x2 board with 'RD', 'UL'\n    Expected Output: 1 1 4\n    Explanation: The robot can move in a cycle indefinitely, but since it revisits a cell, it stops after 4 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases involving cycles and single-cell boards.\n    - Implement cycle detection using a set to track visited cells.\n    - Handle single-cell boards by checking if the robot moves out of bounds immediately.\n\n", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read dimensions\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot's movement from a given start position\n        def simulate(start_r, start_c):\n            visited = set()\n            r, c = start_r, start_c\n            steps = 0\n            \n            while True:\n                if (r, c) in visited:\n                    break\n                visited.add((r, c))\n                steps += 1\n                \n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                \n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            \n            return steps\n        \n        max_steps = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for r in range(n):\n            for c in range(m):\n                steps = simulate(r, c)\n                if steps > max_steps:\n                    max_steps = steps\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_steps}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and board configurations.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board starting from each cell.\",\n      \"details\": \"Implement a function to simulate the robot's movement based on the direction indicated in each cell, keeping track of visited cells and stopping conditions.\"\n    },\n    {\n      \"description\": \"Determine the maximum number of moves the robot can make before breaking or stopping.\",\n      \"details\": \"For each starting cell, calculate the number of moves until the robot either falls off the board or revisits a cell, and keep track of the maximum number of moves.\"\n    },\n    {\n      \"description\": \"Identify the starting cell that allows the maximum number of moves.\",\n      \"details\": \"Compare the results from all starting cells and select the one with the highest number of moves.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": \"Format the output to include the starting cell coordinates and the maximum number of moves for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract test cases, board dimensions, and configurations.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, tracking visited cells and move count.\",\n    \"Determine the maximum number of moves for each starting cell and identify the optimal starting cell.\",\n    \"Output the starting cell coordinates and maximum move count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions ('L', 'R', 'D', 'U') based on the symbol in the current cell. The goal is to maximize the number of moves before the robot breaks or stops.\n\n    'maximum number of steps'\n    Explanation: The robot should start from a cell that allows it to make the most moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    'maximum number of steps': The robot should make as many moves as possible before breaking or stopping. This involves simulating the robot's movement from each cell and counting the moves.\n\n# [degree adverb] \n    'maximum': The robot should start from the cell that allows the highest number of moves.\n\n# [code logic]\n    The steps related to simulating the robot's movement and determining the maximum number of moves should be implemented simultaneously. Specifically, the simulation of movement and tracking of visited cells should occur in one code block to efficiently determine when the robot breaks or stops.\n\n# [edge case] \n    Test case with minimal board size (1x1) where the robot immediately breaks: \n    1 1\n    R\n    Expected output: 1 1 1\n    Explanation: The robot starts at the only cell and moves right, breaking immediately.\n\n    Test case where all cells point towards the edge:\n    2 2\n    RR\n    RR\n    Expected output: 1 1 2\n    Explanation: Starting from (1,1), the robot moves right twice and breaks.\n\n    Test case with a loop:\n    2 2\n    RD\n    UR\n    Expected output: 1 1 4\n    Explanation: Starting from (1,1), the robot moves right, down, left, up, and revisits (1,1), breaking.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell or moves beyond the board edge.\n        (code for handling the edge case)\n        def simulate_robot_movement(board, n, m):\n            def move(r, c, direction):\n                if direction == 'L':\n                    return r, c - 1\n                elif direction == 'R':\n                    return r, c + 1\n                elif direction == 'U':\n                    return r - 1, c\n                elif direction == 'D':\n                    return r + 1, c", "Round_0": {"code": "def simulate_robot_movement(board, n, m):\n    def move(r, c, direction):\n        if direction == 'L':\n            return r, c - 1\n        elif direction == 'R':\n            return r, c + 1\n        elif direction == 'U':\n            return r - 1, c\n        elif direction == 'D':\n            return r + 1, c\n\n    max_moves = 0\n    best_start = (1, 1)\n\n    for start_r in range(n):\n        for start_c in range(m):\n            visited = set()\n            r, c = start_r, start_c\n            moves = 0\n\n            while True:\n                if (r, c) in visited or r < 0 or r >= n or c < 0 or c >= m:\n                    break\n\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                r, c = move(r, c, direction)\n\n            if moves > max_moves:\n                max_moves = moves\n                best_start = (start_r + 1, start_c + 1)\n\n    return best_start[0], best_start[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = simulate_robot_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 154, "prompt": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Consider edge cases where the board dimensions might be minimal or where all cells point towards the edge.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 38}
