{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems must meet at least one criterion. It should satisfy either one of two conditions or both:\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). Every single one of the problems is different from the others. In other words, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems must meet at least one criterion. It should satisfy either one of two conditions or both:\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams and he decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and also has a difficulty b_i (an integer from 1 to n), with all problems being different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems must meet at least one criterion. It should satisfy either one of two conditions or both: the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # For each problem, calculate the number of invalid combinations\n            # where this problem is included and the other two have the same topic or difficulty\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for a_i, b_i in problems:\n            same_topic_ways += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Calculate valid ways using inclusion-exclusion principle\n        valid_ways = total_ways - same_topic_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    # Calculate total combinations of 3 problems\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count occurrences of each topic and difficulty\n    topic_count = defaultdict(int)\n    difficulty_count = defaultdict(int)\n    \n    for a, b in problems:\n        topic_count[a] += 1\n        difficulty_count[b] += 1\n    \n    # Calculate invalid combinations where topics or difficulties are not different\n    invalid_combinations = 0\n    \n    for a, b in problems:\n        # Combinations where the topic is the same\n        invalid_combinations += (topic_count[a] - 1) * (topic_count[a] - 2) // 2\n        # Combinations where the difficulty is the same\n        invalid_combinations += (difficulty_count[b] - 1) * (difficulty_count[b] - 2) // 2\n        # Subtract combinations where both topic and difficulty are the same\n        invalid_combinations -= (topic_count[a] - 1) * (difficulty_count[b] - 1)\n    \n    # Valid combinations are total minus invalid\n    valid_combinations = total_combinations - invalid_combinations\n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        \n        result = count_valid_combinations(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Calculate invalid combinations for this problem being part of a set\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "from sys import stdin, stdout\nfrom collections import defaultdict\n\ndef solve():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            # If we choose this problem, we can't choose two more with the same topic or difficulty\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef count_valid_combinations(n, problems):\n    # Calculate total combinations of 3 problems\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count occurrences of each topic and difficulty\n    topic_count = defaultdict(int)\n    difficulty_count = defaultdict(int)\n    \n    for a, b in problems:\n        topic_count[a] += 1\n        difficulty_count[b] += 1\n    \n    # Calculate invalid combinations where topics or difficulties are not different\n    invalid_combinations = 0\n    \n    for a, b in problems:\n        # Combinations where topics are not different\n        invalid_combinations += (topic_count[a] - 1) * (topic_count[a] - 2) // 2\n        # Combinations where difficulties are not different\n        invalid_combinations += (difficulty_count[b] - 1) * (difficulty_count[b] - 2) // 2\n    \n    # Subtract invalid combinations from total combinations\n    valid_combinations = total_combinations - invalid_combinations\n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        \n        result = count_valid_combinations(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            # If we choose this problem, we can't choose 2 more problems with the same topic or difficulty\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations where all three have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid combinations where all three have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract combinations where two problems have the same topic or difficulty\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # For each problem, calculate the number of invalid combinations\n            # where this problem is included and the other two have the same topic or difficulty\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where the topics are not all different.\",\n      \"details\": \"Use a dictionary to count the occurrences of each topic. For each topic with count c, calculate the number of invalid combinations C(c, 3) and C(c, 2) * (n - c).\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where the difficulties are not all different.\",\n      \"details\": \"Use a dictionary to count the occurrences of each difficulty. For each difficulty with count d, calculate the number of invalid combinations C(d, 3) and C(d, 2) * (n - d).\"\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations that meet at least one of the criteria.\",\n      \"details\": \"Subtract the invalid combinations (from both topic and difficulty) from the total combinations to get the valid combinations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"Count the number of invalid combinations where the topics are not all different.\",\n    \"Count the number of invalid combinations where the difficulties are not all different.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic' and 'difficulty'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria are based on these attributes. The goal is to select problems such that either all topics or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems from the list.\n    'different': means that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for counting invalid combinations based on topics and difficulties can be implemented simultaneously using dictionaries to track occurrences. This can be done in a single loop iterating over the problems.\n\n# [edge case] \n    Test case with minimum n = 3:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select all three problems, and they meet both criteria.\n\n    Test case with all problems having the same topic:\n    Input: 3\n           1 2\n           1 3\n           1 4\n    Output: 0\n    Explanation: No valid selection as all topics are the same.\n\n    Test case with all problems having the same difficulty:\n    Input: 3\n           1 1\n           2 1\n           3 1\n    Output: 0\n    Explanation: No valid selection as all difficulties are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations by subtracting invalid ones will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # For each problem, calculate the number of invalid combinations\n            # where this problem is included and the other two have the same topic or difficulty\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"input\": \"Raw input string containing multiple test cases.\",\n      \"output\": \"Structured data containing the number of test cases and a list of problems for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"input\": \"List of problems for a test case.\",\n      \"output\": \"Total number of ways to select any three problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different topics.\",\n      \"input\": \"List of problems for a test case.\",\n      \"output\": \"Number of ways to select three problems with different topics.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different difficulties.\",\n      \"input\": \"List of problems for a test case.\",\n      \"output\": \"Number of ways to select three problems with different difficulties.\"\n    },\n    {\n      \"description\": \"Combine the results from the previous subproblems to determine the number of valid problem sets for each test case.\",\n      \"input\": \"Results from subproblems 2, 3, and 4.\",\n      \"output\": \"Number of valid problem sets for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using combinatorial methods.\",\n    \"For each test case, calculate the number of ways to select three problems with different topics by iterating over the list and using a frequency count of topics.\",\n    \"For each test case, calculate the number of ways to select three problems with different difficulties by iterating over the list and using a frequency count of difficulties.\",\n    \"For each test case, use the inclusion-exclusion principle to combine the results from the previous steps to find the number of valid problem sets.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics' and 'difficulties'\n    Explanation: Each problem has a topic and a difficulty, both represented as integers. The requirement is to select problems such that either all topics or all difficulties are different among the selected problems.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select precisely three problems from the list.\n    'at least one criterion': This means the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the number of ways to select problems with different topics and different difficulties should be considered simultaneously. This is because both calculations are needed to apply the inclusion-exclusion principle effectively.\n\n# [edge case]\n    1. Test case with n = 3, all problems having the same topic and difficulty:\n       Input: 3\n              1 1\n              1 1\n              1 1\n       Expected Output: 0\n       Explanation: All problems have the same topic and difficulty, so no valid selection can be made.\n\n    2. Test case with n = 3, all problems having different topics and difficulties:\n       Input: 3\n              1 2\n              2 3\n              3 1\n       Expected Output: 1\n       Explanation: All problems have different topics and difficulties, so there is exactly one valid selection.\n\n    3. Test case with n = 4, where only one valid selection exists:\n       Input: 4\n              1 1\n              2 2\n              3 3\n              1 2\n       Expected Output: 1\n       Explanation: Only one set of three problems (1, 2, 3) can be selected with different topics and difficulties.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3, as the logic for larger n might not directly apply.\n    ```python\n    if n == 3:\n        # Check if all topics or all difficulties are the same\n        if len(set(topics)) == 1 or len(set(difficulties)) == 1:\n            return 0\n        else:\n            return 1\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topics.values():\n            if count >= 3:\n                same_topic_ways += comb(count, 3)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulties.values():\n            if count >= 3:\n                same_difficulty_ways += comb(count, 3)\n        \n        # Apply inclusion-exclusion principle\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for a_i, b_i in problems:\n            same_topic_ways += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Calculate valid ways using inclusion-exclusion principle\n        valid_ways = total_ways - same_topic_ways\n        \n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of ways to select three problems that meet the criteria for each test case.\",\n      \"steps\": [\n        \"For each test case, generate all possible combinations of three problems from the list of n problems.\",\n        \"Check each combination to see if it satisfies at least one of the criteria: all topics are different or all difficulties are different.\",\n        \"Count the number of combinations that satisfy the criteria.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the number of valid combinations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, iterate over all possible combinations of three problems.\",\n    \"Check each combination against the criteria and count the valid combinations.\",\n    \"Output the count of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic': Refers to the subject or category of a problem, represented by integer a_i.\n    'difficulty': Refers to the level of challenge of a problem, represented by integer b_i.\n    'different': Indicates that the selected problems must have distinct topics or difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': Means that we need to select precisely three problems from the list.\n    'at least one': Means that the selected problems must satisfy at least one of the given criteria (different topics or different difficulties).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented simultaneously when checking combinations:\n    \"Generate all possible combinations of three problems from the list of n problems\",\n    \"Check each combination to see if it satisfies at least one of the criteria: all topics are different or all difficulties are different\",\n    These can be implemented in a single loop that iterates over combinations and checks the criteria using if-else statements.\n\n# [edge case] \n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination is possible, and it satisfies both criteria.\n\n    Test case with all topics and difficulties the same:\n    Input: 3\n           1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: No valid combinations as all topics and difficulties are the same.\n\n    Test case with maximum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems satisfy the criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Consider using sets to track unique topics and difficulties for quick validation.\n    Implement logic to handle cases where n is exactly 3 or where all topics/difficulties are the same.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    # Calculate total combinations of 3 problems\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count occurrences of each topic and difficulty\n    topic_count = defaultdict(int)\n    difficulty_count = defaultdict(int)\n    \n    for a, b in problems:\n        topic_count[a] += 1\n        difficulty_count[b] += 1\n    \n    # Calculate invalid combinations where topics or difficulties are not different\n    invalid_combinations = 0\n    \n    for a, b in problems:\n        # Combinations where the topic is the same\n        invalid_combinations += (topic_count[a] - 1) * (topic_count[a] - 2) // 2\n        # Combinations where the difficulty is the same\n        invalid_combinations += (difficulty_count[b] - 1) * (difficulty_count[b] - 2) // 2\n        # Subtract combinations where both topic and difficulty are the same\n        invalid_combinations -= (topic_count[a] - 1) * (difficulty_count[b] - 1)\n    \n    # Valid combinations are total minus invalid\n    valid_combinations = total_combinations - invalid_combinations\n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        \n        result = count_valid_combinations(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"input\": \"Raw input from standard input\",\n      \"output\": \"Structured data containing test cases with their respective problems\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Total combinations of three problems\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of invalid combinations where either topics or difficulties are not unique.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of invalid combinations\"\n    },\n    {\n      \"description\": \"Subtract the number of invalid combinations from the total combinations to get the valid combinations for each test case.\",\n      \"input\": \"Total combinations and invalid combinations\",\n      \"output\": \"Valid combinations for each test case\"\n    },\n    {\n      \"description\": \"Output the number of valid combinations for each test case.\",\n      \"input\": \"Valid combinations for each test case\",\n      \"output\": \"Formatted output to standard output\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of ways to choose three problems using combinatorial mathematics (n choose 3).\",\n    \"For each test case, identify and count the invalid combinations where either all topics or all difficulties are the same.\",\n    \"Subtract the count of invalid combinations from the total combinations to determine the valid combinations.\",\n    \"Print the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either different topics or different difficulties, or both. This means that when selecting three problems, they should not all share the same topic or difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This indicates that the selection must be of three problems, no more, no less.\n    'number of ways': This refers to calculating the different combinations possible to select the problems.\n    Implementation: Use combinatorial mathematics to calculate combinations, specifically \"n choose 3\" for total combinations.\n\n# [degree adverb]\n    'different': This implies that the selected problems must have distinct topics or difficulties.\n    Implementation: Ensure that the selected problems do not have overlapping topics or difficulties.\n\n# [code logic]\n    The steps for calculating total combinations and invalid combinations should be considered simultaneously.\n    Explanation: While calculating total combinations, invalid combinations should be identified in parallel to optimize the process. This can be done using combinatorial logic and filtering based on topic and difficulty.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected Output: 1\n    Explanation: Only one way to select three problems, and they meet the criteria of different topics and difficulties.\n\n    Test case with all problems having the same topic:\n    Input: 3\n           1 2\n           1 3\n           1 4\n    Expected Output: 0\n    Explanation: No valid combinations as all problems share the same topic.\n\n    Test case with all problems having the same difficulty:\n    Input: 3\n           1 1\n           2 1\n           3 1\n    Expected Output: 0\n    Explanation: No valid combinations as all problems share the same difficulty.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    def calculate_combinations(n, problems):\n        from itertools import combinations\n        valid_combinations = 0\n        for combo in combinations(problems, 3):\n            topics = {p[0] for p in combo}\n            difficulties = {p[1] for p in combo}\n            if len(topics) == 3 or len(difficulties) == ", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Calculate invalid combinations for this problem being part of a set\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Calculate invalid combinations for this problem being part of a set\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read two integers a_i and b_i, representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": [\n        \"Use combinatorial logic to calculate the total number of combinations of three problems from n problems.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of valid combinations that meet the criteria.\",\n      \"details\": [\n        \"For each test case, iterate through all combinations of three problems.\",\n        \"Check if the combination satisfies at least one of the criteria: all topics are different or all difficulties are different.\",\n        \"Count the number of valid combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": [\n        \"Print the number of valid combinations for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems from n problems.\",\n    \"For each test case, iterate through all combinations of three problems and check if they meet the criteria.\",\n    \"Count and store the number of valid combinations for each test case.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic' and 'difficulty'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria are based on these attributes.\n\n    'combinatorial logic'\n    Explanation: This refers to using combinations to calculate the number of ways to select three problems from n problems.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select precisely three problems from the list.\n    'number of ways': This refers to calculating the different combinations possible.\n    Implementation: Use combinatorial functions like combinations from itertools to generate combinations of three problems.\n\n# [degree adverb]\n    'different': This means that the selected problems must have distinct topics or difficulties.\n    Implementation: Check if all topics or all difficulties in a combination are unique using set operations.\n\n# [code logic]\n    The steps for parsing input and calculating combinations can be implemented simultaneously using nested loops or list comprehensions to streamline the process of checking combinations.\n\n# [edge case]\n    Edge Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected Output: 1\n    Explanation: Only one combination is possible, and it meets both criteria.\n    \n    Edge Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected Output: 0\n    Explanation: No combination of three problems can meet the criteria since all combinations will have repeated topics or difficulties.\n    \n    Edge Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected Output: 10\n    Explanation: All combinations of three problems will meet the criteria since all topics and difficulties are unique.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "from sys import stdin, stdout\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "from sys import stdin, stdout\nfrom collections import defaultdict\n\ndef solve():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    stdout.write('\\n'.join(map(str, results)) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different topics.\",\n      \"output\": \"The number of combinations of three problems with different topics.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different difficulties.\",\n      \"output\": \"The number of combinations of three problems with different difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that both conditions (different topics and different difficulties) are satisfied.\",\n      \"output\": \"The number of combinations of three problems with both different topics and different difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, compute the final result by subtracting the invalid combinations (those that do not satisfy either condition) from the total combinations.\",\n      \"output\": \"The number of valid combinations of three problems for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of ways to select any three problems using combinatorial mathematics.\",\n    \"For each test case, use data structures (e.g., dictionaries) to count occurrences of each topic and difficulty.\",\n    \"Calculate the number of combinations with different topics by iterating over the topic counts.\",\n    \"Calculate the number of combinations with different difficulties by iterating over the difficulty counts.\",\n    \"Calculate the number of combinations that satisfy both conditions by considering the intersection of different topics and difficulties.\",\n    \"Subtract the invalid combinations from the total combinations to get the valid combinations for each test case.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either all different topics or all different difficulties, or both. This means that when selecting three problems, they should not share the same topic or difficulty unless they meet the other condition.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means that the selection must consist of three problems, no more, no less.\n    'number of ways': This refers to the different combinations possible to select the problems meeting the criteria.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating combinations with different topics and different difficulties should be considered simultaneously. This is because both calculations are needed to determine the valid combinations, and they can be computed in parallel using similar logic structures (e.g., iterating over counts).\n\n# [edge case] \n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one way to select all three problems, and they meet both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No way to select three problems that meet either condition.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All combinations of three problems meet both conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3, as the logic for larger n might not directly apply.\n    ```python\n    if n == 3:\n        # Directly check if the three problems meet the conditions\n        if len(set(topics)) == 3 or len(set(difficulties)) == 3:\n            return 1\n        else:\n            return 0\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            # If we choose this problem, we can't choose two more with the same topic or difficulty\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that meet the criteria for each test case.\",\n      \"steps\": [\n        \"For each test case, generate all possible combinations of three problems from the list of n problems.\",\n        \"For each combination, check if the topics of the three problems are all different.\",\n        \"Check if the difficulties of the three problems are all different.\",\n        \"Count the combination if it satisfies at least one of the criteria.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the number of valid combinations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, iterate over all combinations of three problems.\",\n    \"Check each combination against the criteria of different topics and different difficulties.\",\n    \"Count and store the number of valid combinations for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics' and 'difficulties'\n    Explanation: Each problem has a unique topic and difficulty, and the task is to select three problems such that either all topics are different or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select combinations of three problems from the list.\n    'at least one criterion': means that a valid selection must satisfy at least one of the two conditions (different topics or different difficulties).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Check if the topics of the three problems are all different\" and \"Check if the difficulties of the three problems are all different\" should be implemented simultaneously. This can be done using a single if-else statement to check both conditions for each combination of problems.\n\n# [edge case] \n    3 problems with the same topic and difficulty = 0\n    Explanation: If all three problems have the same topic and difficulty, they do not satisfy either condition, so the count is 0.\n    \n    3 problems with different topics but same difficulty = 1\n    Explanation: Since the topics are different, this combination is valid, so the count is 1.\n    \n    3 problems with different difficulties but same topic = 1\n    Explanation: Since the difficulties are different, this combination is valid, so the count is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for different topics or difficulties will naturally handle these cases.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef count_valid_combinations(n, problems):\n    # Calculate total combinations of 3 problems\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count occurrences of each topic and difficulty\n    topic_count = defaultdict(int)\n    difficulty_count = defaultdict(int)\n    \n    for a, b in problems:\n        topic_count[a] += 1\n        difficulty_count[b] += 1\n    \n    # Calculate invalid combinations where topics or difficulties are not different\n    invalid_combinations = 0\n    \n    for a, b in problems:\n        # Combinations where topics are not different\n        invalid_combinations += (topic_count[a] - 1) * (topic_count[a] - 2) // 2\n        # Combinations where difficulties are not different\n        invalid_combinations += (difficulty_count[b] - 1) * (difficulty_count[b] - 2) // 2\n    \n    # Subtract invalid combinations from total combinations\n    valid_combinations = total_combinations - invalid_combinations\n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        \n        result = count_valid_combinations(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: count_valid_combinations() missing 1 required positional argument: 'problems'"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef count_valid_combinations(n, problems):\n    # Calculate total combinations of 3 problems\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    \n    # Count occurrences of each topic and difficulty\n    topic_count = defaultdict(int)\n    difficulty_count = defaultdict(int)\n    \n    for a, b in problems:\n        topic_count[a] += 1\n        difficulty_count[b] += 1\n    \n    # Calculate invalid combinations where topics or difficulties are not different\n    invalid_combinations = 0\n    \n    for a, b in problems:\n        # Combinations where topics are not different\n        invalid_combinations += (topic_count[a] - 1) * (topic_count[a] - 2) // 2\n        # Combinations where difficulties are not different\n        invalid_combinations += (difficulty_count[b] - 1) * (difficulty_count[b] - 2) // 2\n    \n    # Subtract invalid combinations from total combinations\n    valid_combinations = total_combinations - invalid_combinations\n    return valid_combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        \n        result = count_valid_combinations(n, problems)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different topics.\",\n      \"output\": \"The number of combinations of three problems with different topics.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different difficulties.\",\n      \"output\": \"The number of combinations of three problems with different difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same topic and the same difficulty.\",\n      \"output\": \"The number of combinations of three problems with the same topic and difficulty.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of valid combinations by subtracting the invalid combinations (same topic and difficulty) from the total combinations and adding the valid combinations (different topics or different difficulties).\",\n      \"output\": \"The number of valid combinations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"Iterate over each test case and extract the list of problems.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"Calculate the number of ways to select three problems with different topics using a counting approach.\",\n    \"Calculate the number of ways to select three problems with different difficulties using a counting approach.\",\n    \"Identify and count any invalid combinations where all three problems have the same topic and difficulty.\",\n    \"Compute the number of valid combinations by adjusting the total combinations with the valid and invalid counts.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics': The selected problems must have unique topics, meaning no two problems can share the same topic.\n    'different difficulties': The selected problems must have unique difficulties, meaning no two problems can share the same difficulty.\n    'combinations': Refers to the different ways to select a subset of problems from the given set.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This means we need to select precisely three problems from the list.\n    'number of ways': This refers to the different possible selections of three problems that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    Steps 3 and 4 should be considered simultaneously because they both involve counting combinations based on different criteria (topics and difficulties). This can be implemented using a single loop that checks both conditions for each combination of problems.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one way to select all three problems, and they meet both criteria.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No way to select three problems that meet either criterion.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All combinations of three problems meet both criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3 or where no valid combinations exist.\n    ```python\n    if n == 3:\n        # Directly check if the only combination meets the criteria\n        if len(set(topics)) == 3 or len(set(difficulties)) == 3:\n            return 1\n        else:\n            return 0\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            # If we choose this problem, we can't choose 2 more problems with the same topic or difficulty\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same topic.\",\n      \"output\": \"The number of combinations where all three problems have the same topic.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same difficulty.\",\n      \"output\": \"The number of combinations where all three problems have the same difficulty.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same topic and difficulty.\",\n      \"output\": \"The number of combinations where all three problems have the same topic and difficulty.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of valid combinations by subtracting invalid combinations from the total combinations.\",\n      \"output\": \"The number of valid combinations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of ways to select any three problems using combinatorial mathematics.\",\n    \"For each test case, count the occurrences of each topic and calculate the number of invalid combinations where all three problems have the same topic.\",\n    \"For each test case, count the occurrences of each difficulty and calculate the number of invalid combinations where all three problems have the same difficulty.\",\n    \"For each test case, calculate the number of invalid combinations where all three problems have the same topic and difficulty.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid combinations for each test case.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either different topics or different difficulties, or both. This means that for a valid selection, the three problems should not share the same topic or difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that we need to select precisely three problems from the given set.\n    'number of ways': This refers to calculating the combinations of selecting three problems that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to calculating invalid combinations based on topics and difficulties should be considered simultaneously. Specifically, steps 3, 4, and 5 can be implemented in a single code block where we calculate invalid combinations for both topics and difficulties, and then subtract them from the total combinations.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected output: 1\n    Explanation: With only three problems, the only valid selection is to choose all three, as they inherently have different topics and difficulties.\n\n    Test case with all problems having the same topic:\n    Input: 3\n           1 2\n           1 3\n           1 4\n    Expected output: 0\n    Explanation: All problems have the same topic, so no valid selection can be made.\n\n    Test case with all problems having the same difficulty:\n    Input: 3\n           1 1\n           2 1\n           3 1\n    Expected output: 0\n    Explanation: All problems have the same difficulty, so no valid selection can be made.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3, and all topics or difficulties are the same.\n    if n == 3:\n        if all problems have the same topic or all have the same difficulty:\n            return 0\n        else:\n            return 1\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations where all three have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid combinations where all three have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations where all three have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid combinations where all three have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems, which is computed using the combination formula C(n, 3).\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all topics are the same.\",\n      \"output\": \"A count of combinations where three problems have the same topic, using a frequency count of topics.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all difficulties are the same.\",\n      \"output\": \"A count of combinations where three problems have the same difficulty, using a frequency count of difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where both topics and difficulties are the same.\",\n      \"output\": \"A count of combinations where three problems have both the same topic and difficulty, which should be zero due to the problem constraints.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of valid combinations by subtracting invalid combinations from the total combinations.\",\n      \"output\": \"The number of valid combinations for each test case, which is the total combinations minus the invalid combinations (same topic and same difficulty).\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of combinations of three problems using the combination formula C(n, 3).\",\n    \"For each test case, count the frequency of each topic and calculate the number of invalid combinations where all three problems have the same topic.\",\n    \"For each test case, count the frequency of each difficulty and calculate the number of invalid combinations where all three problems have the same difficulty.\",\n    \"For each test case, calculate the number of valid combinations by subtracting the invalid combinations (same topic and same difficulty) from the total combinations.\",\n    \"Output\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics': Refers to the category or subject matter of each problem. Each problem has a unique topic identifier.\n    'difficulties': Refers to the level of challenge each problem presents. Each problem has a unique difficulty identifier.\n    'combinations': Refers to the different ways to select a subset of problems from the total set, specifically choosing 3 problems in this context.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': Means that we need to select a subset of 3 problems from the given set.\n    'number of ways': Refers to the different possible selections of 3 problems that meet the criteria.\n\n# [degree adverb]\n    'different': Used to specify that the topics or difficulties of the selected problems must not be the same.\n\n# [code logic]\n    The steps for calculating the total combinations and subtracting invalid combinations should be considered simultaneously. Specifically, the calculation of total combinations and the subtraction of invalid combinations (same topic or same difficulty) should be integrated to ensure the correct number of valid combinations is determined.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one way to select 3 problems, and they all have different topics and difficulties.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No way to select 3 problems where either all topics or all difficulties are different.\n    3. n = 5, problems = [(1, 1), (1, 2), (1, 3), (2, 1), (3, 1)] = 3\n       Explanation: Three ways to select problems with different topics or difficulties: (1, 2, 3), (1, 2, 4), (1, 3, 4).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the logic for counting invalid combinations (same topic or same difficulty) is correctly implemented to handle cases where n is small or where topics/difficulties are highly repetitive.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations where all topics are the same\n        invalid_topic_combinations = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        \n        # Invalid combinations where all difficulties are the same\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract combinations where two problems have the same topic or difficulty\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where the topics are not all different.\",\n      \"details\": \"Use a dictionary to count the occurrences of each topic. For each topic with count c, calculate the number of invalid combinations C(c, 3) and C(c, 2) * (n - c).\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where the difficulties are not all different.\",\n      \"details\": \"Use a dictionary to count the occurrences of each difficulty. For each difficulty with count d, calculate the number of invalid combinations C(d, 3) and C(d, 2) * (n - d).\"\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations that meet at least one of the criteria.\",\n      \"details\": \"Subtract the invalid combinations (from both topic and difficulty) from the total combinations to get the valid combinations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"Count the number of invalid combinations where the topics are not all different.\",\n    \"Count the number of invalid combinations where the difficulties are not all different.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic' and 'difficulty'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria are based on these attributes. The goal is to select problems such that either all topics or all difficulties are different.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems from the list.\n    'different': means that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for counting invalid combinations based on topics and difficulties can be implemented simultaneously using dictionaries to track occurrences. This can be done in a single loop iterating over the problems.\n\n# [edge case] \n    Test case with minimum n = 3:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select all three problems, and they meet both criteria.\n\n    Test case with all problems having the same topic:\n    Input: 3\n           1 2\n           1 3\n           1 4\n    Output: 0\n    Explanation: No valid selection as all topics are the same.\n\n    Test case with all problems having the same difficulty:\n    Input: 3\n           1 1\n           2 1\n           3 1\n    Output: 0\n    Explanation: No valid selection as all difficulties are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations by subtracting invalid ones will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # For each problem, calculate the number of invalid combinations\n            # where this problem is included and the other two have the same topic or difficulty\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, true, false, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 184, "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems must meet at least one criterion. It should satisfy either one of two conditions or both:\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 111}
