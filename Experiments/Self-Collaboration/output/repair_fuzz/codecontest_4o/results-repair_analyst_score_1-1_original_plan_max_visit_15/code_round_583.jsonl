{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'), representing the board configuration. Ensure that both n and m are positive integers. Your task is to interpret this board and perform specified operations based on the character directions.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'), representing the board configuration. Make sure that n is a positive integer. Also verify that m is a positive integer. Your task is to interpret this board and perform specified operations based on the character directions.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'), representing the board configuration. Ensure that both n and m are positive integers, and your task is to interpret this board and perform specified operations based on the character directions.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def is_within_bounds(r, c):\n        return 0 <= r < n and 0 <= c < m\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            visited = set()\n            current_r, current_c = r, c\n            moves = 0\n\n            while (current_r, current_c) not in visited:\n                visited.add((current_r, current_c))\n                moves += 1\n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                next_r, next_c = current_r + dr, current_c + dc\n\n                if not is_within_bounds(next_r, next_c):\n                    break\n\n                current_r, current_c = next_r, next_c\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    # Function to simulate moves from a given starting position\n    def count_moves(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n        \n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return moves\n    \n    # Iterate over each cell in the board\n    for r in range(n):\n        for c in range(m):\n            moves = count_moves(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Simulate and get the result\n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while 0 <= r < n and 0 <= c < m and (r, c) not in visited:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while True:\n        if (r, c) in visited or r < 0 or r >= n or c < 0 or c >= m:\n            break\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Iterate over each cell to find the best starting point\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Initialize variables to track the maximum number of moves and the starting position\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        # Iterate over each cell on the board\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        # Store the result for this test case\n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Output all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate movement from a starting point\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for i in range(n):\n            for j in range(m):\n                moves = simulate(i, j)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = i + 1, j + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    # Directions mapping\n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n    \n    return moves\n\ndef find_max_moves_for_test_case(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves_for_test_case(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot_movement(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r, c = r + dr, c + dc\n            moves += 1\n        return moves\n\n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n\n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1  # Skip blank lines\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate moves from a starting position\n        def simulate_moves(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for r in range(n):\n            for c in range(m):\n                moves = simulate_moves(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def is_within_bounds(r, c):\n        return 0 <= r < n and 0 <= c < m\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            visited = set()\n            current_r, current_c = r, c\n            moves = 0\n\n            while (current_r, current_c) not in visited:\n                visited.add((current_r, current_c))\n                moves += 1\n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                next_r, next_c = current_r + dr, current_c + dc\n\n                if not is_within_bounds(next_r, next_c):\n                    break\n\n                current_r, current_c = next_r, next_c\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration itself.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters, to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement on the board starting from each cell to determine the maximum number of moves possible.\",\n      \"steps\": [\n        \"For each cell (r, c) on the board, simulate the movement based on the character directions ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made until a cycle is detected or the edge of the board is reached.\",\n        \"Store the starting cell and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows for the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves from each starting cell.\",\n        \"Identify the cell (r, c) that results in the maximum number of moves d.\",\n        \"If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row r, column c, and the maximum number of moves d.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over each cell on the board and simulate the movement to determine the number of moves possible.\",\n    \"Track the maximum number of moves and the corresponding starting cell for each test case.\",\n    \"Output the starting cell and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the grid of characters ('L', 'R', 'D', 'U') that dictate movement directions on the board.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves that can be made starting from any cell on the board before reaching an edge or entering a cycle.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the highest possible count of moves from a starting cell.\n    Implementation: Use a loop to simulate moves from each cell and track the count, updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest number of moves possible.\n    Implementation: Use a variable to keep track of the maximum number of moves and update it whenever a new maximum is found.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement on the board starting from each cell to determine the maximum number of moves possible\" should be implemented simultaneously. Specifically, simulating the movement, tracking moves, and storing results should be done in a single loop over the board cells.\n\n# [edge case]\n    Test case with a single cell board: \n    Input: 1 1 R\n    Output: 1 1 1\n    Explanation: The only move possible is from the single cell itself.\n\n    Test case with all cells pointing to the edge:\n    Input: 2 2 RR DD\n    Output: 1 1 2\n    Explanation: Starting from (1,1), the moves are (1,1) -> (1,2) -> (1,3) (out of bounds).\n\n    Test case with a cycle:\n    Input: 2 2 LR RL\n    Output: 1 1 4\n    Explanation: Starting from (1,1), the moves are (1,1) -> (1,2) -> (2,2) -> (2,1) -> (1,1), forming a cycle.\n\n# [extra code for edge case]\n    We need extra code to handle cycles and ensure that the simulation stops when a cycle is detected.\n    ```\n    def simulate_moves(board, n, m):\n        visited = set()\n        max_moves = 0\n        start_cell = (1, 1)\n        \n        for r in range(n):\n            for c in range(m):\n                current_r, current", "Round_0": {"code": "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def is_within_bounds(r, c):\n        return 0 <= r < n and 0 <= c < m\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            visited = set()\n            current_r, current_c = r, c\n            moves = 0\n\n            while (current_r, current_c) not in visited:\n                visited.add((current_r, current_c))\n                moves += 1\n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                next_r, next_c = current_r + dr, current_c + dc\n\n                if not is_within_bounds(next_r, next_c):\n                    break\n\n                current_r, current_c = next_r, next_c\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_moves() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def is_within_bounds(r, c):\n        return 0 <= r < n and 0 <= c < m\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            visited = set()\n            current_r, current_c = r, c\n            moves = 0\n\n            while (current_r, current_c) not in visited:\n                visited.add((current_r, current_c))\n                moves += 1\n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                next_r, next_c = current_r + dr, current_c + dc\n\n                if not is_within_bounds(next_r, next_c):\n                    break\n\n                current_r, current_c = next_r, next_c\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure n and m are positive integers and the board configuration matches the specified dimensions.\",\n      \"steps\": [\n        \"Check that n and m are within the specified range (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000).\",\n        \"Ensure that each line of the board contains exactly m characters.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the logic to interpret the board and determine the starting position and maximum number of moves.\",\n      \"steps\": [\n        \"For each cell in the board, simulate the movement of a robot according to the direction specified by the character ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made from each starting position.\",\n        \"Determine the starting position (r, c) that results in the maximum number of moves d.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output three integers r, c, and d, representing the starting position and maximum number of moves.\",\n        \"Ensure the output format matches the requirement, with each test case result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Validate the input dimensions and board structure.\",\n    \"Simulate robot movements on the board to find the optimal starting position.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves without leaving the board.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by simulating movements from each position and keeping track of the number of moves, updating the maximum as needed.\n\n# [degree adverb] \n    'maximum': This means the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by comparing the number of moves from each starting position and selecting the one with the highest count.\n\n# [code logic]\n    The steps in the subproblem \"Implement the logic to interpret the board and determine the starting position and maximum number of moves\" should be considered simultaneously. Specifically, simulating the robot's movement and tracking the number of moves should be done in a single loop or function to efficiently determine the optimal starting position.\n\n# [edge case] \n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move in any direction.\n\n    Test case with all same direction:\n    2 2\n    RR\n    RR\n    Expected output: 1 1 4\n    Explanation: The robot can move continuously in the right direction, making 4 moves.\n\n    Test case with no valid moves:\n    1 1\n    U\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move upwards, but it will immediately leave the board.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the board is very small or the directions lead to immediate exits. This can be handled by ensuring the simulation correctly accounts for board boundaries and updates the move count accordingly.\n\n    Example code for handling edge cases:\n    ```python\n    def simulate_moves(board, n, m):\n        max_moves = 0\n        start_position = (1, 1)\n        for r", "Round_0": {"code": "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    # Function to simulate moves from a given starting position\n    def count_moves(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n        \n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return moves\n    \n    # Iterate over each cell in the board\n    for r in range(n):\n        for c in range(m):\n            moves = count_moves(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Simulate and get the result\n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_moves() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    # Function to simulate moves from a given starting position\n    def count_moves(start_r, start_c):\n        visited = set()\n        r, c = start_r, start_c\n        moves = 0\n        \n        while (r, c) not in visited:\n            visited.add((r, c))\n            moves += 1\n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r, c = r + dr, c + dc\n            \n            if r < 0 or r >= n or c < 0 or c >= m:\n                break\n        \n        return moves\n    \n    # Iterate over each cell in the board\n    for r in range(n):\n        for c in range(m):\n            moves = count_moves(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Simulate and get the result\n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t, then for each test case, read integers n and m, followed by n lines of m characters each.\"\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration matches the specified dimensions.\",\n      \"details\": \"Check that each board has exactly n lines and each line has exactly m characters consisting only of 'L', 'R', 'D', 'U'.\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board starting from each cell to determine the number of moves possible.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the robot's movement according to the direction characters until it either leaves the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of moves for each test case.\",\n      \"details\": \"Track the number of moves for each starting cell and identify the cell with the maximum moves. If there are multiple, any can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": \"For each test case, output the row, column, and maximum number of moves as three integers.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read integers n and m, then read the n lines of the board.\",\n    \"  b. Validate the board dimensions and characters.\",\n    \"  c. Initialize a variable to track the maximum number of moves and the corresponding starting cell.\",\n    \"  d. For each cell (r, c) on the board, simulate the robot's movement:\",\n    \"     i. Follow the direction characters until the robot leaves the board or revisits a cell.\",\n    \"     ii. Count the number of moves made.\",\n    \"     iii. Update the maximum moves and starting cell if the current count is greater.\",\n    \"  e. Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board is represented by a grid of n rows and m columns, where each cell contains a character ('L', 'R', 'D', 'U') indicating a direction for movement.\n\n    'maximum number of moves'\n    Explanation: The task is to determine the starting position on the board that allows the robot to make the most moves before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means we need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by keeping track of the move count for each starting position and updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This indicates that we are looking for the highest possible number of moves. In code, this can be implemented by comparing the current move count with the stored maximum and updating it if the current count is higher.\n\n# [code logic]\n    The steps related to simulating the robot's movement and determining the maximum number of moves should be implemented simultaneously. Specifically, steps 3 and 4 in the subproblems can be combined into a single loop that iterates over each cell, simulates the movement, and updates the maximum move count and starting position.\n\n# [edge case]\n    1 1\n    L\n    = 1 1 1\n    Explanation: With a single cell containing 'L', the robot can only make one move before exiting the board.\n\n    2 2\n    LL\n    LL\n    = 1 1 2\n    Explanation: Starting from (1, 1), the robot can move right to (1, 2) and then exit the board, making two moves.\n\n    2 2\n    LR\n    RL\n    = 1 1 1\n    Explanation: Any starting position results in the robot revisiting a cell immediately, so the maximum number of moves is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking the maximum number of moves will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while 0 <= r < n and 0 <= c < m and (r, c) not in visited:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 157)"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while 0 <= r < n and 0 <= c < m and (r, c) not in visited:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t, followed by t test cases. For each test case, read integers n and m, then read n lines each containing m characters ('L', 'R', 'D', 'U').\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board based on the direction characters.\",\n      \"details\": \"For each starting position on the board, simulate the robot's movement according to the direction characters until it either leaves the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Determine the starting position that allows the robot to make the maximum number of moves.\",\n      \"details\": \"Track the number of moves for each starting position and identify the position with the maximum moves. If there are multiple positions with the same number of moves, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the row, column, and maximum number of moves for the optimal starting position.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a loop to process each test case.\",\n    \"For each test case, parse the input to get the board dimensions and configuration.\",\n    \"Initialize a data structure to track the number of moves from each starting position.\",\n    \"Iterate over each cell in the board as a potential starting position.\",\n    \"Simulate the robot's movement from the current starting position, counting the number of moves until the robot exits the board or revisits a cell.\",\n    \"Update the maximum moves and corresponding starting position if the current simulation yields more moves.\",\n    \"After processing all starting positions, store the result for the test case.\",\n    \"Output the results for all test cases in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the setup of the board with n strings each containing m characters ('L', 'R', 'D', 'U'), which dictate the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the starting position that results in the highest count of moves. In code, this can be implemented by tracking the number of moves for each starting position and updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by comparing move counts and updating the maximum value accordingly.\n\n# [code logic]\n    The steps related to simulating the robot's movement and updating the maximum moves should be considered simultaneously. Specifically:\n    - \"Simulate the robot's movement from the current starting position, counting the number of moves until the robot exits the board or revisits a cell.\"\n    - \"Update the maximum moves and corresponding starting position if the current simulation yields more moves.\"\n    These can be implemented in a single loop where the simulation and update occur together.\n\n# [edge case]\n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move before exiting the board.\n\n    Test case with all directions leading out:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 1\n    Explanation: Any starting position leads the robot out of the board in one move.\n\n    Test case with revisiting cells:\n    2 2\n    RR\n    LL\n    Expected output: 1 1 2\n    Explanation: Starting at (1,1), the robot moves right to (1,2) and then right again, revisiting (1,1).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits cells or exits the board immediately.\n    - Implement a visited set to track cells the robot has visited.\n    - Check if the robot revisits a cell or exits the board in the simulation loop", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while True:\n        if (r, c) in visited or r < 0 or r >= n or c < 0 or c >= m:\n            break\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while True:\n        if (r, c) in visited or r < 0 or r >= n or c < 0 or c >= m:\n            break\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"details\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, representing the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure that n and m are positive integers and that the board configuration adheres to the specified constraints.\",\n      \"details\": [\n        \"Check that 1 \u2264 n \u2264 2000 and 1 \u2264 m \u2264 2000.\",\n        \"Ensure that the sum of sizes of all boards does not exceed 4\u22c510^6.\"\n      ]\n    },\n    {\n      \"description\": \"Develop an algorithm to determine the starting position (r, c) and the maximum number of moves (d) for each test case.\",\n      \"details\": [\n        \"For each cell in the board, simulate the movement of a robot according to the direction specified by the characters ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made from each starting position.\",\n        \"Identify the starting position that results in the maximum number of moves.\",\n        \"If multiple starting positions yield the same maximum number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": [\n        \"For each test case, output three integers r, c, and d, where (r, c) is the starting position and d is the maximum number of moves.\",\n        \"Ensure the output format matches the example provided.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"Validate the input to ensure it meets the specified constraints.\",\n    \"For each test case, iterate over each cell in the board to simulate robot movements and calculate the number of moves.\",\n    \"Determine the starting position that results in the maximum number of moves for each test case.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the grid of characters ('L', 'R', 'D', 'U') that dictate the movement directions on the board.\n\n    'maximum number of moves'\n    Explanation: This refers to the highest number of moves a robot can make starting from any cell on the board, following the directions given by the characters.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the largest possible count of moves a robot can make from a starting position on the board.\n    Implementation: This can be implemented by simulating the robot's movement from each cell and counting the moves until it can no longer move.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible value of moves.\n    Implementation: Use a variable to track the maximum number of moves found during the simulation and update it whenever a higher value is encountered.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the number of moves should be implemented simultaneously. Specifically, the simulation of movement and counting of moves should occur in the same loop to efficiently determine the maximum number of moves from each starting position.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, board = ['L'] -> Output: 1 1 1\n    Explanation: With only one cell, the robot can make only one move.\n\n    Edge Case 2: n = 2, m = 2, board = ['LR', 'UD'] -> Output: 1 1 4\n    Explanation: The robot can move in a loop starting from (1, 1), making 4 moves.\n\n    Edge Case 3: n = 3, m = 3, board = ['RRD', 'LLU', 'UUR'] -> Output: 1 1 9\n    Explanation: The robot can move through all cells starting from (1, 1), making 9 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement from each cell and tracking the maximum number of moves will naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate the robot movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Iterate over each cell to find the best starting point\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board based on the direction characters and determine the starting position that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of moves and the corresponding starting position.\",\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction characters.\",\n        \"Track the number of moves made from each starting position and update the maximum moves and starting position if a new maximum is found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the requirement: three integers separated by spaces.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over each cell on the board and simulate the robot's movement to determine the maximum number of moves possible from any starting position.\",\n    \"Track the starting position that results in the maximum number of moves.\",\n    \"Output the starting position and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration is a grid of n strings each containing m characters ('L', 'R', 'D', 'U') that represent directions for movement.\n\n    'maximum number of moves'\n    Explanation: This refers to the highest number of moves a robot can make starting from any cell on the board following the direction characters.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by tracking the number of moves from each starting position and updating the maximum if a new higher count is found.\n\n# [degree adverb]\n    'maximum': This means the highest possible number of moves. In code, this can be implemented by comparing move counts and updating the maximum value accordingly.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the maximum number of moves should be implemented simultaneously. Specifically:\n    - \"Initialize variables to track the maximum number of moves and the corresponding starting position.\"\n    - \"For each cell (r, c) on the board, simulate the robot's movement according to the direction characters.\"\n    - \"Track the number of moves made from each starting position and update the maximum moves and starting position if a new maximum is found.\"\n    These steps can be implemented in a single loop that iterates over each cell, simulates movement, and updates the maximum moves and position.\n\n# [edge case]\n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move starting from the single cell.\n\n    Test case with all same direction:\n    2 2\n    RR\n    RR\n    Expected output: 1 1 4\n    Explanation: The robot can move continuously in the right direction, making 4 moves starting from the top-left corner.\n\n    Test case with no valid moves:\n    2 2\n    UU\n    UU\n    Expected output: 1 1 0\n    Explanation: The robot cannot move as all directions lead out of bounds immediately.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot cannot move or the board is very small.\n    - Check if the board is 1", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Initialize variables to track the maximum number of moves and the starting position\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        # Iterate over each cell on the board\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        # Store the result for this test case\n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Output all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: main() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Initialize variables to track the maximum number of moves and the starting position\n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Function to simulate the robot's movement\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        # Iterate over each cell on the board\n        for r in range(n):\n            for c in range(m):\n                moves = simulate(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        # Store the result for this test case\n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Output all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration itself.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters, to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement on the board starting from each cell to determine the maximum number of moves possible.\",\n      \"steps\": [\n        \"For each cell (i, j) on the board, simulate the movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made until a cycle is detected or the edge of the board is reached.\",\n        \"Store the starting cell and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows for the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves from each starting cell.\",\n        \"Identify the cell (r, c) that results in the maximum number of moves d.\",\n        \"If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting cell and the maximum number of moves.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over each cell on the board and simulate the movement to calculate the number of moves possible.\",\n    \"Track the maximum number of moves and the corresponding starting cell for each test case.\",\n    \"Output the starting cell and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the grid of characters ('L', 'R', 'D', 'U') that dictate the movement directions on the board. Each character represents a direction: 'L' for left, 'R' for right, 'D' for down, and 'U' for up.\n\n    'maximum number of moves'\n    Explanation: This refers to the highest number of moves that can be made starting from a specific cell on the board before reaching the edge of the board or entering a cycle.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the highest possible count of moves from a starting cell. In code, this can be implemented by keeping a counter for moves and updating a maximum variable whenever a higher count is found.\n\n# [degree adverb] \n    'maximum': This indicates the need to find the largest possible value of moves. In code, this can be implemented by comparing current move counts and updating the maximum value accordingly.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement on the board starting from each cell to determine the maximum number of moves possible\" should be implemented simultaneously. Specifically, simulating the movement, tracking moves, and storing results should be done in a single loop over the board cells to efficiently determine the maximum moves from each starting point.\n\n# [edge case] \n    Edge Case 1: A board with only one cell, e.g., n = 1, m = 1, board = ['R']\n    Expected Output: 1 1 1\n    Explanation: The only move possible is from the single cell itself, resulting in one move.\n\n    Edge Case 2: A board where all cells point to themselves, e.g., n = 2, m = 2, board = ['LL', 'UU']\n    Expected Output: 1 1 1\n    Explanation: Each cell points to itself, resulting in a cycle of one move.\n\n    Edge Case 3: A board with a clear path to the edge, e.g., n = 2, m = 2, board = ['RR', 'DD']\n    Expected Output: 1 1 2\n    Explanation: Starting from (1,1), the path is right to (1,2) and then out of bounds, resulting in two moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    # Direction vectors for 'L', 'R', 'D', 'U'\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'D': (1, 0),\n        'U': (-1, 0)\n    }\n    \n    for _ in range(t):\n        # Skip the blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate movement from a starting point\n        def simulate(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for i in range(n):\n            for j in range(m):\n                moves = simulate(i, j)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = i + 1, j + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board based on the character directions and calculate the number of moves.\",\n      \"steps\": [\n        \"Initialize a starting position (r, c) for the robot on the board.\",\n        \"Based on the character at the current position, move the robot in the specified direction ('L', 'R', 'D', 'U').\",\n        \"Keep track of the number of moves made by the robot.\",\n        \"Ensure the robot stays within the bounds of the board.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position (r, c) that results in the maximum number of moves d for each test case.\",\n      \"steps\": [\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the robot's movement and calculate the number of moves.\",\n        \"Compare the number of moves for each starting position and keep track of the maximum number of moves.\",\n        \"Select any starting position that results in the maximum number of moves.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the requirement: three integers separated by spaces.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board configurations.\",\n    \"For each test case, simulate the robot's movement from all possible starting positions.\",\n    \"Calculate the number of moves for each starting position and determine the maximum.\",\n    \"Output the starting position and maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board is represented by a grid of characters ('L', 'R', 'D', 'U') that dictate the movement directions for a robot. Each character represents a direction: 'L' for left, 'R' for right, 'D' for down, and 'U' for up.\n\n    'maximum number of moves'\n    Explanation: The task is to determine the starting position on the board that allows the robot to make the most moves without leaving the board.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the starting position that results in the highest possible count of moves the robot can make on the board.\n    Implementation: This involves iterating over all possible starting positions and simulating the robot's movement to count the moves, then comparing these counts to find the maximum.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest number of moves possible from any starting position.\n    Implementation: Use a variable to keep track of the highest move count encountered during the simulation of all starting positions.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board based on the character directions and calculate the number of moves\" should be implemented simultaneously. Specifically, initializing the starting position, moving the robot based on the current character, and keeping track of the number of moves should be done in a single loop or function to ensure the robot's movement is accurately simulated.\n\n# [edge case]\n    1 1\n    L\n    = 1 1 1\n    Explanation: With a single cell board, the robot can only make one move regardless of the direction, as it will immediately be out of bounds.\n\n    2 2\n    LL\n    LL\n    = 1 1 1\n    Explanation: Starting from any position, the robot will move left and immediately be out of bounds, resulting in only one move.\n\n    3 3\n    RRR\n    RRR\n    RRR\n    = 1 1 3\n    Explanation: Starting from the first row, the robot can move right three times before going out of bounds.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the board size is minimal or the directions immediately lead out of bounds.\n    ```python\n    if n == 1 and m == 1:\n        print", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    # Directions mapping\n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n    \n    return moves\n\ndef find_max_moves_for_test_case(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves_for_test_case(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_max_moves_for_test_case() missing 3 required positional arguments: 'n', 'm', and 'board'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    # Directions mapping\n    directions = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n    \n    return moves\n\ndef find_max_moves_for_test_case(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip the blank line\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves_for_test_case(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board based on the direction characters and determine the starting position that results in the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of moves and the corresponding starting position.\",\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction characters ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made from each starting position and update the maximum if a longer sequence is found.\",\n        \"Handle edge cases where the robot moves out of bounds and stop the simulation for that path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case, including the starting position and the maximum number of moves.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, where (r, c) is the starting position and d is the maximum number of moves.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over each cell on the board and simulate the robot's movement to determine the maximum number of moves.\",\n    \"Track the starting position that results in the maximum number of moves and store the result.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board configuration refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This refers to the longest sequence of moves the robot can make starting from a specific cell on the board without going out of bounds.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the longest possible sequence of moves from a starting position on the board. In code, this can be implemented by simulating the robot's movement from each cell and tracking the number of moves until it goes out of bounds or repeats.\n\n# [degree adverb]\n    'maximum': This means finding the largest possible number of moves the robot can make from a starting position. In code, this involves comparing the number of moves from different starting positions and updating the maximum value accordingly.\n\n# [code logic]\n    The steps in the second subproblem should be implemented simultaneously:\n    - \"Initialize variables to track the maximum number of moves and the corresponding starting position.\"\n    - \"For each cell (r, c) on the board, simulate the robot's movement according to the direction characters ('L', 'R', 'D', 'U').\"\n    - \"Track the number of moves made from each starting position and update the maximum if a longer sequence is found.\"\n    These steps can be implemented in a single loop that iterates over each cell, simulates the movement, and updates the maximum moves and starting position.\n\n# [edge case]\n    Test case with a single cell board: \n    Input: 1 1 R\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move from the single cell.\n\n    Test case with all directions leading out of bounds:\n    Input: 2 2 LU\n           RD\n    Expected output: 1 1 1\n    Explanation: Any starting position results in only one move before going out of bounds.\n\n    Test case with a board where all moves are possible:\n    Input: 3 3 RRR\n           DDD\n           LLL\n    Expected output: 1 1 9\n    Explanation: Starting from (1,1), the robot can move through all cells without going out of bounds.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the", "Round_0": {"code": "def simulate_robot_movement(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r, c = r + dr, c + dc\n            moves += 1\n        return moves\n\n    max_moves = 0\n    start_position = (1, 1)\n    \n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n\n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1  # Skip blank lines\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_robot_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the input to ensure n and m are positive integers and the board configuration matches the specified dimensions.\",\n      \"steps\": [\n        \"Check that n and m are within the specified range (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000).\",\n        \"Ensure each line of the board contains exactly m characters.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"steps\": [\n        \"For each cell (r, c) on the board, simulate the robot's movement based on the direction characters ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made from each starting position.\",\n        \"Determine the starting position (r, c) that results in the maximum number of moves d.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Validate the input dimensions and board configuration.\",\n    \"Simulate robot movements to find the optimal starting position for maximum moves.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the setup of the board using the characters 'L', 'R', 'D', 'U', which dictate the directions of movement.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves without leaving the board.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible count of moves the robot can make from a starting position. In code, this can be implemented by iterating through all possible starting positions and simulating the moves to find the maximum.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves. In code, this can be implemented by keeping track of the highest move count encountered during the simulation.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the number of moves should be implemented simultaneously. Specifically:\n    - \"For each cell (r, c) on the board, simulate the robot's movement based on the direction characters ('L', 'R', 'D', 'U').\"\n    - \"Track the number of moves made from each starting position.\"\n    These can be implemented in a single loop that iterates over each cell and simulates the movement while counting the moves.\n\n# [edge case]\n    Test case with smallest board: \n    Input: 1 1 \\n L\n    Expected output: 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move.\n\n    Test case with all directions leading out of bounds:\n    Input: 2 2 \\n LR \\n UD\n    Expected output: 1 1 1\n    Explanation: Starting from any position, the robot will immediately move out of bounds, resulting in only one move.\n\n    Test case with maximum board size:\n    Input: 2000 2000 \\n (board filled with 'R')\n    Expected output: 1 1 2000\n    Explanation: Starting from the top-left corner, the robot can move right across the entire row.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot might move out of bounds immediately. This can be handled by checking the bounds during the simulation of moves.\n    Example code for handling out-of-bounds:\n    ```python\n", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate moves from a starting position\n        def simulate_moves(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for r in range(n):\n            for c in range(m):\n                moves = simulate_moves(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 163)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for _ in range(t):\n        # Read a blank line between test cases\n        if data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Function to simulate moves from a starting position\n        def simulate_moves(r, c):\n            visited = set()\n            moves = 0\n            while (r, c) not in visited:\n                visited.add((r, c))\n                moves += 1\n                direction = board[r][c]\n                dr, dc = direction_map[direction]\n                r, c = r + dr, c + dc\n                if r < 0 or r >= n or c < 0 or c >= m:\n                    break\n            return moves\n        \n        max_moves = 0\n        best_r, best_c = 1, 1\n        \n        # Try starting from each cell\n        for r in range(n):\n            for c in range(m):\n                moves = simulate_moves(r, c)\n                if moves > max_moves:\n                    max_moves = moves\n                    best_r, best_c = r + 1, c + 1\n        \n        results.append(f\"{best_r} {best_c} {max_moves}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration itself.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters, to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement on the board starting from each cell to determine the maximum number of moves possible.\",\n      \"steps\": [\n        \"For each cell (r, c) on the board, simulate the movement based on the character directions ('L', 'R', 'D', 'U').\",\n        \"Track the number of moves made until a cycle is detected or the edge of the board is reached.\",\n        \"Store the starting cell and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting cell that allows for the maximum number of moves.\",\n      \"steps\": [\n        \"Compare the number of moves from each starting cell.\",\n        \"Identify the cell (r, c) that results in the maximum number of moves d.\",\n        \"If there are multiple cells with the same maximum number of moves, any of them can be chosen.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row r, column c, and the maximum number of moves d.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over each cell on the board and simulate the movement to determine the number of moves possible.\",\n    \"Track the maximum number of moves and the corresponding starting cell for each test case.\",\n    \"Output the starting cell and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the grid of characters ('L', 'R', 'D', 'U') that dictate movement directions on the board.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves that can be made starting from any cell on the board before reaching an edge or entering a cycle.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the highest possible count of moves from a starting cell.\n    Implementation: Use a loop to simulate moves from each cell and track the count, updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest number of moves possible.\n    Implementation: Use a variable to keep track of the maximum number of moves and update it whenever a new maximum is found.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement on the board starting from each cell to determine the maximum number of moves possible\" should be implemented simultaneously. Specifically, simulating the movement, tracking moves, and storing results should be done in a single loop over the board cells.\n\n# [edge case]\n    Test case with a single cell board: \n    Input: 1 1 R\n    Output: 1 1 1\n    Explanation: The only move possible is from the single cell itself.\n\n    Test case with all cells pointing to the edge:\n    Input: 2 2 RR DD\n    Output: 1 1 2\n    Explanation: Starting from (1,1), the moves are (1,1) -> (1,2) -> (1,3) (out of bounds).\n\n    Test case with a cycle:\n    Input: 2 2 LR RL\n    Output: 1 1 4\n    Explanation: Starting from (1,1), the moves are (1,1) -> (1,2) -> (2,2) -> (2,1) -> (1,1), forming a cycle.\n\n# [extra code for edge case]\n    We need extra code to handle cycles and ensure that the simulation stops when a cycle is detected.\n    ```\n    def simulate_moves(board, n, m):\n        visited = set()\n        max_moves = 0\n        start_cell = (1, 1)\n        \n        for r in range(n):\n            for c in range(m):\n                current_r, current", "Round_0": {"code": "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def is_within_bounds(r, c):\n        return 0 <= r < n and 0 <= c < m\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            visited = set()\n            current_r, current_c = r, c\n            moves = 0\n\n            while (current_r, current_c) not in visited:\n                visited.add((current_r, current_c))\n                moves += 1\n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                next_r, next_c = current_r + dr, current_c + dc\n\n                if not is_within_bounds(next_r, next_c):\n                    break\n\n                current_r, current_c = next_r, next_c\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_moves() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_moves(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    def is_within_bounds(r, c):\n        return 0 <= r < n and 0 <= c < m\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for r in range(n):\n        for c in range(m):\n            visited = set()\n            current_r, current_c = r, c\n            moves = 0\n\n            while (current_r, current_c) not in visited:\n                visited.add((current_r, current_c))\n                moves += 1\n                direction = board[current_r][current_c]\n                dr, dc = direction_map[direction]\n                next_r, next_c = current_r + dr, current_c + dc\n\n                if not is_within_bounds(next_r, next_c):\n                    break\n\n                current_r, current_c = next_r, next_c\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        if data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = simulate_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 583, "prompt": "The input should consist of an integer n and an integer m, followed by a sequence of n strings each containing m characters ('L', 'R', 'D', 'U'), representing the board configuration. Ensure that both n and m are positive integers. Your task is to interpret this board and perform specified operations based on the character directions.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 319}
