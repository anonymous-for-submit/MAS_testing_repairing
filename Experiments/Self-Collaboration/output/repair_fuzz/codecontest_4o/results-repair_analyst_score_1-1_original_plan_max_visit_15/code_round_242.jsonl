{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). Every problem is unique in nature. In other words, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). The problem also has a difficulty b_i (an integer from 1 to n). Every problem is unique in nature. In other words, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has n problems that none of his students have seen yet, with the i-th problem having a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n); every problem is unique in nature, meaning there are no two tasks with the same topic and difficulty simultaneously. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different;\n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a, b in problems:\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                same_topic_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                same_difficulty_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Valid ways\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract invalid combinations where topics or difficulties are not all different\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to select 3 problems\n        total_ways = comb(n, 3)\n        \n        # Calculate invalid selections\n        invalid_topic_selections = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        invalid_difficulty_selections = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid selections\n        valid_selections = total_ways - invalid_topic_selections - invalid_difficulty_selections\n        \n        results.append(valid_selections)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = {}\n        difficulties = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            \n            problems.append((a, b))\n            \n            if a not in topics:\n                topics[a] = 0\n            if b not in difficulties:\n                difficulties[b] = 0\n            \n            topics[a] += 1\n            difficulties[b] += 1\n        \n        # Total ways to choose 3 problems from n\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid ways\n        invalid_ways = 0\n        \n        for a, b in problems:\n            # If we fix one problem, the remaining two must not have the same topic or difficulty\n            invalid_ways += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        # Valid ways are total ways minus invalid ways\n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            invalid_topic_combinations += calculate_combinations(count)\n        \n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            invalid_difficulty_combinations += calculate_combinations(count)\n        \n        # Adjust for over-counting where both topic and difficulty are not different\n        invalid_both_combinations = 0\n        for a_i, b_i in problems:\n            invalid_both_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_both_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i in topic_count:\n                topic_count[a_i] += 1\n            else:\n                topic_count[a_i] = 1\n            \n            if b_i in difficulty_count:\n                difficulty_count[b_i] += 1\n            else:\n                difficulty_count[b_i] = 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            f_topic = topic_count[a_i]\n            f_difficulty = difficulty_count[b_i]\n            \n            # Subtract invalid combinations for this specific problem\n            invalid_combinations += (f_topic - 1) * (f_difficulty - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract invalid combinations for this specific problem\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i in topic_count:\n                topic_count[a_i] += 1\n            else:\n                topic_count[a_i] = 1\n            \n            if b_i in difficulty_count:\n                difficulty_count[b_i] += 1\n            else:\n                difficulty_count[b_i] = 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid ways based on topics\n        invalid_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_ways += count * (count - 1) * (count - 2) // 6\n            if count >= 2:\n                invalid_topic_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Calculate invalid ways based on difficulties\n        invalid_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_ways += count * (count - 1) * (count - 2) // 6\n            if count >= 2:\n                invalid_difficulty_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Calculate valid ways\n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations where topics are not all different\n        invalid_topic_combinations = 0\n        for count in topics.values():\n            if count >= 2:\n                invalid_topic_combinations += comb(count, 2) * (n - count)\n        \n        # Invalid combinations where difficulties are not all different\n        invalid_difficulty_combinations = 0\n        for count in difficulties.values():\n            if count >= 2:\n                invalid_difficulty_combinations += comb(count, 2) * (n - count)\n        \n        # Invalid combinations where both topics and difficulties are not all different\n        invalid_both_combinations = 0\n        for a_i, b_i in problems:\n            invalid_both_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_both_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a, b in problems:\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A structured format containing the number of test cases and a list of problems for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all topics are different.\",\n      \"output\": \"The number of combinations of three problems with different topics.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all difficulties are different.\",\n      \"output\": \"The number of combinations of three problems with different difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where both topics and difficulties are the same.\",\n      \"output\": \"The number of combinations of three problems with the same topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, compute the final result by subtracting the invalid combinations (same topics and difficulties) from the total combinations and adding the valid combinations (different topics or difficulties).\",\n      \"output\": \"The number of valid ways to select three problems for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of combinations of three problems from n problems using combinatorial mathematics.\",\n    \"For each test case, use a counting method to determine the number of combinations where all topics are different.\",\n    \"For each test case, use a counting method to determine the number of combinations where all difficulties are different.\",\n    \"For each test case, identify and count the number of invalid combinations where both topics and difficulties are the same.\",\n    \"Compute the valid number of ways to select three problems by adjusting the total combinations with the valid and invalid counts.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in terms of its topic and difficulty, meaning no two problems share both the same topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of exactly three problems from the given set of problems.\n\n    'different topics' and 'different difficulties'\n    Explanation: The selected problems must either have all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This means the selection must consist of precisely three problems.\n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    Steps 3 and 4 could be considered simultaneously since they both involve counting combinations based on distinct attributes (topics and difficulties). This can be implemented using combinatorial counting methods for both attributes in a single loop or function.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one way to select all three problems, and they satisfy both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No way to select three problems such that all topics or all difficulties are different.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All combinations of three problems will satisfy the conditions since all topics and difficulties are unique.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3 or where no valid combinations exist.\n    ```python\n    if n < 3:\n        return 0\n    if n == 3:\n        # Check if the only combination satisfies the conditions\n        if len(set(topics)) == 3 or len(set(difficulties)) == 3:\n            return 1\n        else:\n            return 0\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a, b in problems:\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are the same.\",\n      \"details\": \"Group problems by their topic and for each group with at least 3 problems, calculate the number of ways to choose 3 problems using the combination formula.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are the same.\",\n      \"details\": \"Group problems by their difficulty and for each group with at least 3 problems, calculate the number of ways to choose 3 problems using the combination formula.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are the same.\",\n      \"details\": \"Since no two problems have the same topic and difficulty, this count is always zero.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid ways to select three problems.\",\n      \"details\": \"Subtract the number of invalid selections (same topic or same difficulty) from the total number of selections.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using the combination formula.\",\n    \"For each test case, group problems by topic and calculate the number of ways to select three problems with the same topic.\",\n    \"For each test case, group problems by difficulty and calculate the number of ways to select three problems with the same difficulty.\",\n    \"For each test case, calculate the number of valid ways to select three problems by subtracting invalid selections from the total selections.\",\n    \"Output the number of valid ways\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in terms of its topic and difficulty, meaning no two problems share both the same topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a set of three problems from the given list.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a different topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a different difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    'at least one of two conditions': This means that the selection must satisfy at least one of the conditions (different topics or different difficulties) or both.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the number of ways to select three problems with the same topic and the same difficulty should be considered simultaneously. This is because both calculations involve grouping problems and using the combination formula, and they both contribute to identifying invalid selections.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: There is only one way to select three problems, and they satisfy both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: Any selection of three problems will have either the same topic or the same difficulty.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All combinations of three problems will satisfy both conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is very small (e.g., n = 3) to ensure that the logic correctly identifies valid selections.\n    ```python\n    if n < 3:\n        return 0\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                same_topic_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                same_difficulty_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Valid ways\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where the topics are not all different.\",\n      \"details\": \"For each topic, count the number of problems with that topic. Use these counts to calculate the number of invalid combinations where the topics are not all different.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where the difficulties are not all different.\",\n      \"details\": \"For each difficulty, count the number of problems with that difficulty. Use these counts to calculate the number of invalid combinations where the difficulties are not all different.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations for each test case.\",\n      \"details\": \"Subtract the invalid combinations (where topics or difficulties are not all different) from the total combinations to get the number of valid combinations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"For each test case, calculate the number of invalid combinations where the topics are not all different.\",\n    \"For each test case, calculate the number of invalid combinations where the difficulties are not all different.\",\n    \"For each test case, subtract the invalid combinations from the total combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique': Each problem has a unique combination of topic and difficulty, meaning no two problems share the same topic and difficulty simultaneously.\n    'different': The requirement specifies that either the topics or the difficulties of the selected problems must be different.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select exactly three problems from the list.\n    'at least one': The selected problems must satisfy at least one of the conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating invalid combinations based on topics and difficulties can be implemented simultaneously. This involves counting occurrences and using these counts to determine invalid combinations.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with all topics or difficulties the same:\n    Input: 3\n           1 1\n           1 2\n           1 3\n    Output: 1\n    Explanation: Only one way to select three problems, and they satisfy the condition of different difficulties.\n\n    Test case with maximum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will handle these cases correctly.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract invalid combinations where topics or difficulties are not all different\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial mathematics to calculate the total number of ways to select three problems from n problems, which is given by the combination formula C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where either all topics or all difficulties are the same.\",\n      \"steps\": [\n        \"Count the number of problems for each unique topic and difficulty.\",\n        \"For each unique topic, calculate the number of ways to select three problems with the same topic using the combination formula C(count_topic, 3).\",\n        \"For each unique difficulty, calculate the number of ways to select three problems with the same difficulty using the combination formula C(count_difficulty, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid selections that satisfy at least one of the conditions.\",\n      \"steps\": [\n        \"Subtract the number of invalid selections from the total number of ways to select three problems.\",\n        \"Ensure that the result accounts for selections that satisfy at least one of the conditions.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial mathematics.\",\n    \"Count the number of problems for each unique topic and difficulty.\",\n    \"Calculate the number of invalid selections where all topics or all difficulties are the same.\",\n    \"Subtract the number of invalid selections from the total number of ways to select three problems.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique in nature'\n    Explanation: This means that no two problems have the same topic and difficulty simultaneously, ensuring that each problem is distinct in terms of its attributes.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, which is a combinatorial selection problem.\n\n    'topics of all three selected problems are different'\n    Explanation: This condition requires that the three chosen problems have distinct topics.\n\n    'difficulties of all three selected problems are different'\n    Explanation: This condition requires that the three chosen problems have distinct difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must be precisely three problems, not more or less.\n    'at least one': This means that the selection must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the total number of ways to select three problems and the steps for calculating invalid selections should be considered simultaneously. This is because the valid selections are derived by subtracting invalid selections from the total selections.\n\n# [edge case]\n    Edge Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected Output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Edge Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected Output: 0\n    Explanation: No way to select three problems that satisfy either condition.\n\n    Edge Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected Output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that combinations are checked against both conditions and handle cases where n is exactly 3 or where all topics/difficulties are the same.\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to select 3 problems\n        total_ways = comb(n, 3)\n        \n        # Calculate invalid selections\n        invalid_topic_selections = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        invalid_difficulty_selections = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid selections\n        valid_selections = total_ways - invalid_topic_selections - invalid_difficulty_selections\n        \n        results.append(valid_selections)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to select 3 problems\n        total_ways = comb(n, 3)\n        \n        # Calculate invalid selections\n        invalid_topic_selections = sum(comb(count, 3) for count in topics.values() if count >= 3)\n        invalid_difficulty_selections = sum(comb(count, 3) for count in difficulties.values() if count >= 3)\n        \n        # Valid selections\n        valid_selections = total_ways - invalid_topic_selections - invalid_difficulty_selections\n        \n        results.append(valid_selections)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial mathematics to calculate the total number of ways to select three problems from n problems, which is given by the combination formula C(n, 3).\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of invalid selections where neither condition is satisfied.\",\n      \"steps\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"Calculate the number of invalid selections where all three problems have the same topic.\",\n        \"Calculate the number of invalid selections where all three problems have the same difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid selections.\",\n      \"steps\": [\n        \"Subtract the number of invalid selections from the total number of ways to select three problems.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Print the number of valid selections for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using the combination formula.\",\n    \"Determine the number of invalid selections where neither condition is satisfied by counting problems with the same topic or difficulty.\",\n    \"Calculate the number of valid selections by subtracting invalid selections from the total number of ways.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique in nature'\n    Explanation: This means that no two problems have the same topic and difficulty simultaneously, ensuring each problem is distinct in its combination of topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose three problems from the given set of problems.\n\n    'topics of all three selected problems are different'\n    Explanation: One of the conditions for a valid selection is that the three chosen problems must each have a different topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: Another condition for a valid selection is that the three chosen problems must each have a different difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are well-structured and do not require simultaneous implementation. Each step logically follows from the previous one, and they should be executed in sequence.\n\n# [edge case]\n    1. Test case with minimum n (n=3):\n       Input: 3\n              1 1\n              2 2\n              3 3\n       Expected Output: 1\n       Explanation: Only one way to select three problems, and it satisfies both conditions.\n\n    2. Test case with all topics or difficulties the same:\n       Input: 3\n              1 1\n              1 2\n              1 3\n       Expected Output: 1\n       Explanation: Only one way to select three problems, and it satisfies the condition of different difficulties.\n\n    3. Test case with maximum n for a single test case:\n       Input: 200000\n              (1 1, 2 2, ..., 200000 200000)\n       Expected Output: (calculated based on the logic)\n       Explanation: This tests the performance and correctness of the solution for large inputs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting invalid selections and subtracting from the total should handle these cases correctly.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = {}\n        difficulties = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            \n            problems.append((a, b))\n            \n            if a not in topics:\n                topics[a] = 0\n            if b not in difficulties:\n                difficulties[b] = 0\n            \n            topics[a] += 1\n            difficulties[b] += 1\n        \n        # Total ways to choose 3 problems from n\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid ways\n        invalid_ways = 0\n        \n        for a, b in problems:\n            # If we fix one problem, the remaining two must not have the same topic or difficulty\n            invalid_ways += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        # Valid ways are total ways minus invalid ways\n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n for the number of problems, followed by n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"Count the occurrences of each topic. For each topic with count c, calculate the number of invalid combinations C(c, 3) and subtract from the total.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"Count the occurrences of each difficulty. For each difficulty with count d, calculate the number of invalid combinations C(d, 3) and subtract from the total.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are not different.\",\n      \"details\": \"For each pair of problems with the same topic and difficulty, adjust the count to avoid double subtraction.\"\n    },\n    {\n      \"description\": \"Output the number of valid combinations for each test case.\",\n      \"details\": \"For each test case, compute the valid combinations by subtracting invalid combinations from the total and print the result.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"For each test case, calculate the number of invalid combinations where all topics are not different.\",\n    \"For each test case, calculate the number of invalid combinations where all difficulties are not different.\",\n    \"Adjust for over-counting of combinations where both topics and difficulties are not different.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in terms of its topic and difficulty, meaning no two problems share both the same topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a set of three problems from the given list.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a different topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a different difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This means that the selection must consist of precisely three problems, no more, no less.\n    'at least one of two conditions': This means that the selected problems must satisfy at least one of the given conditions (different topics or different difficulties).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating invalid combinations for topics and difficulties should be considered simultaneously to avoid double counting. Specifically, when calculating invalid combinations, adjustments should be made for cases where both topics and difficulties are not different.\n\n# [edge case] \n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: All problems have different topics and difficulties, so there is exactly one valid combination.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No combination of three problems can satisfy either condition since there are only two unique topics and difficulties.\n    3. n = 5, problems = [(1, 1), (1, 2), (2, 1), (2, 2), (3, 3)] = 3\n       Explanation: Valid combinations include (1, 2, 5), (2, 3, 5), and (1, 3, 5) where either topics or difficulties are different.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that when counting invalid combinations, we correctly adjust for cases where both topics and difficulties are not different. This can be done by maintaining a count of each topic and difficulty and using these counts to adjust the total number", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            invalid_topic_combinations += calculate_combinations(count)\n        \n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            invalid_difficulty_combinations += calculate_combinations(count)\n        \n        # Adjust for over-counting where both topic and difficulty are not different\n        invalid_both_combinations = 0\n        for a_i, b_i in problems:\n            invalid_both_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_both_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            invalid_topic_combinations += calculate_combinations(count)\n        \n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            invalid_difficulty_combinations += calculate_combinations(count)\n        \n        # Adjust for over-counting where both topic and difficulty are not different\n        invalid_both_combinations = 0\n        for a_i, b_i in problems:\n            invalid_both_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_both_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any 3 problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select 3 problems where the topics are not all different.\",\n      \"details\": \"Use a dictionary to count the frequency of each topic. For each topic with frequency f, calculate the number of invalid combinations C(f, 3) and C(f, 2) * (n - f).\"\n    },\n    {\n      \"description\": \"Count the number of ways to select 3 problems where the difficulties are not all different.\",\n      \"details\": \"Use a dictionary to count the frequency of each difficulty. For each difficulty with frequency f, calculate the number of invalid combinations C(f, 3) and C(f, 2) * (n - f).\"\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations by subtracting invalid combinations from the total combinations.\",\n      \"details\": \"Subtract the invalid combinations (from both topic and difficulty) from the total combinations to get the valid combinations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any 3 problems using the combination formula.\",\n    \"Count the number of invalid combinations where the topics are not all different using a frequency dictionary.\",\n    \"Count the number of invalid combinations where the difficulties are not all different using a frequency dictionary.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique': Each problem has a unique combination of topic and difficulty, meaning no two problems share the same topic and difficulty simultaneously.\n    'different': The selected problems must have either different topics or different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select precisely three problems from the list.\n    'at least one': The selected problems must satisfy at least one of the conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for counting invalid combinations for topics and difficulties can be implemented simultaneously using separate dictionaries for topics and difficulties. This can be done in a single loop iterating over the problems to populate both dictionaries.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with all topics and difficulties the same:\n    Input: 3\n           1 1\n           1 1\n           1 1\n    Output: 0\n    Explanation: No valid way to select three problems as they do not satisfy either condition.\n\n    Test case with maximum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating valid combinations by subtracting invalid combinations from total combinations will handle these cases.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i in topic_count:\n                topic_count[a_i] += 1\n            else:\n                topic_count[a_i] = 1\n            \n            if b_i in difficulty_count:\n                difficulty_count[b_i] += 1\n            else:\n                difficulty_count[b_i] = 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            f_topic = topic_count[a_i]\n            f_difficulty = difficulty_count[b_i]\n            \n            # Subtract invalid combinations for this specific problem\n            invalid_combinations += (f_topic - 1) * (f_difficulty - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 103)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i in topic_count:\n                topic_count[a_i] += 1\n            else:\n                topic_count[a_i] = 1\n            \n            if b_i in difficulty_count:\n                difficulty_count[b_i] += 1\n            else:\n                difficulty_count[b_i] = 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            f_topic = topic_count[a_i]\n            f_difficulty = difficulty_count[b_i]\n            \n            # Subtract invalid combinations for this specific problem\n            invalid_combinations += (f_topic - 1) * (f_difficulty - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of problems.\",\n        \"For each problem, read the integers a_i and b_i representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"steps\": [\n        \"Use combinatorial formula to calculate the total number of combinations of 3 problems from n: C(n, 3) = n * (n - 1) * (n - 2) / 6.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of invalid combinations where neither condition is satisfied.\",\n      \"steps\": [\n        \"Count the number of problems for each topic and difficulty.\",\n        \"For each topic, calculate the number of invalid combinations where all three problems have the same topic.\",\n        \"For each difficulty, calculate the number of invalid combinations where all three problems have the same difficulty.\",\n        \"Adjust for overcounting where both topic and difficulty are the same for all three problems.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations.\",\n      \"steps\": [\n        \"Subtract the number of invalid combinations from the total number of combinations to get the number of valid combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Print the number of valid combinations for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of combinations of 3 problems from n.\",\n    \"For each test case, calculate the number of invalid combinations where neither condition is satisfied.\",\n    \"Subtract the number of invalid combinations from the total number of combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique in nature'\n    Explanation: This means that no two problems have the same topic and difficulty simultaneously, ensuring each problem is distinct.\n\n    'exactly 3 problems'\n    Explanation: The requirement is to select precisely three problems from the given set.\n\n    'different topics' and 'different difficulties'\n    Explanation: The selected problems must either have all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must be of three problems, no more, no less.\n    Implementation: Use combinations to select exactly three problems from the list.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the total number of combinations and invalid combinations should be considered simultaneously.\n    Explanation: Calculating the total combinations and invalid combinations can be done in a single loop over the problems, using combinatorial logic to count valid and invalid sets.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected Output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with all same topics:\n    Input: 3\n           1 2\n           1 3\n           1 4\n    Expected Output: 0\n    Explanation: All problems have the same topic, so no valid selection.\n\n    Test case with all same difficulties:\n    Input: 3\n           1 1\n           2 1\n           3 1\n    Expected Output: 0\n    Explanation: All problems have the same difficulty, so no valid selection.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Implement checks for cases where all topics or all difficulties are the same, and adjust the count accordingly.\n\n    Example code for handling edge cases:\n    ```python\n    if n < 3:\n        return 0\n    total_combinations = n * (n - 1) * (n - 2) // 6\n    invalid_combinations = 0\n    # Count invalid combinations for same topics or difficulties\n    for topic in topic_count:\n        if topic_count[topic] >= 3:\n            invalid_combinations += topic_count[topic] * (topic_count[topic", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract invalid combinations for this specific problem\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where the topics are not all different.\",\n      \"details\": \"Use a dictionary to count the occurrences of each topic. For each topic with count c, calculate the number of ways to choose 3 problems with the same topic using C(c, 3) and the number of ways to choose 2 problems with the same topic and 1 different using C(c, 2) * (n - c).\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where the difficulties are not all different.\",\n      \"details\": \"Use a dictionary to count the occurrences of each difficulty. For each difficulty with count d, calculate the number of ways to choose 3 problems with the same difficulty using C(d, 3) and the number of ways to choose 2 problems with the same difficulty and 1 different using C(d, 2) * (n - d).\"\n    },\n    {\n      \"description\": \"Calculate the number of valid problem sets for each test case.\",\n      \"details\": \"Subtract the number of invalid sets (where topics or difficulties are not all different) from the total number of sets to get the number of valid sets.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store the results for each test case.\",\n    \"For each test case, perform the following steps:\",\n    \"  Parse the input to get the number of problems and their respective topics and difficulties.\",\n    \"  Calculate the total number of ways to select any three problems.\",\n    \"  Count the number of ways to select three problems where the topics are not all different.\",\n    \"  Count the number of ways to select three\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique in nature'\n    Explanation: This means that no two problems have the same topic and difficulty simultaneously, ensuring each problem is distinct in terms of its attributes.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specified conditions.\n\n    'topics of all three selected problems are different'\n    Explanation: This condition requires that the three chosen problems have distinct topics.\n\n    'difficulties of all three selected problems are different'\n    Explanation: This condition requires that the three chosen problems have distinct difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must be precisely three problems, not more or less.\n    'at least one': This means that the selected problems must satisfy at least one of the given conditions (topics or difficulties being different).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for counting invalid sets based on topics and difficulties can be implemented simultaneously using dictionaries to track occurrences and calculate combinations. This can be done in a single code block where both topic and difficulty checks are performed.\n\n# [edge case]\n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 0\n    Explanation: No way to select three problems that satisfy either condition.\n\n    Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid sets by subtracting invalid sets from total combinations will handle these cases correctly.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i in topic_count:\n                topic_count[a_i] += 1\n            else:\n                topic_count[a_i] = 1\n            \n            if b_i in difficulty_count:\n                difficulty_count[b_i] += 1\n            else:\n                difficulty_count[b_i] = 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid ways based on topics\n        invalid_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_ways += count * (count - 1) * (count - 2) // 6\n            if count >= 2:\n                invalid_topic_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Calculate invalid ways based on difficulties\n        invalid_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_ways += count * (count - 1) * (count - 2) // 6\n            if count >= 2:\n                invalid_difficulty_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Calculate valid ways\n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains a list of problems with their topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems, which is computed using combinatorial mathematics (n choose 3).\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where the topics are not all different.\",\n      \"output\": \"The number of invalid combinations where at least two problems have the same topic.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where the difficulties are not all different.\",\n      \"output\": \"The number of invalid combinations where at least two problems have the same difficulty.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where both the topics and difficulties are not all different.\",\n      \"output\": \"The number of invalid combinations where at least two problems have the same topic and at least two problems have the same difficulty.\"\n    },\n    {\n      \"description\": \"For each test case, compute the valid number of ways to select three problems by subtracting the invalid combinations from the total combinations.\",\n      \"output\": \"The number of valid combinations for each test case that satisfy at least one of the conditions.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of ways to select any three problems using combinatorial mathematics.\",\n    \"For each test case, count the occurrences of each topic and each difficulty.\",\n    \"Calculate the number of invalid combinations where topics are not all different using the topic counts.\",\n    \"Calculate the number of invalid combinations where difficulties are not all different using the difficulty counts.\",\n    \"Calculate the number of invalid combinations where both topics and difficulties are not all different using both counts.\",\n    \"Subtract the invalid combinations from the total combinations to get the valid number of ways for each test case.\",\n    \"Output the result for each\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique': Each problem has a distinct combination of topic and difficulty, ensuring no duplicates.\n    'different': The requirement for selected problems to have either different topics or different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select precisely three problems for the problemset.\n    'at least one': The selected problems must satisfy at least one of the conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    Steps 3, 4, and 5 should be considered simultaneously. These steps involve calculating invalid combinations based on topic and difficulty counts. They can be implemented in a single code block where both counts are used to determine invalid combinations.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Test case with all topics and difficulties the same:\n    Input: 3\n           1 1\n           1 1\n           1 1\n    Expected output: 0\n    Explanation: No valid way to select three problems as they do not satisfy either condition.\n\n    Test case with maximum n:\n    Input: 200000\n           (random unique combinations of topics and difficulties)\n    Expected output: (depends on the specific combinations)\n    Explanation: The output will depend on the distribution of topics and difficulties.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is the minimum or all topics/difficulties are the same.\n    ```python\n    if n == 3:\n        return 1 if len(set(topics)) == 3 or len(set(difficulties)) == 3 else 0\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations where topics are not all different\n        invalid_topic_combinations = 0\n        for count in topics.values():\n            if count >= 2:\n                invalid_topic_combinations += comb(count, 2) * (n - count)\n        \n        # Invalid combinations where difficulties are not all different\n        invalid_difficulty_combinations = 0\n        for count in difficulties.values():\n            if count >= 2:\n                invalid_difficulty_combinations += comb(count, 2) * (n - count)\n        \n        # Invalid combinations where both topics and difficulties are not all different\n        invalid_both_combinations = 0\n        for a_i, b_i in problems:\n            invalid_both_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_both_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 110)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = comb(n, 3)\n        \n        # Invalid combinations where topics are not all different\n        invalid_topic_combinations = 0\n        for count in topics.values():\n            if count >= 2:\n                invalid_topic_combinations += comb(count, 2) * (n - count)\n        \n        # Invalid combinations where difficulties are not all different\n        invalid_difficulty_combinations = 0\n        for count in difficulties.values():\n            if count >= 2:\n                invalid_difficulty_combinations += comb(count, 2) * (n - count)\n        \n        # Invalid combinations where both topics and difficulties are not all different\n        invalid_both_combinations = 0\n        for a_i, b_i in problems:\n            invalid_both_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + invalid_both_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A structured format containing the number of test cases and a list of problems for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all topics are different.\",\n      \"output\": \"The number of combinations of three problems with different topics.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where all difficulties are different.\",\n      \"output\": \"The number of combinations of three problems with different difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems where both topics and difficulties are the same.\",\n      \"output\": \"The number of combinations of three problems with the same topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, compute the final result by subtracting the invalid combinations (same topics and difficulties) from the total combinations and adding the valid combinations (different topics or difficulties).\",\n      \"output\": \"The number of valid ways to select three problems for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of combinations of three problems from n problems using combinatorial mathematics.\",\n    \"For each test case, use a counting method to determine the number of combinations where all topics are different.\",\n    \"For each test case, use a counting method to determine the number of combinations where all difficulties are different.\",\n    \"For each test case, identify and count the number of invalid combinations where both topics and difficulties are the same.\",\n    \"Compute the valid number of ways to select three problems by adjusting the total combinations with the valid and invalid counts.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in terms of its topic and difficulty, meaning no two problems share both the same topic and difficulty.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of exactly three problems from the given set of problems.\n\n    'different topics' and 'different difficulties'\n    Explanation: The selected problems must either have all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This means the selection must consist of precisely three problems.\n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    Steps 3 and 4 could be considered simultaneously since they both involve counting combinations based on distinct attributes (topics and difficulties). This can be implemented using combinatorial counting methods for both attributes in a single loop or function.\n\n# [edge case]\n    1. n = 3, problems = [(1, 1), (2, 2), (3, 3)] = 1\n       Explanation: Only one way to select all three problems, and they satisfy both conditions.\n    2. n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n       Explanation: No way to select three problems such that all topics or all difficulties are different.\n    3. n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] = 10\n       Explanation: All combinations of three problems will satisfy the conditions since all topics and difficulties are unique.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where n is exactly 3 or where no valid combinations exist.\n    ```python\n    if n < 3:\n        return 0\n    if n == 3:\n        # Check if the only combination satisfies the conditions\n        if len(set(topics)) == 3 or len(set(difficulties)) == 3:\n            return 1\n        else:\n            return 0\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        for a, b in problems:\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 4, "round": 242, "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). Every problem is unique in nature. In other words, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 111}
