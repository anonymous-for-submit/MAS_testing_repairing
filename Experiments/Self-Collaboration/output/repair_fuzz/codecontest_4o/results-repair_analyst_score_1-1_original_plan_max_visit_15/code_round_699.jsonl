{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "repair_prompt": ["The robot is positioned on a checkered rectangular board of dimensions n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot can move to one of the four neighboring cells by the side from its present position.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U'. These symbol commands are responsible for triggering movement to the left, right, down, or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will cause him to cross over the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is positioned on a checkered rectangular board of dimensions n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot can move to one of the four neighboring cells by the side from its present position. It can move left, right, up, or down.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U'. These symbol commands are responsible for triggering movement to the left, right, down, or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will cause him to cross over the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is positioned on a checkered rectangular board of dimensions n \u00d7 m (n rows, m columns), with rows in the board numbered from 1 to n from top to bottom and columns from 1 to m from left to right. The robot can move to one of the four neighboring cells by the side from its present position. The sequence of commands s executed by the robot is given, with each command denoted by one of the symbols 'L', 'R', 'D' or 'U' responsible for triggering movement to the left, right, down, or up, respectively. The robot can start its movement in any cell, and executes the commands starting from the first one in the order they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, and a command that causes the robot to break is not considered successfully executed. The robot's task is to execute as many commands as possible without falling off the board; for example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will cause him to cross over the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column). Determine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Simulate the robot's movement\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot falls off the board\n                    if row < 1 or row > n or col < 1 or col > m:\n                        break\n                    commands_executed += 1\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def find_optimal_start_position(n, m, s):\n    # Initialize the boundaries for the robot's movement\n    min_row, max_row = 0, 0\n    min_col, max_col = 0, 0\n    \n    # Current position of the robot\n    current_row, current_col = 0, 0\n    \n    # Iterate over the command sequence to determine the movement boundaries\n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        # Update the boundaries\n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Calculate the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within the board limits\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        if n == 1 and m == 1:\n            results.append((1, 1))\n        else:\n            result = find_optimal_start_position(n, m, s)\n            if result:\n                results.append(result)\n    \n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        # Initialize the best starting position\n        best_r, best_c = 1, 1\n        max_commands = 0\n        \n        # Simulate the robot's movement\n        for start_r in range(1, n + 1):\n            for start_c in range(1, m + 1):\n                r, c = start_r, start_c\n                commands_executed = 0\n                for command in s:\n                    if command == 'L':\n                        c -= 1\n                    elif command == 'R':\n                        c += 1\n                    elif command == 'U':\n                        r -= 1\n                    elif command == 'D':\n                        r += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= r <= n and 1 <= c <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_r, best_c = start_r, start_c\n        \n        results.append(f\"{best_r} {best_c}\")\n    \n    # Output the results for all test cases\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Try each possible starting position\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= row <= n and 1 <= col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        # Store the result for this test case\n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_starting_cell(n, m, commands):\n    # Initialize variables to track the boundaries of the robot's movement\n    min_row, max_row = 0, 0\n    min_col, max_col = 0, 0\n    current_row, current_col = 0, 0\n\n    # Iterate over the commands to determine the movement boundaries\n    for command in commands:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n\n        # Update the boundaries based on the current position\n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n\n        # Check if the robot would fall off the board\n        if max_row - min_row >= n or max_col - min_col >= m:\n            break\n\n    # Calculate the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n\n    return start_row, start_col\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        commands = data[index]\n        index += 1\n\n        start_row, start_col = find_starting_cell(n, m, commands)\n        results.append(f\"{start_row} {start_col}\")\n\n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(n, m, commands):\n    # Directions mapping\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    # Initialize the best starting position and maximum commands executed\n    best_start_position = (1, 1)\n    max_commands_executed = 0\n    \n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            current_row, current_col = start_row, start_col\n            commands_executed = 0\n            \n            # Simulate the robot's movement\n            for command in commands:\n                dr, dc = direction_map[command]\n                new_row, new_col = current_row + dr, current_col + dc\n                \n                # Check if the new position is within bounds\n                if 1 <= new_row <= n and 1 <= new_col <= m:\n                    current_row, current_col = new_row, new_col\n                    commands_executed += 1\n                else:\n                    break\n            \n            # Update the best starting position if more commands are executed\n            if commands_executed > max_commands_executed:\n                max_commands_executed = commands_executed\n                best_start_position = (start_row, start_col)\n    \n    return best_start_position\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        commands = data[index]\n        index += 1\n        \n        # Get the best starting position for the current test case\n        best_start_position = simulate_movement(n, m, commands)\n        results.append(best_start_position)\n    \n    # Print the results for each test case\n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Try each possible starting position\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= row <= n and 1 <= col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_starting_position(n, m, commands):\n    # Initialize the starting position and the maximum number of commands executed\n    max_commands = 0\n    best_start = (1, 1)\n\n    # Directions mapping\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n\n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            # Simulate the robot's movement\n            row, col = start_row, start_col\n            executed_commands = 0\n\n            for command in commands:\n                # Calculate the new position\n                dr, dc = direction_map[command]\n                new_row, new_col = row + dr, col + dc\n\n                # Check if the new position is within the board\n                if 1 <= new_row <= n and 1 <= new_col <= m:\n                    row, col = new_row, new_col\n                    executed_commands += 1\n                else:\n                    break\n\n            # Update the best starting position if more commands are executed\n            if executed_commands > max_commands:\n                max_commands = executed_commands\n                best_start = (start_row, start_col)\n\n    return best_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        commands = data[index + 1]\n        index += 2\n\n        # Find the best starting position for this test case\n        best_start = find_starting_position(n, m, commands)\n        results.append(f\"{best_start[0]} {best_start[1]}\")\n\n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_starting_position(n, m, s):\n    min_r, max_r, min_c, max_c = 0, 0, 0, 0\n    r, c = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            c -= 1\n        elif command == 'R':\n            c += 1\n        elif command == 'U':\n            r -= 1\n        elif command == 'D':\n            r += 1\n        \n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n    \n    start_r = 1 - min_r\n    start_c = 1 - min_c\n    \n    if start_r + max_r > n or start_c + max_c > m:\n        return None\n    \n    return start_r, start_c\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize the best starting position and max commands executed\n        best_r, best_c = 1, 1\n        max_commands = 0\n        \n        # Try all possible starting positions\n        for start_r in range(1, n + 1):\n            for start_c in range(1, m + 1):\n                r, c = start_r, start_c\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        c -= 1\n                    elif command == 'R':\n                        c += 1\n                    elif command == 'U':\n                        r -= 1\n                    elif command == 'D':\n                        r += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= r <= n and 1 <= c <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_r, best_c = start_r, start_c\n        \n        results.append(f\"{best_r} {best_c}\")\n    \n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Simulate the robot's movement\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot falls off the board\n                    if row < 1 or row > n or col < 1 or col > m:\n                        break\n                    commands_executed += 1\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t from the input, representing the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the board dimensions.\",\n        \"Read the string s, representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case.\",\n      \"steps\": [\n        \"Initialize variables to track the robot's position and the maximum number of commands executed without falling.\",\n        \"For each possible starting position on the board, simulate the robot's movement according to the command sequence.\",\n        \"Check if the robot falls off the board after each command and stop the simulation if it does.\",\n        \"Track the starting position that allows the maximum number of commands to be executed without falling.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the optimal starting position for the robot.\",\n      \"steps\": [\n        \"Compare the results of the simulations for all possible starting positions.\",\n        \"Select the starting position that allows the maximum number of commands to be executed without falling.\",\n        \"If multiple positions yield the same result, choose any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row and column of the optimal starting position.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test case data.\",\n    \"For each test case, simulate the robot's movement from all possible starting positions.\",\n    \"Track the starting position that allows the maximum number of commands to be executed without falling.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left (L), right (R), down (D), and up (U). The task is to determine the starting position on the board that allows the robot to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means the goal is to maximize the number of commands executed without the robot falling off the board. In code, this involves simulating the robot's movement from different starting positions and counting the number of successful commands.\n\n# [degree adverb]\n    'maximum': This refers to the largest number of commands that can be executed without the robot falling off the board. In code, this involves keeping track of the highest count of successful commands for each starting position.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and checking if it falls off the board should be implemented simultaneously. Specifically, the simulation of movement and the check for falling should occur within the same loop or function to efficiently track the robot's position and the number of commands executed.\n\n# [edge case]\n    1 1 L = 1 1\n    Explanation: On a 1x1 board, any command will cause the robot to fall off immediately, so the starting position doesn't matter; the robot will execute zero commands successfully.\n\n    2 2 U = 1 1\n    Explanation: On a 2x2 board, starting at (1,1) and moving up will cause the robot to fall off immediately, so the robot should start at (1,1) to execute zero commands successfully.\n\n    3 3 RRR = 1 1\n    Explanation: On a 3x3 board, starting at (1,1) and moving right three times will cause the robot to fall off after the third command, so the robot should start at (1,1) to execute two commands successfully.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include checks for the board boundaries during the simulation of the robot's movement to ensure the robot does not fall off the board. This can be done by checking the robot's position after each command and stopping the simulation if the position is outside the board dimensions.\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Simulate the robot's movement\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot falls off the board\n                    if row < 1 or row > n or col < 1 or col > m:\n                        break\n                    commands_executed += 1\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t from the input, representing the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the board dimensions.\",\n        \"Read the string s, representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case to determine the optimal starting position.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of commands executed and the corresponding starting position.\",\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the robot's movement according to the command sequence s.\",\n        \"Track the number of successfully executed commands before the robot falls off the board.\",\n        \"Update the maximum number of commands executed and the starting position if the current simulation results in more commands executed.\"\n      ]\n    },\n    {\n      \"description\": \"Output the optimal starting position for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row and column of the starting position that allows the maximum number of commands to be executed.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of successfully executed commands.\",\n    \"Determine the starting position that allows the maximum number of commands to be executed.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left, right, up, and down, based on the commands 'L', 'R', 'U', and 'D'. The goal is to execute as many commands as possible without the robot falling off the board.\n\n    'starting position'\n    Explanation: The robot can start from any cell on the board, and the task is to find the optimal starting position that allows the maximum number of commands to be executed without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible'\n    Explanation: This means the robot should execute the maximum number of commands from the sequence without falling off the board. In code, this involves simulating the robot's movement from different starting positions and counting the number of commands executed before falling off.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the starting position that allows the maximum number of commands to be executed. In code, this involves keeping track of the highest number of commands executed from any starting position.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially, as each step builds upon the previous one. However, the simulation of the robot's movement for each starting position can be optimized by considering boundary conditions simultaneously to avoid unnecessary computations.\n\n# [edge case]\n    1 1 L = 1 1\n    Explanation: On a 1x1 board, any command will cause the robot to fall off immediately, so the starting position is irrelevant, and the output is the only cell available.\n\n    1 2 L = 1 2\n    Explanation: On a 1x2 board, starting from the second column allows the robot to execute the 'L' command without falling off.\n\n    3 3 RRR = 1 1\n    Explanation: On a 3x3 board, starting from the first column allows the robot to execute the 'R' command three times without falling off.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for small board sizes where the robot can fall off immediately.\n    ```python\n    if n == 1 and m == 1:\n        print(1, 1)\n    else:\n        # Continue with the simulation logic for larger boards\n    ```\n\nYES", "Round_0": {"code": "def find_optimal_start_position(n, m, s):\n    # Initialize the boundaries for the robot's movement\n    min_row, max_row = 0, 0\n    min_col, max_col = 0, 0\n    \n    # Current position of the robot\n    current_row, current_col = 0, 0\n    \n    # Iterate over the command sequence to determine the movement boundaries\n    for command in s:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n        \n        # Update the boundaries\n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n    \n    # Calculate the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n    \n    # Ensure the starting position is within the board limits\n    if start_row + max_row <= n and start_col + max_col <= m:\n        return start_row, start_col\n    else:\n        return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        if n == 1 and m == 1:\n            results.append((1, 1))\n        else:\n            result = find_optimal_start_position(n, m, s)\n            if result:\n                results.append(result)\n    \n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"details\": \"Read the first integer as the number of test cases. For each test case, read two integers representing the board dimensions (n and m) and a string representing the sequence of commands.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case.\",\n      \"details\": \"For each test case, simulate the robot's movement starting from each possible cell on the board. Track the number of successfully executed commands before the robot falls off the board.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of commands to be executed.\",\n      \"details\": \"For each test case, identify the starting cell that results in the maximum number of commands being executed without the robot falling off the board.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the coordinates of the starting cell that allows the maximum number of commands to be executed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the board dimensions and command sequence.\",\n    \"Initialize variables to track the maximum number of commands executed and the corresponding starting cell.\",\n    \"Iterate over each possible starting cell on the board.\",\n    \"Simulate the robot's movement from the current starting cell, counting the number of commands executed before falling off the board.\",\n    \"Update the maximum commands executed and starting cell if the current simulation results in more commands executed.\",\n    \"After checking all starting cells, store the result for the test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The requirement involves simulating the movement of a robot on a board based on a sequence of commands. The robot can move in four directions: left, right, up, and down.\n\n    'board dimensions'\n    Explanation: The board is defined by its dimensions n (rows) and m (columns), which determine the boundaries within which the robot can move.\n\n    'starting cell'\n    Explanation: The task is to determine the optimal starting cell for the robot to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many as possible': This means the goal is to maximize the number of commands executed without the robot falling off the board.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to simulating the robot's movement and determining the starting cell with the maximum commands executed should be considered simultaneously. Specifically, the simulation of the robot's movement from each starting cell and the tracking of the maximum number of commands executed should be integrated into a single loop or function.\n\n# [edge case]\n    1 1, L = 1 1\n    Explanation: On a 1x1 board, any movement will cause the robot to fall off immediately. The only starting cell is (1, 1), and no commands can be executed successfully.\n\n    2 2, LR = 1 1\n    Explanation: On a 2x2 board, starting from (1, 1) and executing 'L' will cause the robot to fall off. Starting from (1, 2) allows executing 'L' successfully, but 'R' will cause a fall. The optimal starting cell is (1, 1) or (1, 2) as they allow executing at least one command.\n\n    3 3, UUU = 3 1\n    Explanation: On a 3x3 board, starting from the bottom row (3, 1) allows executing 'U' commands until reaching the top row. Starting from any other row will result in fewer commands executed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include boundary checks to ensure the robot does not move outside the board dimensions. This can be implemented by checking the robot's position after each command and ensuring it remains within the valid range of rows and columns.\n\n```python\ndef simulate", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        # Initialize the best starting position\n        best_r, best_c = 1, 1\n        max_commands = 0\n        \n        # Simulate the robot's movement\n        for start_r in range(1, n + 1):\n            for start_c in range(1, m + 1):\n                r, c = start_r, start_c\n                commands_executed = 0\n                for command in s:\n                    if command == 'L':\n                        c -= 1\n                    elif command == 'R':\n                        c += 1\n                    elif command == 'U':\n                        r -= 1\n                    elif command == 'D':\n                        r += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= r <= n and 1 <= c <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_r, best_c = start_r, start_c\n        \n        results.append(f\"{best_r} {best_c}\")\n    \n    # Output the results for all test cases\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the string s, which represents the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each starting position to determine the maximum number of commands that can be executed without falling off.\",\n      \"steps\": [\n        \"For each test case, iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the robot's movement according to the command sequence s.\",\n        \"Track the number of successfully executed commands before the robot falls off the board.\",\n        \"Keep track of the starting position that allows the maximum number of commands to be executed.\"\n      ]\n    },\n    {\n      \"description\": \"Output the optimal starting position for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row and column of the starting position that allows the maximum number of commands to be executed.\",\n        \"Ensure the output format matches the required specification.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of successfully executed commands.\",\n    \"Determine the starting position that allows the maximum number of commands to be executed.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The requirement involves simulating the movement of a robot on a board based on a sequence of commands ('L', 'R', 'D', 'U') and determining the optimal starting position to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many as possible': This means maximizing the number of commands executed without the robot falling off the board. In code, this involves iterating over possible starting positions and tracking the number of commands executed successfully.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the number of commands should be implemented simultaneously. Specifically, the steps:\n    - \"For each starting position, simulate the robot's movement according to the command sequence s.\"\n    - \"Track the number of successfully executed commands before the robot falls off the board.\"\n    These can be implemented in a single loop that iterates over each starting position and simulates the movement while counting the commands.\n\n# [edge case]\n    1 1\n    L = 1 1\n    Explanation: On a 1x1 board, any command will cause the robot to fall off immediately, so the starting position doesn't matter, and the robot cannot execute any commands successfully.\n\n    2 2\n    UU = 1 1\n    Explanation: On a 2x2 board, starting from (1,1), the robot will fall off after the first 'U' command, so the maximum number of commands executed is 0.\n\n    3 3\n    RRR = 1 1\n    Explanation: On a 3x3 board, starting from (1,1), the robot can execute all 'R' commands without falling off, as it will move to (1,2) and then (1,3).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the board dimensions are minimal (e.g., 1x1) or where the command sequence is such that the robot falls off immediately. This can be handled by checking the board dimensions and the initial command direction before simulating the movement.\n    \n    ```python\n    if n == 1 and m == 1:\n        print(1, 1)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Try each possible starting position\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= row <= n and 1 <= col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        # Store the result for this test case\n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"details\": \"Read the input data and split it into individual test cases. For each test case, extract the integers n and m representing the board dimensions, and the string s representing the sequence of commands.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case.\",\n      \"details\": \"For each test case, simulate the robot's movement starting from each possible cell on the board. Track the number of commands successfully executed before the robot falls off the board.\"\n    },\n    {\n      \"description\": \"Determine the starting cell that allows the maximum number of commands to be executed.\",\n      \"details\": \"For each test case, compare the results of the simulations from different starting cells and identify the cell that allows the maximum number of commands to be executed without the robot falling off the board.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the coordinates of the starting cell that allows the maximum number of commands to be executed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting cells on the board.\",\n    \"Simulate the robot's movement from each starting cell, executing the sequence of commands until the robot falls off the board or all commands are executed.\",\n    \"Track the number of successfully executed commands for each starting cell.\",\n    \"Identify the starting cell that allows the maximum number of commands to be executed for each test case.\",\n    \"Output the coordinates of the optimal starting cell for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left, right, up, and down, based on the commands 'L', 'R', 'U', and 'D'. The goal is to execute as many commands as possible without the robot falling off the board.\n\n    'starting cell'\n    Explanation: The robot can start from any cell on the board, and the task is to determine the optimal starting cell that allows the maximum number of commands to be executed.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible'\n    Explanation: This means the robot should execute the maximum number of commands from the sequence without falling off the board. In code, this involves simulating the robot's movement and counting the number of commands executed before a fall occurs.\n\n# [degree adverb]\n    'maximum'\n    Explanation: The requirement is to find the starting cell that allows the maximum number of commands to be executed. In code, this involves comparing the number of commands executed from different starting cells and selecting the one with the highest count.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially, as each step builds on the previous one. However, the simulation of the robot's movement from each starting cell can be optimized by considering boundary checks simultaneously within the movement logic.\n\n# [edge case]\n    1 1\n    L = 1 1\n    Explanation: With a 1x1 board, any movement will cause the robot to fall off immediately. The robot should start at the only cell available, (1, 1), and no commands can be executed successfully.\n\n    2 2\n    LR = 1 1\n    Explanation: On a 2x2 board, starting at (1, 1) allows the robot to execute the 'L' command without falling, but the 'R' command will cause a fall. Starting at (1, 1) maximizes the number of commands executed.\n\n    3 3\n    UUU = 3 1\n    Explanation: Starting at (3, 1) allows the robot to execute all 'U' commands without falling off the board, as it moves upwards within the board's boundaries.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the board dimensions are minimal (e.g., 1x1) or the command sequence immediately causes a fall.\n    ```python\n    if", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    # Initialize variables to track the boundaries of the robot's movement\n    min_row, max_row = 0, 0\n    min_col, max_col = 0, 0\n    current_row, current_col = 0, 0\n\n    # Iterate over the commands to determine the movement boundaries\n    for command in commands:\n        if command == 'L':\n            current_col -= 1\n        elif command == 'R':\n            current_col += 1\n        elif command == 'U':\n            current_row -= 1\n        elif command == 'D':\n            current_row += 1\n\n        # Update the boundaries based on the current position\n        min_row = min(min_row, current_row)\n        max_row = max(max_row, current_row)\n        min_col = min(min_col, current_col)\n        max_col = max(max_col, current_col)\n\n        # Check if the robot would fall off the board\n        if max_row - min_row >= n or max_col - min_col >= m:\n            break\n\n    # Calculate the optimal starting position\n    start_row = 1 - min_row\n    start_col = 1 - min_col\n\n    return start_row, start_col\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        commands = data[index]\n        index += 1\n\n        start_row, start_col = find_starting_cell(n, m, commands)\n        results.append(f\"{start_row} {start_col}\")\n\n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the sequence of commands.\",\n      \"output\": \"A list of test cases, each containing the board dimensions and the command sequence.\"\n    },\n    {\n      \"description\": \"For each test case, determine the starting position on the board that allows the robot to execute the maximum number of commands without falling off the board.\",\n      \"output\": \"The optimal starting position (row and column) for each test case.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for a given starting position and command sequence, checking if the robot falls off the board.\",\n      \"output\": \"The number of successfully executed commands for a given starting position.\"\n    },\n    {\n      \"description\": \"Iterate over all possible starting positions on the board to find the one that allows the maximum number of commands to be executed.\",\n      \"output\": \"The starting position that maximizes the number of executed commands.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases from the input.\",\n    \"For each test case, read the board dimensions and the command sequence.\",\n    \"Initialize variables to track the maximum number of commands executed and the corresponding starting position.\",\n    \"For each possible starting position on the board:\",\n    \"  Simulate the robot's movement using the command sequence.\",\n    \"  Track the number of commands executed before the robot falls off the board.\",\n    \"  If the current starting position allows more commands to be executed than previously recorded, update the maximum and the starting position.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board'\n    Explanation: This refers to the grid-like structure of the board where the robot can move. Each cell in the board can be identified by its row and column number.\n\n    'sequence of commands'\n    Explanation: This is the list of movements ('L', 'R', 'D', 'U') that the robot will execute. Each command corresponds to a direction the robot will move.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible'\n    Explanation: This means the robot should execute the maximum number of commands without falling off the board. In code, this involves simulating the robot's movement and counting the number of successful moves.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to simulating the robot's movement and checking if it falls off the board should be implemented simultaneously. Specifically, the simulation of movement and the check for falling off the board should occur in the same loop or function to ensure accurate tracking of the robot's position and the number of commands executed.\n\n# [edge case]\n    Test case with a 1x1 board and a command sequence of 'L' = 1 1\n    Explanation: The robot cannot move anywhere without falling off the board, so the starting position is the only cell available.\n\n    Test case with a 1x2 board and a command sequence of 'R' = 1 1\n    Explanation: The robot can start at the first column and move right once without falling off.\n\n    Test case with a 2x2 board and a command sequence of 'UU' = 2 1\n    Explanation: Starting at the bottom row allows the robot to move up twice without falling off.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include boundary checks to ensure the robot does not move beyond the board's edges. This can be done by checking the robot's position after each move and ensuring it remains within the valid range of rows and columns.\n\n```python\ndef simulate_movement(n, m, commands):\n    max_commands_executed = 0\n    best_start_position = (1, 1)\n    \n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            current_row, current_col = start_row, start_col\n            commands_executed = 0\n            \n", "Round_0": {"code": "def simulate_movement(n, m, commands):\n    # Directions mapping\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    # Initialize the best starting position and maximum commands executed\n    best_start_position = (1, 1)\n    max_commands_executed = 0\n    \n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            current_row, current_col = start_row, start_col\n            commands_executed = 0\n            \n            # Simulate the robot's movement\n            for command in commands:\n                dr, dc = direction_map[command]\n                new_row, new_col = current_row + dr, current_col + dc\n                \n                # Check if the new position is within bounds\n                if 1 <= new_row <= n and 1 <= new_col <= m:\n                    current_row, current_col = new_row, new_col\n                    commands_executed += 1\n                else:\n                    break\n            \n            # Update the best starting position if more commands are executed\n            if commands_executed > max_commands_executed:\n                max_commands_executed = commands_executed\n                best_start_position = (start_row, start_col)\n    \n    return best_start_position\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        commands = data[index]\n        index += 1\n        \n        # Get the best starting position for the current test case\n        best_start_position = simulate_movement(n, m, commands)\n        results.append(best_start_position)\n    \n    # Print the results for each test case\n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t from the input, representing the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the board dimensions.\",\n        \"Read the string s, representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of commands executed and the starting position.\",\n        \"For each possible starting position on the board, simulate the robot's movement according to the command sequence.\",\n        \"Check if the robot moves beyond the board's boundaries after each command.\",\n        \"If the robot falls off the board, stop the simulation for that starting position.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that allows the maximum number of commands to be executed.\",\n      \"steps\": [\n        \"Compare the number of successfully executed commands for each starting position.\",\n        \"Update the maximum number of commands and the corresponding starting position if a better option is found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the row and column of the starting position that allows the maximum number of commands to be executed.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of commands executed.\",\n    \"Determine the starting position that allows the maximum number of commands to be executed.\",\n    \"Output the starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The requirement involves simulating the movement of a robot on a board based on a sequence of commands. The robot can move left, right, up, or down, and the goal is to find the starting position that allows the maximum number of commands to be executed without the robot falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means the robot should execute the maximum number of commands without falling off the board. In code, this involves simulating the robot's movement from each possible starting position and counting the number of commands executed before the robot falls off.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and checking if it falls off the board should be implemented simultaneously. Specifically, the steps \"Simulate the robot's movement according to the command sequence\" and \"Check if the robot moves beyond the board's boundaries after each command\" should be executed in a single loop for each starting position.\n\n# [edge case]\n    Test case with a 1x1 board and a command sequence 'L' = (1, 1)\n    Explanation: On a 1x1 board, any command will cause the robot to fall off immediately, so the starting position is the only cell available.\n    \n    Test case with a 1x2 board and a command sequence 'L' = (1, 2)\n    Explanation: The robot can start at (1, 2) and execute the 'L' command without falling off, as it moves to (1, 1).\n    \n    Test case with a 3x3 board and a command sequence 'RRDLUU' = (2, 1)\n    Explanation: Starting at (2, 1) allows the robot to execute all commands without falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement from each possible starting position inherently handles these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Try each possible starting position\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= row <= n and 1 <= col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the sequence of commands.\",\n      \"output\": \"A list of test cases, each containing the board dimensions and the command sequence.\"\n    },\n    {\n      \"description\": \"For each test case, determine the starting position on the board that allows the robot to execute the maximum number of commands without falling off the board.\",\n      \"output\": \"The optimal starting position (row and column) for each test case.\"\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for a given starting position and command sequence, checking if the robot falls off the board.\",\n      \"output\": \"The number of successfully executed commands for a given starting position.\"\n    },\n    {\n      \"description\": \"Iterate over all possible starting positions on the board to find the one that allows the maximum number of commands to be executed.\",\n      \"output\": \"The starting position that maximizes the number of executed commands.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases from the input.\",\n    \"For each test case, read the board dimensions and the command sequence.\",\n    \"Initialize variables to track the maximum number of commands executed and the corresponding starting position.\",\n    \"For each possible starting position on the board:\",\n    \"  Simulate the robot's movement using the command sequence.\",\n    \"  Count the number of commands executed before the robot falls off the board.\",\n    \"  If this count is greater than the current maximum, update the maximum and the starting position.\",\n    \"Store the optimal starting position for each test case.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board'\n    Explanation: This refers to the grid-like structure of the board where the robot can move. Each cell in the board can be identified by its row and column number.\n\n    'sequence of commands'\n    Explanation: This is the list of movements ('L', 'R', 'D', 'U') that the robot will execute. Each command corresponds to a movement direction.\n\n    'execute as many commands as possible'\n    Explanation: The goal is to find a starting position where the robot can perform the maximum number of movements without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many as possible': This means maximizing the number of commands executed without the robot falling off the board. In code, this involves iterating through possible starting positions and tracking the number of successful commands.\n\n# [degree adverb]\n    'maximum': This refers to the highest number of commands that can be executed from a starting position without the robot falling off the board. In code, this involves comparing the number of commands executed from different starting positions and selecting the highest.\n\n# [code logic]\n    The steps \"Simulate the robot's movement using the command sequence\" and \"Count the number of commands executed before the robot falls off the board\" should be implemented simultaneously. This can be done by iterating through the command sequence and updating the robot's position while checking if it remains within the board boundaries.\n\n# [edge case]\n    Test case with a 1x1 board and any command sequence: The robot will fall off immediately after the first command.\n    Explanation: Since the board is only 1x1, any movement will cause the robot to fall off. The expected output is the starting position (1, 1) with 0 commands executed.\n\n    Test case with a command sequence longer than the board dimensions: The robot will eventually fall off.\n    Explanation: If the command sequence exceeds the board dimensions, the robot will fall off after executing commands equal to the board's perimeter. The expected output is the starting position that allows the maximum perimeter traversal.\n\n    Test case with a command sequence that loops back to the starting position: The robot can execute all commands.\n    Explanation: If the command sequence forms a loop that returns to the starting position, the robot can execute all commands without falling off. The expected output is any starting position that completes the loop.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling", "Round_0": {"code": "def find_starting_position(n, m, commands):\n    # Initialize the starting position and the maximum number of commands executed\n    max_commands = 0\n    best_start = (1, 1)\n\n    # Directions mapping\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n\n    # Iterate over all possible starting positions\n    for start_row in range(1, n + 1):\n        for start_col in range(1, m + 1):\n            # Simulate the robot's movement\n            row, col = start_row, start_col\n            executed_commands = 0\n\n            for command in commands:\n                # Calculate the new position\n                dr, dc = direction_map[command]\n                new_row, new_col = row + dr, col + dc\n\n                # Check if the new position is within the board\n                if 1 <= new_row <= n and 1 <= new_col <= m:\n                    row, col = new_row, new_col\n                    executed_commands += 1\n                else:\n                    break\n\n            # Update the best starting position if more commands are executed\n            if executed_commands > max_commands:\n                max_commands = executed_commands\n                best_start = (start_row, start_col)\n\n    return best_start\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        commands = data[index + 1]\n        index += 2\n\n        # Find the best starting position for this test case\n        best_start = find_starting_position(n, m, commands)\n        results.append(f\"{best_start[0]} {best_start[1]}\")\n\n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the board dimensions and the sequence of commands.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the board dimensions.\",\n        \"Read the string s, representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each starting position to determine the maximum number of commands that can be executed without falling off the board.\",\n      \"steps\": [\n        \"For each test case, iterate over all possible starting positions (r, c) on the board.\",\n        \"For each starting position, simulate the robot's movement according to the command sequence s.\",\n        \"Track the number of successfully executed commands before the robot falls off the board.\",\n        \"Update the maximum number of commands executed and the corresponding starting position if a new maximum is found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the starting position for each test case that allows the robot to execute the maximum number of commands.\",\n      \"steps\": [\n        \"For each test case, output the row and column of the starting position that allows the maximum number of commands to be executed.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement for each starting position and track the number of commands executed.\",\n    \"Determine the starting position that allows the maximum number of commands to be executed.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered rectangular board'\n    This refers to the grid-like structure of the board where the robot can move. Each cell is a potential starting point for the robot.\n\n    'sequence of commands'\n    This is the list of movements ('L', 'R', 'D', 'U') that the robot will execute.\n\n    'falling off the board'\n    This means the robot moves beyond the boundaries of the board, which should be avoided.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible'\n    This indicates the goal is to maximize the number of commands executed without the robot falling off the board.\n\n# [degree adverb]\n    'maximum'\n    This refers to the highest number of commands that can be executed successfully from a starting position.\n\n# [code logic]\n    The plan suggests iterating over all possible starting positions and simulating the robot's movement for each. However, this approach is computationally expensive given the constraints (up to 10^6 for n and m). Instead, we should consider optimizing the simulation by tracking the boundaries of movement and adjusting the starting position accordingly.\n\n# [edge case]\n    Test case with smallest board and single command:\n    1 1\n    R\n    Expected output: 1 1\n    Explanation: The robot cannot move right as it will fall off the board immediately.\n\n    Test case with a board where all commands lead to falling:\n    2 2\n    RRRR\n    Expected output: 1 1\n    Explanation: Any starting position will result in falling off the board after the first command.\n\n    Test case with a board and commands that form a loop:\n    3 3\n    RDLU\n    Expected output: 1 1\n    Explanation: Starting at (1,1) allows the robot to execute all commands without falling.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently by tracking the boundaries of movement and adjusting the starting position dynamically.\n    ```python\n    def find_starting_position(n, m, s):\n        min_r, max_r, min_c, max_c = 0, 0, 0, 0\n        r, c = 0, 0\n        for command in s:\n            if command == 'L':\n                c -= 1\n            elif command == 'R':\n                c += 1\n            elif command == 'U':\n                r -=", "Round_0": {"code": "def find_starting_position(n, m, s):\n    min_r, max_r, min_c, max_c = 0, 0, 0, 0\n    r, c = 0, 0\n    \n    for command in s:\n        if command == 'L':\n            c -= 1\n        elif command == 'R':\n            c += 1\n        elif command == 'U':\n            r -= 1\n        elif command == 'D':\n            r += 1\n        \n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n    \n    start_r = 1 - min_r\n    start_c = 1 - min_c\n    \n    if start_r + max_r > n or start_c + max_c > m:\n        return None\n    \n    return start_r, start_c\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = find_starting_position(n, m, s)\n        if result:\n            results.append(f\"{result[0]} {result[1]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read the integers n and m representing the board dimensions.\",\n        \"Read the string s representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case to determine the optimal starting position.\",\n      \"steps\": [\n        \"Initialize variables to track the maximum number of commands executed and the corresponding starting position.\",\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each starting position, simulate the execution of the command sequence s.\",\n        \"Track the number of commands executed before the robot falls off the board.\",\n        \"Update the maximum number of commands executed and the starting position if the current simulation results in more commands executed.\"\n      ]\n    },\n    {\n      \"description\": \"Output the optimal starting position for each test case.\",\n      \"steps\": [\n        \"For each test case, print the row and column of the starting position that allows the maximum number of commands to be executed.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement from each starting position and track the number of commands executed.\",\n    \"Determine the starting position that allows the maximum number of commands to be executed without the robot falling off the board.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left (L), right (R), down (D), and up (U). The task is to find the starting position on the board that allows the robot to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means the goal is to maximize the number of commands executed without the robot falling off the board. In code, this can be implemented by simulating the robot's movement from each possible starting position and counting the number of commands executed before falling off.\n\n# [degree adverb]\n    'maximum': This refers to the largest number of commands that can be executed from a starting position without the robot falling off the board. In code, this involves keeping track of the highest count of successfully executed commands.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially. However, the simulation of the robot's movement for each starting position (steps in the second subproblem) can be optimized by considering boundary checks simultaneously within the loop that simulates the movement.\n\n# [edge case]\n    Test case with smallest board and single command: \n    1 1\n    R\n    Expected output: 1 1\n    Explanation: The board is 1x1, and any command will cause the robot to fall off immediately. The starting position doesn't matter as the robot can't execute any command successfully.\n\n    Test case with a board where all commands lead to falling off:\n    2 2\n    RRRR\n    Expected output: 1 1\n    Explanation: Starting from any position, the robot will fall off after executing the first command. The starting position doesn't matter as no command can be executed successfully.\n\n    Test case with a board and commands that form a loop:\n    3 3\n    RDLU\n    Expected output: 1 1\n    Explanation: The commands form a loop, allowing the robot to stay within the board. The starting position can be any cell that allows the loop to be executed without falling off.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the board is too small or the commands immediately lead to falling off.\n    ```python\n    if n == 1 and m == 1:\n        print(1, 1)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize the best starting position and max commands executed\n        best_r, best_c = 1, 1\n        max_commands = 0\n        \n        # Try all possible starting positions\n        for start_r in range(1, n + 1):\n            for start_c in range(1, m + 1):\n                r, c = start_r, start_c\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        c -= 1\n                    elif command == 'R':\n                        c += 1\n                    elif command == 'U':\n                        r -= 1\n                    elif command == 'D':\n                        r += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= r <= n and 1 <= c <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_r, best_c = start_r, start_c\n        \n        results.append(f\"{best_r} {best_c}\")\n    \n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences.\",\n      \"steps\": [\n        \"Read the integer t from the input, representing the number of test cases.\",\n        \"For each test case, read the integers n and m, representing the board dimensions.\",\n        \"Read the string s, representing the sequence of commands.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the robot's movement on the board for each test case.\",\n      \"steps\": [\n        \"Initialize variables to track the robot's position and the maximum number of commands executed without falling.\",\n        \"For each possible starting position on the board, simulate the robot's movement according to the command sequence.\",\n        \"Check if the robot falls off the board after each command and stop the simulation if it does.\",\n        \"Track the starting position that allows the maximum number of commands to be executed without falling.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the optimal starting position for the robot.\",\n      \"steps\": [\n        \"Compare the results of the simulations for all possible starting positions.\",\n        \"Select the starting position that allows the maximum number of commands to be executed without falling.\",\n        \"If multiple positions yield the same result, choose any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the row and column of the optimal starting position.\",\n        \"Ensure the output format matches the specified requirements.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test case data.\",\n    \"For each test case, simulate the robot's movement from all possible starting positions.\",\n    \"Track the starting position that allows the maximum number of commands to be executed without falling.\",\n    \"Output the optimal starting position for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The robot can move in four directions: left (L), right (R), down (D), and up (U). The task is to determine the starting position on the board that allows the robot to execute the maximum number of commands without falling off the board.\n\n# [phrase showing quantity relationship]\n    'as many commands as possible': This means the goal is to maximize the number of commands executed without the robot falling off the board. In code, this involves simulating the robot's movement from different starting positions and counting the number of successful commands.\n\n# [degree adverb]\n    'maximum': This refers to the largest number of commands that can be executed without the robot falling off the board. In code, this involves keeping track of the highest count of successful commands for each starting position.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and checking if it falls off the board should be implemented simultaneously. Specifically, the simulation of movement and the check for falling should occur within the same loop or function to efficiently track the robot's position and the number of commands executed.\n\n# [edge case]\n    1 1 L = 1 1\n    Explanation: On a 1x1 board, any command will cause the robot to fall off immediately, so the starting position doesn't matter; the robot will execute zero commands successfully.\n\n    2 2 U = 1 1\n    Explanation: On a 2x2 board, starting at (1,1) and moving up will cause the robot to fall off immediately, so the robot should start at (1,1) to execute zero commands successfully.\n\n    3 3 RRR = 1 1\n    Explanation: On a 3x3 board, starting at (1,1) and moving right three times will cause the robot to fall off after the third command, so the robot should start at (1,1) to execute two commands successfully.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include checks for the board boundaries during the simulation of the robot's movement to ensure the robot does not fall off the board. This can be done by checking the robot's position after each command and stopping the simulation if the position is outside the board dimensions.\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        # Initialize variables to track the best starting position\n        max_commands = 0\n        best_start = (1, 1)\n        \n        # Simulate the robot's movement\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                row, col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        col -= 1\n                    elif command == 'R':\n                        col += 1\n                    elif command == 'U':\n                        row -= 1\n                    elif command == 'D':\n                        row += 1\n                    \n                    # Check if the robot falls off the board\n                    if row < 1 or row > n or col < 1 or col > m:\n                        break\n                    commands_executed += 1\n                \n                # Update the best starting position if this one is better\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n        \n        results.append(f\"{best_start[0]} {best_start[1]}\")\n    \n    # Output the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, true, false, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 699, "prompt": "The robot is positioned on a checkered rectangular board of dimensions n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot can move to one of the four neighboring cells by the side from its present position.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U'. These symbol commands are responsible for triggering movement to the left, right, down, or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will cause him to cross over the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 328}
