{"name": "1582_A. Luntik and Concerts", "description": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "tags": ["math"], "difficulty": 7, "id": 1582, "sample_io": [{"input": "4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}], "test_list": [{"input": "4\n1 1 1\n2 1 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 5\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 1 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 4\n2 2 2\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n4 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 8\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 7\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 5\n1 2 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n2 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 3 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 1 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n3 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 4 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 3\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 0\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 1\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 5\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 1 1\n4 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 2 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 5 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 6\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 6\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 3\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 3\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n2 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 2\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 0\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 4 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 6\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 3 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n4 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n4 2 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 0\n5 2 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n12 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n4 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 0 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 4 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 10\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n2 4 5\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n11 4 9\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n9 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 6\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 1 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n1 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n3 1 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 4 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 0\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 4 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 1\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n2 3 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n4 1 2\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 7 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n6 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 0\n4 3 2\n3 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n3 4 5\n1 1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n2 2 0\n0 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 8\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 13\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 1\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 1\n0 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 6 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n4 3 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 2 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 5 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 10\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 2 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 1 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n3 2 1\n1 4 0\n1 1 0\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 3\n2 2 1\n3 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 4\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 8 5\n2 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n2 1 1\n3 3 1\n6 4 3\n1 1 3\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 2\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}], "task_id": "codecontest/28", "repair_prompt": ["Luntik has decided to try singing. He possesses a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He aims to minimize the absolute difference in durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please assist Luntik and determine the minimal possible difference in minutes between the concerts durations. Note that Luntik can choose how to distribute each song freely to achieve the smallest difference in concert durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Luntik has decided to try singing. He possesses a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He aims to minimize the absolute difference in durations of the concerts. He wants to make the difference as small as it is possible for him to make. The duration of the concert is the sum of durations of all songs in that concert. Please assist Luntik and determine the minimal possible difference in minutes between the concerts durations. Note that Luntik can choose how to distribute each song freely to achieve the smallest difference in concert durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Luntik has decided to try singing. He possesses a one-minute songs, b two-minute songs and c three-minute songs, and he wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He aims to minimize the absolute difference in durations of the concerts as much as possible, with the duration of the concert being the sum of durations of all songs in that concert. Please assist Luntik and determine the minimal possible difference in minutes between the concerts durations. Note that Luntik can choose how to distribute each song freely to achieve the smallest difference in concert durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The problem can be reduced to finding the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        \n        # Initialize a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "completions": ["def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n        else:\n            # If total duration is even, the minimal difference is 0\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is odd, the minimal difference is 1\n        # If total duration is even, the minimal difference is 0\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 == 1:\n            results.append(1)\n        else:\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If there are no songs, the difference is 0\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # If there is only one song, the difference is the duration of that song\n        if a + b + c == 1:\n            results.append(min(a, b, c))\n            continue\n        \n        # Calculate the minimal possible difference\n        # We need to find the closest sum to total_duration / 2\n        half_duration = total_duration // 2\n        min_difference = total_duration\n        \n        # Use dynamic programming to find the closest sum to half_duration\n        possible_sums = {0}\n        \n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        for sum1 in possible_sums:\n            sum2 = total_duration - sum1\n            difference = abs(sum1 - sum2)\n            min_difference = min(min_difference, difference)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n        else:\n            # If the total duration is even, the minimal difference is 0\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a DP array to track possible sums\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to half of the total duration\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                min_diff = total_duration - 2 * i\n                results.append(min_diff)\n                break\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find the closest sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 0 and b == 0:\n            results.append(c % 2 * 3)\n            continue\n        if a == 0 and c == 0:\n            results.append(b % 2 * 2)\n            continue\n        if b == 0 and c == 0:\n            results.append(a % 2)\n            continue\n        \n        # General case\n        # The minimal difference is the remainder when total_duration is divided by 2\n        results.append(total_duration % 2)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n            continue\n        \n        # If the total duration is even, we need to check if we can split it evenly\n        half_duration = total_duration // 2\n        \n        # Check if it's possible to achieve exactly half_duration using the given songs\n        # We use a greedy approach to check if we can reach exactly half_duration\n        possible = False\n        \n        # Try to reach half_duration using 3-minute songs first\n        max_three_minute_songs = min(c, half_duration // 3)\n        remaining_duration = half_duration - max_three_minute_songs * 3\n        \n        # Try to reach the remaining duration using 2-minute songs\n        max_two_minute_songs = min(b, remaining_duration // 2)\n        remaining_duration -= max_two_minute_songs * 2\n        \n        # Try to reach the remaining duration using 1-minute songs\n        if remaining_duration <= a:\n            possible = True\n        \n        # If possible, the minimal difference is 0, otherwise it's 1\n        if possible:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The problem can be reduced to finding the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        \n        # Initialize a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers a, b, c representing the number of one-minute, two-minute, and three-minute songs.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total duration as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference.\",\n        \"Use a dynamic programming approach to explore all possible distributions of songs between two concerts.\",\n        \"Iterate over possible total durations for one concert and calculate the difference with the other concert.\",\n        \"Update the minimal difference if a smaller difference is found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal difference calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"Implement a dynamic programming solution to find the minimal possible difference in concert durations.\",\n    \"Output the minimal difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the event where songs are distributed, and the goal is to balance the duration of songs between two concerts.\n    'absolute difference': means the non-negative difference between the durations of two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': these phrases indicate the duration of each type of song. They are used to calculate the total duration of songs in each concert.\n    Implementation: Use multiplication to calculate the total duration for each type of song (e.g., `total_duration = a * 1 + b * 2 + c * 3`).\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n    Implementation: Use a dynamic programming approach to explore all possible distributions and find the smallest difference.\n\n# [code logic]\n    The steps for calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, the dynamic programming approach should be integrated with the calculation of total duration to efficiently find the minimal difference.\n\n# [edge case]\n    Test case: 1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it can only be placed in one concert.\n    \n    Test case: 0 0 0 = 0\n    Explanation: With no songs, the difference is 0 as both concerts have a duration of 0.\n    \n    Test case: 1 1 0 = 1\n    Explanation: With one one-minute song and one two-minute song, the minimal difference is 1 by placing the one-minute song in one concert and the two-minute song in the other.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    Example code:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n    elif a + b + c == 1:\n        print(min(a, b, c))\n    else:\n        # Implement dynamic programming solution\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        elif a + b + c == 1:\n            results.append(min(a, b, c))\n            continue\n        \n        # Dynamic programming approach\n        # We can use a set to track possible durations for one concert\n        possible_durations = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the minimal difference\n        min_difference = float('inf')\n        for duration in possible_durations:\n            other_concert_duration = total_duration - duration\n            min_difference = min(min_difference, abs(duration - other_concert_duration))\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The problem can be reduced to finding the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        \n        # Initialize a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each duration for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference.\",\n        \"Iterate over possible distributions of songs between two concerts.\",\n        \"Calculate the duration of each concert based on the distribution.\",\n        \"Compute the absolute difference between the durations of the two concerts.\",\n        \"Update the minimal difference if the current difference is smaller.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal difference calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in concert durations by exploring possible distributions of songs.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimize the absolute difference'\n    Explanation: The goal is to distribute the songs between two concerts such that the absolute difference in their total durations is as small as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': These phrases indicate the duration of each type of song. In code, this translates to multiplying the count of each type of song by its respective duration to get the total duration.\n    'as much as possible': This implies finding the smallest possible value for the difference, which involves exploring all possible distributions of songs.\n\n# [degree adverb] \n    'minimal': This indicates that the solution should aim for the smallest possible difference in concert durations.\n\n# [code logic]\n    The steps in the plan related to calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, the calculation of total duration and the exploration of possible distributions should be integrated to efficiently find the minimal difference.\n\n# [edge case] \n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, the difference will be 1 since it must be assigned to one concert.\n    \n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: If there are no songs, the difference is naturally 0 as there are no durations to compare.\n    \n    Edge Case 3: (1, 1, 1) = 0\n    Explanation: As given in the example, one possible distribution is one one-minute song and one two-minute song in one concert, and one three-minute song in the other, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to handle cases where there are no songs or only one type of song, as these can be directly solved without iterating over distributions.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return a * 1 + b * 2 + c * 3\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n        else:\n            # If total duration is even, the minimal difference is 0\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each duration for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line of input, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference.\",\n        \"Iterate over possible distributions of songs between two concerts.\",\n        \"Calculate the duration of each concert based on the distribution.\",\n        \"Compute the absolute difference between the durations of the two concerts.\",\n        \"Update the minimal difference if the current difference is smaller.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal difference calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, iterate over possible distributions of songs to minimize the difference in concert durations.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimize the absolute difference'\n    Explanation: The goal is to distribute the songs between two concerts such that the absolute difference in their total durations is as small as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': These phrases indicate the duration of each type of song. In code, this is represented by multiplying the count of each type of song by its duration (1, 2, or 3) to get the total duration.\n\n# [degree adverb] \n    'minimal': This indicates that we need to find the smallest possible difference in durations between the two concerts.\n\n# [code logic]\n    The steps in the plan related to calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, the steps:\n    - \"Calculate the duration of each concert based on the distribution.\"\n    - \"Compute the absolute difference between the durations of the two concerts.\"\n    - \"Update the minimal difference if the current difference is smaller.\"\n    These steps can be implemented in a loop that iterates over possible distributions of songs.\n\n# [edge case] \n    1 0 0 = 1\n    Explanation: With only one one-minute song, the best distribution is to place it in one concert, resulting in a difference of 1.\n    \n    0 0 0 = 0\n    Explanation: With no songs, the difference is naturally 0.\n    \n    1 1 1 = 0\n    Explanation: As explained in the example, distributing one one-minute and one two-minute song in one concert and the three-minute song in the other results in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return max(a, b, c)\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is odd, the minimal difference is 1\n        # If total duration is even, the minimal difference is 0\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Given a, b, c, calculate the total duration as total_duration = a * 1 + b * 2 + c * 3.\"\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"details\": \"The target duration for each concert is half of the total duration, i.e., target_duration = total_duration / 2.\"\n    },\n    {\n      \"description\": \"Distribute songs to minimize the difference in concert durations.\",\n      \"details\": \"Use a strategy to distribute songs such that the absolute difference between the durations of the two concerts is minimized.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference.\",\n      \"details\": \"Compute the absolute difference between the durations of the two concerts after distribution.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases, t.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Read the values of a, b, c.\",\n    \"  - Calculate the total duration of all songs.\",\n    \"  - Determine the target duration for each concert.\",\n    \"  - Implement a strategy to distribute songs to minimize the difference in concert durations.\",\n    \"  - Calculate and store the minimal possible difference for the current test case.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimize the absolute difference'\n    Explanation: The goal is to distribute the songs between two concerts such that the absolute difference in their total durations is as small as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its duration (1, 2, or 3) to get the total duration.\n    'half of the total duration': This indicates that the target duration for each concert is half of the total duration of all songs. In code, this can be calculated as `total_duration / 2`.\n\n# [degree adverb]\n    'minimal': This indicates that the goal is to achieve the smallest possible difference in concert durations. In code, this involves finding a distribution of songs that results in the smallest absolute difference.\n\n# [code logic]\n    The steps \"Calculate the total duration of all songs\" and \"Determine the target duration for each concert\" can be implemented simultaneously as they are both preparatory calculations before the main logic of distributing songs.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, the best distribution is one concert with the song and the other empty, resulting in a difference of 1.\n    \n    0 0 0 = 0\n    Explanation: With no songs, both concerts have a duration of 0, resulting in a difference of 0.\n    \n    1 1 1 = 0\n    Explanation: As given in the example, one possible distribution is one one-minute song and one two-minute song in one concert, and the three-minute song in the other, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the total number of songs is very small or zero.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return min(a, b * 2, c * 3)\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 == 1:\n            results.append(1)\n        else:\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the input, which represent the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference.\",\n        \"Iterate over possible distributions of songs between two concerts.\",\n        \"Calculate the duration of each concert based on the distribution.\",\n        \"Compute the absolute difference between the durations of the two concerts.\",\n        \"Update the minimal difference if the current difference is smaller.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in concert durations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in concert durations by exploring possible distributions of songs.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The requirement is to minimize the absolute difference in durations between two concerts, meaning the difference should be non-negative and as small as possible.\n\n    'distribute all songs into two concerts'\n    Explanation: Each song must be assigned to one of the two concerts, and the goal is to balance the total duration of songs in each concert.\n\n# [phrase showing quantity relationship]\n    'minimal possible difference'\n    Explanation: The requirement is to find the smallest possible difference in total durations between the two concerts. This involves exploring different distributions of songs to achieve the smallest difference.\n\n# [degree adverb]\n    'minimal'\n    Explanation: The requirement is to achieve the smallest possible difference in concert durations. This means finding the optimal distribution of songs to minimize the difference.\n\n# [code logic]\n    The steps for calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, the iteration over possible distributions and calculation of differences should be done in a single code block to efficiently find the minimal difference.\n\n# [edge case]\n    Test case: 1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it must be assigned to one concert, leaving the other concert with a duration of 0.\n\n    Test case: 0 0 0 = 0\n    Explanation: With no songs, both concerts have a duration of 0, resulting in a minimal difference of 0.\n\n    Test case: 1 1 0 = 1\n    Explanation: With one one-minute song and one two-minute song, the minimal difference is 1 by assigning the one-minute song to one concert and the two-minute song to the other.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the logic accounts for cases where there are no songs or only one type of song.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n    elif a + b + c == 1:\n        print(min(a, b, c))\n    else:\n        # Original logic for distributing songs\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If there are no songs, the difference is 0\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # If there is only one song, the difference is the duration of that song\n        if a + b + c == 1:\n            results.append(min(a, b, c))\n            continue\n        \n        # Calculate the minimal possible difference\n        # We need to find the closest sum to total_duration / 2\n        half_duration = total_duration // 2\n        min_difference = total_duration\n        \n        # Iterate over possible distributions\n        for x in range(a + 1):\n            for y in range(b + 1):\n                for z in range(c + 1):\n                    concert1_duration = x * 1 + y * 2 + z * 3\n                    concert2_duration = total_duration - concert1_duration\n                    difference = abs(concert1_duration - concert2_duration)\n                    min_difference = min(min_difference, difference)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If there are no songs, the difference is 0\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # If there is only one song, the difference is the duration of that song\n        if a + b + c == 1:\n            results.append(min(a, b, c))\n            continue\n        \n        # Calculate the minimal possible difference\n        # We need to find the closest sum to total_duration / 2\n        half_duration = total_duration // 2\n        min_difference = total_duration\n        \n        # Use dynamic programming to find the closest sum to half_duration\n        possible_sums = {0}\n        \n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        for sum1 in possible_sums:\n            sum2 = total_duration - sum1\n            difference = abs(sum1 - sum2)\n            min_difference = min(min_difference, difference)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the input, which represent the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference.\",\n        \"Iterate over possible distributions of songs between two concerts.\",\n        \"Calculate the duration of each concert based on the distribution.\",\n        \"Compute the absolute difference between the durations of the two concerts.\",\n        \"Update the minimal difference if the current difference is smaller.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in concert durations by exploring possible distributions of songs.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the two separate events where songs are distributed.\n    'absolute difference': the non-negative difference between the total durations of the two concerts.\n    Explanation: The task is to distribute songs into two concerts such that the absolute difference in their total durations is minimized.\n\n# [phrase showing quantity relationship]\n    'as much as possible': indicates the goal is to minimize the difference to the smallest possible value.\n    'sum of durations': refers to the total time of songs in each concert.\n    Implementation: Use arithmetic operations to calculate the total duration and compare differences.\n\n# [degree adverb]\n    'minimal': means the smallest possible value.\n    Implementation: Use a loop or algorithm to find the smallest difference by exploring all possible distributions.\n\n# [code logic]\n    The steps in the plan related to calculating the total duration and determining the minimal difference should be considered simultaneously. Specifically, iterating over possible distributions and calculating differences should be done in a single loop or recursive function to efficiently find the minimal difference.\n\n# [edge case]\n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it must be placed in one concert.\n    \n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: No songs to distribute, so the difference is 0.\n    \n    Edge Case 3: (1, 1, 1) = 0\n    Explanation: Distribute one-minute and two-minute songs in one concert and the three-minute song in the other, resulting in equal durations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no songs are present or when the distribution is straightforward.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n    else:\n        # Implement logic to find minimal difference\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n        else:\n            # If the total duration is even, the minimal difference is 0\n            results.append(0)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, and c, which represent the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference, starting with a large value.\",\n        \"Use a dynamic programming approach to explore all possible distributions of songs between two concerts.\",\n        \"Iterate over possible sums of durations for one concert and calculate the corresponding sum for the other concert.\",\n        \"Update the minimal difference if a smaller difference is found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in durations between the two concerts.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference in durations between two concerts.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimal possible difference'\n    Explanation: The goal is to distribute the songs between two concerts such that the absolute difference in their total durations is minimized.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its duration (1, 2, or 3) to get the total duration.\n\n# [degree adverb] \n    'minimal'\n    Explanation: This indicates that the solution should aim to achieve the smallest possible difference in concert durations. In code, this can be implemented by iterating over possible distributions and updating the minimal difference found.\n\n# [code logic]\n    The steps in the subproblem \"Determine the minimal possible difference in durations between two concerts\" should be implemented simultaneously. Specifically, the dynamic programming approach involves iterating over possible sums and updating the minimal difference in one cohesive block of logic.\n\n# [edge case] \n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, the minimal difference is 1, as it must be assigned to one concert.\n    \n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: If there are no songs, the difference is naturally 0 since both concerts have a duration of 0.\n    \n    Edge Case 3: (1, 1, 1) = 0\n    Explanation: As given in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n        continue\n    if a + b + c == 1:\n        print(abs(a * 1 + b * 2 + c * 3))\n        continue\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We can only achieve half of the total duration at most in one concert\n        half_duration = total_duration // 2\n        \n        # Initialize a DP array to track possible sums\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to half of the total duration\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                min_diff = total_duration - 2 * i\n                results.append(min_diff)\n                break\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a DP array to track possible sums\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to half of the total duration\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                min_diff = total_duration - 2 * i\n                results.append(min_diff)\n                break\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each duration for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line of input, representing the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference.\",\n        \"Iterate over possible distributions of songs between two concerts.\",\n        \"Calculate the duration of each concert based on the distribution.\",\n        \"Compute the absolute difference between the durations of the two concerts.\",\n        \"Update the minimal difference if the current difference is smaller.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in durations between two concerts by exploring possible distributions of songs.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimize the absolute difference'\n    Explanation: The goal is to distribute the songs between two concerts such that the absolute difference in their total durations is as small as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its duration (1, 2, or 3) to get the total duration.\n\n# [degree adverb] \n    'minimal possible difference'\n    Explanation: This means finding the smallest possible value for the absolute difference between the durations of the two concerts. In code, this involves iterating over possible distributions and keeping track of the smallest difference found.\n\n# [code logic]\n    The steps in the plan related to calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, the steps:\n    - \"Calculate the duration of each concert based on the distribution.\"\n    - \"Compute the absolute difference between the durations of the two concerts.\"\n    - \"Update the minimal difference if the current difference is smaller.\"\n    These steps can be implemented in a loop that iterates over possible distributions of songs.\n\n# [edge case] \n    1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it must be placed in one concert.\n    \n    0 0 0 = 0\n    Explanation: With no songs, the difference is 0 as both concerts have a duration of 0.\n    \n    1 1 1 = 0\n    Explanation: As explained in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return a * 1 + b * 2 + c * 3\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find the closest sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find the closest sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Given the number of one-minute, two-minute, and three-minute songs, calculate the total duration by summing up the products of the number of songs and their respective durations.\"\n    },\n    {\n      \"description\": \"Determine the possible distributions of songs between two concerts.\",\n      \"details\": \"Explore different combinations of distributing songs into two groups to minimize the absolute difference in their total durations.\"\n    },\n    {\n      \"description\": \"Calculate the absolute difference in durations for each distribution.\",\n      \"details\": \"For each possible distribution, calculate the absolute difference between the total durations of the two concerts.\"\n    },\n    {\n      \"description\": \"Find the minimal possible difference.\",\n      \"details\": \"Identify the distribution that results in the smallest absolute difference in concert durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Read the number of one-minute, two-minute, and three-minute songs.\",\n    \"  - Calculate the total duration of all songs.\",\n    \"  - Explore different distributions of songs between two concerts.\",\n    \"  - Calculate the absolute difference in durations for each distribution.\",\n    \"  - Track the minimal possible difference across all distributions.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The requirement is to minimize the absolute difference in durations between two concerts, meaning the difference should be non-negative and as small as possible.\n\n    'distribute all songs into two concerts'\n    Explanation: Each song must be assigned to one of the two concerts, ensuring that all songs are used.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. The total duration of songs in a concert is calculated by multiplying the number of songs by their respective durations.\n\n# [degree adverb] \n    'minimal possible difference'\n    Explanation: The goal is to achieve the smallest possible difference in concert durations. This requires exploring all possible distributions of songs to find the one that results in the least difference.\n\n# [code logic]\n    The steps related to exploring different distributions and calculating the absolute difference should be considered simultaneously. This involves iterating through possible combinations of song distributions and calculating the difference in durations for each.\n\n# [edge case] \n    Test case: 1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1, as it can only be placed in one concert.\n    \n    Test case: 0 0 0 = 0\n    Explanation: No songs are present, so the difference is 0.\n    \n    Test case: 1 1 0 = 1\n    Explanation: With one one-minute song and one two-minute song, the minimal difference is 1, as they can be split into two concerts with durations 1 and 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the number of songs is zero or when only one type of song is present.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a == 0 and b == 0:\n        return c % 2 * 3\n    if a == 0 and c == 0:\n        return b % 2 * 2\n    if b == 0 and c == 0:\n        return a % 2\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 0 and b == 0:\n            results.append(c % 2 * 3)\n            continue\n        if a == 0 and c == 0:\n            results.append(b % 2 * 2)\n            continue\n        if b == 0 and c == 0:\n            results.append(a % 2)\n            continue\n        \n        # General case\n        # The minimal difference is the remainder when total_duration is divided by 2\n        results.append(total_duration % 2)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each duration for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line of input, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in concert durations.\",\n      \"steps\": [\n        \"For each test case, attempt to distribute the songs into two concerts such that the absolute difference in their durations is minimized.\",\n        \"Use a strategy to balance the total duration between two concerts, possibly using a greedy or dynamic programming approach to achieve the minimal difference.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the calculated minimal possible difference in minutes between the durations of the two concerts.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"Implement a method to distribute songs into two concerts to minimize the duration difference.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimize the absolute difference'\n    Explanation: The goal is to distribute the songs between two concerts such that the absolute difference in their total durations is as small as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its duration to get the total duration.\n\n# [degree adverb] \n    'minimal possible difference'\n    Explanation: This means finding the smallest possible difference in the total durations of the two concerts. In code, this involves finding a distribution of songs that results in the smallest absolute difference.\n\n# [code logic]\n    The steps in the plan related to calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, the calculation of total duration and the strategy to distribute songs to minimize the difference should be integrated, possibly using a dynamic programming approach to balance the durations.\n\n# [edge case] \n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, the best distribution is to place it in one concert, resulting in a difference of 1.\n    \n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: With no songs, the difference is naturally 0 as both concerts have a duration of 0.\n    \n    Edge Case 3: (1, 1, 1) = 0\n    Explanation: As explained in the example, distributing one one-minute song and one two-minute song in one concert and the three-minute song in the other results in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when there are no songs or when the distribution is straightforward.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split the total_duration into two parts as evenly as possible\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n        \n        # Initialize a set to store possible sums we can achieve\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to target\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is odd, the minimal difference is 1\n        if total_duration % 2 != 0:\n            results.append(1)\n            continue\n        \n        # If the total duration is even, we need to check if we can split it evenly\n        half_duration = total_duration // 2\n        \n        # Check if it's possible to achieve exactly half_duration using the given songs\n        # We use a greedy approach to check if we can reach exactly half_duration\n        possible = False\n        \n        # Try to reach half_duration using 3-minute songs first\n        max_three_minute_songs = min(c, half_duration // 3)\n        remaining_duration = half_duration - max_three_minute_songs * 3\n        \n        # Try to reach the remaining duration using 2-minute songs\n        max_two_minute_songs = min(b, remaining_duration // 2)\n        remaining_duration -= max_two_minute_songs * 2\n        \n        # Try to reach the remaining duration using 1-minute songs\n        if remaining_duration <= a:\n            possible = True\n        \n        # If possible, the minimal difference is 0, otherwise it's 1\n        if possible:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers a, b, c representing the number of one-minute, two-minute, and three-minute songs.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total duration as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, initialize a variable to store the minimal difference.\",\n        \"Use a dynamic programming approach to explore all possible distributions of songs between two concerts.\",\n        \"Iterate over possible total durations for one concert and calculate the difference with the other concert.\",\n        \"Update the minimal difference if a smaller difference is found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal difference calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"Implement a dynamic programming solution to find the minimal possible difference in concert durations.\",\n    \"Output the minimal difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concert': refers to the event where songs are distributed, and the goal is to balance the duration of songs between two concerts.\n    'absolute difference': means the non-negative difference between the durations of two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': these phrases indicate the duration of each type of song. They are used to calculate the total duration of songs in each concert.\n    Implementation: Use multiplication to calculate the total duration for each type of song (e.g., `total_duration = a * 1 + b * 2 + c * 3`).\n\n# [degree adverb]\n    'minimal': means the smallest possible difference between the durations of the two concerts.\n    Implementation: Use a dynamic programming approach to explore all possible distributions and find the smallest difference.\n\n# [code logic]\n    The steps for calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, the dynamic programming approach should be integrated with the calculation of total duration to efficiently find the minimal difference.\n\n# [edge case]\n    Test case: 1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it can only be placed in one concert.\n    \n    Test case: 0 0 0 = 0\n    Explanation: With no songs, the difference is 0 as both concerts have a duration of 0.\n    \n    Test case: 1 1 0 = 1\n    Explanation: With one one-minute song and one two-minute song, the minimal difference is 1 by placing the one-minute song in one concert and the two-minute song in the other.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    Example code:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n    elif a + b + c == 1:\n        print(min(a, b, c))\n    else:\n        # Implement dynamic programming solution\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        elif a + b + c == 1:\n            results.append(min(a, b, c))\n            continue\n        \n        # Dynamic programming approach\n        # We can use a set to track possible durations for one concert\n        possible_durations = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the minimal difference\n        min_difference = float('inf')\n        for duration in possible_durations:\n            other_concert_duration = total_duration - duration\n            min_difference = min(min_difference, abs(duration - other_concert_duration))\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The problem can be reduced to finding the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        \n        # Initialize a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 320, "prompt": "Luntik has decided to try singing. He possesses a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He aims to minimize the absolute difference in durations of the concerts as much as possible. The duration of the concert is the sum of durations of all songs in that concert. Please assist Luntik and determine the minimal possible difference in minutes between the concerts durations. Note that Luntik can choose how to distribute each song freely to achieve the smallest difference in concert durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 167}
