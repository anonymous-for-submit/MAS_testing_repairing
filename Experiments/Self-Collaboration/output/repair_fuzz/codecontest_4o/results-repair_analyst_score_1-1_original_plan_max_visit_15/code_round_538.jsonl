{"name": "1619_H. Permutation and Queries", "description": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y. \n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times. \n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "tags": ["brute force", "data structures", "divide and conquer", "two pointers"], "difficulty": 14, "id": 1619, "sample_io": [{"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}], "test_list": [{"input": "1 1\n1\n2 1 1\n", "output": ["1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n6\n8\n9\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 3\n2 1 2\n", "output": ["4\n1\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n59\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n1\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 7 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 1 2\n", "output": ["4\n4\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n1\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["4\n2\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 22\n2 1 72\n2 65 13\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["21\n6\n57\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n7\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n3\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 9\n1 3 6\n", "output": ["10\n6\n8\n7\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 2 72\n2 65 8\n1 18 37\n1 19 89\n1 86 3\n2 36 69\n1 100 59\n", "output": ["71\n16\n40\n54\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 2 3\n2 1 2\n", "output": ["4\n4\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 44 44\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["64\n6\n40\n54\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n3\n1\n2\n3\n3\n5\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 4\n1 1 2\n2 1 2\n", "output": ["3\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n1\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 3 6\n", "output": ["7\n6\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n8\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 83 22\n2 1 72\n2 65 10\n1 18 37\n1 19 89\n1 86 6\n2 36 69\n1 100 59\n", "output": ["19\n6\n47\n54\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n2 1 3\n2 1 2\n", "output": ["4\n1\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 1\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n4\n3\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 2\n1 1 3\n2 2 2\n", "output": ["4\n4\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n4\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n6\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n9\n7\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 5 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n2\n2\n3\n1\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n2 1 3\n1 1 2\n2 1 2\n", "output": ["3\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["10\n3\n7\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n3\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n6\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n3\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 5 6\n2 5 9\n2 8 2\n1 3 6\n", "output": ["10\n6\n9\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n1\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n4\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 3\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n4\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n7\n5\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n1\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n6\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 0\n1 4 6\n2 5 9\n2 9 8\n1 3 7\n", "output": ["10\n9\n9\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n2 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["3\n1\n4\n2\n4\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n7\n6\n10\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n8\n8\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n7\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n2 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n2 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n2\n2\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 0\n", "output": ["4\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n2 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n4\n8\n7\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 4 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n4\n4\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 3\n2 1 72\n2 65 8\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["55\n6\n40\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 2\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 2\n", "output": ["4\n2\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n4\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 8\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["10\n9\n4\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 7 6\n1 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 0\n1 1 4\n1 1 2\n2 1 2\n", "output": ["3\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n2 1 3\n2 1 2\n", "output": ["4\n4\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n2\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n6\n8\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 7 6\n2 3 3\n1 6 2\n2 5 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n5\n3\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 2 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 2\n", "output": ["3\n5\n1\n2\n3\n5\n3\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 1 3\n2 5 8\n1 5 4\n2 5 3\n2 2 7\n2 5 1\n", "output": ["3\n5\n1\n5\n2\n3\n1\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 10\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 1 8\n1 3 6\n", "output": ["7\n6\n7\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 6\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 8 8\n1 4 6\n", "output": ["2\n3\n7\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n8\n4\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n8\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 9\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n6\n10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 4\n1 7 6\n2 3 3\n1 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n7\n4\n5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 0\n1 3 6\n2 6 9\n2 8 6\n2 4 6\n", "output": ["2\n6\n9\n6\n8\n4\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 5\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n2 3 6\n", "output": ["10\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 4\n1 1 2\n2 9 5\n1 4 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n3\n4\n5\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 3\n2 1 1\n", "output": ["4\n2\n5\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 2\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n1\n2\n3\n3\n5\n2\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 0\n2 5 4\n1 5 1\n2 1 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n5\n3\n4\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 3 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n1\n5\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n5\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n2 1 2\n2 1 1\n", "output": ["4\n2\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n2 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n8\n1\n5\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 0\n2 1 2\n2 1 1\n", "output": ["4\n3\n1\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 6\n1 9 6\n1 4 3\n1 6 2\n2 9 5\n1 4 6\n2 5 9\n2 10 10\n1 3 6\n", "output": ["10\n6\n5\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 5\n2 8 10\n1 3 8\n", "output": ["10\n6\n5\n2\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 9 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n8\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n1 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n", "output": ["3\n5\n4\n2\n2\n2\n4\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 13\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 1\n2 36 69\n1 100 59\n", "output": ["33\n89\n40\n94\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n8\n6\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n1 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["95\n40\n32\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 4 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n1\n2\n4\n3\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 1\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n4\n4\n2\n3\n3\n1\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 2\n1 2 3\n2 1 2\n", "output": ["4\n2\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 2 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n2\n4\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n7\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 8 8\n1 3 6\n", "output": ["10\n9\n8\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n2 7 6\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 8\n2 9 8\n1 3 6\n", "output": ["10\n9\n6\n9\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 1 2\n2 9 4\n1 4 6\n1 8 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n9\n2\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["4\n5\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 3 4\n1 1 4\n2 1 2\n", "output": ["4\n4\n3\n"]}, {"input": "5 2\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 4 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n2 5 8\n2 9 8\n1 3 6\n", "output": ["10\n6\n8\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 3\n2 4 8\n1 3 6\n", "output": ["10\n6\n8\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 7 6\n1 7 9\n2 3 1\n1 6 2\n2 9 5\n1 4 6\n2 4 9\n2 8 8\n1 5 6\n", "output": ["7\n4\n7\n8\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n3\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 6\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n4\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 1 3\n2 1 3\n2 1 2\n", "output": ["4\n5\n5\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 4 5\n2 1 1\n2 5 3\n2 1 4\n1 5 2\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n4\n2\n2\n4\n3\n1\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 10\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["2\n6\n3\n5\n10\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 17\n2 4 2\n", "output": ["3\n5\n4\n2\n3\n5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n5\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 7 5\n1 1 6\n1 7 10\n2 3 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n1 3 6\n", "output": ["7\n3\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 4 5\n1 6 2\n2 9 0\n1 4 6\n1 5 9\n2 9 8\n1 3 7\n", "output": ["10\n2\n9\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 4 1\n2 5 3\n2 5 8\n1 5 4\n1 5 3\n2 2 7\n2 5 2\n", "output": ["3\n5\n1\n2\n2\n3\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n6\n8\n4\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 7 6\n1 4 6\n2 5 9\n2 8 10\n1 3 6\n", "output": ["10\n6\n3\n8\n8\n"]}, {"input": "5 7\n2 3 5 1 4\n1 3 5\n2 5 7\n2 5 1\n2 5 3\n2 5 6\n1 5 4\n2 5 2\n2 2 7\n2 4 1\n", "output": ["5\n5\n5\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["10\n6\n9\n4\n2\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n1 5 3\n2 1 4\n1 5 1\n2 5 3\n2 2 7\n2 4 1\n", "output": ["3\n5\n4\n1\n4\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 0\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n5\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 1\n1 6 2\n2 9 4\n2 1 6\n1 7 9\n2 9 22\n1 3 6\n", "output": ["10\n4\n8\n6\n8\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 4 3\n2 5 4\n1 5 1\n2 5 3\n2 4 12\n2 4 1\n", "output": ["3\n5\n4\n3\n3\n5\n4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 4\n1 5 1\n2 5 3\n2 2 10\n2 4 3\n", "output": ["3\n5\n1\n2\n3\n5\n3\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 6 9\n2 9 8\n1 4 6\n", "output": ["2\n6\n7\n6\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n2 6 2\n2 3 5\n1 1 6\n1 7 9\n2 9 22\n2 3 4\n", "output": ["10\n6\n8\n8\n4\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 7\n2 8 8\n2 4 6\n", "output": ["2\n6\n8\n4\n10\n4\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 0\n2 5 4\n2 5 4\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 2\n2 5 2\n", "output": ["3\n3\n3\n2\n3\n3\n5\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n6\n5\n5\n8\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n2 8 5\n1 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n1 3 8\n", "output": ["10\n8\n6\n9\n10\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 6\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n2\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 6\n2 3 2\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 5\n", "output": ["7\n1\n8\n9\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 2\n1 4 6\n1 1 9\n2 9 16\n1 3 6\n", "output": ["10\n6\n2\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 7 6\n2 3 3\n1 5 2\n2 9 5\n1 4 6\n1 5 8\n2 8 8\n1 3 6\n", "output": ["10\n6\n10\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 2 2\n1 1 5\n2 1 2\n", "output": ["5\n1\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 6\n1 7 6\n1 7 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["9\n6\n8\n5\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n2 9 5\n1 3 6\n2 9 9\n2 8 8\n1 3 8\n", "output": ["10\n6\n9\n9\n8\n"]}, {"input": "5 4\n5 3 4 2 1\n2 1 1\n2 1 3\n1 1 2\n2 1 2\n", "output": ["5\n5\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 2\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n8\n7\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 3 3\n1 10 2\n2 9 4\n1 5 3\n1 5 8\n2 4 15\n1 3 6\n", "output": ["10\n3\n8\n1\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 3 3\n1 6 2\n1 9 5\n1 5 6\n2 5 9\n2 8 8\n1 3 6\n", "output": ["10\n6\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 6\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n6\n2\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 4 6\n2 3 3\n2 6 2\n2 9 5\n1 1 6\n1 7 1\n2 9 22\n2 3 6\n", "output": ["10\n9\n6\n4\n4\n7\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 1\n1 8 5\n1 7 6\n2 3 3\n2 6 2\n2 9 6\n1 4 6\n2 5 9\n2 8 13\n1 3 6\n", "output": ["9\n6\n9\n4\n2\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 8 5\n2 7 6\n2 3 3\n1 6 2\n2 9 12\n1 4 6\n2 2 9\n2 8 10\n2 3 6\n", "output": ["10\n7\n6\n5\n3\n2\n5\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 6\n1 10 6\n2 3 11\n1 6 2\n2 3 4\n1 4 6\n1 7 9\n2 9 8\n1 3 6\n", "output": ["10\n6\n7\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 6\n", "output": ["10\n10\n6\n3\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 9 22\n1 5 6\n", "output": ["7\n8\n6\n3\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 4 8\n2 3 8\n", "output": ["10\n10\n6\n3\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 1 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n4\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 5\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n6\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 2 5\n1 7 6\n1 6 9\n2 3 3\n1 6 2\n2 9 6\n1 3 6\n2 6 12\n2 8 8\n1 4 6\n", "output": ["2\n6\n9\n6\n8\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 1 6\n1 7 6\n2 2 3\n1 10 1\n2 9 4\n1 4 6\n1 5 8\n2 3 8\n2 3 8\n", "output": ["10\n10\n6\n10\n10\n"]}, {"input": "10 5\n6 7 4 1 5 3 10 2 8 9\n2 10 5\n1 7 10\n1 7 9\n2 2 3\n1 6 2\n1 9 5\n1 5 6\n3 5 9\n2 8 8\n1 3 6\n", "output": ["10\n2\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 9\n1 7 6\n1 10 4\n2 3 3\n1 6 2\n2 9 8\n1 1 6\n1 7 9\n2 8 22\n1 5 6\n", "output": ["7\n8\n4\n10\n"]}, {"input": "10 10\n6 7 4 1 5 3 10 2 8 9\n2 10 4\n1 7 6\n1 10 3\n2 3 3\n1 6 2\n2 9 4\n1 4 6\n1 5 9\n2 9 8\n1 3 6\n", "output": ["7\n2\n4\n9\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 1 2\n2 5 1\n", "output": ["3\n5\n4\n2\n3\n3\n3\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n2 3 1\n2 2 4\n1 1 3\n2 1 2\n", "output": ["4\n3\n2\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 8\n1 18 37\n1 19 37\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n40\n51\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 2 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n4\n2\n1\n3\n5\n1\n"]}, {"input": "100 10\n71 72 20 93 38 81 19 44 88 57 3 37 86 64 63 97 15 85 53 99 61 66 75 96 48 67 6 31 92 70 27 54 74 43 7 5 84 33 60 65 95 76 11 14 49 24 77 21 50 98 46 25 83 45 94 8 68 91 28 4 80 18 17 1 47 34 40 26 69 35 58 9 36 32 22 16 10 79 13 90 78 29 23 41 100 51 55 59 62 56 12 30 82 2 89 52 73 87 39 42\n1 64 46\n1 97 45\n2 50 22\n2 1 72\n2 65 10\n1 18 68\n1 19 89\n1 86 5\n2 36 69\n1 100 59\n", "output": ["71\n6\n47\n6\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 7\n2 5 0\n", "output": ["3\n5\n4\n2\n3\n3\n1\n5\n"]}, {"input": "5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 2\n2 5 3\n2 5 7\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["3\n5\n1\n2\n1\n3\n5\n1\n"]}, {"input": "5 3\n5 3 4 2 1\n2 3 1\n2 1 4\n1 1 2\n2 1 2\n", "output": ["4\n1\n"]}, {"input": "5 9\n2 3 5 1 4\n1 3 5\n2 4 5\n2 5 1\n2 5 3\n2 1 4\n1 5 4\n2 5 3\n2 2 2\n2 5 1\n", "output": ["1\n5\n5\n1\n3\n4\n1\n"]}, {"input": "5 4\n5 3 4 2 1\n1 3 1\n2 3 2\n1 1 3\n2 1 2\n", "output": ["1\n1\n"]}], "task_id": "codecontest/146", "repair_prompt": ["You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y.\n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly. Ensure that your solution is optimized for time and space complexity.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You are required to perform q queries on the given permutation of n elements.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y.\n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly. Ensure that your solution is optimized for time and space complexity.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations, and you should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y.\n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly, ensuring that your solution is optimized for time and space complexity.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def find_final_position(p, i, k):\n    visited = {}\n    current = i\n    steps = 0\n\n    while steps < k:\n        if current in visited:\n            cycle_length = steps - visited[current]\n            remaining_steps = (k - steps) % cycle_length\n            for _ in range(remaining_steps):\n                current = p[current - 1]\n            return current\n        visited[current] = steps\n        current = p[current - 1]\n        steps += 1\n\n    return current\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n\n    results = []\n    index = 0\n\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1])\n            y = int(queries[index + 2])\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Simulate permutation k times\n            i = x - 1\n            k = y\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            # Simulate the assignment process\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def process_queries(n, q, permutation, queries):\n    results = []\n    \n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            # Swap operation\n            permutation[a - 1], permutation[b - 1] = permutation[b - 1], permutation[a - 1]\n        elif t == 2:\n            # Transformation operation\n            current = a\n            for _ in range(b):\n                current = permutation[current - 1]\n            results.append(current)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    permutation = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = process_queries(n, q, permutation, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def process_queries(n, q, permutation, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            permutation[x-1], permutation[y-1] = permutation[y-1], permutation[x-1]\n        elif t == 2:\n            # Repeated assignment operation\n            i = x\n            for _ in range(y):\n                i = permutation[i-1]\n            results.append(i)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    permutation = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index+1])\n        y = int(data[index+2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, permutation, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    \n    def find_cycle_length(start):\n        visited = {}\n        current = start\n        length = 0\n        while current not in visited:\n            visited[current] = length\n            current = p[current - 1]\n            length += 1\n        return length, visited[start]\n    \n    index = 0\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1]) - 1\n            y = int(queries[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            index += 3\n            \n            cycle_length, cycle_start = find_cycle_length(i)\n            k = (k - cycle_start) % cycle_length + cycle_start\n            \n            current = i\n            for _ in range(k):\n                current = p[current - 1]\n            \n            results.append(current)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    def find_final_position(p, i, k):\n        visited = {}\n        current = i\n        steps = 0\n        while steps < k:\n            if current in visited:\n                cycle_length = steps - visited[current]\n                remaining_steps = (k - steps) % cycle_length\n                for _ in range(remaining_steps):\n                    current = p[current - 1]\n                return current\n            visited[current] = steps\n            current = p[current - 1]\n            steps += 1\n        return current\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1]) - 1\n            y = int(queries[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def process_queries(n, q, permutation, queries):\n    results = []\n    \n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            # Swap operation\n            permutation[a - 1], permutation[b - 1] = permutation[b - 1], permutation[a - 1]\n        elif t == 2:\n            # Iterative calculation\n            current = a\n            for _ in range(b):\n                current = permutation[current - 1]\n            results.append(current)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    permutation = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = process_queries(n, q, permutation, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_final_position(p, i, k):\n    visited = {}\n    current = i\n    steps = 0\n\n    while steps < k:\n        if current in visited:\n            cycle_length = steps - visited[current]\n            remaining_steps = (k - steps) % cycle_length\n            for _ in range(remaining_steps):\n                current = p[current - 1]\n            return current\n        visited[current] = steps\n        current = p[current - 1]\n        steps += 1\n\n    return current\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n\n    results = []\n    index = 0\n\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1])\n            y = int(queries[index + 2])\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the transformation operation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly transform the index i using the permutation array p for k times and return the final value.\"\n    },\n    {\n      \"description\": \"Optimize the transformation operation to handle large k efficiently.\",\n      \"details\": \"Use cycle detection in the permutation to avoid redundant transformations when k is large.\"\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": \"Collect results for each second-type query and print them in order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate over each query:\",\n    \"  If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  If the query is of type 2, perform the transformation operation using cycle detection for efficiency, and store the result.\",\n    \"Output the stored results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number in the range 1 to n appears exactly once in the array.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps two elements and another that transforms an index a certain number of times.\n\n# [phrase showing quantity relationship]\n    'at least one second-type query'\n    Explanation: This means that among the queries provided, there is guaranteed to be at least one query of the second type. This ensures that the output will always have at least one result to print.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the queries should be considered simultaneously:\n    - For each query, determine its type and perform the corresponding operation. This involves checking the type of the query and then either performing a swap or a transformation. The transformation should be optimized using cycle detection to handle large k efficiently.\n\n# [edge case]\n    1. Input: 1 1\n       1\n       2 1 1\n       Output: 1\n       Explanation: With only one element, the permutation is [1]. The query asks for the transformation of index 1, which remains 1.\n\n    2. Input: 3 2\n       3 1 2\n       2 1 3\n       2 2 2\n       Output: 3\n               1\n       Explanation: The first query transforms index 1 three times, resulting in 3. The second query transforms index 2 twice, resulting in 1.\n\n    3. Input: 4 3\n       4 3 2 1\n       1 1 4\n       2 1 1\n       2 4 1\n       Output: 1\n               4\n       Explanation: After the swap, the permutation becomes [1, 3, 2, 4]. The first transformation query results in 1, and the second results in 4.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to cycle detection for large k.\n    ```python\n    def find_final_position(p, i, k):\n        visited = {}\n       ", "Round_0": {"code": "def find_final_position(p, i, k):\n    visited = {}\n    current = i\n    steps = 0\n\n    while steps < k:\n        if current in visited:\n            cycle_length = steps - visited[current]\n            remaining_steps = (k - steps) % cycle_length\n            for _ in range(remaining_steps):\n                current = p[current - 1]\n            return current\n        visited[current] = steps\n        current = p[current - 1]\n        steps += 1\n\n    return current\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n\n    results = []\n    index = 0\n\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1])\n            y = int(queries[index + 2])\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_final_position() missing 3 required positional arguments: 'p', 'i', and 'k'"}, "Round_1": {"code": "def find_final_position(p, i, k):\n    visited = {}\n    current = i\n    steps = 0\n\n    while steps < k:\n        if current in visited:\n            cycle_length = steps - visited[current]\n            remaining_steps = (k - steps) % cycle_length\n            for _ in range(remaining_steps):\n                current = p[current - 1]\n            return current\n        visited[current] = steps\n        current = p[current - 1]\n        steps += 1\n\n    return current\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n\n    results = []\n    index = 0\n\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1])\n            y = int(queries[index + 2])\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the logic to handle the first type of query (swap operation).\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the logic to handle the second type of query (iterative assignment).\",\n      \"details\": \"For a query of type 2 i k, iteratively assign i = p[i] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Optimize the solution for time and space complexity.\",\n      \"details\": \"Ensure that the operations for each query are efficient, especially for large values of n and q.\"\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"details\": \"Collect the results of all second-type queries and print each result on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query one by one.\",\n    \"For each query, check the type of query:\",\n    \"If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"If the query is of type 2, perform the iterative assignment operation and store the result.\",\n    \"After processing all queries, output the results of all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an arrangement of integers from 1 to n such that each integer appears exactly once. This means the array is a rearrangement of the numbers 1 to n.\n\n# [phrase showing quantity relationship]\n    'k times': means that the operation of assigning i = p[i] should be repeated k times.\n    Implementation: Use a loop to perform the assignment operation k times.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for handling the second-type query should be implemented simultaneously:\n    \"For a query of type 2 i k, iteratively assign i = p[i] for k times and return the final value of i.\"\n    This can be done using a loop that updates the value of i k times.\n\n# [edge case] \n    Input: 1 1\n    Output: 1\n    Explanation: With only one element, any swap operation is irrelevant, and the second-type query will always return the single element itself.\n\n    Input: 5 1\n    Output: 5\n    Explanation: If k is equal to n, the iterative assignment will cycle through the permutation and return the original value.\n\n    Input: 5 0\n    Output: 5\n    Explanation: If k is zero, the iterative assignment does not change the value, so the output is the initial value of i.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating k times and handling swaps will naturally cover these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of elements (n), number of queries (q), the permutation array (p), and the list of queries.\",\n      \"details\": \"Read the input data and store n, q, the permutation array p, and the list of queries in appropriate data structures.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the permutation array.\",\n      \"details\": \"For a query of type 1, swap the elements at indices x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the operation to find the result of applying k iterations of the permutation starting from index i.\",\n      \"details\": \"For a query of type 2, simulate the process of applying the permutation k times starting from index i and return the resulting value.\"\n    },\n    {\n      \"description\": \"Efficiently handle multiple queries and output the results for type 2 queries.\",\n      \"details\": \"Iterate through the list of queries, perform the required operations, and store the results of type 2 queries for output.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a loop to iterate over each query.\",\n    \"For each query, check the type of query:\",\n    \"If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"If the query is of type 2, simulate the permutation k times starting from index i and store the result.\",\n    \"After processing all queries, output the results of all type 2 queries in the order they were received.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is an arrangement of all the elements of a set into some sequence or order. In this requirement, it means the array contains each integer from 1 to n exactly once.\n\n    'query'\n    Explanation: A query is a request for information or action. In this requirement, there are two types of queries: one for swapping elements and another for simulating the permutation.\n\n# [phrase showing quantity relationship]\n    'exactly once': This means each integer from 1 to n appears only one time in the permutation array.\n    'k times': This means the operation should be repeated k times, which can be implemented using a loop in code.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling each query should be implemented simultaneously within the loop that iterates over the queries. Specifically, the check for the type of query and the corresponding operation (swap or simulate) should be handled in a single code block using an if-else statement.\n\n# [edge case]\n    1. Input: 1 1\n       Output: 1\n       Explanation: With only one element, any swap or simulation will result in the same element.\n       \n    2. Input: 5 1\n       Output: 5\n       Explanation: With a single query of type 2 and k=1, the output will be the element itself since no permutation is applied.\n       \n    3. Input: 5 5\n       Output: 5\n       Explanation: If k equals the length of the permutation, the element will map back to itself after completing one full cycle.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling queries and simulating permutations will naturally cover these scenarios.\n\nNO", "Round_0": {"code": "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Simulate permutation k times\n            i = x - 1\n            k = y\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 98)"}, "Round_1": {"code": "def process_queries(n, q, p, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            # Simulate permutation k times\n            i = x - 1\n            k = y\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, p, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the list of queries.\"\n    },\n    {\n      \"description\": \"Implement a function to handle the first type of query (swap operation).\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array.\"\n    },\n    {\n      \"description\": \"Implement a function to handle the second type of query (iterative assignment).\",\n      \"details\": \"For a query of type 2 i k, iteratively assign i = p[i] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Optimize the solution for time and space complexity.\",\n      \"details\": \"Ensure that the solution can handle up to 100,000 elements and queries efficiently.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query in the list of queries.\",\n    \"For each query, check the type of query:\",\n    \"  - If the query is of type 1, call the swap function to swap the elements at the specified positions.\",\n    \"  - If the query is of type 2, call the iterative assignment function to compute the result and store it.\",\n    \"After processing all queries, output the results of all second-type queries in the order they were processed.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n without repetition.\n\n# [phrase showing quantity relationship]\n    'k times': means that the operation of assigning i = p[i] should be performed k times in the second type of query.\n    Implementation: Use a loop to perform the assignment operation k times.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for handling each query should be implemented simultaneously within the loop that processes each query. Specifically, the check for the type of query and the corresponding function call (swap or iterative assignment) should be handled in one code block using an if-else statement.\n\n# [edge case] \n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the result of assigning i = p[i] once, which remains 1.\n\n    Input: 2 2\n           1 2\n           1 1 2\n           2 1 1\n    Output: 2\n    Explanation: After swapping, the permutation becomes [2, 1]. The query asks for the result of assigning i = p[i] once, which is 2.\n\n    Input: 3 3\n           3 1 2\n           2 1 2\n           1 1 3\n           2 1 1\n    Output: 1\n    Explanation: After the swap, the permutation becomes [2, 1, 3]. The query asks for the result of assigning i = p[i] once, which is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of processing each query and handling swaps and iterative assignments will naturally cover these edge cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 76)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            for _ in range(k):\n                i = p[i] - 1\n            results.append(p[i])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the list of queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the operation to find the result of the second type of query.\",\n      \"details\": \"For a query of type 2 i k, simulate the process of assigning i = p_i k times and determine the final value of i.\"\n    },\n    {\n      \"description\": \"Optimize the solution for handling multiple queries efficiently.\",\n      \"details\": \"Consider using data structures or algorithms that minimize time complexity, especially for the second type of query which involves repeated assignments.\"\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"details\": \"For each query of type 2, compute the result and print it on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Iterate over each query and perform the following steps:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, compute the result by simulating the assignment process and store the result.\",\n    \"Output the results for all second-type queries in the order they were processed.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number between 1 and n appears exactly once in the array.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps two elements and another that simulates a process of repeated assignments.\n\n# [phrase showing quantity relationship]\n    'k times'\n    Explanation: In the second type of query, \"k times\" means that the assignment process should be repeated k times. This can be implemented in code using a loop that iterates k times to perform the assignment.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling each query should be implemented in a loop that processes each query one by one. The swap operation and the assignment simulation are distinct operations and should be handled separately within the loop.\n\n# [edge case]\n    1. Input: 1 1\n       Output: (No output, as this is a swap operation)\n       Explanation: With only one element, a swap operation is trivial and does not change the permutation.\n\n    2. Input: 2 1 1\n       Output: 1\n       Explanation: With k=1, the assignment process is performed once, resulting in the same element.\n\n    3. Input: 2 1 100000\n       Output: 1\n       Explanation: Even with a large k, the assignment process will cycle back to the same element due to the nature of permutations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the assignment process and handling swaps will naturally cover these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            # Simulate the assignment process\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 80)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    index = n + 2\n    results = []\n    \n    for _ in range(q):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index + 1]) - 1\n            y = int(data[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            # Simulate the assignment process\n            current = i\n            for _ in range(k):\n                current = p[current] - 1\n            \n            results.append(p[current])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": [\n        \"Read the first line to get the values of n and q.\",\n        \"Read the second line to get the permutation array p of n elements.\",\n        \"Read the next q lines to get the list of queries.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": [\n        \"Identify queries of type 1.\",\n        \"For each query, swap the elements at positions x and y in the permutation array.\"\n      ]\n    },\n    {\n      \"description\": \"Implement the transformation operation for the second type of query.\",\n      \"details\": [\n        \"Identify queries of type 2.\",\n        \"For each query, perform the transformation i = p_i k times.\",\n        \"Output the result of the transformation for each second-type query.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the solution for time and space complexity.\",\n      \"details\": [\n        \"Ensure that the swap operation is performed in constant time.\",\n        \"Optimize the transformation operation to avoid redundant calculations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query.\",\n    \"For each query, check the type:\",\n    \"  - If type 1, perform the swap operation on the permutation array.\",\n    \"  - If type 2, perform the transformation operation and store the result.\",\n    \"Output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps elements and another that performs a transformation based on the permutation.\n\n# [phrase showing quantity relationship]\n    'k times': This indicates that the transformation operation should be applied k times. In code, this can be implemented using a loop that iterates k times to perform the transformation.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling each query should be implemented simultaneously within a loop that processes each query. Specifically, the check for the type of query and the corresponding operation (swap or transformation) should be handled in a single code block using an if-else statement.\n\n# [edge case]\n    1. Input: 1 1\n       Output: 1\n       Explanation: With only one element, any swap operation is redundant, and any transformation will always result in the same element.\n       \n    2. Input: 2 1 1\n       Output: 1\n       Explanation: With a single element, the transformation will always result in the same element regardless of k.\n\n    3. Input: 5 1\n       Output: 5\n       Explanation: If the permutation is already sorted, any transformation with k=1 will result in the same element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling swaps and transformations will naturally handle these cases due to the constraints and properties of permutations.\n\nNO", "Round_0": {"code": "def process_queries(n, q, permutation, queries):\n    results = []\n    \n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            # Swap operation\n            permutation[a - 1], permutation[b - 1] = permutation[b - 1], permutation[a - 1]\n        elif t == 2:\n            # Transformation operation\n            current = a\n            for _ in range(b):\n                current = permutation[current - 1]\n            results.append(current)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    permutation = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = process_queries(n, q, permutation, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 79)"}, "Round_1": {"code": "def process_queries(n, q, permutation, queries):\n    results = []\n    \n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            # Swap operation\n            permutation[a - 1], permutation[b - 1] = permutation[b - 1], permutation[a - 1]\n        elif t == 2:\n            # Transformation operation\n            current = a\n            for _ in range(b):\n                current = permutation[current - 1]\n            results.append(current)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    permutation = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = process_queries(n, q, permutation, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the list of queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the repeated assignment operation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly assign i = p[i-1] for k times and return the final value of i.\"\n    },\n    {\n      \"description\": \"Efficiently handle multiple queries and output results for second-type queries.\",\n      \"details\": \"Iterate through the list of queries, perform the required operations, and store results for second-type queries. Output the results in the order they were queried.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Initialize an empty list to store results for second-type queries.\",\n    \"Iterate through each query:\",\n    \"  - If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  - If the query is of type 2, perform the repeated assignment operation and append the result to the results list.\",\n    \"Output each result from the results list on a new line.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an arrangement of integers from 1 to n in a specific order, where each integer appears exactly once.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: swapping elements and repeated assignment.\n\n# [phrase showing quantity relationship]\n    'exactly once': Each integer from 1 to n appears only one time in the permutation.\n    'k times': The operation of assigning i = p[i-1] is performed k times.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling each query should be considered simultaneously within the loop that processes each query. Specifically, the logic for determining whether a query is of type 1 or type 2 and executing the corresponding operation should be implemented in a single code block using an if-else statement.\n\n# [edge case]\n    1. Input: 1 1\n       Output: 1\n       Explanation: With only one element, any query of type 2 will always return the element itself, as there are no other elements to swap or reassign.\n       \n    2. Input: 5 1\n       Output: 5\n       Explanation: If the permutation is already sorted in ascending order, any query of type 2 with k = 1 will return the element itself.\n\n    3. Input: 5 5\n       Output: 5\n       Explanation: If k is equal to the length of the permutation, the repeated assignment will cycle through the permutation and return the original element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling queries and performing operations based on the type of query will naturally handle these edge cases. \n\nNO", "Round_0": {"code": "def process_queries(n, q, permutation, queries):\n    results = []\n    \n    for query in queries:\n        t, x, y = query\n        if t == 1:\n            # Swap operation\n            permutation[x-1], permutation[y-1] = permutation[y-1], permutation[x-1]\n        elif t == 2:\n            # Repeated assignment operation\n            i = x\n            for _ in range(y):\n                i = permutation[i-1]\n            results.append(i)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    permutation = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        x = int(data[index+1])\n        y = int(data[index+2])\n        queries.append((t, x, y))\n        index += 3\n    \n    results = process_queries(n, q, permutation, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the list of queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at positions x and y in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the transformation operation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, determine the element that i will become after k transformations using the permutation array p.\"\n    },\n    {\n      \"description\": \"Optimize the transformation operation to handle large k efficiently.\",\n      \"details\": \"Use cycle detection in the permutation to reduce the number of transformations needed when k is large.\"\n    },\n    {\n      \"description\": \"Output the results for each second-type query.\",\n      \"details\": \"For each query of type 2, compute the result and print it.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query in the list of queries.\",\n    \"For each query, check the type of query:\",\n    \"If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"If the query is of type 2, perform the transformation operation to determine the result after k transformations.\",\n    \"Optimize the transformation operation by detecting cycles in the permutation to handle large k efficiently.\",\n    \"Store the result of each second-type query.\",\n    \"After processing all queries, output the results for each second-type query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n.\n\n    'query'\n    A query is an operation that needs to be performed on the permutation array. There are two types of queries: swap and transformation.\n\n# [phrase showing quantity relationship]\n    'k times'\n    This indicates that the transformation operation should be applied k times. In code, this can be implemented by iterating or using cycle detection to efficiently compute the result after k transformations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to parsing the input and processing each query should be implemented simultaneously in a loop. Specifically, the steps:\n    \"Initialize a loop to process each query in the list of queries.\"\n    \"For each query, check the type of query:\"\n    These can be implemented in a single loop that iterates over the queries and performs the necessary operations based on the query type.\n\n# [edge case]\n    Input: 1 1\n           1\n           2 1 1\n    Output: 1\n    Explanation: With only one element, the permutation is [1]. The query asks for the transformation of index 1 one time, which remains 1.\n\n    Input: 3 3\n           3 1 2\n           2 1 3\n           1 1 3\n           2 1 3\n    Output: 2\n            3\n    Explanation: Initially, the permutation is [3, 1, 2]. The first query transforms index 1 three times, resulting in 2. After swapping indices 1 and 3, the permutation becomes [2, 1, 3]. The second query transforms index 1 three times, resulting in 3.\n\n    Input: 5 1\n           5 4 3 2 1\n           2 5 5\n    Output: 1\n    Explanation: The permutation is [5, 4, 3, 2, 1]. The query transforms index 5 five times, resulting in 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large k values.\n    Implement cycle detection to reduce the number of transformations needed", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    \n    def find_cycle_length(start):\n        visited = {}\n        current = start\n        length = 0\n        while current not in visited:\n            visited[current] = length\n            current = p[current - 1]\n            length += 1\n        return length, visited[start]\n    \n    index = 0\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1]) - 1\n            y = int(queries[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            index += 3\n            \n            cycle_length, cycle_start = find_cycle_length(i)\n            k = (k - cycle_start) % cycle_length + cycle_start\n            \n            current = i\n            for _ in range(k):\n                current = p[current - 1]\n            \n            results.append(current)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 94)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = list(map(int, data[2:n+2]))\n    \n    queries = data[n+2:]\n    \n    results = []\n    \n    def find_cycle_length(start):\n        visited = {}\n        current = start\n        length = 0\n        while current not in visited:\n            visited[current] = length\n            current = p[current - 1]\n            length += 1\n        return length, visited[start]\n    \n    index = 0\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1]) - 1\n            y = int(queries[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            index += 3\n            \n            cycle_length, cycle_start = find_cycle_length(i)\n            k = (k - cycle_start) % cycle_length + cycle_start\n            \n            current = i\n            for _ in range(k):\n                current = p[current - 1]\n            \n            results.append(current)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the transformation operation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly transform the index i using the permutation array p for k times and return the final value.\"\n    },\n    {\n      \"description\": \"Optimize the transformation operation to handle large k efficiently.\",\n      \"details\": \"Use cycle detection in the permutation to avoid redundant transformations when k is large.\"\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": \"Collect the results of all second-type queries and print them in order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a list to store the results of second-type queries.\",\n    \"Iterate over each query:\",\n    \"  If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  If the query is of type 2, perform the transformation operation using cycle detection for efficiency and store the result.\",\n    \"Output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number in the range 1 to n appears exactly once in the array.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps two elements and another that transforms an index using the permutation.\n\n# [phrase showing quantity relationship]\n    'k times'\n    Explanation: In the second type of query, the transformation operation is performed k times. This means that the index i is transformed using the permutation array p repeatedly for k iterations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the second type of query should be considered simultaneously with cycle detection to optimize the transformation operation. This involves detecting cycles in the permutation to avoid redundant transformations when k is large.\n\n# [edge case]\n    1. n = 1, q = 1, p = [1], query = [2, 1, 1]\n       Expected output: 1\n       Explanation: With only one element, any transformation will always result in the same element.\n\n    2. n = 5, q = 1, p = [1, 2, 3, 4, 5], query = [2, 3, 100000]\n       Expected output: 3\n       Explanation: Since the permutation is already in order, any number of transformations will result in the same index.\n\n    3. n = 5, q = 1, p = [5, 4, 3, 2, 1], query = [2, 5, 2]\n       Expected output: 1\n       Explanation: The transformation will cycle through the permutation, and after two transformations, index 5 will map to index 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases involving large k efficiently.\n    ```python\n    def find_final_position(p, i, k):\n        visited = {}\n        current = i\n        steps = 0\n        while steps < k:\n            if current in visited:\n                cycle_length = steps - visited[current]\n                remaining_steps = (k - steps) % cycle_length\n                for _ in range(remaining_steps):\n                    current = p[current - 1", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    def find_final_position(p, i, k):\n        visited = {}\n        current = i\n        steps = 0\n        while steps < k:\n            if current in visited:\n                cycle_length = steps - visited[current]\n                remaining_steps = (k - steps) % cycle_length\n                for _ in range(remaining_steps):\n                    current = p[current - 1]\n                return current\n            visited[current] = steps\n            current = p[current - 1]\n            steps += 1\n        return current\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1]) - 1\n            y = int(queries[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 91)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n    \n    results = []\n    index = 0\n    \n    def find_final_position(p, i, k):\n        visited = {}\n        current = i\n        steps = 0\n        while steps < k:\n            if current in visited:\n                cycle_length = steps - visited[current]\n                remaining_steps = (k - steps) % cycle_length\n                for _ in range(remaining_steps):\n                    current = p[current - 1]\n                return current\n            visited[current] = steps\n            current = p[current - 1]\n            steps += 1\n        return current\n    \n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1]) - 1\n            y = int(queries[index + 2]) - 1\n            p[x], p[y] = p[y], p[x]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the list of queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the calculation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, calculate the result by iteratively updating i = p[i-1] for k times and return the final value.\"\n    },\n    {\n      \"description\": \"Optimize the solution for time and space complexity.\",\n      \"details\": \"Ensure that the operations are performed efficiently, especially the second type of query which involves repeated access to the permutation array.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, the permutation array p, and the list of queries.\",\n    \"Initialize a loop to process each query in the list of queries.\",\n    \"For each query, check the type of query:\",\n    \"If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"If the query is of type 2, perform the iterative calculation to determine the result and store the result.\",\n    \"After processing all queries, output the results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that the array is a rearrangement of the numbers from 1 to n without any repetition or omission.\n\n# [phrase showing quantity relationship]\n    'at least one second-type query': This means that among the queries provided, there is guaranteed to be at least one query of type 2, which requires outputting a result.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for processing each query should be considered simultaneously within a loop that iterates over the list of queries. Specifically, the logic for determining the type of query and executing the corresponding operation (swap or iterative calculation) should be handled in a single code block using an if-else statement.\n\n# [edge case] \n    1. Input: 1 1\n       1\n       2 1 1\n       Output: 1\n       Explanation: With only one element, the permutation is [1]. The query asks for the result of i = p_i 1 time, which is simply p_1 = 1.\n\n    2. Input: 2 2\n       1 2\n       1 1 2\n       2 1 1\n       Output: 2\n       Explanation: The permutation starts as [1, 2]. After the swap query, it becomes [2, 1]. The second query asks for the result of i = p_i 1 time, which is p_1 = 2.\n\n    3. Input: 3 3\n       3 1 2\n       2 1 1\n       2 2 1\n       2 3 1\n       Output: 3\n       1\n       2\n       Explanation: The permutation is [3, 1, 2]. Each query asks for the result of i = p_i 1 time, which directly returns the value at the index.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over the queries and performing the specified operations will naturally handle these cases.\n\nNO", "Round_0": {"code": "def process_queries(n, q, permutation, queries):\n    results = []\n    \n    for query in queries:\n        t, a, b = query\n        if t == 1:\n            # Swap operation\n            permutation[a - 1], permutation[b - 1] = permutation[b - 1], permutation[a - 1]\n        elif t == 2:\n            # Iterative calculation\n            current = a\n            for _ in range(b):\n                current = permutation[current - 1]\n            results.append(current)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    permutation = list(map(int, data[2:n+2]))\n    queries = []\n    \n    index = n + 2\n    for _ in range(q):\n        t = int(data[index])\n        a = int(data[index + 1])\n        b = int(data[index + 2])\n        queries.append((t, a, b))\n        index += 3\n    \n    results = process_queries(n, q, permutation, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the permutation array and the list of queries.\",\n      \"details\": \"Read the first line to get n and q. Read the second line to get the permutation array p. Read the next q lines to get the queries.\"\n    },\n    {\n      \"description\": \"Implement the swap operation for the first type of query.\",\n      \"details\": \"For a query of type 1 x y, swap the elements at indices x-1 and y-1 in the permutation array p.\"\n    },\n    {\n      \"description\": \"Implement the transformation operation for the second type of query.\",\n      \"details\": \"For a query of type 2 i k, repeatedly transform the index i using the permutation array p for k times and return the final value.\"\n    },\n    {\n      \"description\": \"Optimize the transformation operation to handle large k efficiently.\",\n      \"details\": \"Use cycle detection in the permutation to avoid redundant transformations when k is large.\"\n    },\n    {\n      \"description\": \"Output the results for all second-type queries.\",\n      \"details\": \"Collect results for each second-type query and print them in order.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, q, permutation array p, and the list of queries.\",\n    \"Initialize a list to store results for second-type queries.\",\n    \"Iterate over each query:\",\n    \"  If the query is of type 1, perform the swap operation on the permutation array.\",\n    \"  If the query is of type 2, perform the transformation operation using cycle detection for efficiency, and store the result.\",\n    \"Output the stored results for all second-type queries.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. This means that each number in the range 1 to n appears exactly once in the array.\n\n    'query'\n    Explanation: A query is an operation that needs to be performed on the permutation. There are two types of queries: one that swaps two elements and another that transforms an index a certain number of times.\n\n# [phrase showing quantity relationship]\n    'at least one second-type query'\n    Explanation: This means that among the queries provided, there is guaranteed to be at least one query of the second type. This ensures that the output will always have at least one result to print.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for handling the queries should be considered simultaneously:\n    - For each query, determine its type and perform the corresponding operation. This involves checking the type of the query and then either performing a swap or a transformation. The transformation should be optimized using cycle detection to handle large k efficiently.\n\n# [edge case]\n    1. Input: 1 1\n       1\n       2 1 1\n       Output: 1\n       Explanation: With only one element, the permutation is [1]. The query asks for the transformation of index 1, which remains 1.\n\n    2. Input: 3 2\n       3 1 2\n       2 1 3\n       2 2 2\n       Output: 3\n               1\n       Explanation: The first query transforms index 1 three times, resulting in 3. The second query transforms index 2 twice, resulting in 1.\n\n    3. Input: 4 3\n       4 3 2 1\n       1 1 4\n       2 1 1\n       2 4 1\n       Output: 1\n               4\n       Explanation: After the swap, the permutation becomes [1, 3, 2, 4]. The first transformation query results in 1, and the second results in 4.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to cycle detection for large k.\n    ```python\n    def find_final_position(p, i, k):\n        visited = {}\n       ", "Round_0": {"code": "def find_final_position(p, i, k):\n    visited = {}\n    current = i\n    steps = 0\n\n    while steps < k:\n        if current in visited:\n            cycle_length = steps - visited[current]\n            remaining_steps = (k - steps) % cycle_length\n            for _ in range(remaining_steps):\n                current = p[current - 1]\n            return current\n        visited[current] = steps\n        current = p[current - 1]\n        steps += 1\n\n    return current\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n\n    results = []\n    index = 0\n\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1])\n            y = int(queries[index + 2])\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_final_position() missing 3 required positional arguments: 'p', 'i', and 'k'"}, "Round_1": {"code": "def find_final_position(p, i, k):\n    visited = {}\n    current = i\n    steps = 0\n\n    while steps < k:\n        if current in visited:\n            cycle_length = steps - visited[current]\n            remaining_steps = (k - steps) % cycle_length\n            for _ in range(remaining_steps):\n                current = p[current - 1]\n            return current\n        visited[current] = steps\n        current = p[current - 1]\n        steps += 1\n\n    return current\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    p = list(map(int, data[2:n+2]))\n    queries = data[n+2:]\n\n    results = []\n    index = 0\n\n    for _ in range(q):\n        t = int(queries[index])\n        if t == 1:\n            x = int(queries[index + 1])\n            y = int(queries[index + 2])\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n            index += 3\n        elif t == 2:\n            i = int(queries[index + 1])\n            k = int(queries[index + 2])\n            result = find_final_position(p, i, k)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [true, false, true, true, true, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 538, "prompt": "You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.\n\nThere are two types of queries:\n\n  * 1 x y \u2014 swap p_x and p_y.\n  * 2 i k \u2014 print the number that i will become if we assign i = p_i k times.\n\nYour task is to efficiently handle each query and return the expected results promptly. Ensure that your solution is optimized for time and space complexity.\n\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "examples": "\nInput\n\nThe first line contains two integers n and q (1 \u2264 n, q \u2264 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n.\n\nEach of the next q lines contains three integers. The first integer is t (1 \u2264 t \u2264 2) \u2014 type of query. If t = 1, then the next two integers are x and y (1 \u2264 x, y \u2264 n; x \u2260 y) \u2014 first-type query. If t = 2, then the next two integers are i and k (1 \u2264 i, k \u2264 n) \u2014 second-type query.\n\nIt is guaranteed that there is at least one second-type query.\n\nOutput\n\nFor every second-type query, print one integer in a new line \u2014 answer to this query.\n\nExamples\n\nInput\n\n\n5 4\n5 3 4 2 1\n2 3 1\n2 1 2\n1 1 3\n2 1 2\n\n\nOutput\n\n\n4\n1\n2\n\n\nInput\n\n\n5 9\n2 3 5 1 4\n2 3 5\n2 5 5\n2 5 1\n2 5 3\n2 5 4\n1 5 4\n2 5 3\n2 2 5\n2 5 1\n\n\nOutput\n\n\n3\n5\n4\n2\n3\n3\n3\n1\n\nNote\n\nIn the first example p = \\{5, 3, 4, 2, 1\\}. \n\nThe first query is to print p_3. The answer is 4.\n\nThe second query is to print p_{p_1}. The answer is 1.\n\nThe third query is to swap p_1 and p_3. Now p = \\{4, 3, 5, 2, 1\\}.\n\nThe fourth query is to print p_{p_1}. The answer is 2.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 182}
