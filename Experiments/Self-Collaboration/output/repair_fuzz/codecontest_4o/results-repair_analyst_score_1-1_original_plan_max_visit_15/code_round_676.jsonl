{"name": "1618_E. Singers' Tour", "description": "n towns are arranged in a circle sequentially. The towns are numbered from 1 to n in clockwise order. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. In addition, in each town, the i-th singer got inspired and came up with a song that lasts a_i minutes. The song was added to his repertoire so that he could perform it in the rest of the cities.\n\nHence, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "tags": ["constructive algorithms", "math"], "difficulty": 11, "id": 1618, "sample_io": [{"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n", "output": ["YES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n"]}], "test_list": [{"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n4\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["YES\n3 1 3\nYES\n4\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n3\n3\n1 2 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n3\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n4\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n4\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n2\n3\n1 2 0\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n2\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n19 16 19\n1\n1\n3\n1 0 3\n6\n8 37 80 169 133 87\n", "output": ["YES\n3 4 2\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 133 105\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 62 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n112 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 132 75 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 39 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n112 75 75 93 93 124\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 2 3\n6\n8 39 75 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n2\n8 37 80 169 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 22\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 16 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n2\n1 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 91 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 19 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 184 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 0\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 184 129 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 4 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 4 3\n6\n13 75 32 4 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 2 3\n6\n8 75 75 93 93 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n10 75 75 93 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 155 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 13\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 18 14\n1\n1\n3\n1 2 1\n6\n62 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 3\n6\n8 75 84 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 93 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n14 102 119 179 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n1 1 3\n6\n8 75 75 82 16 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 87\n", "output": ["NO\nYES\n1\nNO\nYES\n5 5 4 1 4 5\n"]}, {"input": "4\n3\n12 16 27\n1\n1\n3\n0 2 3\n6\n8 75 75 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 119 93 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n8 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n3\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 81 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 2 3\n6\n8 75 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 6\n6\n8 75 32 50 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 64 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 0 3\n6\n8 75 119 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n6\n8 75 75 82 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n4 16 7\n1\n1\n3\n1 2 3\n6\n14 75 119 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 22\n1\n1\n3\n1 2 2\n6\n81 75 75 93 93 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n8 16 4\n1\n1\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 75 32 50 16 2\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 8\n6\n8 75 75 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n22 16 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n2 2 3\n6\n8 39 4 82 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 3 3\n6\n8 75 32 50 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n14 75 202 176 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 75 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 4 3\n6\n8 75 32 91 3 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 0 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 75 75 93 93 -1\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 42 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n24 10 3\n1\n1\n3\n2 2 1\n6\n81 138 75 184 93 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 6\n1\n1\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 1\n6\n2 75 202 179 42 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 75 32 4 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n6\n13 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 2 3\n6\n8 75 75 93 21 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n10 75 75 88 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 240 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 13\n1\n1\n3\n1 2 3\n6\n8 75 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n8 16 119 93 49 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n13 16 14\n1\n1\n3\n1 1 3\n6\n8 75 84 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 75 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 41 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 14\n1\n1\n3\n1 2 3\n6\n14 102 119 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n1 2 3\n6\n8 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 93 140\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 27\n1\n1\n3\n0 0 3\n6\n8 75 75 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 119 93 4 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 4\n6\n12 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 2 3\n6\n8 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 37 81 3\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 3\n6\n8 75 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 75 62 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 0 3\n6\n8 75 112 93 49 15\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n3\n8 75 75 82 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n8 16 4\n1\n2\n3\n1 2 3\n6\n16 75 119 93 93 111\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n22 16 7\n1\n1\n2\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n16 16 14\n1\n1\n3\n2 2 3\n6\n8 39 4 82 133 20\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 3 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 49 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 1\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 24\n1\n1\n3\n0 4 3\n6\n8 75 32 91 3 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n8 75 32 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n0 0 3\n6\n2 75 202 179 91 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n2 75 202 179 55 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 6\n1\n2\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 53 32 4 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n4\n13 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n10 75 75 88 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n8 75 119 93 15 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 13\n1\n1\n3\n1 2 3\n6\n8 109 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 93 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n13 16 14\n1\n1\n3\n1 1 3\n6\n8 75 104 50 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 19 14\n1\n1\n3\n1 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 1 6\n6\n8 75 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 14\n1\n1\n3\n1 2 3\n6\n14 102 38 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n2\n1 2 3\n6\n11 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n6 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 93 38 140\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 143 93 4 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 1 4\n6\n12 81 75 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 2 3\n6\n10 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n1 2 1\n6\n81 75 75 37 81 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 3\n6\n8 21 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 35 62 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 4\n3\n8 75 75 133 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 0 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n22 22 7\n1\n1\n3\n1 2 3\n6\n14 75 202 179 49 39\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 6 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 47 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 3\n1\n1\n3\n1 2 2\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n8 75 28 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 3\n6\n3 75 202 179 55 4\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n0 16 6\n1\n2\n3\n0 2 3\n6\n8 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n0 2 3\n6\n13 53 32 2 4 6\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n1\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n0 75 75 88 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 23\n1\n1\n3\n1 2 3\n6\n8 109 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 141 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 6 14\n1\n1\n3\n1 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 6\n6\n8 75 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n11 16 28\n1\n1\n3\n1 2 3\n6\n14 102 38 179 49 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n11 37 80 8 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 25\n1\n1\n3\n1 0 3\n6\n8 75 143 93 5 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n2 1 4\n6\n12 81 144 82 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n19 16 14\n1\n1\n2\n1 0 3\n6\n10 37 80 169 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 4\n1\n1\n3\n1 1 2\n6\n8 21 119 93 167 111\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 2 1\n6\n8 35 12 41 133 87\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 -1 4\n3\n8 75 75 133 133 133\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n1 1 8\n6\n8 75 76 82 133 117\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n2\n3\n0 6 3\n6\n8 75 32 50 3 169\n", "output": ["YES\n3 1 3\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n2\n3\n1 2 2\n6\n14 75 202 176 57 39\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 10 4\n1\n1\n3\n1 2 2\n6\n81 93 75 93 29 0\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 22\n1\n1\n2\n0 2 3\n6\n13 75 28 91 3 6\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 7\n1\n3\n3\n1 1 1\n6\n2 75 202 179 72 39\n", "output": ["NO\nYES\n3\nNO\nNO\n"]}, {"input": "4\n3\n12 10 14\n1\n2\n3\n0 4 3\n4\n26 75 32 4 3 6\n", "output": ["NO\nYES\n2\nNO\nNO\n"]}, {"input": "4\n3\n12 17 14\n1\n1\n3\n1 2 3\n6\n0 75 75 27 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n14 19 23\n1\n1\n3\n1 2 3\n6\n8 136 80 93 133 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 26 14\n1\n1\n3\n0 2 3\n6\n8 16 119 141 64 87\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 6 14\n1\n1\n3\n2 2 2\n6\n8 42 80 181 133 150\n", "output": ["NO\nYES\n1\nNO\nNO\n"]}, {"input": "4\n3\n12 16 14\n1\n1\n3\n1 0 6\n6\n8 141 75 82 41 77\n", "output": ["YES\n3 1 3\nYES\n1\nNO\nNO\n"]}], "task_id": "codecontest/136", "repair_prompt": ["n towns are arranged in a circle in sequence. The towns are numbered from 1 to n clockwise. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. Additionally, in each town, the i-th singer got inspired and came up with a song of a_i minutes. The song was added to his repertoire so that he could perform it in the remaining cities.\n\nThus, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "n towns are arranged in a circle in sequence. The arrangement of the towns is in a circular and sequential manner. The towns are numbered from 1 to n clockwise. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. Additionally, in each town, the i-th singer got inspired and came up with a song of a_i minutes. The song was added to his repertoire so that he could perform it in the remaining cities.\n\nThus, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "n towns are arranged in a circle in sequence, and the towns are numbered from 1 to n clockwise. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n]. Each singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town, and in each town, the i-th singer got inspired and came up with a song of a_i minutes, adding it to his repertoire to perform in the remaining cities. Thus, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes. You are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if the total sum of b is divisible by the sum of the first n natural numbers\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between consecutive b values\n            diff = b[i] - b[i - 1]\n            # Check if the difference minus total_a is divisible by n and positive\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        sum_natural = n * (n + 1) // 2\n        \n        if total_b % sum_natural != 0:\n            results.append(\"NO\")\n        else:\n            base_value = total_b // sum_natural\n            a = [0] * n\n            possible = True\n            \n            for i in range(n):\n                prev_index = (i - 1 + n) % n\n                a[i] = b[i] - b[prev_index] + base_value\n                if a[i] % n != 0 or a[i] <= 0:\n                    possible = False\n                    break\n                a[i] //= n\n            \n            if possible:\n                results.append(\"YES\")\n                results.append(\" \".join(map(str, a)))\n            else:\n                results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n*(n+1)/2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a_i\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between b[i] and b[i-1] in circular manner\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            \n            # Calculate a[i]\n            if (total_a + diff) % n != 0:\n                possible = False\n                break\n            \n            a[i] = (total_a + diff) // n\n            \n            if a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n\nmain()", "def solve_concert_problem():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve_concert_problem()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Special case for n = 1\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case: If there's only one town, the answer is directly the value of b[0]\n            results.append(\"YES\")\n            results.append(f\"{b[0]}\")\n            continue\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (total_a + diff) // n\n            \n            # Check if a[i] is a positive integer\n            if a[i] <= 0 or (total_a + diff) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        sum_n = n * (n + 1) // 2\n        \n        if total_b % sum_n != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // sum_n\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            if (total_a + diff) % n != 0 or (total_a + diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a + diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] > 0:\n                results.append(\"YES\")\n                results.append(f\"{b[0]}\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n# This function will be called when the script is executed\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read the integer n representing the number of towns.\",\n        \"Read the array b of n integers representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n        \"Check if the calculated sequence satisfies the conditions given in the problem statement.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence was found, print 'YES' followed by the sequence.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations.\",\n    \"Check the validity of the reconstructed sequence against the given conditions.\",\n    \"Output 'YES' and the sequence if valid, or 'NO' if no valid sequence exists.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after the last town back to the first.\n\n    'repertoire'\n    Explanation: The initial duration of songs each singer has before starting their tour.\n\n    'concert duration'\n    Explanation: The total time a singer performs in a town, which increases as they visit more towns.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly once in each town.\n\n    'k + 2'\n    Explanation: This indicates the multiplier for the concert duration as the singer moves to the next town. It starts from 1 and increases by 1 for each subsequent town.\n\n# [degree adverb]\n    'any correct sequence'\n    Explanation: There can be multiple valid sequences of initial repertoire durations that satisfy the conditions.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the initial repertoire duration for each singer and the validation of the sequence can be done in a single loop for efficiency.\n\n# [edge case]\n    Edge Case 1: n = 1, b = [1]\n    Expected Output: YES 1\n    Explanation: With only one town, the initial repertoire must be equal to the total concert duration.\n\n    Edge Case 2: n = 2, b = [2, 2]\n    Expected Output: NO\n    Explanation: It's impossible to have two singers with initial durations that satisfy the conditions for both towns.\n\n    Edge Case 3: n = 3, b = [3, 6, 9]\n    Expected Output: YES 1 2 3\n    Explanation: Each singer's initial repertoire can be 1, 2, and 3, respectively, satisfying the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should check if the sum of the calculated initial repertoires matches the total concert durations for each town. If not, it should return \"NO\".\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b, which contains the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, check if the sum of b_i is divisible by n.\",\n        \"If not divisible, output 'NO' for that test case.\",\n        \"If divisible, proceed to reconstruct the sequence a.\"\n      ]\n    },\n    {\n      \"description\": \"Reconstruct the sequence of initial repertoire durations for each test case.\",\n      \"steps\": [\n        \"Calculate the total sum of b_i and divide by n to get the sum of initial durations.\",\n        \"Use the properties of the problem to deduce a valid sequence a.\",\n        \"Ensure that each a_i is positive and satisfies the constraints.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"If a valid sequence a is found, output 'YES' followed by the sequence.\",\n        \"If no valid sequence is found, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, check if the sum of b_i is divisible by n.\",\n    \"If divisible, attempt to reconstruct the sequence a using mathematical deductions.\",\n    \"Output 'YES' and the sequence a if successful, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around, and the last town is followed by the first town again.\n\n    'repertoire'\n    Explanation: This refers to the initial set of songs each singer has, which grows as they visit each town.\n\n    'concert duration'\n    Explanation: The duration of each concert increases as the singer visits more towns, based on their initial repertoire.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly one concert in each town, which affects the calculation of total concert durations.\n\n    'k + 2'\n    Explanation: This indicates the multiplier for the concert duration in the k-th town after the initial town, which is implemented by incrementing the multiplier as the singer moves to the next town.\n\n# [degree adverb]\n    'any correct sequence'\n    Explanation: The requirement allows for any valid sequence of initial durations, meaning there can be multiple correct answers.\n\n# [code logic]\n    The steps in the plan related to checking divisibility and reconstructing the sequence should be considered simultaneously. Specifically:\n    - \"For each test case, check if the sum of b_i is divisible by n.\"\n    - \"Calculate the total sum of b_i and divide by n to get the sum of initial durations.\"\n    These steps are logically connected and should be implemented in a single code block to ensure the correct flow of logic.\n\n# [edge case]\n    Test case with n = 1 and b_1 = 1:\n    Output: YES 1\n    Explanation: With only one town and a total duration of 1, the initial repertoire must be 1.\n\n    Test case with n = 2 and b_1 = b_2 = 2:\n    Output: NO\n    Explanation: The total duration of 2 in each town cannot be split into valid initial durations that satisfy the conditions.\n\n    Test case with n = 3 and b_1 = b_2 = b_3 = 3:\n    Output: YES 1 1 1\n    Explanation: Each singer can start with a repertoire of 1, leading to a total duration of 3 in each town.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the sum of b_i is not divisible by n.\n    ```python\n    if sum(b) % n != 0:\n        print(\"", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if the total sum of b is divisible by the sum of the first n natural numbers\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between consecutive b values\n            diff = b[i] - b[i - 1]\n            # Check if the difference minus total_a is divisible by n and positive\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if the total sum of b is divisible by the sum of the first n natural numbers\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between consecutive b values\n            diff = b[i] - b[i - 1]\n            # Check if the difference minus total_a is divisible by n and positive\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, check if the sum of the array b is divisible by the sum of the first n natural numbers (1 to n).\",\n        \"If not divisible, output 'NO' for that test case.\",\n        \"If divisible, proceed to reconstruct the sequence a.\"\n      ]\n    },\n    {\n      \"description\": \"Reconstruct the sequence a for each test case where a valid sequence is possible.\",\n      \"steps\": [\n        \"Calculate the sum of the first n natural numbers (1 to n).\",\n        \"Divide the total sum of b by this sum to find the base value for a.\",\n        \"Use the base value to calculate each a_i such that the sum of concerts matches b_i for each town.\",\n        \"Ensure all a_i are positive integers and within the given constraints.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For test cases where a valid sequence a is found, output 'YES' followed by the sequence a.\",\n        \"For test cases where no valid sequence is possible, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, check if a valid sequence of initial repertoire durations exists.\",\n    \"If a valid sequence exists, reconstruct the sequence a.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence': Refers to the arrangement of towns and singers in a circular manner, where each singer visits all towns in a specific order.\n    'repertoire': The initial duration of songs each singer has before visiting other towns.\n    'concert duration': The total time a singer performs in each town, which increases as they visit more towns.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': Indicates that the concert duration doubles as the singer moves to the next town.\n    'k + 2 \u22c5 a_i': Shows the incremental increase in concert duration as the singer visits subsequent towns.\n    Implementation: Use arithmetic operations to calculate the concert duration based on the singer's position and repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for checking divisibility and reconstructing the sequence should be considered simultaneously. \n    \"Check if the sum of the array b is divisible by the sum of the first n natural numbers (1 to n).\"\n    \"If divisible, proceed to reconstruct the sequence a.\"\n    This can be implemented using an if-else statement to decide whether to reconstruct the sequence or output 'NO'.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town and one singer, the concert duration matches the repertoire directly.\n    Test case with n = 2 and b = [3, 3] = NO\n    Explanation: The sum of b is not divisible by the sum of the first 2 natural numbers (1 + 2 = 3), hence no valid sequence.\n    Test case with n = 4 and b = [10, 10, 10, 10] = NO\n    Explanation: The sum of b is not divisible by the sum of the first 4 natural numbers (1 + 2 + 3 + 4 = 10), hence no valid sequence.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if sum(b) % (n * (n + 1) // 2) != 0:\n            print(\"NO\")\n        else:\n            # Code to reconstruct sequence a\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        sum_natural = n * (n + 1) // 2\n        \n        if total_b % sum_natural != 0:\n            results.append(\"NO\")\n        else:\n            base_value = total_b // sum_natural\n            a = [0] * n\n            possible = True\n            \n            for i in range(n):\n                prev_index = (i - 1 + n) % n\n                a[i] = b[i] - b[prev_index] + base_value\n                if a[i] % n != 0 or a[i] <= 0:\n                    possible = False\n                    break\n                a[i] //= n\n            \n            if possible:\n                results.append(\"YES\")\n                results.append(\" \".join(map(str, a)))\n            else:\n                results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        sum_natural = n * (n + 1) // 2\n        \n        if total_b % sum_natural != 0:\n            results.append(\"NO\")\n        else:\n            base_value = total_b // sum_natural\n            a = [0] * n\n            possible = True\n            \n            for i in range(n):\n                prev_index = (i - 1 + n) % n\n                a[i] = b[i] - b[prev_index] + base_value\n                if a[i] % n != 0 or a[i] <= 0:\n                    possible = False\n                    break\n                a[i] //= n\n            \n            if possible:\n                results.append(\"YES\")\n                results.append(\" \".join(map(str, a)))\n            else:\n                results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n        \"Check if the calculated sequence satisfies the conditions given in the problem statement.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence was found, print 'YES' followed by the sequence.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations.\",\n    \"Output the results for each test case, indicating whether a valid sequence was found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular and sequential arrangement'\n    Explanation: The towns are arranged in a circle, meaning after the last town, the sequence continues back to the first town. This affects how the concerts are calculated as the sequence wraps around.\n\n    'repertoire of a_i minutes'\n    Explanation: Each singer starts with a repertoire of a_i minutes, which increases as they perform in each subsequent town.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i', '(k + 2) \u22c5 a_i', 'n \u22c5 a_i'\n    Explanation: These phrases describe how the concert duration increases as the singer moves from town to town. The concert duration in each town is a multiple of the initial repertoire a_i, increasing by the number of towns visited so far.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the initial repertoire durations for each singer (step 2) involves iterating over the towns and checking conditions simultaneously. This can be done using a loop that calculates and verifies the conditions in one pass.\n\n# [edge case] \n    Test case with n = 1 and b_1 = 1: Output = YES, 1\n    Explanation: With only one town and a concert duration of 1, the initial repertoire must be 1.\n\n    Test case with n = 2 and b_1 = b_2 = 2: Output = NO\n    Explanation: It's impossible to have two towns with the same concert duration without violating the increasing sequence condition.\n\n    Test case with n = 3 and b_1 = b_2 = b_3 = 3: Output = NO\n    Explanation: With equal concert durations in all towns, it's impossible to satisfy the increasing sequence condition.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to check if the calculated sequence of initial repertoire durations is valid by ensuring that the sum of the calculated durations matches the given total durations in each town.\n    - Additionally, handle cases where the sequence cannot be constructed due to constraints.\n\n```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n*(n+1)/2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a_i\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference between b[i] and b[i-1] in circular manner\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            \n            # Calculate a[i]\n            if (total_a + diff) % n != 0:\n                possible = False\n                break\n            \n            a[i] = (total_a + diff) // n\n            \n            if a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total concert durations in each town.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations exists that satisfies the given total concert durations in each town.\",\n      \"input\": \"Number of towns and total concert durations for each town\",\n      \"output\": \"A valid sequence of initial repertoire durations or a determination that no such sequence exists\"\n    },\n    {\n      \"description\": \"Implement a method to reconstruct the sequence of initial repertoire durations for each singer, ensuring that the total concert durations match the given values for each town.\",\n      \"input\": \"Total concert durations for each town\",\n      \"output\": \"A sequence of initial repertoire durations or a determination that no such sequence exists\"\n    },\n    {\n      \"description\": \"Format the output for each test case, indicating whether a valid sequence was found and, if so, providing the sequence.\",\n      \"input\": \"Results from the sequence reconstruction step\",\n      \"output\": \"Formatted output string for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize variables to store the number of towns and the total concert durations for each town.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations:\",\n    \"  - Iterate over possible initial repertoire durations and calculate the resulting concert durations for each town.\",\n    \"  - Check if the calculated concert durations match the given total durations for each town.\",\n    \"  - If a valid sequence is found, store it; otherwise, mark the test case as having no solution.\",\n    \"Format the output for each test case, indicating 'YES' and the sequence if a solution exists, or 'NO' if no solution is possible.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around, and the last town is followed by the first town.\n\n    'repertoire'\n    Explanation: The initial duration of songs each singer has before starting the concerts.\n\n    'concert duration'\n    Explanation: The total time a singer performs in a town, which increases as they visit more towns.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i': This indicates that the concert duration in the next town is twice the initial repertoire.\n    'k + 2': This indicates that the concert duration increases by a factor of (k + 2) times the initial repertoire as the singer visits more towns.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and formatting output can be implemented separately, but the logic for reconstructing the sequence of initial repertoire durations should be handled in a single code block. This involves iterating over possible initial repertoire durations and checking if they satisfy the conditions for all towns.\n\n# [edge case] \n    Test case with n = 1 and b_1 = 1: \n    Expected output: YES, 1\n    Explanation: With only one town, the initial repertoire must equal the total concert duration.\n\n    Test case with n = 2 and b_1 = b_2 = 2:\n    Expected output: YES, 1 1\n    Explanation: Each singer performs for 1 minute in their own town and 2 minutes in the other town, matching the total durations.\n\n    Test case with n = 3 and b_1 = b_2 = b_3 = 3:\n    Expected output: NO\n    Explanation: It's impossible to distribute the initial repertoire such that each town's total concert duration is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to check if the sum of b_i is divisible by n, as this is a necessary condition for a valid sequence to exist.\n    - Additionally, we need to ensure that the calculated initial repertoire values are positive integers.\n\n```python\ndef solve_concert_problem(test_cases):\n    results = []\n    for n, b in test_cases:\n        total_b = sum(b)\n        if total_b % n != 0:\n            results.append(\"NO\")\n            continue\n        \n        a = [0] *", "Round_0": {"code": "def solve_concert_problem():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve_concert_problem()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 101)"}, "Round_1": {"code": "def solve_concert_problem():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve_concert_problem()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration a_i for each singer.\",\n        \"Check if the calculated sequence a satisfies the condition for all towns.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the given conditions.\",\n    \"Check the validity of the sequence by ensuring the total concert durations match the given array b.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found; otherwise, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular and sequential manner'\n    Explanation: The towns are arranged in a circle, meaning after the last town, the sequence continues back to the first town. This affects how the concerts are scheduled and how the durations are calculated.\n\n    'repertoire of a_i minutes'\n    Explanation: Each singer starts with a repertoire of a certain duration, which increases as they perform in each town.\n\n    'total duration of concerts in i-th city'\n    Explanation: This is the sum of all concerts performed by all singers in a particular town.\n\n# [phrase showing quantity relationship]\n    '2 \u22c5 a_i', '(k + 2) \u22c5 a_i', 'n \u22c5 a_i'\n    Explanation: These phrases describe how the concert duration increases as the singer moves from town to town. The duration is a multiple of the initial repertoire, increasing by one multiple for each subsequent town.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the initial repertoire duration a_i for each singer and the validation of the sequence can be done in a single loop for efficiency.\n\n# [edge case] \n    Test case with n = 1 and b_1 = 1: \n    Expected output: YES 1\n    Explanation: With only one town and a total duration of 1, the only possible initial repertoire is 1.\n\n    Test case with n = 2 and b_1 = b_2 = 2:\n    Expected output: NO\n    Explanation: It's impossible to have two singers with initial repertoires that satisfy the given total durations in both towns.\n\n    Test case with n = 3 and b_1 = b_2 = b_3 = 3:\n    Expected output: YES 1 1 1\n    Explanation: Each singer can start with a repertoire of 1, and the total duration in each town will be 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that the calculated sequence a satisfies the condition for all towns, and handle cases where n = 1 separately.\n    ```python\n    if n == 1:\n        if b[0] % n == 0:\n            print(\"YES\")\n            print(b[0] // n)\n        else:\n            print(\"NO\")\n    else:\n        # Original", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Special case for n = 1\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Special case for n = 1\n            if b[0] % n == 0:\n                results.append(\"YES\")\n                results.append(str(b[0] // n))\n            else:\n                results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total concert durations for each town.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total concert durations in each town.\"\n      ]\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations a exists that satisfies the given conditions.\",\n      \"steps\": [\n        \"Initialize an array a of size n to store the initial repertoire durations for each singer.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration a_i for each singer.\",\n        \"Check if the calculated sequence a satisfies the condition that the total concert duration in each town matches the given b array.\",\n        \"If a valid sequence a is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence a was found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations a.\",\n    \"Check if the reconstructed sequence satisfies the total concert durations for each town.\",\n    \"Output 'YES' and the sequence a if a valid sequence is found, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence': refers to the order in which towns and singers are arranged and visited.\n    'repertoire': refers to the initial duration of songs each singer has before visiting other towns.\n    Explanation: The requirement involves reconstructing the initial song durations (repertoire) for singers based on the total concert durations in each town.\n\n# [phrase showing quantity relationship]\n    'total duration': refers to the sum of concert durations in each town.\n    'minutes': refers to the unit of time for each concert.\n    Explanation: The total duration in each town is the sum of concerts given by all singers, calculated based on their repertoire and the sequence of towns.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially. However, the calculation of the initial repertoire duration for each singer and the verification of the sequence should be considered simultaneously within the loop iterating over towns.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town and one singer, the initial repertoire can be directly equal to the total duration.\n    \n    Test case with n = 3 and b = [1, 2, 3] = NO\n    Explanation: The sequence of concerts cannot be reconstructed to match these durations with positive integers.\n    \n    Test case with n = 2 and b = [2, 4] = YES, 1 2\n    Explanation: The first singer can have a repertoire of 1 minute, and the second singer can have a repertoire of 2 minutes, matching the total durations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include logic to check if the sequence can be reconstructed with positive integers and handle cases where n = 1 separately.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            # Edge case: If there's only one town, the answer is directly the value of b[0]\n            results.append(\"YES\")\n            results.append(f\"{b[0]}\")\n            continue\n        \n        # Calculate the sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            a[i] = (total_a + diff) // n\n            \n            # Check if a[i] is a positive integer\n            if a[i] <= 0 or (total_a + diff) % n != 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    # Print all results\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of towns.\",\n        \"Read the array b of n integers, which represents the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, check if the sum of the array b is divisible by the sum of the first n natural numbers (1 to n).\",\n        \"If not divisible, output 'NO' for that test case.\"\n      ]\n    },\n    {\n      \"description\": \"Reconstruct a valid sequence of initial repertoire durations if possible.\",\n      \"steps\": [\n        \"Calculate the sum of the first n natural numbers (1 to n).\",\n        \"Divide the total sum of b by this sum to find the initial repertoire duration for each singer.\",\n        \"Verify that the calculated sequence satisfies the conditions for all towns.\",\n        \"If valid, output 'YES' followed by the sequence of initial repertoire durations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, check if a valid sequence of initial repertoire durations can be reconstructed.\",\n    \"If a valid sequence exists, reconstruct it and output 'YES' followed by the sequence.\",\n    \"If no valid sequence exists, output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular and sequential manner'\n    Explanation: This means that the towns are arranged in a circle, and the sequence of visiting towns wraps around after reaching the last town, continuing from the first town again.\n\n    'repertoire of a_i minutes'\n    Explanation: This refers to the initial duration of songs that each singer has before starting their tour.\n\n    'total duration of concerts in the i-th town'\n    Explanation: This is the sum of all concert durations given by all singers in the i-th town.\n\n# [phrase showing quantity relationship]\n    'exactly one concert in each town': Each singer performs once in each town.\n    '2 \u22c5 a_i': This indicates that the concert duration in the next town is twice the initial repertoire.\n    '(k + 2) \u22c5 a_i': This shows that the concert duration increases by a factor of (k + 2) times the initial repertoire as the singer moves to subsequent towns.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the verification of the sequence should be done simultaneously with the reconstruction to ensure correctness.\n\n# [edge case]\n    1. Test case with n = 1 and b_1 = 1\n       Expected output: YES 1\n       Explanation: With only one town and a total concert duration of 1, the initial repertoire must be 1.\n       \n    2. Test case with n = 2 and b_1 = 3, b_2 = 3\n       Expected output: NO\n       Explanation: The sum of b (6) is not divisible by the sum of the first 2 natural numbers (3), so it's impossible to find a valid sequence.\n       \n    3. Test case with n = 3 and b_1 = 6, b_2 = 6, b_3 = 6\n       Expected output: YES 2 2 2\n       Explanation: Each singer can have an initial repertoire of 2, leading to a total concert duration of 6 in each town.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to check if the sum of b is divisible by the sum of the first n natural numbers and ensure that the reconstructed sequence satisfies the conditions for all towns.\n\n```python\ndef solve():\n    import sys\n    input = sys", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        sum_n = n * (n + 1) // 2\n        \n        if total_b % sum_n != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // sum_n\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1] if i > 0 else b[i] - b[n - 1]\n            if (total_a + diff) % n != 0 or (total_a + diff) // n <= 0:\n                possible = False\n                break\n            a[i] = (total_a + diff) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the corresponding data for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of towns.\",\n        \"Read the array b of n integers, representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence a exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial duration of repertoire for each singer.\",\n        \"Iterate over each town and calculate the possible values for a_i based on the given b array.\",\n        \"Check if the calculated values for a_i are consistent and valid (i.e., positive integers).\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If a valid sequence a is found, print 'YES' followed by the sequence a.\",\n        \"If no valid sequence exists, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the data for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence a that satisfies the conditions given by the b array.\",\n    \"Check the consistency and validity of the reconstructed sequence.\",\n    \"Output the result for each test case, indicating whether a valid sequence was found or not.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence': Refers to the arrangement of towns and singers in a circular manner, where each singer visits all towns in a specific order.\n    'repertoire': The initial duration of songs each singer has before visiting other towns.\n    Explanation: The requirement involves reconstructing the initial song durations for singers based on the total concert durations in each town.\n\n# [phrase showing quantity relationship]\n    'total duration': Refers to the sum of concert durations in each town, which is given by the array b.\n    Explanation: The total duration in each town is the sum of concerts given by all singers, which needs to be broken down to find individual singer's initial repertoire.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for parsing input and determining the sequence should be implemented simultaneously for efficiency. Specifically, parsing the input and calculating possible values for a_i can be done in a single loop for each test case.\n\n# [edge case]\n    Test case with n = 1 and b = [1] = YES, 1\n    Explanation: With only one town and one singer, the initial repertoire must be equal to the total duration, which is 1.\n    Test case with n = 3 and b = [1, 2, 3] = NO\n    Explanation: The sequence cannot be reconstructed as the total durations do not allow for a consistent positive integer sequence.\n    Test case with n = 2 and b = [2, 2] = YES, 1 1\n    Explanation: Each singer can have an initial repertoire of 1, leading to consistent total durations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1:\n            if b[0] > 0:\n                print(\"YES\")\n                print(b[0])\n            else:\n                print(\"NO\")\n        elif sum(b) % n != 0:\n            print(\"NO\")\n        else:\n            # Implement logic to reconstruct sequence a\n            # (other code)\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] > 0:\n                results.append(\"YES\")\n                results.append(f\"{b[0]}\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 1:\n            if b[0] > 0:\n                results.append(\"YES\")\n                results.append(f\"{b[0]}\")\n            else:\n                results.append(\"NO\")\n            continue\n        \n        total_b = sum(b)\n        \n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            diff = b[i] - b[i - 1]\n            a[i] = (total_a + diff) // n\n            if (total_a + diff) % n != 0 or a[i] <= 0:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of towns and the total concert durations in each town.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Parsed data structure containing test cases\"\n    },\n    {\n      \"description\": \"For each test case, determine if a valid sequence of initial repertoire durations exists that satisfies the given total concert durations for each town.\",\n      \"input\": \"Number of towns and total concert durations for each town\",\n      \"output\": \"A valid sequence of initial repertoire durations or a determination that no such sequence exists\"\n    },\n    {\n      \"description\": \"Implement a method to reconstruct the sequence of initial repertoire durations for each test case, if possible.\",\n      \"input\": \"Total concert durations for each town\",\n      \"output\": \"A sequence of initial repertoire durations or a determination that no such sequence exists\"\n    },\n    {\n      \"description\": \"Format the output for each test case according to the specified format, either printing 'YES' followed by the sequence or 'NO' if no sequence is possible.\",\n      \"input\": \"Result of the sequence reconstruction for each test case\",\n      \"output\": \"Formatted output string\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize variables to store the number of towns and the total concert durations for each town.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations:\",\n    \"  - Iterate over possible initial durations and calculate the expected total concert durations for each town.\",\n    \"  - Check if the calculated durations match the given durations.\",\n    \"  - If a match is found, store the sequence; otherwise, determine that no valid sequence exists.\",\n    \"Format the output for each test case, printing 'YES' and the sequence if a valid sequence is found, or 'NO' if not.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sequence of positive integers a'\n    Explanation: This refers to the initial repertoire durations of each singer in each town. The task is to determine if such a sequence can be reconstructed from the given total concert durations.\n\n    'total duration of concerts in the i-th town'\n    Explanation: This is the sum of all concerts given by all singers in the i-th town. Each singer's concert duration increases as they move from town to town.\n\n# [phrase showing quantity relationship]\n    'exactly one concert in each town'\n    Explanation: Each singer performs once in each town, and the duration of their concert increases as they move to the next town.\n\n    'k + 2'\n    Explanation: This indicates the multiplier for the concert duration as the singer moves to subsequent towns. It starts from 1 and increases by 1 for each town visited.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the reconstruction of the sequence of initial repertoire durations involves iterating over possible initial durations and checking if they match the given total durations. This involves a nested loop or a systematic approach to check each possibility.\n\n# [edge case]\n    1. n = 1, b = [1] = YES, 1\n       Explanation: With only one town and a total duration of 1, the only possible initial repertoire is 1.\n    2. n = 2, b = [2, 2] = NO\n       Explanation: With two towns and equal total durations, it's impossible to have a sequence where each singer's concert duration increases as required.\n    3. n = 3, b = [3, 6, 9] = YES, 1 2 3\n       Explanation: Each singer can start with 1, 2, and 3 minutes respectively, and the total durations match the given values.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should systematically try to reconstruct the sequence by iterating over possible initial durations and checking if they match the given total durations. If no valid sequence is found, it should return 'NO'.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        # Calculate the total sum of b\n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) / 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        # Calculate the total sum of a\n        total_a = total_b // (n * (n + 1) // 2)\n        \n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            # Calculate the difference\n            diff = b[i] - b[i - 1]\n            # Calculate a[i]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\n# This function will be called when the script is executed\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t representing the number of test cases.\",\n        \"For each test case, read the integer n representing the number of towns.\",\n        \"Read the array b of n integers representing the total duration of concerts in each town.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a valid sequence of initial repertoire durations exists for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize an array a of size n to store the initial repertoire durations.\",\n        \"Iterate over each town and calculate the possible initial repertoire duration for each singer.\",\n        \"Check if the calculated sequence satisfies the conditions given in the problem statement.\",\n        \"If a valid sequence is found, store it; otherwise, mark the test case as impossible.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, if a valid sequence was found, print 'YES' followed by the sequence.\",\n        \"If no valid sequence was found, print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, attempt to reconstruct a valid sequence of initial repertoire durations.\",\n    \"Check the validity of the reconstructed sequence against the given conditions.\",\n    \"Output 'YES' and the sequence if valid, or 'NO' if no valid sequence exists.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'circular arrangement'\n    Explanation: The towns are arranged in a circle, meaning the sequence wraps around after the last town back to the first.\n\n    'repertoire'\n    Explanation: The initial duration of songs each singer has before starting their tour.\n\n    'concert duration'\n    Explanation: The total time a singer performs in a town, which increases as they visit more towns.\n\n# [phrase showing quantity relationship]\n    'exactly one concert'\n    Explanation: Each singer performs exactly once in each town.\n\n    'k + 2'\n    Explanation: This indicates the multiplier for the concert duration as the singer moves to the next town. It starts from 1 and increases by 1 for each subsequent town.\n\n# [degree adverb]\n    'any correct sequence'\n    Explanation: There can be multiple valid sequences of initial repertoire durations that satisfy the conditions.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the calculation of the initial repertoire duration for each singer and the validation of the sequence can be done in a single loop for efficiency.\n\n# [edge case]\n    Edge Case 1: n = 1, b = [1]\n    Expected Output: YES 1\n    Explanation: With only one town, the initial repertoire must be equal to the total concert duration.\n\n    Edge Case 2: n = 2, b = [2, 2]\n    Expected Output: NO\n    Explanation: It's impossible to have two singers with initial durations that satisfy the conditions for both towns.\n\n    Edge Case 3: n = 3, b = [3, 6, 9]\n    Expected Output: YES 1 2 3\n    Explanation: Each singer's initial repertoire can be 1, 2, and 3, respectively, satisfying the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should check if the sum of the calculated initial repertoires matches the total concert durations for each town. If not, it should return \"NO\".\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_b = sum(b)\n        \n        # Check if total_b is divisible by n * (n + 1) // 2\n        if total_b % (n * (n + 1) // 2) != 0:\n            results.append(\"NO\")\n            continue\n        \n        total_a = total_b // (n * (n + 1) // 2)\n        a = [0] * n\n        possible = True\n        \n        for i in range(n):\n            prev = (i - 1 + n) % n\n            diff = b[i] - b[prev]\n            if (diff - total_a) % n != 0 or (diff - total_a) // n <= 0:\n                possible = False\n                break\n            a[i] = (diff - total_a) // n\n        \n        if possible:\n            results.append(\"YES\")\n            results.append(\" \".join(map(str, a)))\n        else:\n            results.append(\"NO\")\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()\n"}}], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 1, "round": 676, "prompt": "n towns are arranged in a circle in sequence. The towns are numbered from 1 to n clockwise. In the i-th town, there lives a singer with a repertoire of a_i minutes for each i \u2208 [1, n].\n\nEach singer visited all n towns in clockwise order, starting with the town he lives in, and gave exactly one concert in each town. Additionally, in each town, the i-th singer got inspired and came up with a song of a_i minutes. The song was added to his repertoire so that he could perform it in the remaining cities.\n\nThus, for the i-th singer, the concert in the i-th town will last a_i minutes, in the (i + 1)-th town the concert will last 2 \u22c5 a_i minutes, ..., in the ((i + k) mod n + 1)-th town the duration of the concert will be (k + 2) \u22c5 a_i, ..., in the town ((i + n - 2) mod n + 1) \u2014 n \u22c5 a_i minutes.\n\nYou are given an array of b integer numbers, where b_i is the total duration of concerts in the i-th town. Reconstruct any correct sequence of positive integers a or say that it is impossible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^3) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines. The first line contains a single integer n (1 \u2264 n \u2264 4 \u22c5 10^4) \u2014 the number of cities. The second line contains n integers b_1, b_2, ..., b_n (1 \u2264 b_i \u2264 10^{9}) \u2014 the total duration of concerts in i-th city.\n\nThe sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, print the answer as follows:\n\nIf there is no suitable sequence a, print NO. Otherwise, on the first line print YES, on the next line print the sequence a_1, a_2, ..., a_n of n integers, where a_i (1 \u2264 a_i \u2264 10^{9}) is the initial duration of repertoire of the i-th singer. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n4\n3\n12 16 14\n1\n1\n3\n1 2 3\n6\n81 75 75 93 93 87\n\n\nOutput\n\n\nYES\n3 1 3 \nYES\n1 \nNO\nYES\n5 5 4 1 4 5 \n\nNote\n\nLet's consider the 1-st test case of the example:\n\n  1. the 1-st singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 6 minutes, in the 3-rd \u2014 for 9 minutes; \n  2. the 2-nd singer in the 1-st city will give a concert for 3 minutes, in the 2-nd \u2014 for 1 minute, in the 3-rd - for 2 minutes; \n  3. the 3-rd singer in the 1-st city will give a concert for 6 minutes, in the 2-nd \u2014 for 9 minutes, in the 3-rd \u2014 for 3 minutes. ", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 45}
