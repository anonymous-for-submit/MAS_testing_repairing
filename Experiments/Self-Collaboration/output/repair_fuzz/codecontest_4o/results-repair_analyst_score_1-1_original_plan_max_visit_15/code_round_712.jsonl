{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days? Aim to balance the heights of the towers as evenly as possible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). During this operation, you move a block from tower i to tower j. Effectively, this decreases a_i by 1 while simultaneously increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days? Aim to balance the heights of the towers as evenly as possible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days? Aim to balance the heights of the towers as evenly as possible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate ugliness for floor average\n        excess_blocks_floor = sum(max(0, h - avg_floor) for h in heights)\n        needed_blocks_floor = sum(max(0, avg_floor - h) for h in heights)\n        ugliness_floor = max(excess_blocks_floor, needed_blocks_floor)\n\n        # Calculate ugliness for ceiling average\n        excess_blocks_ceil = sum(max(0, h - avg_ceil) for h in heights)\n        needed_blocks_ceil = sum(max(0, avg_ceil - h) for h in heights)\n        ugliness_ceil = max(excess_blocks_ceil, needed_blocks_ceil)\n\n        # The minimum ugliness is the minimum of the two calculated ugliness values\n        min_ugliness = min(ugliness_floor, ugliness_ceil)\n        results.append(min_ugliness)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height_floor = total_sum // n\n        average_height_ceil = average_height_floor if total_sum % n == 0 else average_height_floor + 1\n        \n        # Calculate the number of towers that should have the floor and ceil heights\n        count_floor = n - (total_sum % n)\n        count_ceil = total_sum % n\n        \n        # Calculate the ugliness\n        min_possible_ugliness = average_height_ceil - average_height_floor\n        \n        results.append(min_possible_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_height_floor = total_height // n\n        avg_height_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Count how many towers should have the floor height and how many should have the ceil height\n        count_floor = n * avg_height_ceil - total_height\n        count_ceil = n - count_floor\n\n        # The minimum ugliness is the difference between the ceil and floor heights\n        min_ugliness = avg_height_ceil - avg_height_floor\n\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        remainder = total_sum % n\n        # The minimum possible ugliness is determined by the remainder\n        results.append(remainder)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        # If there is a remainder, the minimum ugliness is 1, otherwise it's 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height = total_blocks // n\n        remainder = total_blocks % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate how many buildings should have the floor and ceiling heights\n        num_ceil = total_height % n\n        num_floor = n - num_ceil\n\n        # The minimum possible ugliness is the difference between the ceiling and floor\n        min_ugliness = avg_ceil - avg_floor\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate the minimum possible ugliness\n        # If remainder is 0, all buildings can be of the same height\n        # Otherwise, the difference will be 1 (between floor and ceiling)\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        # If there is a remainder, the minimum ugliness is 1, otherwise it's 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport math\n\ndef calculate_minimum_ugliness(heights):\n    total_sum = sum(heights)\n    n = len(heights)\n    average_height_floor = total_sum // n\n    average_height_ceil = math.ceil(total_sum / n)\n    \n    # Calculate the number of towers that can have the floor and ceil heights\n    floor_count = total_sum - average_height_floor * n\n    ceil_count = n - floor_count\n    \n    # Calculate the ugliness\n    min_ugliness = average_height_ceil - average_height_floor if floor_count > 0 else 0\n    return min_ugliness\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_ugliness = calculate_minimum_ugliness(heights)\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate ugliness for floor average\n        excess_blocks_floor = sum(max(0, h - avg_floor) for h in heights)\n        needed_blocks_floor = sum(max(0, avg_floor - h) for h in heights)\n        ugliness_floor = max(excess_blocks_floor, needed_blocks_floor)\n\n        # Calculate ugliness for ceiling average\n        excess_blocks_ceil = sum(max(0, h - avg_ceil) for h in heights)\n        needed_blocks_ceil = sum(max(0, avg_ceil - h) for h in heights)\n        ugliness_ceil = max(excess_blocks_ceil, needed_blocks_ceil)\n\n        # The minimum ugliness is the minimum of the two calculated ugliness values\n        min_ugliness = min(ugliness_floor, ugliness_ceil)\n        results.append(min_ugliness)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by n, and consider both the floor and ceiling of this average.\",\n        \"Calculate the potential ugliness for both the floor and ceiling average by redistributing the blocks to achieve these heights.\",\n        \"Choose the minimum ugliness from the calculated potential ugliness values.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the minimum possible ugliness calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and consider both the floor and ceiling of this average.\",\n    \"Calculate the potential ugliness for both the floor and ceiling average.\",\n    \"Choose the minimum ugliness from the calculated potential ugliness values.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a). The goal is to minimize this difference by redistributing blocks between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means finding the smallest value of max(a) - min(a) after redistributing blocks.\n    'as evenly as possible': implies redistributing blocks to make the heights of the towers as close to each other as possible.\n\n# [degree adverb]\n    'minimum': means the smallest possible value of ugliness that can be achieved.\n\n# [code logic]\n    The steps for calculating the potential ugliness for both the floor and ceiling average should be considered simultaneously. This involves redistributing blocks to achieve these heights and calculating the ugliness for both scenarios in one code block.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: The towers are already balanced, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] => Expected output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest towers to achieve equal heights.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: After redistributing blocks, the closest possible balance results in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve the floor and ceiling average will handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate ugliness for floor average\n        excess_blocks_floor = sum(max(0, h - avg_floor) for h in heights)\n        needed_blocks_floor = sum(max(0, avg_floor - h) for h in heights)\n        ugliness_floor = max(excess_blocks_floor, needed_blocks_floor)\n\n        # Calculate ugliness for ceiling average\n        excess_blocks_ceil = sum(max(0, h - avg_ceil) for h in heights)\n        needed_blocks_ceil = sum(max(0, avg_ceil - h) for h in heights)\n        ugliness_ceil = max(excess_blocks_ceil, needed_blocks_ceil)\n\n        # The minimum ugliness is the minimum of the two calculated ugliness values\n        min_ugliness = min(ugliness_floor, ugliness_ceil)\n        results.append(min_ugliness)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the floor and ceiling of the average height.\",\n        \"Compute the difference between the tallest and shortest buildings after redistributing blocks to achieve the closest possible balance.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness by redistributing blocks to balance the heights as evenly as possible.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, formally expressed as max(a) - min(a).\n\n    'balance the heights'\n    Explanation: This means redistributing the blocks among the towers to make their heights as equal as possible, minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest value of max(a) - min(a) that can be achieved by redistributing blocks among the towers.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest buildings after redistribution.\n\n# [code logic]\n    The steps in the plan related to calculating the total sum, determining the average height, and calculating the minimum possible ugliness should be considered simultaneously. Specifically, calculating the floor and ceiling of the average height and redistributing blocks to achieve balance should be done in a single logical block to ensure the correct redistribution of blocks.\n\n# [edge case]\n    1. Test case with all towers having the same height: \n       Input: 3\n              3\n              5 5 5\n       Expected output: 0\n       Explanation: All towers are already balanced, so the ugliness is 0.\n\n    2. Test case with two towers of significantly different heights:\n       Input: 1\n              2\n              1 100\n       Expected output: 0\n       Explanation: You can move blocks from the taller tower to the shorter one until they are equal.\n\n    3. Test case with the minimum number of towers:\n       Input: 1\n              2\n              1 1\n       Expected output: 0\n       Explanation: Both towers are already balanced, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve the closest possible balance will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average_height_floor = total_sum // n\n        average_height_ceil = average_height_floor if total_sum % n == 0 else average_height_floor + 1\n        \n        # Calculate the number of towers that should have the floor and ceil heights\n        count_floor = n - (total_sum % n)\n        count_ceil = total_sum % n\n        \n        # Calculate the ugliness\n        min_possible_ugliness = average_height_ceil - average_height_floor\n        \n        results.append(min_possible_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the floor and ceiling of the average height to determine the target heights for balancing.\",\n        \"Distribute the blocks to achieve the target heights, minimizing the difference between the tallest and shortest buildings.\",\n        \"Calculate the minimum possible ugliness as the difference between the maximum and minimum heights after redistribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the target heights for balancing.\",\n    \"Redistribute the blocks to achieve the target heights, minimizing the height difference.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'balance the heights'\n    Explanation: The goal is to redistribute the blocks among the towers to make their heights as even as possible, thereby minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to achieving the smallest possible difference between the tallest and shortest buildings after redistribution. In code, this is implemented by redistributing blocks to minimize max(a) - min(a).\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to find the smallest possible value of ugliness after redistributing the blocks. In code, this involves calculating the difference between the maximum and minimum heights after redistribution.\n\n# [code logic]\n    The steps for calculating the total sum, determining average height, and redistributing blocks should be considered simultaneously. This can be implemented in a single function that handles the redistribution logic and calculates the minimum ugliness.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1]\n    Expected output: 0\n    Explanation: The towers are already balanced, so the ugliness is 0.\n\n    Case 2: n = 3, heights = [1, 1, 10]\n    Expected output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest ones to achieve equal heights.\n\n    Case 3: n = 4, heights = [1, 1, 1, 10]\n    Expected output: 1\n    Explanation: After redistribution, the closest balance achievable is [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve balance will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_height_floor = total_height // n\n        avg_height_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Count how many towers should have the floor height and how many should have the ceil height\n        count_floor = n * avg_height_ceil - total_height\n        count_ceil = n - count_floor\n\n        # The minimum ugliness is the difference between the ceil and floor heights\n        min_ugliness = avg_height_ceil - avg_height_floor\n\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the remainder when the total sum is divided by n, which represents the imbalance that cannot be evenly distributed.\",\n        \"The minimum possible ugliness is determined by the remainder, which is either 0 or 1.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the remainder to determine the minimum possible ugliness.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the height difference between the tallest and shortest buildings, which is calculated as max(a) - min(a).\n\n    'balance the heights'\n    Explanation: The goal is to make the heights of the towers as even as possible by redistributing blocks between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest value of max(a) - min(a) that can be achieved after redistributing blocks between towers. In code, this is determined by calculating the remainder when the total sum of heights is divided by the number of buildings, n.\n\n# [degree adverb]\n    'nicest'\n    Explanation: This refers to the most balanced state of the building heights, where the ugliness is minimized.\n\n# [code logic]\n    The steps for calculating the total sum, determining the average height, and calculating the remainder should be considered simultaneously as they are part of the same logical operation to determine the minimum possible ugliness.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1]\n    Expected output: 0\n    Explanation: The towers are already balanced, so the ugliness is 0.\n\n    Case 2: n = 3, heights = [1, 1, 3]\n    Expected output: 1\n    Explanation: After redistributing blocks, the closest balance is [2, 2, 1], resulting in an ugliness of 1.\n\n    Case 3: n = 4, heights = [1, 1, 1, 1]\n    Expected output: 0\n    Explanation: The towers are already balanced, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the remainder when the total sum is divided by n will handle these cases correctly.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        remainder = total_sum % n\n        # The minimum possible ugliness is determined by the remainder\n        results.append(remainder)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the remainder when the total sum is divided by n, which indicates how many buildings will have a height of average + 1.\",\n        \"Determine the minimum possible ugliness as the difference between average + 1 and average, which is 1 if there is a remainder, otherwise 0.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and calculate the remainder.\",\n    \"Calculate the minimum possible ugliness based on the average height and remainder.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'balance the heights'\n    Explanation: The goal is to make the heights of the towers as even as possible, minimizing the difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest difference between the tallest and shortest buildings that can be achieved through operations.\n\n# [degree adverb] \n    'nicest'\n    Explanation: This refers to the most balanced state of the building heights, where the ugliness is minimized.\n\n# [code logic]\n    The steps for calculating the average height and determining the remainder should be considered simultaneously. \n    \"Calculate the total sum of the building heights.\"\n    \"Determine the average height by dividing the total sum by the number of buildings, n.\"\n    \"Calculate the remainder when the total sum is divided by n.\"\n    These steps can be implemented in a single code block to efficiently compute the average and remainder.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: The towers are already balanced, so the ugliness is 0.\n\n    Case 2: n = 3, heights = [1, 1, 1] => Expected output: 0\n    Explanation: All towers have the same height, so the ugliness is 0.\n\n    Case 3: n = 4, heights = [1, 1, 1, 4] => Expected output: 1\n    Explanation: After operations, the heights can be balanced to [2, 2, 2, 1], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the average and remainder will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        # If there is a remainder, the minimum ugliness is 1, otherwise it's 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of buildings and their respective heights.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing the number of test cases and a list of building heights for each test case\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of blocks across all towers.\",\n      \"input\": \"List of building heights for a test case\",\n      \"output\": \"Total number of blocks\"\n    },\n    {\n      \"description\": \"Determine the target height for each tower to minimize ugliness. This is the integer division of the total number of blocks by the number of towers.\",\n      \"input\": \"Total number of blocks and number of towers\",\n      \"output\": \"Target height for each tower\"\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness by determining the difference between the maximum possible height and the minimum possible height after redistribution.\",\n      \"input\": \"Total number of blocks, number of towers, and target height\",\n      \"output\": \"Minimum possible ugliness\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and the list of building heights for each test case.\",\n    \"For each test case, calculate the total number of blocks by summing up the heights of all towers.\",\n    \"Determine the target height for each tower by performing integer division of the total number of blocks by the number of towers.\",\n    \"Calculate the remainder when the total number of blocks is divided by the number of towers to determine how many towers will have an extra block.\",\n    \"The minimum possible ugliness is determined by the difference between the target height and the target height plus one (if there is a remainder).\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'balance the heights'\n    Explanation: The goal is to redistribute the blocks among the towers to make their heights as even as possible, minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest difference between the tallest and shortest buildings that can be achieved through redistribution.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The requirement is asking for the smallest possible value of ugliness after redistribution.\n\n# [code logic]\n    The steps to calculate the total number of blocks and determine the target height should be considered simultaneously. Specifically, calculating the target height and the remainder can be done in one code block as they are directly related.\n\n# [edge case] \n    Test case with all towers having the same height: \n    Input: 2\n           5 5\n    Expected output: 0\n    Explanation: Since all towers already have the same height, the ugliness is 0.\n\n    Test case with one tower significantly taller than others:\n    Input: 3\n           1 1 10\n    Expected output: 1\n    Explanation: After redistribution, the heights can be [4, 4, 4], resulting in an ugliness of 0.\n\n    Test case with minimum number of towers:\n    Input: 2\n           1 2\n    Expected output: 0\n    Explanation: After redistribution, the heights can be [1, 2], resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the target height and remainder will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_blocks = sum(heights)\n        target_height = total_blocks // n\n        remainder = total_blocks % n\n        # The minimum possible ugliness is 1 if there is a remainder, otherwise 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Compute the average height by dividing the total sum by the number of buildings, n.\",\n        \"Determine the floor and ceiling of the average height to handle integer division.\",\n        \"Calculate the number of buildings that should have the floor height and the ceiling height to balance the heights as evenly as possible.\",\n        \"Compute the minimum possible ugliness as the difference between the ceiling and floor values.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Compute the average height and determine the floor and ceiling values.\",\n    \"Calculate the number of buildings that should have the floor height and the ceiling height.\",\n    \"Determine the minimum possible ugliness as the difference between the ceiling and floor values.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a). The goal is to minimize this difference by redistributing the blocks among the towers.\n\n# [phrase showing quantity relationship]\n    'as evenly as possible': This means redistributing the blocks so that the heights of the towers are as close to each other as possible, ideally making them all equal or as close to equal as possible.\n\n# [degree adverb] \n    'minimum': This refers to achieving the smallest possible value of ugliness, which is the smallest difference between the tallest and shortest towers.\n\n# [code logic]\n    The steps for calculating the total sum, computing the average, and determining the floor and ceiling values should be considered simultaneously. These calculations are interdependent and can be efficiently handled in a single block of code.\n\n# [edge case] \n    1. Input: 1\n       2\n       10000000 10000000\n       Expected Output: 0\n       Explanation: Both towers are already of equal height, so the ugliness is 0.\n       \n    2. Input: 1\n       3\n       1 1 10000000\n       Expected Output: 9999999\n       Explanation: The difference between the tallest and shortest tower is 9999999, and it's not possible to make them equal with the given operations.\n       \n    3. Input: 1\n       4\n       1 1 1 1\n       Expected Output: 0\n       Explanation: All towers are already of equal height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the floor and ceiling values and determining the minimum possible ugliness will naturally handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate how many buildings should have the floor and ceiling heights\n        num_ceil = total_height % n\n        num_floor = n - num_ceil\n\n        # The minimum possible ugliness is the difference between the ceiling and floor\n        min_ugliness = avg_ceil - avg_floor\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the floor and ceiling of the average height to handle integer division.\",\n        \"Determine how many buildings should have the floor height and how many should have the ceiling height to balance the heights as evenly as possible.\",\n        \"Calculate the minimum possible ugliness as the difference between the ceiling and floor heights.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and calculate the floor and ceiling of this average.\",\n    \"Calculate how many buildings should have the floor height and how many should have the ceiling height.\",\n    \"Compute the minimum possible ugliness as the difference between the ceiling and floor heights.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a). The goal is to minimize this difference by redistributing the blocks among the towers.\n\n# [phrase showing quantity relationship]\n    'as evenly as possible': This implies that the heights of the buildings should be as close to each other as possible, ideally all being the same or differing by at most 1.\n    'minimum possible ugliness': This means finding the smallest possible value of max(a) - min(a) after redistributing the blocks.\n\n# [degree adverb]\n    'minimum': This indicates that the goal is to achieve the smallest possible ugliness, which is the smallest difference between the tallest and shortest buildings.\n\n# [code logic]\n    The steps related to calculating the floor and ceiling of the average height and determining how many buildings should have each height should be considered simultaneously. This can be done in a single calculation block where the total sum is divided by the number of buildings to get the average, and then the floor and ceiling values are used to determine the distribution of heights.\n\n# [edge case]\n    1. Input: 1\n       2\n       10000000 10000000\n       Expected Output: 0\n       Explanation: Both buildings are already of the same height, so the ugliness is 0.\n       \n    2. Input: 1\n       3\n       1 1 10000000\n       Expected Output: 9999999\n       Explanation: The maximum possible ugliness is the difference between the tallest and shortest buildings, which is 9999999.\n       \n    3. Input: 1\n       4\n       1 1 1 1\n       Expected Output: 0\n       Explanation: All buildings are already of the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the floor and ceiling of the average height and redistributing the blocks will naturally handle these cases. \n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_sum = sum(heights)\n        average = total_sum // n\n        remainder = total_sum % n\n        \n        # Calculate the minimum possible ugliness\n        # If remainder is 0, all buildings can be of the same height\n        # Otherwise, the difference will be 1 (between floor and ceiling)\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the heights of the buildings.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the remainder when the total sum is divided by n, which represents the number of buildings that will have a height of average height + 1.\",\n        \"The minimum possible ugliness is determined by the difference between the tallest and shortest buildings after redistribution, which is 1 if there is a remainder, otherwise 0.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the heights and determine the average height.\",\n    \"Calculate the minimum possible ugliness based on the average height and remainder.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'balance the heights'\n    Explanation: The goal is to redistribute the blocks among the towers to make their heights as even as possible, minimizing the ugliness.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: This refers to the smallest difference between the tallest and shortest buildings that can be achieved through redistribution.\n\n# [degree adverb] \n    'tallest', 'shortest'\n    Explanation: 'Tallest' refers to the building with the maximum height, and 'shortest' refers to the building with the minimum height. The code should find these values to calculate ugliness.\n\n# [code logic]\n    The steps for calculating the total sum, average height, and remainder should be considered simultaneously when determining the minimum possible ugliness. This can be implemented in a single function that processes each test case.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 1] = 0\n    Explanation: Both buildings have the same height, so the ugliness is already 0.\n    \n    Case 2: n = 3, heights = [1, 1, 1] = 0\n    Explanation: All buildings have the same height, so the ugliness is 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 4] = 1\n    Explanation: After redistribution, the heights can be [2, 2, 2, 1] or [1, 2, 2, 2], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the average and remainder will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        average_height = total_height // n\n        remainder = total_height % n\n        # If there is a remainder, the minimum ugliness is 1, otherwise it's 0\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of buildings.\",\n        \"For each test case, read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by the number of buildings, n.\",\n        \"Calculate the minimum possible ugliness by considering the ceiling and floor values of the average height.\",\n        \"Compute the difference between the maximum and minimum possible heights after redistributing blocks to achieve balance.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the calculated minimum possible ugliness.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and calculate the minimum possible ugliness by redistributing blocks.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a). The goal is to minimize this difference by redistributing blocks between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means finding the smallest value of max(a) - min(a) after redistributing blocks.\n    'as evenly as possible': means redistributing blocks to make the heights of the towers as close to each other as possible.\n\n# [degree adverb]\n    'minimum': means the smallest possible value of ugliness after redistributing blocks.\n\n# [code logic]\n    The steps for calculating the total sum, determining the average height, and calculating the minimum possible ugliness should be considered simultaneously. This can be done by iterating through the heights once to calculate the sum, then using the sum to determine the average and calculate the possible heights.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: Both towers are already equal in height, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] => Expected output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest ones to make all heights equal, resulting in ugliness of 0.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: After redistributing blocks, the closest possible heights are [3, 3, 3, 4], resulting in an ugliness of 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling the edge case:\n    ```python\n    import math\n\n    def calculate_minimum_ugliness(heights):\n        total_sum = sum(heights)\n        n = len(heights)\n        average_height_floor = total_sum // n\n        average_height_ceil = math.ceil(total_sum / n)\n        \n        # Calculate the number of towers that can have the floor and ceil heights\n        floor_count = total_sum - average_height_floor * n\n        ceil_count = n - floor_count\n        \n        # Calculate the ugliness\n        min_ugliness = average_height_ceil", "Round_0": {"code": "import sys\nimport math\n\ndef calculate_minimum_ugliness(heights):\n    total_sum = sum(heights)\n    n = len(heights)\n    average_height_floor = total_sum // n\n    average_height_ceil = math.ceil(total_sum / n)\n    \n    # Calculate the number of towers that can have the floor and ceil heights\n    floor_count = total_sum - average_height_floor * n\n    ceil_count = n - floor_count\n    \n    # Calculate the ugliness\n    min_ugliness = average_height_ceil - average_height_floor if floor_count > 0 else 0\n    return min_ugliness\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        min_ugliness = calculate_minimum_ugliness(heights)\n        results.append(min_ugliness)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of buildings.\",\n        \"Read the list of integers representing the heights of the buildings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum possible ugliness for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total sum of the building heights.\",\n        \"Determine the average height by dividing the total sum by n, and consider both the floor and ceiling of this average.\",\n        \"Calculate the potential ugliness for both the floor and ceiling average by redistributing the blocks to achieve these heights.\",\n        \"Choose the minimum ugliness from the calculated potential ugliness values.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the minimum possible ugliness calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, calculate the total sum of the building heights.\",\n    \"Determine the average height and consider both the floor and ceiling of this average.\",\n    \"Calculate the potential ugliness for both the floor and ceiling average.\",\n    \"Choose the minimum ugliness from the calculated potential ugliness values.\",\n    \"Output the minimum possible ugliness for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a). The goal is to minimize this difference by redistributing blocks between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': means finding the smallest value of max(a) - min(a) after redistributing blocks.\n    'as evenly as possible': implies redistributing blocks to make the heights of the towers as close to each other as possible.\n\n# [degree adverb]\n    'minimum': means the smallest possible value of ugliness that can be achieved.\n\n# [code logic]\n    The steps for calculating the potential ugliness for both the floor and ceiling average should be considered simultaneously. This involves redistributing blocks to achieve these heights and calculating the ugliness for both scenarios in one code block.\n\n# [edge case]\n    Case 1: n = 2, heights = [1, 1] => Expected output: 0\n    Explanation: The towers are already balanced, so the ugliness is 0.\n    \n    Case 2: n = 3, heights = [1, 1, 10] => Expected output: 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest towers to achieve equal heights.\n    \n    Case 3: n = 4, heights = [1, 1, 1, 10] => Expected output: 1\n    Explanation: After redistributing blocks, the closest possible balance results in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve the floor and ceiling average will handle these cases.\n\nNO", "Round_0": {"code": "def minimum_ugliness(test_cases):\n    results = []\n    for n, heights in test_cases:\n        total_height = sum(heights)\n        avg_floor = total_height // n\n        avg_ceil = (total_height + n - 1) // n  # Equivalent to math.ceil(total_height / n)\n\n        # Calculate ugliness for floor average\n        excess_blocks_floor = sum(max(0, h - avg_floor) for h in heights)\n        needed_blocks_floor = sum(max(0, avg_floor - h) for h in heights)\n        ugliness_floor = max(excess_blocks_floor, needed_blocks_floor)\n\n        # Calculate ugliness for ceiling average\n        excess_blocks_ceil = sum(max(0, h - avg_ceil) for h in heights)\n        needed_blocks_ceil = sum(max(0, avg_ceil - h) for h in heights)\n        ugliness_ceil = max(excess_blocks_ceil, needed_blocks_ceil)\n\n        # The minimum ugliness is the minimum of the two calculated ugliness values\n        min_ugliness = min(ugliness_floor, ugliness_ceil)\n        results.append(min_ugliness)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, heights))\n    \n    results = minimum_ugliness(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 712, "prompt": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and in a single day, you can perform an operation to make the buildings look as nice as possible: choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j). In this operation, you move a block from tower i to tower j, essentially decreasing a_i by 1 and increasing a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days? Aim to balance the heights of the towers as evenly as possible.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 173}
