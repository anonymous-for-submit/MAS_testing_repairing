{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. This means the sum is divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. This essentially means the sum is divided by n, where n is the total number of elements in the array. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is calculated by dividing the sum of elements by their count, so the sum is divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a hashmap to count occurrences\n        from collections import defaultdict\n        count = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "completions": ["def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean_k = total_sum / n\n    target_sum = (n - 2) * mean_k\n    count = 0\n    freq_map = {}\n\n    for num in a:\n        target_value = target_sum - num\n        if target_value in freq_map:\n            count += freq_map[target_value]\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        target_sum = 2 * mean_k\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = {}\n        pair_count = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in element_count:\n                pair_count += element_count[complement]\n            \n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        results.append(pair_count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        if n < 4:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if len(set(a)) == 1:\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        target_sum = 2 * k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += n + 1\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        target_sum = 2 * mean_k\n        \n        # Use a hashmap to count occurrences of each element\n        freq = {}\n        for num in a:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        count_pairs = 0\n        \n        # Iterate over the array to find valid pairs\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count_pairs += freq[complement]\n                # If complement is the same as num, we counted the pair (num, num) twice\n                if complement == num:\n                    count_pairs -= 1\n        \n        # Each pair is counted twice (once as (i, j) and once as (j, i)), so divide by 2\n        results.append(count_pairs // 2)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n        \n        target_sum = int(target_sum)\n        count = 0\n        freq = {}\n        \n        for num in a:\n            complement = target_sum - (total_sum - num)\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2)  # This is the sum we need after removing two elements\n        \n        # Dictionary to count occurrences of each element\n        count = {}\n        for num in a:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        pair_count = 0\n        \n        for num in a:\n            # Decrease the count of the current number as we are considering it as removed\n            count[num] -= 1\n            \n            # Calculate the required second number to maintain the mean\n            required = target_sum - total_sum + num * n\n            \n            # Check if the required number is in the dictionary and has a positive count\n            if required in count and count[required] > 0:\n                pair_count += count[required]\n        \n        # Since each pair is counted twice, divide by 2\n        results.append(pair_count // 2)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            needed_value = target_sum - value\n            if needed_value in value_count:\n                count += value_count[needed_value]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        target_sum = 2 * mean_k\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Count valid pairs\n        valid_pairs = 0\n        for num in a:\n            complement = target_sum - num\n            if complement in element_count:\n                valid_pairs += element_count[complement]\n                # If complement is the same as num, we need to decrement by one to avoid counting the pair (num, num)\n                if complement == num:\n                    valid_pairs -= 1\n        \n        # Each pair is counted twice (i, j) and (j, i), so divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        if total_sum * (n - 2) % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = total_sum * (n - 2) // n\n        count = 0\n        freq = {}\n        \n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a hashmap to count occurrences\n        from collections import defaultdict\n        count = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations to reduce the problem to finding pairs of elements that satisfy a specific condition derived from the mean equation.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs for each test case.\",\n      \"details\": \"Efficiently count and output the number of valid pairs for each test case using the optimized approach.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse Input\",\n      \"action\": \"Read the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate Initial Mean\",\n      \"action\": \"For each test case, calculate the sum of the array a and derive the mean k.\"\n    },\n    {\n      \"step\": \"Transform Problem\",\n      \"action\": \"Transform the condition for maintaining the mean into a mathematical equation that can be checked efficiently.\"\n    },\n    {\n      \"step\": \"Find Valid Pairs\",\n      \"action\": \"Use a hashmap or similar data structure to efficiently find and count pairs (i, j) that satisfy the transformed condition.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"action\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by dividing the sum of its elements by the number of elements. In this problem, the mean must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that precisely two elements must be removed from the array.\n    'number of pairs of positions [i, j] (i < j)': This refers to counting pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate Initial Mean\" and \"Transform Problem\" should be considered simultaneously. Once the mean is calculated, the transformation of the problem can be done immediately to set up the condition for finding valid pairs.\n\n# [edge case]\n    Test case with all elements equal: If all elements in the array are the same, any pair can be removed without changing the mean.\n    Example: [8, 8, 8, 8] = 6 pairs\n    Explanation: All elements are equal, so removing any two will keep the mean unchanged.\n\n    Test case with minimum elements: If n = 3, only one pair can be removed.\n    Example: [1, 2, 3] = 0 pairs\n    Explanation: Removing any two elements will change the mean unless all elements are equal.\n\n    Test case with large numbers: If the array contains very large numbers, ensure the mean calculation handles large values correctly.\n    Example: [10^9, 10^9, 10^9, 10^9] = 6 pairs\n    Explanation: All elements are equal, so removing any two will keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are equal.\n    ```python\n    if all(x == a[0] for x in a):\n        return comb(n, 2)  # Calculate combinations of n elements taken 2 at a time\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a hashmap to count occurrences\n        from collections import defaultdict\n        count = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For the mean to remain the same after removing two elements a[i] and a[j], the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if the sum of these two elements equals 2 * k. If so, they can be removed while maintaining the mean.\"\n    },\n    {\n      \"description\": \"Efficiently count the number of valid pairs.\",\n      \"details\": \"Use a hashmap or dictionary to store the frequency of each element and efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the integer n and the array a of n elements.\",\n    \"  Calculate the sum of the array a and derive the mean k.\",\n    \"  Initialize a counter to zero for counting valid pairs.\",\n    \"  Use a hashmap to store the frequency of each element in the array.\",\n    \"  Iterate over each element a[i] in the array:\",\n    \"    Calculate the target value needed to pair with a[i] to maintain the mean.\",\n    \"    Check the hashmap for the frequency of this target value.\",\n    \"    If found, increment the counter by the frequency of the target value.\",\n    \"    Update the hashmap to reflect the removal of a[i] from consideration.\",\n    \"  Output the counter value for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of a set of numbers is the sum of the numbers divided by the count of numbers. In this requirement, it refers to the average value of the elements in the array.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum divided by n': This indicates the calculation of the mean, where the sum of elements is divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to calculating the mean and checking pairs should be considered simultaneously:\n    \"Calculate the sum of the array a and derive the mean k.\"\n    \"Identify pairs of elements that can be removed while maintaining the mean.\"\n    These steps can be implemented in a loop where we calculate the mean and simultaneously check for valid pairs.\n\n# [edge case]\n    Test case with all elements equal: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Test case with multiple valid pairs: [1, 4, 7, 3, 5] = 2\n    Explanation: Pairs (1, 7) and (3, 5) can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should use a hashmap to store frequencies and check for valid pairs:\n    ```python\n    def count_valid_pairs(n, a):\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        target_sum = (n - 2) * mean_k\n        count = 0\n        freq_map = {}\n        \n        for num in a:\n            target_value = target_sum - num\n            if target_value in freq_map:\n                count += freq_map[target_value]\n            freq_map[num] = freq_map.get(num, 0) + 1\n        \n        return count\n    ```\n\nYES", "Round_0": {"code": "def count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean_k = total_sum / n\n    target_sum = (n - 2) * mean_k\n    count = 0\n    freq_map = {}\n\n    for num in a:\n        target_value = target_sum - num\n        if target_value in freq_map:\n            count += freq_map[target_value]\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_valid_pairs(n, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For the mean to remain the same after removing two elements a[i] and a[j], the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if the sum of these two elements equals 2 * k. If so, they can be removed while maintaining the mean.\"\n    },\n    {\n      \"description\": \"Efficiently count the number of valid pairs.\",\n      \"details\": \"Use a hashmap or dictionary to store the frequency of each element and efficiently count pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Initialize a hashmap to store element frequencies\",\n      \"details\": \"Create a hashmap to keep track of how many times each element appears in the array.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs\",\n      \"details\": \"For each element a[i], calculate the required complement to maintain the mean and use the hashmap to count how many such complements exist.\"\n    },\n    {\n      \"step\": \"Count and output the number of valid pairs for each test case\",\n      \"details\": \"For each test case, output the total number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by summing all elements and dividing by the number of elements. In this problem, the mean must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This indicates the calculation of the mean, which is the sum of elements divided by the number of elements.\n    'n - 2': Refers to the number of elements remaining after removing two elements.\n    '2 * k': This is the condition for the sum of the two elements to be removed, ensuring the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to calculating the mean and checking pairs should be considered simultaneously:\n    \"Calculate the mean k for each test case\",\n    \"Iterate over each element to find valid pairs\"\n    These steps can be implemented in a loop where the mean is calculated first, and then pairs are checked in the same iteration.\n\n# [edge case]\n    Test case with all elements equal: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Test case with minimum elements: [1, 1, 1] = 0\n    Explanation: With only three elements, removing two will always change the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking pairs based on the condition 2 * k will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        target_sum = 2 * mean_k\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = {}\n        pair_count = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in element_count:\n                pair_count += element_count[complement]\n            \n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        results.append(pair_count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the mathematical mean k of the original array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For the mean to remain the same after removing two elements a[i] and a[j], the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if their sum equals 2 * k. If so, they can be removed while maintaining the mean.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap or dictionary to efficiently count occurrences of elements and find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the integer n and the array a of n integers.\",\n    \"  Calculate the sum of the array a and derive the mean k.\",\n    \"  Initialize a counter to track the number of valid pairs.\",\n    \"  Use a hashmap to store the frequency of each element in the array.\",\n    \"  Iterate over each element a[i] in the array:\",\n    \"    Calculate the required complement to maintain the mean, which is 2 * k - a[i].\",\n    \"    Check if this complement exists in the hashmap and count the valid pairs.\",\n    \"    Update the hashmap to reflect the removal of a[i] from consideration.\",\n    \"  Output the count of valid pairs for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean must remain the same after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that precisely two elements must be removed from the array.\n    'sum of elements divided by the number of these elements': This describes the calculation of the mean, which is implemented in code as `sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to calculating the mean and checking pairs should be considered simultaneously:\n    - Calculate the mean k.\n    - For each element, calculate the required complement and check if it exists in the hashmap.\n    These steps can be implemented in a single loop over the array.\n\n# [edge case]\n    1. Input: 3, [1, 1, 1] = 0\n       Explanation: With only three identical elements, removing any two will not maintain the mean.\n    2. Input: 4, [0, 0, 0, 0] = 6\n       Explanation: Any pair of elements can be removed since all are zero, maintaining the mean.\n    3. Input: 5, [1, 2, 3, 4, 5] = 0\n       Explanation: No pair of elements can be removed to maintain the mean as the array is strictly increasing.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has fewer than 4 elements or all elements are identical.\n    ```python\n    if n < 4:\n        print(0)\n        continue\n    if len(set(a)) == 1:\n        print((n * (n - 1)) // 2)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        if n < 4:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if len(set(a)) == 1:\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        target_sum = 2 * k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += n + 1\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        if n < 4:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        k = total_sum / n\n        \n        if len(set(a)) == 1:\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        target_sum = 2 * k\n        count = 0\n        freq = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(t):\n    n = int(data[index])\n    a = list(map(int, data[index + 1:index + 1 + n]))\n    test_cases.append((n, a))\n    index += n + 1\n\nresults = find_valid_pairs(t, test_cases)\n\nfor result in results:\n    print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair of elements, check if their sum equals 2 * k. If so, they can be removed while maintaining the mean.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap to store the frequency of each element and efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Initialize a hashmap for frequency counting\",\n      \"details\": \"Create a hashmap to store the frequency of each element in the array.\"\n    },\n    {\n      \"step\": \"Iterate over the array to find valid pairs\",\n      \"details\": \"For each element a[i], calculate the required complement to form a valid pair and use the hashmap to count valid pairs.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"For each test case, print the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain the same even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum of elements divided by the number of these elements': This describes the calculation of the mean, which is implemented in code as `sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Determine the condition for maintaining the mean after removing two elements\" should be considered simultaneously. This is because the condition for maintaining the mean directly depends on the calculated mean k.\n\n# [edge case]\n    1. Input: 3 1 1 1\n       Output: 0\n       Explanation: With only three identical elements, removing any two will not change the mean, but since the mean is already equal to each element, no valid pairs exist.\n       \n    2. Input: 4 0 0 0 0\n       Output: 6\n       Explanation: All elements are zero, so any pair can be removed without changing the mean.\n       \n    3. Input: 5 10 10 10 10 10\n       Output: 10\n       Explanation: All elements are the same, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking pairs based on the condition `a[i] + a[j] == 2 * k` will naturally handle these cases. \n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # We need to find pairs (i, j) such that a[i] + a[j] = 2 * mean_k\n        target_sum = 2 * mean_k\n        \n        # Use a hashmap to count occurrences of each element\n        freq = {}\n        for num in a:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        count_pairs = 0\n        \n        # Iterate over the array to find valid pairs\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                count_pairs += freq[complement]\n                # If complement is the same as num, we counted the pair (num, num) twice\n                if complement == num:\n                    count_pairs -= 1\n        \n        # Each pair is counted twice (once as (i, j) and once as (j, i)), so divide by 2\n        results.append(count_pairs // 2)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if the sum of the remaining elements equals (n-2) * k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap or similar data structure to efficiently find pairs that satisfy the condition.\"\n    },\n    {\n      \"description\": \"Handle multiple test cases efficiently.\",\n      \"details\": \"Iterate over each test case, apply the above logic, and store the results.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the integer n and the array a of size n.\",\n    \"  Calculate the sum of the array a and derive the mean k.\",\n    \"  Calculate the target sum for the remaining elements: target_sum = (n-2) * k.\",\n    \"  Initialize a hashmap to store the frequency of elements.\",\n    \"  Iterate over each element a[i] in the array:\",\n    \"    Calculate the required complement to maintain the mean: complement = target_sum - (sum_of_array - a[i]).\",\n    \"    Check if the complement exists in the hashmap and count valid pairs.\",\n    \"    Update the hashmap with the current element a[i].\",\n    \"  Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean is used to determine if removing two elements keeps the mean of the remaining elements the same.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'equal to': This indicates that the mean of the remaining elements must be the same as the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps related to calculating the mean and checking pairs should be considered simultaneously:\n    - Calculate the sum of the array and derive the mean.\n    - For each element, calculate the required complement and check if it exists in the hashmap.\n    These steps can be implemented in a single loop to efficiently find valid pairs.\n\n# [edge case] \n    Case 1: n = 3, a = [1, 1, 1]\n    Expected output: 0\n    Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n    \n    Case 2: n = 4, a = [0, 0, 0, 0]\n    Expected output: 6\n    Explanation: Any pair of elements can be removed since all elements are the same, maintaining the mean.\n    \n    Case 3: n = 5, a = [1, 2, 3, 4, 5]\n    Expected output: 0\n    Explanation: No pair of elements can be removed to maintain the mean of the remaining elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of calculating the complement and checking against the hashmap will naturally handle these cases.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n        \n        target_sum = int(target_sum)\n        count = 0\n        freq = {}\n        \n        for num in a:\n            complement = target_sum - (total_sum - num)\n            if complement in freq:\n                count += freq[complement]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair of elements, check if their removal results in the required sum of the remaining elements.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap or similar data structure to efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs\",\n      \"details\": \"For each element, calculate the required sum of the remaining elements and use a hashmap to find pairs that satisfy the condition.\"\n    },\n    {\n      \"step\": \"Count and store the number of valid pairs for each test case\",\n      \"details\": \"For each test case, count the number of valid pairs and store the result.\"\n    },\n    {\n      \"step\": \"Output the results\",\n      \"details\": \"Print the number of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is used to determine if removing two elements keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'sum is divided by n': This indicates the calculation of the mean, where the sum of elements is divided by the number of elements.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. \n    This can be done by calculating the mean once and then using it to check each pair of elements in a single loop.\n\n# [edge case] \n    Test case with all elements equal: [4, 4, 4, 4] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains unchanged.\n    \n    Test case with only three elements: [1, 2, 3] = 0\n    Explanation: Removing any two elements will leave only one element, which cannot maintain the original mean.\n    \n    Test case with large numbers: [10^9, 10^9, 10^9, 10^9] = 6\n    Explanation: Similar to the first edge case, any pair can be removed since all elements are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking pairs and maintaining the mean will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2)  # This is the sum we need after removing two elements\n        \n        # Dictionary to count occurrences of each element\n        count = {}\n        for num in a:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        pair_count = 0\n        \n        for num in a:\n            # Decrease the count of the current number as we are considering it as removed\n            count[num] -= 1\n            \n            # Calculate the required second number to maintain the mean\n            required = target_sum - total_sum + num * n\n            \n            # Check if the required number is in the dictionary and has a positive count\n            if required in count and count[required] > 0:\n                pair_count += count[required]\n        \n        # Since each pair is counted twice, divide by 2\n        results.append(pair_count // 2)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the sum of the remaining elements must equal (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements that can be removed while maintaining the mean.\",\n      \"details\": \"For each pair (i, j), check if the sum of the remaining elements equals (n-2) * k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap or similar data structure to efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the initial mean k\",\n      \"details\": \"For each test case, compute the sum of the array and divide by n to get k.\"\n    },\n    {\n      \"step\": \"Iterate over possible pairs\",\n      \"details\": \"For each test case, iterate over all pairs (i, j) with i < j and check if removing them maintains the mean.\"\n    },\n    {\n      \"step\": \"Use a hashmap for optimization\",\n      \"details\": \"Store and lookup necessary values in a hashmap to quickly find pairs that satisfy the condition.\"\n    },\n    {\n      \"step\": \"Count valid pairs\",\n      \"details\": \"For each test case, count the number of valid pairs and store the result.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"Print the number of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is calculated by dividing the sum of its elements by the number of elements. In this problem, the mean of the array should remain the same even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'n - 2': This indicates the number of elements remaining after removing two elements.\n    Implementation: When calculating the new mean, use the formula (sum of remaining elements) / (n - 2).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Iterate over possible pairs\" and \"Use a hashmap for optimization\" should be considered simultaneously. \n    Implementation: While iterating over pairs, use a hashmap to store and quickly access the necessary values to check if removing a pair maintains the mean.\n\n# [edge case]\n    1. Input: 3 10 10 10\n       Output: 3\n       Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    2. Input: 3 1 2 3\n       Output: 0\n       Explanation: No pair can be removed to maintain the mean since all elements are different.\n    3. Input: 4 5 5 5 5\n       Output: 6\n       Explanation: Any pair of elements can be removed since all are equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over pairs and checking the condition using a hashmap will naturally handle these cases.\n\nNO", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            needed_value = target_sum - value\n            if needed_value in value_count:\n                count += value_count[needed_value]\n            \n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For two elements a[i] and a[j] to be removed, the sum of the remaining elements must be equal to (n-2) * k. This implies that a[i] + a[j] = 2 * k.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs (i, j) such that a[i] + a[j] = 2 * k.\",\n      \"details\": \"Use a hashmap to store the frequency of each element and efficiently find pairs that satisfy the condition.\"\n    },\n    {\n      \"description\": \"Handle multiple test cases efficiently.\",\n      \"details\": \"Iterate over each test case, apply the above logic, and store the results for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the integer n and the array a of n integers.\",\n    \"  Calculate the sum of the array and derive the mean k.\",\n    \"  Calculate the target sum for pairs, which is 2 * k.\",\n    \"  Initialize a hashmap to store the frequency of each element in the array.\",\n    \"  Iterate over the array to find pairs (i, j) such that a[i] + a[j] = 2 * k using the hashmap.\",\n    \"  For each valid pair found, increment the count of valid pairs.\",\n    \"  Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is used to determine if the mean remains unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'divided by': This refers to the operation of dividing the sum of elements by the number of elements to calculate the mean.\n    'equal to': This indicates that the mean of the remaining elements after removing two should be the same as the original mean.\n    '2 * k': This is the target sum for the two elements to be removed, derived from the condition that their removal should not change the mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps for calculating the mean and determining the condition for maintaining the mean should be considered simultaneously. Specifically, calculating the target sum (2 * k) and using it to find valid pairs should be done in a cohesive manner, likely within the same loop or function.\n\n# [edge case] \n    Test case with all elements the same: [4, 4, 4, 4] = 6\n    Explanation: Any pair of elements can be removed since all are equal, and the mean remains unchanged.\n    \n    Test case with no valid pairs: [1, 2, 3] = 0\n    Explanation: No two elements can be removed to maintain the mean, as no pair sums to 2 * k.\n    \n    Test case with minimum elements: [1, 1, 1] = 0\n    Explanation: With only three elements, removing two will always leave one, which cannot maintain the original mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of checking pairs with the condition a[i] + a[j] = 2 * k inherently handles these scenarios.\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean_k = total_sum / n\n        target_sum = 2 * mean_k\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Count valid pairs\n        valid_pairs = 0\n        for num in a:\n            complement = target_sum - num\n            if complement in element_count:\n                valid_pairs += element_count[complement]\n                # If complement is the same as num, we need to decrement by one to avoid counting the pair (num, num)\n                if complement == num:\n                    valid_pairs -= 1\n        \n        # Each pair is counted twice (i, j) and (j, i), so divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Determine the condition for maintaining the mean after removing two elements.\",\n      \"details\": \"For the mean to remain the same after removing two elements a[i] and a[j], the sum of the remaining elements must be equal to (n-2) * k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"Find pairs (i, j) such that a[i] + a[j] = 2 * k. This ensures the sum of the remaining elements equals (n-2) * k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use a hashmap to count occurrences of each element and efficiently find pairs that satisfy the condition.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the integer n and the array a of n elements.\",\n    \"  Calculate the sum of the array a and derive the mean k.\",\n    \"  Initialize a hashmap to store the frequency of each element in a.\",\n    \"  Iterate over each element in a to populate the hashmap.\",\n    \"  Initialize a counter to zero for counting valid pairs.\",\n    \"  Iterate over each element a[i] in the array:\",\n    \"    Calculate the required complement to maintain the mean: complement = 2 * k - a[i].\",\n    \"    Check if the complement exists in the hashmap and is valid (considering i < j).\",\n    \"    If valid, increment the counter by the number of occurrences of the complement.\",\n    \"    Update the hashmap to reflect the removal of a[i] from consideration.\",\n    \"  Output the counter as the result for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that precisely two elements must be removed from the array.\n    'equal to k': This means that the mean of the remaining elements after removing two should be the same as the original mean.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps related to calculating the complement and checking its existence in the hashmap should be implemented simultaneously. Specifically:\n    - \"Calculate the required complement to maintain the mean: complement = 2 * k - a[i].\"\n    - \"Check if the complement exists in the hashmap and is valid (considering i < j).\"\n    These can be done in a single loop iteration over the array.\n\n# [edge case] \n    Test case with all elements the same: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No two elements can be removed to maintain the mean.\n    \n    Test case with minimum elements: [1, 1, 1] = 1\n    Explanation: Only one pair can be removed, which is the only possible pair in the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to track occurrences and checking for valid pairs will naturally handle these cases.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        if total_sum * (n - 2) % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = total_sum * (n - 2) // n\n        count = 0\n        freq = {}\n        \n        for num in a:\n            if target_sum - num in freq:\n                count += freq[target_sum - num]\n            \n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Compute the sum of all elements in the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical transformations to reduce the problem to finding pairs of elements that satisfy a specific condition derived from the mean equation.\"\n    },\n    {\n      \"description\": \"Count the number of valid pairs for each test case.\",\n      \"details\": \"Efficiently count and output the number of valid pairs for each test case using the optimized approach.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse Input\",\n      \"action\": \"Read the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate Initial Mean\",\n      \"action\": \"For each test case, calculate the sum of the array a and derive the mean k.\"\n    },\n    {\n      \"step\": \"Transform Problem\",\n      \"action\": \"Transform the condition for maintaining the mean into a mathematical equation that can be checked efficiently.\"\n    },\n    {\n      \"step\": \"Find Valid Pairs\",\n      \"action\": \"Use a hashmap or similar data structure to efficiently find and count pairs (i, j) that satisfy the transformed condition.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"action\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by dividing the sum of its elements by the number of elements. In this problem, the mean must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that precisely two elements must be removed from the array.\n    'number of pairs of positions [i, j] (i < j)': This refers to counting pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate Initial Mean\" and \"Transform Problem\" should be considered simultaneously. Once the mean is calculated, the transformation of the problem can be done immediately to set up the condition for finding valid pairs.\n\n# [edge case]\n    Test case with all elements equal: If all elements in the array are the same, any pair can be removed without changing the mean.\n    Example: [8, 8, 8, 8] = 6 pairs\n    Explanation: All elements are equal, so removing any two will keep the mean unchanged.\n\n    Test case with minimum elements: If n = 3, only one pair can be removed.\n    Example: [1, 2, 3] = 0 pairs\n    Explanation: Removing any two elements will change the mean unless all elements are equal.\n\n    Test case with large numbers: If the array contains very large numbers, ensure the mean calculation handles large values correctly.\n    Example: [10^9, 10^9, 10^9, 10^9] = 6 pairs\n    Explanation: All elements are equal, so removing any two will keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are equal.\n    ```python\n    if all(x == a[0] for x in a):\n        return comb(n, 2)  # Calculate combinations of n elements taken 2 at a time\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are the same\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a hashmap to count occurrences\n        from collections import defaultdict\n        count = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, false, true, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 567, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements. This means the sum is divided by n. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the solutions are derived efficiently considering large inputs. Consider optimizing the algorithm to ensure it runs within a reasonable time frame for the maximum constraints.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 241}
