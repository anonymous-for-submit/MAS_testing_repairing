{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The inhabitants of Baltia are eager to throw a thriving party, but they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The inhabitants of Baltia are eager to throw a thriving party. However, they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other; the inhabitants of Baltia are eager to throw a thriving party, but they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nimport itertools\n\ndef find_successful_party(N, M, friendships):\n    if M == 0:\n        # If there are no friendships, any group of 5 will have no friends among them\n        return list(range(1, 6))\n    \n    if M == N * (N - 1) // 2:\n        # If all possible pairs are friends, any group of 5 will all be friends with each other\n        return list(range(1, 6))\n    \n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check combinations\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combination[j] in adj_list[combination[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            return list(combination)\n    \n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any group of 5 people will satisfy the condition of no two people being friends.\n        print(\"1 2 3 4 5\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2:\n        # If all possible pairs are friends, then no group of 5 can have no friendships\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_successful_party(N, M, friendships):\n    from collections import defaultdict\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    N = int(data[0])\n    M = int(data[1])\n    friendships = [(int(data[i]), int(data[i+1])) for i in range(2, 2*M, 2)]\n    \n    # Edge case: If M == 0, any 5 people form an independent set\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M is maximum, any 5 people form a clique\n    if M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Create adjacency list\n    adj_list = defaultdict(set)\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check for a clique of size 5\n    def is_clique(nodes):\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adj_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Check for an independent set of size 5\n    def is_independent_set(nodes):\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adj_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Try to find a successful party\n    from itertools import combinations\n    \n    for combo in combinations(range(1, N + 1), 5):\n        if is_clique(combo) or is_independent_set(combo):\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(-1)\n\n# Example usage:\n# The function will read from standard input, so you can test it by providing input in the expected format.\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "from itertools import combinations\nimport sys\ninput = sys.stdin.read\n\ndef is_successful_party(friends, group):\n    # Check if all are friends\n    all_friends = all((u, v) in friends or (v, u) in friends for u, v in combinations(group, 2))\n    # Check if none are friends\n    no_friends = all((u, v) not in friends and (v, u) not in friends for u, v in combinations(group, 2))\n    return all_friends or no_friends\n\ndef find_successful_party(N, M, friendships):\n    # Create a set of friendships for quick lookup\n    friends = set(friendships)\n    \n    # Check all combinations of 5 people\n    for group in combinations(range(1, N + 1), 5):\n        if is_successful_party(friends, group):\n            return group\n    \n    return -1\n\ndef main():\n    data = input().strip().split()\n    N = int(data[0])\n    M = int(data[1])\n    friendships = [(int(data[i]), int(data[i+1])) for i in range(2, 2 + 2 * M, 2)]\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "from itertools import combinations\nimport sys\ninput = sys.stdin.read\n\ndef find_successful_party(N, M, friendships):\n    # Create an adjacency list\n    friends = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N+1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i+1, 5):\n                if combo[j] in friends[combo[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\ndef main():\n    data = input().strip().split()\n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    find_successful_party(N, M, friendships)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def find_successful_party(N, M, friendships):\n    from collections import defaultdict\n    import itertools\n\n    # Create adjacency list\n    adj_list = defaultdict(set)\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Check for clique of 5\n    for person in range(1, N + 1):\n        friends = adj_list[person]\n        if len(friends) >= 4:\n            for combo in itertools.combinations(friends, 4):\n                if all(adj_list[f1].intersection(combo) == set(combo) for f1 in combo):\n                    return [person] + list(combo)\n\n    # Check for independent set of 5\n    all_people = set(range(1, N + 1))\n    for combo in itertools.combinations(all_people, 5):\n        if all(combo[i] not in adj_list[combo[j]] for i in range(5) for j in range(i + 1, 5)):\n            return list(combo)\n\n    return -1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    friendships = [(int(data[i]), int(data[i+1])) for i in range(2, 2*M, 2)]\n    \n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(result)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    people = list(range(1, N + 1))\n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Edge case: If M is 0, any 5 people can form a successful party\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M is very high, check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2:\n        print(\"-1\")\n        return\n    \n    # Generate all possible combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Edge cases\n    if M == 0:\n        print(' '.join(map(str, range(1, 6))))\n        return\n    if M >= (N * (N - 1)) // 2:\n        print(' '.join(map(str, range(1, 6))))\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef find_successful_party(N, M, friendships):\n    if M == 0:\n        # If there are no friendships, any group of 5 will have no friends among them\n        return list(range(1, 6))\n    \n    if M == N * (N - 1) // 2:\n        # If all possible pairs are friends, any group of 5 will all be friends with each other\n        return list(range(1, 6))\n    \n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check combinations\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combination[j] in adj_list[combination[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            return list(combination)\n    \n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"Graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"List of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"Boolean indicating if a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the 5 people. If none is found after checking all combinations, output -1.\",\n      \"output\": \"5 integers representing a successful party or -1 if not possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all 5 individuals are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of exactly 5 people, no more, no less.\n    'all': All 5 individuals must be friends with each other for one condition of a successful party.\n    'no two': None of the 5 individuals should be friends with each other for the other condition of a successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to generate all possible combinations of 5 people and check if they form a successful party should be implemented simultaneously. This involves iterating over combinations and checking the friendship conditions in one loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any group of 5 people will have no friends among them, satisfying the condition for a successful party.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With maximum friendships, any group of 5 people will all be friends with each other, satisfying the condition for a successful party.\n    3. Input: 6 15\n       Output: -1\n       Explanation: If all possible pairs are friends, it is impossible to have a group of 5 where no two are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large N and M. This involves using efficient graph traversal and combination generation techniques to avoid excessive computation time.\n    \n    ```python\n    import itertools\n\n    def find_successful_party(N, M, friendships):\n        if M == 0:\n            return list(range(1, 6))\n        if M == N * (N - 1) // 2:\n            return list(range(1, 6))\n        \n        # Create adjacency list\n        adj_list = {i: set() for i in range(1, N + 1)}\n        for u, v in friendships:\n            adj_list[u].add(v)\n            adj_list[v].add(u)\n        \n        # Check combinations\n        for combination in itertools.combinations(range(1,", "Round_0": {"code": "import sys\nimport itertools\n\ndef find_successful_party(N, M, friendships):\n    if M == 0:\n        # If there are no friendships, any group of 5 will have no friends among them\n        return list(range(1, 6))\n    \n    if M == N * (N - 1) // 2:\n        # If all possible pairs are friends, any group of 5 will all be friends with each other\n        return list(range(1, 6))\n    \n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check combinations\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combination[j] in adj_list[combination[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            return list(combination)\n    \n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_successful_party() missing 3 required positional arguments: 'N', 'M', and 'friendships'"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef find_successful_party(N, M, friendships):\n    if M == 0:\n        # If there are no friendships, any group of 5 will have no friends among them\n        return list(range(1, 6))\n    \n    if M == N * (N - 1) // 2:\n        # If all possible pairs are friends, any group of 5 will all be friends with each other\n        return list(range(1, 6))\n    \n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check combinations\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combination[j] in adj_list[combination[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            return list(combination)\n    \n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"output\": \"A list of friendships and the values of N and M.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendships between people. This can be an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph representation of friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each combination of 5 people, check if they are all friends with each other or if none of them are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party can be formed with the current combination.\"\n    },\n    {\n      \"description\": \"If a successful party is found, output the combination of 5 people. If no successful party is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of 5 people forming a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph representation of the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if all 5 people are friends with each other or if none of them are friends with each other.\",\n    \"If a successful party is found, print the indices of the 5 people. If no such combination exists, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the attendees should be friends with each other for one type of successful party.\n\n# [degree adverb]\n    'successful': Refers to the condition where either all attendees are friends or none are friends.\n\n# [code logic]\n    The steps related to checking combinations of 5 people should be implemented simultaneously. Specifically:\n    - \"Generate all possible combinations of 5 people from the N people.\"\n    - \"For each combination, check if all 5 people are friends with each other or if none of them are friends with each other.\"\n    These can be implemented in a loop where each combination is checked for the friendship conditions.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will satisfy the condition of no two people being friends.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, then no group of 5 can have no friendships, and if any group of 5 is chosen, they will all be friends.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If the number of friendships is such that every person is friends with every other person, then no group of 5 can have no friendships.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where either M = 0 or M is very large (close to N choose 2).\n    - If M = 0, any group of 5 people can be chosen.\n    - If M is large enough that all possible pairs are friends, return -1.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if M == 0:\n        # If there are no friendships, any group of 5 people will satisfy the condition of no two people being friends.\n        print(\"1 2 3 4 5\")\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2:\n        # If all possible pairs are friends, then no group of 5 can have no friendships\n        print(\"-1\")\n        return\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where all 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a complete subgraph of 5 nodes in the friendship graph.\",\n        \"Use graph traversal techniques to identify cliques of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized where no two of the 5 people are friends with each other.\",\n      \"steps\": [\n        \"Check if there exists a set of 5 nodes with no edges between them in the friendship graph.\",\n        \"Use graph traversal techniques to identify independent sets of size 5.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people involved.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Construct a graph representation using adjacency lists or matrices.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the selected individuals should have a friendship connection.\n\n# [degree adverb]\n    'successful': Refers to the condition where either all attendees are friends or none are friends.\n\n# [code logic]\n    The steps for checking a complete subgraph and an independent set should be considered simultaneously. Both conditions need to be checked to determine if a successful party can be organized. This can be implemented using graph traversal techniques to identify cliques and independent sets in one code block.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any 5 people form an independent set.\n    \n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all possible pairs are friends, any 5 people form a clique.\n    \n    Input: 5 4\n    Output: -1\n    Explanation: The friendships form a chain, preventing both a clique and an independent set.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement graph traversal to check for cliques and independent sets.\n    - Use adjacency lists or matrices to efficiently check connections between nodes.\n\nYES", "Round_0": {"code": "def find_successful_party(N, M, friendships):\n    from collections import defaultdict\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    N = int(data[0])\n    M = int(data[1])\n    friendships = [(int(data[i]), int(data[i+1])) for i in range(2, 2*M, 2)]\n    \n    # Edge case: If M == 0, any 5 people form an independent set\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M is maximum, any 5 people form a clique\n    if M >= (N * (N - 1)) // 2:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Create adjacency list\n    adj_list = defaultdict(set)\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check for a clique of size 5\n    def is_clique(nodes):\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adj_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Check for an independent set of size 5\n    def is_independent_set(nodes):\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adj_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Try to find a successful party\n    from itertools import combinations\n    \n    for combo in combinations(range(1, N + 1), 5):\n        if is_clique(combo) or is_independent_set(combo):\n            print(\" \".join(map(str, combo)))\n            return\n    \n    # If no successful party is found\n    print(-1)\n\n# Example usage:\n# The function will read from standard input, so you can test it by providing input in the expected format.\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships among people.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party can be formed with the current combination.\"\n    },\n    {\n      \"description\": \"If a successful party is found, output the combination. If no successful party is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of the 5 people forming a successful party or -1 if no such party exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph to represent friendships using the parsed data.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it satisfies the conditions for a successful party (all friends or no friends).\",\n    \"If a successful party is found, print the indices of the 5 people. If no successful party is found, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    Implementation: Ensure that any combination of people selected for the party has a length of 5.\n\n# [degree adverb]\n    'successful': The party is deemed successful if it meets the strict friendship criteria.\n    Implementation: Check each combination of 5 people to see if they are all friends or none are friends.\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 people from the N people\" and \"For each combination, check if it satisfies the conditions for a successful party\" should be implemented simultaneously. This can be done by iterating over each combination and immediately checking the friendship conditions.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will have no friends among them, making the party successful.\n\n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, then no group of 5 can have no friends among them, making it impossible to have a successful party.\n\n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all 6 people are friends with each other, any group of 5 will be a successful party.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each combination for the friendship conditions will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized.\",\n      \"steps\": [\n        \"Check if there exists a group of 5 people where all are friends with each other.\",\n        \"Check if there exists a group of 5 people where no two are friends with each other.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the 5 people.\",\n        \"If no successful party configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a data structure to represent the friendships (e.g., adjacency list or matrix).\",\n    \"Iterate over possible combinations of 5 people to check for successful party conditions.\",\n    \"For each combination, check if all are friends or none are friends using the friendship data structure.\",\n    \"Output the first successful combination found or -1 if none exist.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all 5 individuals are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of exactly 5 people, no more, no less.\n    'all': All 5 individuals must be friends with each other for one condition of a successful party.\n    'no two': None of the 5 individuals should be friends with each other for the other condition of a successful party.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps to check if a group of 5 people are all friends or none are friends should be implemented simultaneously. This can be done by iterating over all combinations of 5 people and checking both conditions in a single loop.\n\n# [edge case] \n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any group of 5 people will have no friends among them, satisfying the condition for a successful party.\n       \n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With maximum friendships, any group of 5 people will all be friends with each other, satisfying the condition for a successful party.\n       \n    3. Input: 6 15\n       Output: -1\n       Explanation: If all possible pairs among 6 people are friends, it's impossible to find a group of 5 where no two are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases. Specifically, we need to efficiently check combinations of 5 people for the two conditions using the friendship data structure.\n    ```\n    from itertools import combinations\n\n    def is_successful_party(friends, group):\n        # Check if all are friends\n        all_friends = all((u, v) in friends or (v, u) in friends for u, v in combinations(group, 2))\n        # Check if none are friends\n        no_friends = all((u, v) not in friends and (v, u) not in friends for u, v in combinations(group, 2))\n        return all_friends or no_friends\n\n    def find_successful_party(N, M,", "Round_0": {"code": "from itertools import combinations\nimport sys\ninput = sys.stdin.read\n\ndef is_successful_party(friends, group):\n    # Check if all are friends\n    all_friends = all((u, v) in friends or (v, u) in friends for u, v in combinations(group, 2))\n    # Check if none are friends\n    no_friends = all((u, v) not in friends and (v, u) not in friends for u, v in combinations(group, 2))\n    return all_friends or no_friends\n\ndef find_successful_party(N, M, friendships):\n    # Create a set of friendships for quick lookup\n    friends = set(friendships)\n    \n    # Check all combinations of 5 people\n    for group in combinations(range(1, N + 1), 5):\n        if is_successful_party(friends, group):\n            return group\n    \n    return -1\n\ndef main():\n    data = input().strip().split()\n    N = int(data[0])\n    M = int(data[1])\n    friendships = [(int(data[i]), int(data[i+1])) for i in range(2, 2 + 2 * M, 2)]\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 66)"}, "Round_1": {"code": "from itertools import combinations\nimport sys\ninput = sys.stdin.read\n\ndef is_successful_party(friends, group):\n    # Check if all are friends\n    all_friends = all((u, v) in friends or (v, u) in friends for u, v in combinations(group, 2))\n    # Check if none are friends\n    no_friends = all((u, v) not in friends and (v, u) not in friends for u, v in combinations(group, 2))\n    return all_friends or no_friends\n\ndef find_successful_party(N, M, friendships):\n    # Create a set of friendships for quick lookup\n    friends = set(friendships)\n    \n    # Check all combinations of 5 people\n    for group in combinations(range(1, N + 1), 5):\n        if is_successful_party(friends, group):\n            return group\n    \n    return -1\n\ndef main():\n    data = input().strip().split()\n    N = int(data[0])\n    M = int(data[1])\n    friendships = [(int(data[i]), int(data[i+1])) for i in range(2, 2 + 2 * M, 2)]\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a successful party can be organized.\",\n      \"steps\": [\n        \"Check if there exists a group of 5 people where all are friends with each other.\",\n        \"Check if there exists a group of 5 people where no two are friends with each other.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the 5 people.\",\n        \"If no successful party configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a data structure to represent friendships (e.g., adjacency list or matrix).\",\n    \"Implement a function to check for a clique of 5 friends.\",\n    \"Implement a function to check for a group of 5 people with no friendships.\",\n    \"Iterate through possible combinations of 5 people to check for successful party conditions.\",\n    \"Output the result based on whether a successful party configuration is found.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all 5 individuals are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'all': All 5 people must be friends with each other for one condition of a successful party.\n    'no two': None of the 5 people should be friends with each other for the other condition of a successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to check for a clique of 5 friends and a group of 5 people with no friendships should be considered simultaneously. This can be done by iterating through all possible combinations of 5 people and checking both conditions in the same loop.\n\n# [edge case]\n    5 0 = 1 2 3 4 5\n    Explanation: With 5 people and 0 friendships, all 5 people can be invited as they have no friendships, satisfying the condition of no two being friends.\n    \n    5 10 = -1\n    Explanation: With 5 people and 10 friendships, all are friends with each other, satisfying the condition of all being friends.\n    \n    6 15 = -1\n    Explanation: With 6 people and 15 friendships, it is impossible to select 5 people such that no two are friends, as all are interconnected.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should iterate through all combinations of 5 people and check both conditions for a successful party. This can be done using combinations from itertools and checking the adjacency matrix or list for friendships.\n\n```python\nfrom itertools import combinations\n\ndef find_successful_party(N, M, friendships):\n    # Create an adjacency matrix or list\n    friends = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N+1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i+1, 5):\n                if combo[j", "Round_0": {"code": "from itertools import combinations\nimport sys\ninput = sys.stdin.read\n\ndef find_successful_party(N, M, friendships):\n    # Create an adjacency list\n    friends = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N+1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i+1, 5):\n                if combo[j] in friends[combo[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\ndef main():\n    data = input().strip().split()\n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    find_successful_party(N, M, friendships)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 87)"}, "Round_1": {"code": "from itertools import combinations\nimport sys\ninput = sys.stdin.read\n\ndef find_successful_party(N, M, friendships):\n    # Create an adjacency list\n    friends = {i: set() for i in range(1, N+1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N+1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i+1, 5):\n                if combo[j] in friends[combo[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(-1)\n\ndef main():\n    data = input().strip().split()\n    N = int(data[0])\n    M = int(data[1])\n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    find_successful_party(N, M, friendships)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"input\": \"Raw input data\",\n      \"output\": \"N, M, and a list of tuples representing friendships\"\n    },\n    {\n      \"description\": \"Check for the possibility of a successful party where all 5 people are friends with each other.\",\n      \"input\": \"N, M, and the list of friendships\",\n      \"output\": \"A list of 5 people who are all friends with each other or an indication that such a group does not exist\"\n    },\n    {\n      \"description\": \"Check for the possibility of a successful party where no two of the 5 people are friends with each other.\",\n      \"input\": \"N, M, and the list of friendships\",\n      \"output\": \"A list of 5 people who are not friends with each other or an indication that such a group does not exist\"\n    },\n    {\n      \"description\": \"Determine the final output based on the results of the previous checks.\",\n      \"input\": \"Results from the checks for both types of successful parties\",\n      \"output\": \"5 numbers indicating a successful party or -1 if no successful party is possible\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"Create a graph representation of the friendships using an adjacency list.\",\n    \"For each person, check if there exists a clique of 5 people (all friends with each other) by exploring their friends and friends of friends.\",\n    \"If a clique of 5 is found, output the 5 people and terminate.\",\n    \"If no clique is found, check for an independent set of 5 people (no two are friends) by examining the complement of the friendship graph.\",\n    \"If an independent set of 5 is found, output the 5 people and terminate.\",\n    \"If neither a clique nor an independent set is found, output -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all 5 individuals are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people, no more, no less.\n    'all the people': All 5 individuals must be friends with each other.\n    'no two people': None of the 5 individuals should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for checking a clique of 5 and an independent set of 5 should be considered separately, as they involve different graph properties. However, within each check, the logic for exploring friendships or non-friendships can be implemented in a single code block using graph traversal techniques.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any 5 people form an independent set.\n       \n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With maximum friendships, any 5 people form a clique.\n       \n    3. Input: 6 1\n       Output: -1\n       Explanation: With only one friendship, neither a clique nor an independent set of 5 can be formed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, particularly to efficiently check for cliques and independent sets in large graphs.\n    ```python\n    def find_successful_party(N, M, friendships):\n        from collections import defaultdict\n        import itertools\n\n        # Create adjacency list\n        adj_list = defaultdict(set)\n        for u, v in friendships:\n            adj_list[u].add(v)\n            adj_list[v].add(u)\n\n        # Check for clique of 5\n        for person in range(1, N + 1):\n            friends = adj_list[person]\n            if len(friends) >= 4:\n                for combo in itertools.combinations(friends, 4):\n                    if all(adj_list[f1].intersection(combo) == set(combo) for f1 in combo):\n                        return [person] + list(combo)\n\n        # Check for independent set of 5\n        all_people = set(range(1,", "Round_0": {"code": "def find_successful_party(N, M, friendships):\n    from collections import defaultdict\n    import itertools\n\n    # Create adjacency list\n    adj_list = defaultdict(set)\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Check for clique of 5\n    for person in range(1, N + 1):\n        friends = adj_list[person]\n        if len(friends) >= 4:\n            for combo in itertools.combinations(friends, 4):\n                if all(adj_list[f1].intersection(combo) == set(combo) for f1 in combo):\n                    return [person] + list(combo)\n\n    # Check for independent set of 5\n    all_people = set(range(1, N + 1))\n    for combo in itertools.combinations(all_people, 5):\n        if all(combo[i] not in adj_list[combo[j]] for i in range(5) for j in range(i + 1, 5)):\n            return list(combo)\n\n    return -1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    friendships = [(int(data[i]), int(data[i+1])) for i in range(2, 2*M, 2)]\n    \n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(result)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"Graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"List of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"Boolean indicating if a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, return the combination. If none is found after checking all combinations, return -1.\",\n      \"output\": \"5 numbers indicating a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it satisfies the conditions for a successful party (all friends or no friends).\",\n    \"If a successful combination is found, print the 5 people. If no such combination exists, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a group of exactly 5 individuals where either all are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 people, no more, no less. In code, this can be implemented by generating combinations of 5 people from the list of N people.\n    'no two people': This means that in one scenario, none of the 5 people should be friends with each other. In code, this can be checked by ensuring there are no edges between any of the selected 5 people in the graph.\n\n# [degree adverb] \n    'successful': This indicates the condition that must be met for the party to be considered successful. In code, this is implemented by checking the friendship conditions for the selected group of 5 people.\n\n# [code logic]\n    The steps \"Generate all possible combinations of 5 people from the N people\" and \"For each combination, check if it satisfies the conditions for a successful party (all friends or no friends)\" should be implemented simultaneously. This can be done by iterating over each combination and checking the friendship conditions within the same loop.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With 0 friendships, any group of 5 people will have no friends among them, thus satisfying the condition for a successful party.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If there are 10 friendships among 5 people, it implies that all possible pairs are friends, making it impossible to have a group of 5 where none are friends.\n    \n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: If all 6 people are friends with each other, any group of 5 will satisfy the condition of all being friends.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations of 5 people and their friendship status will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    people = list(range(1, N + 1))\n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph data structure representing friendships among people.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, return the combination. If none is found after checking all combinations, return -1.\",\n      \"output\": \"A list of 5 people for a successful party or -1 if impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the attendees should be friends with each other for one type of successful party.\n\n# [degree adverb]\n    'successful': Refers to the condition where either all attendees are friends or none are friends.\n\n# [code logic]\n    The steps related to checking the friendship conditions for each combination should be implemented simultaneously. Specifically:\n    - \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\"\n    This can be done using a single function that checks both conditions for each combination.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any 5 people can form a successful party where no two are friends.\n    \n    Input: 5 10\n    Output: -1\n    Explanation: If all possible pairs are friends, it's impossible to have a party where no two are friends.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If the number of friendships is very high, it might be impossible to find a group of 5 where none are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially when M is 0 or very high.\n    - If M is 0, directly return any 5 people.\n    - If M is very high, check if all possible pairs are friends and return -1 if true.\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Edge case: If M is 0, any 5 people can form a successful party\n    if M == 0:\n        print(\"1 2 3 4 5\")\n        return\n    \n    # Edge case: If M is very high, check if all possible pairs are friends\n    if M >= (N * (N - 1)) // 2:\n        print(\"-1\")\n        return\n    \n    # Generate all possible combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(\" \".join(map(str, combo)))\n            return\n    \n    print(\"-1\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"Graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"List of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"Boolean indicating if a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the 5 people. If none is found after checking all combinations, output -1.\",\n      \"output\": \"5-person list or -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"Construct a graph to represent friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the attendees should be friends with each other for one type of successful party.\n\n# [degree adverb]\n    'successful': Refers to the condition where either all attendees are friends or none are friends.\n\n# [code logic]\n    The steps related to checking the friendship conditions should be implemented simultaneously. Specifically, when checking each 5-person combination, both conditions (all friends or none friends) should be checked within the same code block or if-else statement.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will satisfy the condition of no two people being friends.\n    \n    Input: 5 10\n    Output: 1 2 3 4 5\n    Explanation: If all possible pairs are friends, any group of 5 people will satisfy the condition of all being friends.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If the number of friendships is such that no group of 5 can satisfy either condition, the output should be -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where either all friendships are present or none are present.\n    ```python\n    if M == 0:\n        print(' '.join(map(str, range(1, 6))))\n        return\n    if M >= (N * (N - 1)) // 2:\n        print(' '.join(map(str, range(1, 6))))\n        return\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Edge cases\n    if M == 0:\n        print(' '.join(map(str, range(1, 6))))\n        return\n    if M >= (N * (N - 1)) // 2:\n        print(' '.join(map(str, range(1, 6))))\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a graph representation of the friendships using an adjacency list or adjacency matrix.\",\n      \"output\": \"Graph data structure representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the N people.\",\n      \"output\": \"List of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all are friends with each other or if none are friends with each other.\",\n      \"output\": \"Boolean indicating if a successful party configuration is found.\"\n    },\n    {\n      \"description\": \"If a successful party configuration is found, output the 5 people. If none is found after checking all combinations, output -1.\",\n      \"output\": \"5 integers representing a successful party or -1 if not possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph to represent the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 people from the N people.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all 5 individuals are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of exactly 5 people, no more, no less.\n    'all': All 5 individuals must be friends with each other for one condition of a successful party.\n    'no two': None of the 5 individuals should be friends with each other for the other condition of a successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps to generate all possible combinations of 5 people and check if they form a successful party should be implemented simultaneously. This involves iterating over combinations and checking the friendship conditions in one loop.\n\n# [edge case]\n    1. Input: 5 0\n       Output: 1 2 3 4 5\n       Explanation: With 0 friendships, any group of 5 people will have no friends among them, satisfying the condition for a successful party.\n    2. Input: 5 10\n       Output: 1 2 3 4 5\n       Explanation: With maximum friendships, any group of 5 people will all be friends with each other, satisfying the condition for a successful party.\n    3. Input: 6 15\n       Output: -1\n       Explanation: If all possible pairs are friends, it is impossible to have a group of 5 where no two are friends.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large N and M. This involves using efficient graph traversal and combination generation techniques to avoid excessive computation time.\n    \n    ```python\n    import itertools\n\n    def find_successful_party(N, M, friendships):\n        if M == 0:\n            return list(range(1, 6))\n        if M == N * (N - 1) // 2:\n            return list(range(1, 6))\n        \n        # Create adjacency list\n        adj_list = {i: set() for i in range(1, N + 1)}\n        for u, v in friendships:\n            adj_list[u].add(v)\n            adj_list[v].add(u)\n        \n        # Check combinations\n        for combination in itertools.combinations(range(1,", "Round_0": {"code": "import sys\nimport itertools\n\ndef find_successful_party(N, M, friendships):\n    if M == 0:\n        # If there are no friendships, any group of 5 will have no friends among them\n        return list(range(1, 6))\n    \n    if M == N * (N - 1) // 2:\n        # If all possible pairs are friends, any group of 5 will all be friends with each other\n        return list(range(1, 6))\n    \n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check combinations\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combination[j] in adj_list[combination[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            return list(combination)\n    \n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_successful_party() missing 3 required positional arguments: 'N', 'M', and 'friendships'"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef find_successful_party(N, M, friendships):\n    if M == 0:\n        # If there are no friendships, any group of 5 will have no friends among them\n        return list(range(1, 6))\n    \n    if M == N * (N - 1) // 2:\n        # If all possible pairs are friends, any group of 5 will all be friends with each other\n        return list(range(1, 6))\n    \n    # Create adjacency list\n    adj_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Check combinations\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combination[j] in adj_list[combination[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        if all_friends or no_friends:\n            return list(combination)\n    \n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    result = find_successful_party(N, M, friendships)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [false, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 76, "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The inhabitants of Baltia are eager to throw a thriving party, but they adhere to very strict definitions of what constitutes a party and when it is deemed successful. On the island of Baltia, a party is a congregation of exactly 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 72}
