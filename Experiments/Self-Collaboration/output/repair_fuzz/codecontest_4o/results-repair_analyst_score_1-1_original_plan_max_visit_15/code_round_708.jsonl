{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The input must include an integer n and an integer m, accompanied by a sequence of n strings each composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration. Ensure that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input must include an integer n and an integer m, accompanied by a sequence of n strings. Each string is composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration. Ensure that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The input must include an integer n and an integer m, accompanied by a sequence of n strings each composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration, ensuring that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def simulate_movement(n, m, board, start_r, start_c):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r, c = r + dr, c + dc\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n    \n    return moves\n\ndef find_max_moves(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(n, m, board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    moves = 0\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = [data[index + i].strip() for i in range(n)]\n        index += n\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return moves\n\ndef find_max_moves(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_robot(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n\n    max_moves = 0\n    start_r, start_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_r, start_c = r + 1, c + 1\n\n    return start_r, start_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot(board, n, m)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, r, c):\n    n, m = len(board), len(board[0])\n    moves = 0\n    visited = set()\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n        moves += 1\n    \n    return moves\n\ndef find_max_moves(board):\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while not data[index].strip():\n            index += 1  # Skip any blank lines\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    # Function to simulate movement from a given start position\n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    # Iterate over each cell to find the best starting position\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Simulate movement and get result\n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(board, n, m, start_r, start_c):\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r, c = r + dr, c + dc\n\n        if not (0 <= r < n and 0 <= c < m):\n            break\n\n    return moves\n\ndef find_maximum_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = find_maximum_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def simulate_movement(n, m, board, start_r, start_c):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r, c = r + dr, c + dc\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n    \n    return moves\n\ndef find_max_moves(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(n, m, board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of test cases, each containing n, m, and the board configuration\"\n    },\n    {\n      \"description\": \"For each test case, determine the starting position (r, c) on the board that allows the robot to make the maximum number of moves.\",\n      \"input\": \"Board configuration for a single test case\",\n      \"output\": \"Starting position (r, c) and the maximum number of moves d\"\n    },\n    {\n      \"description\": \"Implement a function to simulate the robot's movement on the board based on the given directions ('L', 'R', 'D', 'U') and calculate the number of moves.\",\n      \"input\": \"Starting position and board configuration\",\n      \"output\": \"Number of moves the robot can make from the starting position\"\n    },\n    {\n      \"description\": \"Compare the number of moves from different starting positions to find the maximum for each test case.\",\n      \"input\": \"List of possible starting positions and their corresponding move counts\",\n      \"output\": \"Optimal starting position (r, c) and maximum moves d for each test case\"\n    },\n    {\n      \"description\": \"Format the output according to the specified format and print the results for all test cases.\",\n      \"input\": \"Optimal starting positions and move counts for all test cases\",\n      \"output\": \"Formatted output for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and split it into lines.\",\n    \"Parse the number of test cases.\",\n    \"For each test case, parse the dimensions of the board and the board configuration.\",\n    \"For each possible starting position on the board, simulate the robot's movement and calculate the number of moves.\",\n    \"Track the maximum number of moves and the corresponding starting position for each test case.\",\n    \"After processing all test cases, format the results and print them.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves without leaving the board.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that results in the highest number of moves the robot can make. In code, this can be implemented by iterating through all possible starting positions and keeping track of the highest move count.\n\n# [degree adverb] \n    'maximum': This means the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by comparing move counts and updating the maximum value accordingly.\n\n# [code logic]\n    The steps related to simulating the robot's movement and comparing move counts should be considered simultaneously. Specifically:\n    - \"Simulate the robot's movement and calculate the number of moves.\"\n    - \"Compare the number of moves from different starting positions to find the maximum.\"\n    These can be implemented in a loop where each starting position is tested, and the move count is compared to the current maximum.\n\n# [edge case] \n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move.\n\n    Test case with all directions leading off the board immediately:\n    2 2\n    LR\n    UD\n    Expected output: 1 1 1\n    Explanation: Any starting position results in only one move before leaving the board.\n\n    Test case with a loop:\n    2 2\n    LR\n    RL\n    Expected output: 1 1 4\n    Explanation: Starting at (1,1), the robot can move in a loop indefinitely, but the problem constraints limit the board size, so the maximum moves are limited by the board size.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot might move off the board or enter a loop.\n    - Implement boundary checks to ensure the robot does not move off the board.\n    - Implement a mechanism to detect loops and limit the move count accordingly.\n\nYES", "Round_0": {"code": "def simulate_movement(n, m, board, start_r, start_c):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r, c = r + dr, c + dc\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n    \n    return moves\n\ndef find_max_moves(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(n, m, board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"steps\": [\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made by the robot until it either exits the board or revisits a cell.\",\n        \"Store the starting position and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Compare the number of moves for all starting positions on the board.\",\n        \"Select the starting position (r, c) that results in the maximum number of moves d.\",\n        \"If there are multiple positions with the same maximum number of moves, select any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement: one line per test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement from each starting position and calculate the number of moves.\",\n    \"Identify the starting position that results in the maximum number of moves.\",\n    \"Output the starting position and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by tracking the number of moves from each starting position and comparing them to find the maximum.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by using a variable to keep track of the highest number of moves encountered during the simulation.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves\" should be implemented simultaneously. Specifically, simulating the robot's movement, tracking the number of moves, and storing the results can be done in a single loop over the board's cells.\n\n# [edge case]\n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot can only move once to the left and exit the board.\n\n    Test case with all directions leading to exit:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 1\n    Explanation: Starting from any position, the robot exits the board immediately.\n\n    Test case with revisiting cells:\n    2 2\n    RR\n    LL\n    Expected output: 1 1 2\n    Explanation: Starting from (1,1), the robot moves right to (1,2) and then exits the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking the number of moves will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    moves = 0\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = [data[index + i].strip() for i in range(n)]\n        index += n\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 51)"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    moves = 0\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        board = [data[index + i].strip() for i in range(n)]\n        index += n\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Read the integer t, followed by t test cases. For each test case, read integers n and m, followed by n strings each of length m.\"\n    },\n    {\n      \"description\": \"Validate the input constraints.\",\n      \"details\": \"Ensure that 1 \u2264 t \u2264 10000, 1 \u2264 n \u2264 2000, 1 \u2264 m \u2264 2000, and the sum of sizes of all boards does not exceed 4\u22c510^6.\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows for the maximum number of moves.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the robot's movement according to the directions ('L', 'R', 'D', 'U') and count the number of moves until it exits the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Determine the starting position and maximum number of moves for each test case.\",\n      \"details\": \"For each test case, identify the cell (r, c) that results in the maximum number of moves d. If multiple cells yield the same maximum, any of them can be chosen.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the integers r, c, and d in the specified format.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Read integers n and m.\",\n    \"  - Read the n strings representing the board configuration.\",\n    \"  - Initialize variables to track the maximum number of moves and corresponding starting position.\",\n    \"  - For each cell (r, c) on the board, simulate the robot's movement and count the moves.\",\n    \"  - Update the maximum moves and starting position if a new maximum is found.\",\n    \"  - Store the result for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This is the highest number of moves the robot can make starting from a specific cell before it exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means finding the starting position that allows the robot to make the most moves possible.\n    Implementation: Track the number of moves for each starting position and update the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This indicates the need to find the highest possible number of moves.\n    Implementation: Use a variable to keep track of the maximum number of moves and update it whenever a new maximum is found.\n\n# [code logic]\n    The steps related to simulating the robot's movement and updating the maximum number of moves should be implemented simultaneously. Specifically:\n    - \"For each cell (r, c) on the board, simulate the robot's movement and count the moves.\"\n    - \"Update the maximum moves and starting position if a new maximum is found.\"\n    These can be done in a single loop iterating over each cell.\n\n# [edge case]\n    Edge Case 1: A board with only one cell, e.g., n = 1, m = 1, board = ['R']\n    Expected Output: 1 1 1\n    Explanation: The robot can only make one move before exiting the board.\n\n    Edge Case 2: A board where all directions lead out immediately, e.g., n = 2, m = 2, board = ['LR', 'UD']\n    Expected Output: 1 1 1\n    Explanation: Any starting position results in only one move before exiting.\n\n    Edge Case 3: A board with a loop, e.g., n = 2, m = 2, board = ['LR', 'RL']\n    Expected Output: 1 1 0\n    Explanation: The robot revisits cells indefinitely, so the number of moves is effectively zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits cells indefinitely.\n    Code for handling the edge case:\n    ```python\n    def simulate_movement(board, n, m, start_r, start_c):\n", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return moves\n\ndef find_max_moves(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_max_moves() missing 3 required positional arguments: 'n', 'm', and 'board'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n\n    return moves\n\ndef find_max_moves(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"steps\": [\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made by the robot until it either exits the board or revisits a cell.\",\n        \"Store the starting position and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Compare the number of moves for all starting positions on the board.\",\n        \"Select the position (r, c) with the maximum number of moves d.\",\n        \"If there are multiple positions with the same maximum number of moves, select any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement, with each test case result on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement from each starting position to calculate the number of moves.\",\n    \"Track the maximum number of moves and the corresponding starting position for each test case.\",\n    \"Output the starting position and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by tracking the number of moves from each starting position and comparing them to find the maximum.\n\n# [degree adverb] \n    'maximum': This means the highest number of moves possible from any starting position on the board. In code, this can be implemented by using a variable to store the maximum number of moves found and updating it whenever a higher number is encountered.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and tracking the number of moves should be implemented simultaneously. Specifically:\n    - \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\"\n    - \"Track the number of moves made by the robot until it either exits the board or revisits a cell.\"\n    These can be implemented in a single loop that iterates over each cell, simulates the movement, and tracks the moves.\n\n# [edge case] \n    Test case with smallest board size:\n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot starts at the only cell and makes one move before exiting the board.\n\n    Test case with all directions leading out:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 1\n    Explanation: Starting at any position leads to immediate exit, so the maximum moves are 1.\n\n    Test case with revisiting cells:\n    2 2\n    RR\n    LL\n    Expected output: 1 1 2\n    Explanation: Starting at (1,1) moves to (1,2) and then exits, making 2 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating the robot's movement and tracking the number of moves will naturally", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 162)"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of test cases, each containing n, m, and the board configuration\"\n    },\n    {\n      \"description\": \"For each test case, simulate the movement of a robot starting from each cell on the board to determine the maximum number of moves possible.\",\n      \"input\": \"Board configuration for a test case\",\n      \"output\": \"Maximum number of moves and the starting cell coordinates\"\n    },\n    {\n      \"description\": \"Identify the starting cell (r, c) that allows the robot to make the maximum number of moves d for each test case.\",\n      \"input\": \"Results of robot simulations for each starting cell\",\n      \"output\": \"Coordinates (r, c) and maximum moves d for each test case\"\n    },\n    {\n      \"description\": \"Format the output according to the specified format for each test case.\",\n      \"input\": \"Coordinates and maximum moves for each test case\",\n      \"output\": \"Formatted output string\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and split it into lines.\",\n    \"Parse the number of test cases t.\",\n    \"Iterate over each test case to extract n, m, and the board configuration.\",\n    \"For each test case, initialize variables to track the maximum number of moves and the corresponding starting cell.\",\n    \"Simulate the robot's movement from each cell on the board:\",\n    \"  - Use a loop to follow the directions ('L', 'R', 'D', 'U') until the robot moves out of bounds or revisits a cell.\",\n    \"  - Count the number of moves made.\",\n    \"  - Update the maximum moves and starting cell if the current simulation results in more moves.\",\n    \"Store the results for each test case.\",\n    \"Format the results for each test case according to the specified output format.\",\n    \"Print the formatted results.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    This means finding the longest sequence of moves the robot can make starting from any cell on the board without revisiting a cell or moving out of bounds.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the longest possible sequence of moves. In code, this can be implemented by tracking the number of moves made from each starting cell and updating the maximum if a longer sequence is found.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves. In code, this can be implemented by comparing the current number of moves with the stored maximum and updating if the current is greater.\n\n# [code logic]\n    The steps related to simulating the robot's movement and updating the maximum moves should be implemented simultaneously. Specifically:\n    - \"Simulate the robot's movement from each cell on the board\"\n    - \"Count the number of moves made\"\n    - \"Update the maximum moves and starting cell if the current simulation results in more moves\"\n    These can be done within a single loop that iterates over each cell and tracks the moves.\n\n# [edge case]\n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot can only make one move from the single cell.\n\n    Test case with all directions leading out of bounds:\n    2 2\n    LR\n    UD\n    Expected output: 1 1 1\n    Explanation: Starting from any cell, the robot immediately moves out of bounds.\n\n    Test case with a loop:\n    2 2\n    LR\n    RL\n    Expected output: 1 1 4\n    Explanation: The robot can move in a loop without revisiting any cell, making 4 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot might revisit a cell or move out of bounds. This can be handled by:\n    - Using a set to track visited cells and breaking the loop if a cell is revisited.\n    - Checking bounds before each move to ensure the robot does not move out of the board.\n\nYES", "Round_0": {"code": "def simulate_robot(board, n, m):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = directions[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n\n    max_moves = 0\n    start_r, start_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_r, start_c = r + 1, c + 1\n\n    return start_r, start_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        result = simulate_robot(board, n, m)\n        results.append(result)\n    \n    for r, c, d in results:\n        print(r, c, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize a function to simulate the robot's movement from a given starting position (r, c).\",\n        \"Track the number of moves made by the robot until it can no longer move.\",\n        \"Ensure the robot follows the direction indicated by the current cell ('L', 'R', 'D', 'U').\",\n        \"Handle edge cases where the robot moves out of bounds.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position (r, c) that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each position, use the simulation function to calculate the number of moves.\",\n        \"Keep track of the maximum number of moves and the corresponding starting position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the requirement: three integers separated by spaces.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and board configurations.\",\n    \"For each test case, simulate the robot's movement from all possible starting positions.\",\n    \"Determine the starting position that results in the maximum number of moves.\",\n    \"Output the results for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    This means finding the starting position on the board that allows the robot to make the most moves before it can no longer move.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by iterating over all possible starting positions and keeping track of the maximum number of moves achieved.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by comparing the number of moves from each starting position and updating the maximum value accordingly.\n\n# [code logic]\n    The steps in the plan related to simulating the robot's movement and determining the starting position with the maximum moves should be considered simultaneously. Specifically, the simulation of the robot's movement and tracking the number of moves should be integrated into a single function that is called for each starting position.\n\n# [edge case]\n    Test case with a single cell board: \n    Input: 1 1 R\n    Expected output: 1 1 1\n    Explanation: The robot can only move once in a single cell board.\n\n    Test case with all cells pointing out of bounds:\n    Input: 2 2 UU\n           UU\n    Expected output: 1 1 0\n    Explanation: The robot cannot move as all directions lead out of bounds immediately.\n\n    Test case with a loop:\n    Input: 2 2 LR\n           RL\n    Expected output: 1 1 4\n    Explanation: The robot can move in a loop indefinitely, but the problem constraints require a finite number of moves, so the maximum moves before repeating is 4.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot moves out of bounds or encounters a loop.\n        (code for handling out of bounds)\n        def simulate_movement(board, r, c):\n            moves = 0\n            visited = set()\n            while (r, c) not in visited and 0 <= r < len(board) and 0 <= c < len(board[0]):\n                visited.add((r, c))\n", "Round_0": {"code": "def simulate_movement(board, r, c):\n    n, m = len(board), len(board[0])\n    moves = 0\n    visited = set()\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r, c = r + dr, c + dc\n        moves += 1\n    \n    return moves\n\ndef find_max_moves(board):\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while not data[index].strip():\n            index += 1  # Skip any blank lines\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n      \"details\": \"Read the integer t, then for each test case, read integers n and m followed by n lines of m characters representing the board.\"\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows for the maximum number of moves.\",\n      \"details\": \"For each cell (r, c) on the board, simulate the robot's movement according to the directions ('L', 'R', 'D', 'U') and count the number of moves until it exits the board or revisits a cell.\"\n    },\n    {\n      \"description\": \"Determine the maximum number of moves possible from any starting position on the board.\",\n      \"details\": \"Track the maximum number of moves and the corresponding starting position (r, c) for each test case.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the starting position (r, c) and the maximum number of moves d.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read integers n and m, then read the n lines of the board configuration.\",\n    \"  b. Initialize variables to track the maximum number of moves and the best starting position.\",\n    \"  c. For each cell (r, c) on the board, simulate the robot's movement:\",\n    \"     i. Follow the direction indicated by the current cell until the robot exits the board or revisits a cell.\",\n    \"     ii. Count the number of moves made.\",\n    \"     iii. If the number of moves is greater than the current maximum, update the maximum and the starting position.\",\n    \"  d. Store the result (r, c, d) for the current test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before exiting the board or revisiting a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates the need to find the highest possible count of moves the robot can make from any starting position on the board.\n    Implementation: Use a loop to simulate movements from each cell and keep track of the highest move count.\n\n# [degree adverb]\n    'maximum': This means the largest possible number of moves the robot can make from a starting position.\n    Implementation: Use a variable to store the maximum move count and update it whenever a higher count is found during simulation.\n\n# [code logic]\n    Steps 2b, 2c, and 2d should be considered simultaneously:\n    \"Initialize variables to track the maximum number of moves and the best starting position.\"\n    \"For each cell (r, c) on the board, simulate the robot's movement.\"\n    \"Store the result (r, c, d) for the current test case.\"\n    Implementation: These steps can be implemented in a single loop that iterates over each cell, simulates the movement, and updates the maximum move count and starting position.\n\n# [edge case]\n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The robot can only move once before exiting the board.\n\n    Test case with all directions leading out:\n    2 2\n    LR\n    DU\n    Expected output: 1 1 2\n    Explanation: Starting at (1,1), the robot can move right and then out of the board.\n\n    Test case with revisiting cells:\n    2 2\n    RR\n    LL\n    Expected output: 1 1 4\n    Explanation: The robot revisits cells, maximizing moves before exiting.\n\n# [extra code for edge case]\n    We need extra code to handle revisiting cells to ensure the robot doesn't count moves indefinitely.\n    Implementation:\n    ```python\n    visited = set()\n    while (r, c) not in visited and within_bounds(r, c):\n        visited.add((", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_best_start() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n\n    return moves\n\ndef find_best_start(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n\n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_best_start(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"details\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"details\": [\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made by the robot until it either exits the board or revisits a cell.\",\n        \"Store the maximum number of moves and the corresponding starting position for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"details\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the requirement: three integers separated by spaces.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize data structures to store the results for each test case.\",\n    \"Iterate over each test case to parse the input and construct the board.\",\n    \"For each test case, iterate over each cell on the board to simulate the robot's movement and calculate the number of moves.\",\n    \"Track the maximum number of moves and the corresponding starting position for each test case.\",\n    \"Output the results for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: The board is represented by a grid of n strings, each with m characters, where each character ('L', 'R', 'D', 'U') indicates a direction the robot can move.\n\n    'maximum number of moves'\n    Explanation: The goal is to determine the starting position on the board that allows the robot to make the most moves before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This means we need to find the starting position that results in the highest possible number of moves.\n    Implementation: This can be implemented by iterating over each cell, simulating the robot's movement, and keeping track of the maximum number of moves.\n\n# [degree adverb]\n    'maximum': This indicates that we are looking for the highest number of moves possible from any starting position.\n    Implementation: Use a variable to store the maximum number of moves found and update it whenever a higher number is encountered.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the simulation of the robot's movement, checking for board exit or revisiting a cell should be done simultaneously in a loop.\n\n# [edge case]\n    Edge Case 1: A board with only one cell, e.g., 1x1 board with 'R'\n    Expected Output: 1 1 1\n    Explanation: The robot can only make one move before exiting the board.\n\n    Edge Case 2: A board where all directions lead back to the starting point, e.g., 2x2 board with 'LR', 'RL'\n    Expected Output: 1 1 0\n    Explanation: The robot revisits the starting cell immediately, resulting in zero moves.\n\n    Edge Case 3: A board with a single row or column, e.g., 1x3 board with 'RRR'\n    Expected Output: 1 1 3\n    Explanation: The robot can move through all cells in the row before exiting.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot revisits a cell immediately or the board is very small.\n    Code for handling the edge case:\n    ```python\n    def simulate_movement(board, n, m):\n        max_moves = 0\n        start_position = (1, 1)\n        for r in range(n):\n            for c in range(m", "Round_0": {"code": "def simulate_movement(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    # Function to simulate movement from a given start position\n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    # Iterate over each cell to find the best starting position\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Simulate movement and get result\n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: simulate_movement() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "def simulate_movement(board, n, m):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    max_moves = 0\n    start_position = (1, 1)\n    \n    # Function to simulate movement from a given start position\n    def move_from(r, c):\n        visited = set()\n        moves = 0\n        while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n            visited.add((r, c))\n            direction = board[r][c]\n            dr, dc = direction_map[direction]\n            r += dr\n            c += dc\n            moves += 1\n        return moves\n    \n    # Iterate over each cell to find the best starting position\n    for r in range(n):\n        for c in range(m):\n            moves = move_from(r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_position = (r + 1, c + 1)  # Convert to 1-based index\n    \n    return start_position[0], start_position[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        # Skip blank line\n        while index < len(data) and data[index].strip() == '':\n            index += 1\n        \n        # Read n and m\n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        # Read the board\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        # Simulate movement and get result\n        r, c, d = simulate_movement(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"steps\": [\n        \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\",\n        \"Track the number of moves made by the robot until it either exits the board or revisits a cell.\",\n        \"Store the starting position and the number of moves for each simulation.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Compare the number of moves for all starting positions on the board.\",\n        \"Select the starting position (r, c) that results in the maximum number of moves d.\",\n        \"If there are multiple positions with the same maximum number of moves, select any of them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the integers r, c, and d, representing the starting position and the maximum number of moves.\",\n        \"Ensure the output format matches the requirement: each test case's output is separated by a blank line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations for each test case.\",\n    \"For each test case, iterate over all possible starting positions on the board.\",\n    \"Simulate the robot's movement from each starting position and calculate the number of moves.\",\n    \"Identify the starting position that results in the maximum number of moves.\",\n    \"Output the starting position and the maximum number of moves for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictate the movement directions for the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before it either exits the board or revisits a cell.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by keeping track of the number of moves for each starting position and selecting the one with the highest count.\n\n# [degree adverb]\n    'maximum': This means the greatest number of moves possible from any starting position. In code, this can be implemented by comparing the move counts for all starting positions and selecting the largest one.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves\" should be implemented simultaneously. Specifically, the steps:\n    - \"For each cell (r, c) on the board, simulate the robot's movement according to the direction specified by the character in the cell.\"\n    - \"Track the number of moves made by the robot until it either exits the board or revisits a cell.\"\n    - \"Store the starting position and the number of moves for each simulation.\"\n    These can be implemented in a single loop that iterates over each cell, simulates the movement, and tracks the moves.\n\n# [edge case]\n    1 1\n    L\n    = 1 1 1\n    Explanation: The board is 1x1 with a single 'L', so the robot can only make one move before exiting the board.\n\n    2 2\n    LR\n    UD\n    = 1 1 4\n    Explanation: Starting from (1,1), the robot can move right, down, left, and up, revisiting the starting cell, making 4 moves.\n\n    3 3\n    LRU\n    DLR\n    UDL\n    = 1 1 9\n    Explanation: The robot can move in a cycle covering all cells, making 9 moves before revisiting a cell.\n\n# [extra code for edge case]\n    We do not need extra code to handle the", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: find_max_moves() missing 3 required positional arguments: 'board', 'n', and 'm'"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef simulate(board, n, m, start_r, start_c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited and 0 <= r < n and 0 <= c < m:\n        visited.add((r, c))\n        direction = board[r][c]\n        dr, dc = directions[direction]\n        r += dr\n        c += dc\n        moves += 1\n    \n    return moves\n\ndef find_max_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    data = input().strip().split('\\n')\n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n    \n    print(\"\\n\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the board.\",\n        \"Read the next n lines, each containing m characters ('L', 'R', 'D', 'U'), to form the board configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves.\",\n      \"steps\": [\n        \"Initialize a function to simulate robot movement from a given starting position (r, c).\",\n        \"Track the number of moves made by the robot until it can no longer move.\",\n        \"Use a direction map to update the robot's position based on the current cell's character ('L', 'R', 'D', 'U').\",\n        \"Ensure the robot stays within the bounds of the board during movement.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the starting position (r, c) that results in the maximum number of moves for each test case.\",\n      \"steps\": [\n        \"Iterate over all possible starting positions on the board.\",\n        \"For each position, simulate the robot's movement and count the number of moves.\",\n        \"Keep track of the maximum number of moves and the corresponding starting position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case in the specified format.\",\n      \"steps\": [\n        \"For each test case, output the starting position (r, c) and the maximum number of moves d.\",\n        \"Ensure the output format matches the requirement: three integers separated by spaces.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and board configurations.\",\n    \"Implement a simulation function to calculate the number of moves from a given starting position.\",\n    \"Iterate over all possible starting positions to find the one with the maximum moves.\",\n    \"Output the results for each test case in the required format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the grid of characters ('L', 'R', 'D', 'U') that dictate the movement directions on the board.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves before it can no longer move.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that results in the highest possible number of moves. In code, this can be implemented by keeping track of the move count for each starting position and updating the maximum when a higher count is found.\n\n# [degree adverb]\n    'maximum': This means the highest number of moves possible from any starting position. In code, this is typically implemented by comparing current move counts and updating a maximum variable.\n\n# [code logic]\n    The steps in the subproblem \"Simulate the movement of a robot on the board to determine the starting position that allows the maximum number of moves\" should be implemented simultaneously. Specifically, the steps involving initializing the function, tracking moves, updating positions, and ensuring bounds should be part of a single function that simulates the robot's movement.\n\n# [edge case]\n    1 1 R = 1 1 1\n    Explanation: With a single cell board, the robot can only make one move regardless of the direction.\n\n    2 2 LL = 1 1 2\n    Explanation: The robot can move left twice starting from the first row, first column.\n\n    2 2 UU = 1 1 2\n    Explanation: The robot can move up twice starting from the first row, first column.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating moves from each starting position and tracking the maximum should naturally handle these cases.\n\nNO", "Round_0": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r, c = r + dr, c + dc\n\n        if not (0 <= r < n and 0 <= c < m):\n            break\n\n    return moves\n\ndef find_maximum_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = find_maximum_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 158)"}, "Round_1": {"code": "def simulate_movement(board, n, m, start_r, start_c):\n    direction_map = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n\n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r, c = r + dr, c + dc\n\n        if not (0 <= r < n and 0 <= c < m):\n            break\n\n    return moves\n\ndef find_maximum_moves(board, n, m):\n    max_moves = 0\n    best_r, best_c = 0, 0\n\n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(board, n, m, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r, c\n\n    return best_r + 1, best_c + 1, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        while data[index].strip() == \"\":\n            index += 1\n\n        n, m = map(int, data[index].strip().split())\n        index += 1\n\n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n\n        r, c, d = find_maximum_moves(board, n, m)\n        results.append(f\"{r} {c} {d}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the dimensions of the board and the board configuration.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"List of test cases, each containing n, m, and the board configuration\"\n    },\n    {\n      \"description\": \"For each test case, determine the starting position (r, c) on the board that allows the robot to make the maximum number of moves.\",\n      \"input\": \"Board configuration for a single test case\",\n      \"output\": \"Starting position (r, c) and the maximum number of moves d\"\n    },\n    {\n      \"description\": \"Implement a function to simulate the robot's movement on the board based on the given directions ('L', 'R', 'D', 'U') and calculate the number of moves.\",\n      \"input\": \"Starting position and board configuration\",\n      \"output\": \"Number of moves the robot can make from the starting position\"\n    },\n    {\n      \"description\": \"Compare the number of moves from different starting positions to find the maximum for each test case.\",\n      \"input\": \"List of possible starting positions and their corresponding move counts\",\n      \"output\": \"Optimal starting position (r, c) and maximum moves d for each test case\"\n    },\n    {\n      \"description\": \"Format the output according to the specified format and print the results for all test cases.\",\n      \"input\": \"Optimal starting positions and move counts for all test cases\",\n      \"output\": \"Formatted output for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the entire input at once and split it into lines.\",\n    \"Parse the number of test cases.\",\n    \"For each test case, parse the dimensions of the board and the board configuration.\",\n    \"For each possible starting position on the board, simulate the robot's movement and calculate the number of moves.\",\n    \"Track the maximum number of moves and the corresponding starting position for each test case.\",\n    \"After processing all test cases, format the results and print them.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configuration'\n    Explanation: This refers to the arrangement of characters ('L', 'R', 'D', 'U') on the board, which dictates the possible movements of the robot.\n\n    'maximum number of moves'\n    Explanation: This means finding the starting position on the board that allows the robot to make the most moves without leaving the board.\n\n# [phrase showing quantity relationship]\n    'maximum number of moves': This indicates that we need to find the starting position that results in the highest number of moves the robot can make. In code, this can be implemented by iterating through all possible starting positions and keeping track of the highest move count.\n\n# [degree adverb] \n    'maximum': This means the largest possible number of moves the robot can make from a starting position. In code, this can be implemented by comparing move counts and updating the maximum value accordingly.\n\n# [code logic]\n    The steps related to simulating the robot's movement and comparing move counts should be considered simultaneously. Specifically:\n    - \"Simulate the robot's movement and calculate the number of moves.\"\n    - \"Compare the number of moves from different starting positions to find the maximum.\"\n    These can be implemented in a loop where each starting position is tested, and the move count is compared to the current maximum.\n\n# [edge case] \n    Test case with smallest board: \n    1 1\n    L\n    Expected output: 1 1 1\n    Explanation: The board is 1x1, and the robot can only make one move.\n\n    Test case with all directions leading off the board immediately:\n    2 2\n    LR\n    UD\n    Expected output: 1 1 1\n    Explanation: Any starting position results in only one move before leaving the board.\n\n    Test case with a loop:\n    2 2\n    LR\n    RL\n    Expected output: 1 1 4\n    Explanation: Starting at (1,1), the robot can move in a loop indefinitely, but the problem constraints limit the board size, so the maximum moves are limited by the board size.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the robot might move off the board or enter a loop.\n    - Implement boundary checks to ensure the robot does not move off the board.\n    - Implement a mechanism to detect loops and limit the move count accordingly.\n\nYES", "Round_0": {"code": "def simulate_movement(n, m, board, start_r, start_c):\n    # Directions mapping\n    direction_map = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    visited = set()\n    r, c = start_r, start_c\n    moves = 0\n    \n    while (r, c) not in visited:\n        visited.add((r, c))\n        moves += 1\n        direction = board[r][c]\n        dr, dc = direction_map[direction]\n        r, c = r + dr, c + dc\n        \n        if r < 0 or r >= n or c < 0 or c >= m:\n            break\n    \n    return moves\n\ndef find_max_moves(n, m, board):\n    max_moves = 0\n    best_r, best_c = 1, 1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = simulate_movement(n, m, board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1\n    \n    return best_r, best_c, max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    t = int(data[index].strip())\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        while data[index].strip() == '':\n            index += 1\n        \n        n, m = map(int, data[index].strip().split())\n        index += 1\n        \n        board = []\n        for _ in range(n):\n            board.append(data[index].strip())\n            index += 1\n        \n        r, c, d = find_max_moves(n, m, board)\n        results.append(f\"{r} {c} {d}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 708, "prompt": "The input must include an integer n and an integer m, accompanied by a sequence of n strings each composed of m characters ('L', 'R', 'D', 'U'), showing the board configuration. Ensure that both n and m are positive integers.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 355}
