{"name": "1622_E. Math Test", "description": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "tags": ["bitmasks", "brute force", "greedy"], "difficulty": 11, "id": 1622, "sample_io": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n"]}], "test_list": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1 4 2 6 3 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n2 1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n4 1 5 2 3 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 4 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n4 1 2 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000100\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 3 5 1 2 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n0 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["3 1 2\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n100101\n111101\n", "output": ["3 1 2\n3 4 1 2\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n1 1 2 0\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n011110\n000101\n111011\n", "output": ["3 1 2\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 10\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 3 4\n100\n100\n101\n100\n4 4\n12 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 4\n010110\n010101\n111111\n", "output": ["1 2 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 1\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n1 4 3 2\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n3 1 3 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["1 3 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 1\n110\n100\n100\n101\n4 4\n2 2 0 13\n1101\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000001\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 3 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0100\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0111\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 0 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n1101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 1\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 4\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n4 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0000\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n1110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 1 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n1110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010100\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0100\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n3 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 6\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n010\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n010\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0100\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n2 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 2 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 0\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n110\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n100\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000100\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n4 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n011\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n12 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 0 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000111\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n20 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111110\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 8\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}], "task_id": "codecontest/158", "repair_prompt": ["Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points. If the answer is incorrect, he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers. Write an efficient algorithm to solve this problem.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points. If the answer is incorrect, he gets 0 points. In addition, more details are provided regarding the distribution of the points for the questions. The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers. Write an efficient algorithm to solve this problem.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Petya is a math teacher. n of his students has written a test consisting of m questions and for each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points, and if the answer is incorrect, he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers. Write an efficient algorithm to solve this problem.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\ninput = sys.stdin.read\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        answers = [data[index + i] for i in range(n)]\n        index += n\n        \n        # Generate the permutation of points from 1 to m\n        best_permutation = None\n        max_surprise_value = -1\n        \n        # Iterate over all permutations of points from 1 to m\n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            surprise_value = calculate_surprise_value(n, m, x, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for i in range(n):\n            for j in range(m):\n                if correctness_matrix[i][j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Assign points in increasing order of correct counts\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations:\n            # Calculate the actual points for each student\n            r = []\n            for i in range(n):\n                r_i = sum(perm[j] for j in range(m) if s[i][j] == '1')\n                r.append(r_i)\n            \n            # Calculate the surprise value\n            surprise_value = sum(abs(x[i] - r[i]) for i in range(n))\n            \n            # Check if this permutation gives a higher surprise value\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the actual points for each student\n        actual_points = [0] * n\n        \n        # Generate the permutation that maximizes the surprise value\n        # Since we want maximum surprise, we can simply reverse the order of points\n        permutation = list(range(1, m + 1))\n        permutation.reverse()\n        \n        # Calculate actual points based on the permutation\n        for i in range(n):\n            for j in range(m):\n                if answers[i][j] == '1':\n                    actual_points[i] += permutation[j]\n        \n        # Calculate the surprise value\n        surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n        \n        results.append(\" \".join(map(str, permutation)))\n    \n    # Print the results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        r_i = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - r_i)\n    return surprise_value\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for p in permutations:\n            surprise_value = calculate_surprise_value(n, m, x, s, p)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = p\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Sort questions by the number of correct answers in ascending order\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, q_index in enumerate(question_indices):\n            permutation[q_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to the questions with the least correct answers\n        permutation = [0] * m\n        for i, idx in enumerate(question_indices):\n            permutation[idx] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Calculate the best permutation\n        # Since n is small (<= 10), we can afford to calculate permutations\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Generate the permutation of points\n        points = list(range(1, m + 1))\n        \n        # Sort students by expected points in descending order\n        sorted_students = sorted(range(n), key=lambda i: expected_points[i], reverse=True)\n        \n        # Sort questions by the number of students who got them right\n        question_correct_count = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in ascending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j])\n        \n        # Assign the highest points to the questions with the least correct answers\n        best_permutation = [0] * m\n        for i, question_index in enumerate(sorted_questions):\n            best_permutation[question_index] = points[i]\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\ninput = sys.stdin.read\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        answers = [data[index + i] for i in range(n)]\n        index += n\n        \n        # Generate the permutation of points from 1 to m\n        best_permutation = None\n        max_surprise_value = -1\n        \n        # Iterate over all permutations of points from 1 to m\n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points received by summing the points for correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate permutations of points from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation with the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the numbers from 1 to m, which represent the points assigned to each question. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation that results in the highest possible surprise value. In code, this involves iterating over permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the highest possible value of the surprise value. In code, this is implemented by comparing calculated surprise values and keeping track of the highest one.\n\n# [code logic]\n    The steps in the subproblem \"Calculate the actual points each student received based on their answers and a given permutation of points\" and \"Determine the permutation of points that maximizes the surprise value for each test case\" should be implemented simultaneously. This can be done by iterating over permutations and calculating the surprise value in the same loop.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, any permutation will result in a surprise value of 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, and both expect maximum points. The permutation doesn't matter as the surprise value will be 0.\n\n    Test case with no correct answers:\n    2 3\n    0 0\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No points are expected or received, so any permutation will result in a surprise value of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the surprise value will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\ninput = sys.stdin.read\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        answers = [data[index + i] for i in range(n)]\n        index += n\n        \n        # Generate the permutation of points from 1 to m\n        best_permutation = None\n        max_surprise_value = -1\n        \n        # Iterate over all permutations of points from 1 to m\n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and students' answers.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, representing the number of students and questions.\",\n        \"Read the array of expected points x for each student.\",\n        \"Read the binary strings representing students' answers to the questions.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the points received by summing the points of correctly answered questions according to a permutation p.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, generate all possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, iterate over all permutations of points from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and track the maximum surprise value.\",\n    \"Output the permutation that yields the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points for questions in such a way that they are a sequence of numbers from 1 to m. This means each question has a unique point value from 1 to m.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that the permutation of points should be chosen such that the surprise value is as large as possible.\n\n# [degree adverb]\n    'maximum'\n    This means we need to find the permutation that results in the highest possible surprise value.\n\n# [code logic]\n    The steps for calculating the actual points and determining the permutation that maximizes the surprise value should be considered simultaneously. Specifically, generating permutations and calculating the surprise value for each should be done in a loop or recursive function that handles both tasks together.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation that maximizes the surprise value is any permutation since all answers are correct.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No student answered correctly, so the permutation does not affect the surprise value, which remains 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through permutations and calculating the surprise value will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            surprise_value = calculate_surprise_value(n, m, x, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'x', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(x[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            surprise_value = calculate_surprise_value(n, m, x, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the correctness matrix for each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"output\": \"Formatted output of the permutation for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each test case, iterate over all possible permutations of question points to calculate the actual points for each student.\",\n    \"For each permutation, calculate the surprise value as the sum of absolute differences between expected and actual points for all students.\",\n    \"Track the permutation that results in the maximum surprise value.\",\n    \"Once the optimal permutation is found for a test case, store it for output.\",\n    \"After processing all test cases, output the stored permutations, one for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the question points such that each question has a unique point value from 1 to m.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation of question points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: This means we are looking for the permutation that gives the largest possible surprise value.\n\n# [code logic]\n    The steps involving iterating over permutations and calculating the surprise value should be considered simultaneously. Specifically, the steps:\n    - \"For each test case, iterate over all possible permutations of question points to calculate the actual points for each student.\"\n    - \"For each permutation, calculate the surprise value as the sum of absolute differences between expected and actual points for all students.\"\n    These can be implemented in a single loop where each permutation is evaluated for its surprise value.\n\n# [edge case] \n    1. Test case with n = 1, m = 1, x_1 = 0, s_1 = \"0\" = 1\n       Explanation: With only one question and one student who expects 0 points and answers incorrectly, the permutation can only be [1], resulting in a surprise value of 1.\n    2. Test case with n = 1, m = 1, x_1 = 1, s_1 = \"1\" = 0\n       Explanation: With only one question and one student who expects 1 point and answers correctly, the permutation can only be [1], resulting in a surprise value of 0.\n    3. Test case with n = 2, m = 2, x_1 = 1, x_2 = 2, s_1 = \"10\", s_2 = \"01\" = 2\n       Explanation: With two questions and two students, each expecting different points, the permutation [2, 1] maximizes the surprise value to 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, correctness_matrix, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if correctness_matrix[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, correctness_matrix, perm)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'correctness_matrix', and 'permutation'"}, "Round_1": {"code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        correctness_matrix = []\n        for _ in range(n):\n            correctness_matrix.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for i in range(n):\n            for j in range(m):\n                if correctness_matrix[i][j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Assign points in increasing order of correct counts\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers matrix for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the number of students and questions respectively.\",\n        \"Read the list of expected points x for each student.\",\n        \"Read the matrix of answers s, where each row corresponds to a student's answers.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points r_i they received by summing the points for correctly answered questions according to a permutation p.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points p that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation p for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, print the permutation p that was determined to maximize the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate all permutations of points from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation that maximizes it.\",\n    \"Output the permutation that maximizes the surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points assigned to each question such that each number from 1 to m is used exactly once. The goal is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The task is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the goal is to find the permutation that results in the highest possible surprise value. In code, this involves iterating over permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the largest possible value of the surprise value. In code, this can be implemented by keeping track of the highest surprise value encountered during the iteration over permutations.\n\n# [code logic]\n    The steps in the plan are sequential and do not require simultaneous execution. However, the calculation of the actual points and the surprise value for each permutation should be done in a loop iterating over all permutations.\n\n# [edge case]\n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation can only be [1], resulting in a surprise value of 0.\n\n    Edge Case 2: n = 1, m = 2, x = [1], s = [\"01\"]\n    Expected Output: 2 1\n    Explanation: The student expects 1 point and answers the second question correctly. The permutation [2, 1] maximizes the surprise value.\n\n    Edge Case 3: n = 2, m = 2, x = [1, 1], s = [\"10\", \"01\"]\n    Expected Output: 1 2\n    Explanation: Both students expect 1 point, and each answers a different question correctly. The permutation [1, 2] maximizes the surprise value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the surprise value will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for perm in permutations:\n            # Calculate the actual points for each student\n            r = []\n            for i in range(n):\n                r_i = sum(perm[j] for j in range(m) if s[i][j] == '1')\n                r.append(r_i)\n            \n            # Calculate the surprise value\n            surprise_value = sum(abs(x[i] - r[i]) for i in range(n))\n            \n            # Check if this permutation gives a higher surprise value\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = perm\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    # Print all results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as a binary string.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, initialize their score to 0.\",\n        \"Iterate over each question and add the corresponding point value from the permutation if the student answered correctly.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"Generate all possible permutations of point values from 1 to m.\",\n        \"For each permutation, calculate the total surprise value using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate permutations of point values and calculate the actual scores for each student.\",\n    \"Compute the surprise value for each permutation and identify the permutation that maximizes this value.\",\n    \"Output the optimal permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the point values from 1 to m in different orders to calculate the scores.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between expected points and actual points for each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps in the plan related to generating permutations and calculating surprise values should be considered simultaneously. Generating permutations and calculating surprise values can be done in a single loop where each permutation is evaluated for its surprise value.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation 2 1 maximizes the surprise value.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No student answered correctly, so the permutation doesn't affect the scores, and the surprise value is maximized by any permutation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\nimport itertools\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the actual points for each student\n        actual_points = [0] * n\n        \n        # Generate the permutation that maximizes the surprise value\n        # Since we want maximum surprise, we can simply reverse the order of points\n        permutation = list(range(1, m + 1))\n        permutation.reverse()\n        \n        # Calculate actual points based on the permutation\n        for i in range(n):\n            for j in range(m):\n                if answers[i][j] == '1':\n                    actual_points[i] += permutation[j]\n        \n        # Calculate the surprise value\n        surprise_value = sum(abs(expected_points[i] - actual_points[i]) for i in range(n))\n        \n        results.append(\" \".join(map(str, permutation)))\n    \n    # Print the results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers matrix for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the number of students and questions respectively.\",\n        \"Read the list of expected points x for each student.\",\n        \"Read the matrix of answers s, where each row corresponds to a student's answers.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points r_i they received by summing the points for correctly answered questions according to a permutation p.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points p that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation p for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, print the permutation p that was determined to maximize the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate all permutations of points from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation that maximizes it.\",\n    \"Output the permutation that maximizes the surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points assigned to each question such that each number from 1 to m is used exactly once. The goal is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The task is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the goal is to find the permutation that results in the highest possible surprise value. In code, this would involve iterating over all permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the largest possible surprise value that can be achieved with any permutation of points. In code, this involves comparing calculated surprise values and keeping track of the largest one.\n\n# [code logic]\n    The steps in the plan related to generating permutations and calculating surprise values should be considered simultaneously. Specifically, generating permutations and calculating the surprise value for each should be done in a loop, where each permutation is evaluated immediately after it is generated.\n\n# [edge case]\n    1. Test case with n = 1 and m = 1, x_1 = 0, s_1 = \"0\"\n       Expected output: 1\n       Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0 regardless.\n\n    2. Test case with n = 1 and m = 1, x_1 = 1, s_1 = \"1\"\n       Expected output: 1\n       Explanation: The student expects 1 point and answers correctly, so the permutation should assign 1 point to the question to maximize the surprise value.\n\n    3. Test case with n = 2 and m = 2, x_1 = 1, x_2 = 2, s_1 = \"10\", s_2 = \"01\"\n       Expected output: 2 1\n       Explanation: Assigning 2 points to the first question and 1 point to the second maximizes the surprise value, as it results in the largest difference between expected and actual points.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently,", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, x, s, p):\n    surprise_value = 0\n    for i in range(n):\n        r_i = sum(p[j] for j in range(m) if s[i][j] == '1')\n        surprise_value += abs(x[i] - r_i)\n    return surprise_value\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        x = list(map(int, data[index:index + n]))\n        index += n\n        \n        s = []\n        for _ in range(n):\n            s.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for p in permutations:\n            surprise_value = calculate_surprise_value(n, m, x, s, p)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = p\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the correctness of each student's answers.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with students' data\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points for each student based on a permutation\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"List of expected points and list of actual points for each permutation\",\n      \"output\": \"Permutation of question points that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation for each test case.\",\n      \"input\": \"Permutation of question points for each test case\",\n      \"output\": \"Formatted output for all test cases\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a list of possible permutations of question points.\",\n    \"For each permutation, calculate the actual points each student would receive based on their answers.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Select the permutation that yields the maximum surprise value.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points for questions such that they are a sequence from 1 to m, and the goal is to find the permutation that maximizes the surprise value.\n\n    'surprise value'\n    The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by students.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that the goal is to find the permutation of question points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest sum of absolute differences between expected and actual points.\n\n# [code logic]\n    The steps for calculating actual points and computing the surprise value should be considered simultaneously. For each permutation, calculate the actual points and then compute the surprise value in one code block to efficiently evaluate each permutation.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, and the permutation that maximizes the surprise value is 2 1, resulting in a surprise value of 0.\n\n    Test case with mixed expectations:\n    3 3\n    3 0 6\n    111\n    000\n    111\n    Expected output: 3 2 1\n    Explanation: The permutation 3 2 1 maximizes the surprise value by creating the largest difference between expected and actual points.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of evaluating permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Sort questions by the number of correct answers in ascending order\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, q_index in enumerate(question_indices):\n            permutation[q_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 94)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Sort questions by the number of correct answers in ascending order\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, q_index in enumerate(question_indices):\n            permutation[q_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers matrix for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers matrix for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"Initialize a permutation of points from 1 to m.\",\n        \"For each student, calculate the actual points received by summing the points for correctly answered questions.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over all possible permutations of points.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate all permutations of points from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation with the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    In the requirement, permutation refers to arranging the points from 1 to m in different orders to calculate the surprise value.\n\n    'surprise value'\n    The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    This indicates that we need to find the permutation of points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    This means we need to find the permutation that results in the largest surprise value.\n\n# [code logic]\n    The steps in the plan related to generating permutations and calculating surprise values should be considered simultaneously. Specifically, generating permutations and calculating the surprise value for each permutation should be done in a loop or recursive function to efficiently explore all possibilities.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation that maximizes surprise value is any order since all permutations result in the same surprise value.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No student answered correctly, so the permutation does not affect the surprise value, which remains 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to the questions with the least correct answers\n        permutation = [0] * m\n        for i, idx in enumerate(question_indices):\n            permutation[idx] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 136)"}, "Round_1": {"code": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to the questions with the least correct answers\n        permutation = [0] * m\n        for i, idx in enumerate(question_indices):\n            permutation[idx] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the correctness of each student's answers.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with students' data\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points for each student based on a permutation\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"List of expected points and list of actual points for each permutation\",\n      \"output\": \"Permutation of question points that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation for each test case.\",\n      \"input\": \"Permutation of question points for each test case\",\n      \"output\": \"Formatted output for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, generate all possible permutations of question points.\",\n    \"For each permutation, calculate the actual points each student would get.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Select the permutation that maximizes the surprise value.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points assigned to each question such that each question has a unique point value from 1 to m.\n\n    'surprise value'\n    Explanation: The surprise value is defined as the sum of the absolute differences between the expected points and the actual points obtained by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation of question points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: This means we are looking for the permutation that results in the greatest possible surprise value.\n\n# [code logic]\n    The steps \"Generate all possible permutations of question points\" and \"Calculate the actual points each student would get\" should be considered simultaneously. This can be done by iterating over each permutation and calculating the actual points in the same loop.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, x = [0], s = [\"0\"]\n    Expected Output: 1\n    Explanation: With only one question and the student expecting 0 points, the permutation doesn't matter as the surprise value will be 0.\n\n    Edge Case 2: n = 1, m = 10, x = [55], s = [\"1111111111\"]\n    Expected Output: 10 9 8 7 6 5 4 3 2 1\n    Explanation: The student expects the maximum possible points, so the permutation should be in descending order to maximize the surprise value.\n\n    Edge Case 3: n = 10, m = 1, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], s = [\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"]\n    Expected Output: 1\n    Explanation: With all students expecting 0 points and answering incorrectly, the permutation doesn't affect the surprise value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating permutations and calculating the surprise value will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Calculate the best permutation\n        # Since n is small (<= 10), we can afford to calculate permutations\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Generate the permutation of points\n        points = list(range(1, m + 1))\n        \n        # We can optimize by sorting the students by their expected points\n        # and then assigning the highest points to the questions they got right\n        # to maximize the surprise value.\n        \n        # Sort students by expected points in descending order\n        sorted_students = sorted(range(n), key=lambda i: expected_points[i], reverse=True)\n        \n        # Sort questions by the number of students who got them right\n        question_correct_count = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in ascending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j])\n        \n        # Assign the highest points to the questions with the least correct answers\n        best_permutation = [0] * m\n        for i, question_index in enumerate(sorted_questions):\n            best_permutation[question_index] = points[i]\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 157)"}, "Round_1": {"code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Calculate the best permutation\n        # Since n is small (<= 10), we can afford to calculate permutations\n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Generate the permutation of points\n        points = list(range(1, m + 1))\n        \n        # Sort students by expected points in descending order\n        sorted_students = sorted(range(n), key=lambda i: expected_points[i], reverse=True)\n        \n        # Sort questions by the number of students who got them right\n        question_correct_count = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Sort questions by the number of correct answers in ascending order\n        sorted_questions = sorted(range(m), key=lambda j: question_correct_count[j])\n        \n        # Assign the highest points to the questions with the least correct answers\n        best_permutation = [0] * m\n        for i, question_index in enumerate(sorted_questions):\n            best_permutation[question_index] = points[i]\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of test cases, number of students, number of questions, expected points, and students' answers.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"Initialize a permutation of points from 1 to m.\",\n        \"For each student, calculate the total points received using the permutation and their answers.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each permutation of points, calculate the surprise value using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Compare the surprise values for different permutations and select the permutation that yields the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"Iterate over all possible permutations of points for the questions.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation with the maximum surprise value.\",\n    \"Output the optimal permutation for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the points assigned to each question such that each number from 1 to m is used exactly once. The goal is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The task is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that the goal is to find the permutation of points that results in the highest possible surprise value.\n\n# [degree adverb] \n    'maximum'\n    Explanation: The requirement is to find the permutation that results in the largest possible surprise value. This involves comparing the surprise values of different permutations and selecting the one with the highest value.\n\n# [code logic]\n    The steps in the plan related to calculating the surprise value for each permutation and selecting the maximum should be implemented simultaneously. Specifically, the calculation of the surprise value and the comparison to find the maximum can be done in a single loop over permutations.\n\n# [edge case] \n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, the permutation is trivial, and the surprise value is 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, expecting maximum points. The permutation that maximizes surprise value is one that assigns lower points to questions.\n\n    Test case with no correct answers:\n    3 3\n    0 0 0\n    000\n    000\n    000\n    Expected output: 1 2 3\n    Explanation: No student answered correctly, so the permutation does not affect the surprise value, which remains 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating surprise values will naturally handle these scenarios.\n\nNO", "Round_0": {"code": "import sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points received by summing the points for correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate permutations of points from 1 to m.\",\n    \"Calculate the actual points received by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and identify the permutation with the maximum surprise value.\",\n    \"Output the permutation with the maximum surprise value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation refers to an arrangement of the numbers from 1 to m, which represent the points assigned to each question. The task is to find a permutation that maximizes the surprise value.\n\n    'surprise value'\n    Explanation: The surprise value is calculated as the sum of the absolute differences between the expected points and the actual points received by each student. The goal is to maximize this value.\n\n# [phrase showing quantity relationship]\n    'maximum possible'\n    Explanation: This indicates that we need to find the permutation that results in the highest possible surprise value. In code, this involves iterating over permutations and selecting the one with the highest calculated surprise value.\n\n# [degree adverb]\n    'maximum'\n    Explanation: This refers to the highest possible value of the surprise value. In code, this is implemented by comparing calculated surprise values and keeping track of the highest one.\n\n# [code logic]\n    The steps in the subproblem \"Calculate the actual points each student received based on their answers and a given permutation of points\" and \"Determine the permutation of points that maximizes the surprise value for each test case\" should be implemented simultaneously. This can be done by iterating over permutations and calculating the surprise value in the same loop.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    0\n    0\n    Expected output: 1\n    Explanation: With only one question and one student expecting 0 points, any permutation will result in a surprise value of 0.\n\n    Test case with all students expecting maximum points:\n    2 2\n    3 3\n    11\n    11\n    Expected output: 2 1\n    Explanation: Both students answered all questions correctly, and both expect maximum points. The permutation doesn't matter as the surprise value will be 0.\n\n    Test case with no correct answers:\n    2 3\n    0 0\n    000\n    000\n    Expected output: 3 2 1\n    Explanation: No points are expected or received, so any permutation will result in a surprise value of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over permutations and calculating the surprise value will naturally handle these cases.\n\nNO", "Round_0": {"code": "import sys\ninput = sys.stdin.read\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    data = input().strip().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        answers = [data[index + i] for i in range(n)]\n        index += n\n        \n        # Generate the permutation of points from 1 to m\n        best_permutation = None\n        max_surprise_value = -1\n        \n        # Iterate over all permutations of points from 1 to m\n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(\" \".join(map(str, best_permutation)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, false, true, false, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 306, "prompt": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points. If the answer is incorrect, he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Assume all input values are integers. Write an efficient algorithm to solve this problem.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 151}
