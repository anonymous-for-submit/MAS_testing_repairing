{"name": "1607_D. Blue-Red Permutation", "description": "You are given an array of integers a of length n. The elements of the array can be either different or the same. \n\nEach element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:\n\n  * either you can select any blue element and decrease its value by 1; \n  * or you can select any red element and increase its value by 1. \n\n\n\nSituations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.\n\nDetermine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?\n\nIn other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.", "tags": ["greedy", "math", "sortings"], "difficulty": 10, "id": 1607, "sample_io": [{"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}], "test_list": [{"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 7 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nNO\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 1\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n6 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 7 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n2 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 2 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 6 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n0 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 7 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nNO\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 8 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 6 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 2\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 -1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n8 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nNO\nNO\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nYES\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n3 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n2 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 1 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 4 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 8 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 6 9\nRBRRB\n5\n3 1 3 1 1\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nNO\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 1\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 8 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nNO\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 2\nBB\n5\n3 1 7 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nYES\nNO\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 3\nRBRRB\n5\n3 1 6 0 5\nRBRRB\n5\n5 2 4 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 0\nRBRRB\n5\n0 1 6 1 10\nRBRRA\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 0 -1\nRRRR\n", "output": ["YES\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n7 1 3 1 3\nRBRRB\n5\n5 1 2 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n2 1\nBB\n5\n3 0 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nBRRBR\n4\n3 2 2 2\nBRBR\n2\n1 -1\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nYES\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 4\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n1 2 1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 10\nBRRBR\n5\n4 1 6 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 3\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n2 1 4 2 5\nRBRRB\n5\n2 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -1\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 -1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 0 5\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nBRRBR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 3 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 6 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 6 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n3 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nRRBB\n2\n1 1\nBB\n5\n3 1 4 3 10\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 1 2\nBRBR\n2\n1 -1\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 0 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 0 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n5 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nRBBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n0 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n1 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 6 1\nBRBR\n2\n0 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 3\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n3 3 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 1\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 7 2 0\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n6 0 4 2 0\nRBRRB\n5\n5 1 6 0 5\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nBRRBR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nRBRRB\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 0 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 0 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-3 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBBR\n2\n1 1\nBB\n5\n5 1 4 2 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nRBBR\n2\n1 1\nBB\n5\n3 1 5 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 2 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 2\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 2 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 2 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 1\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 3 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 1 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 -1\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nBRRBR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nBRRBR\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 3\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n0 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 -1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 9 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 0 1 3\nRBRRB\n5\n5 1 9 1 5\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-3 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n4 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n0 2 -1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 1\nRBBR\n2\n1 1\nBB\n5\n3 1 5 2 3\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 5 1 8\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 3 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 4\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 3 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 2 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 3\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n5 0 4 2 1\nRBRRB\n5\n5 1 6 1 5\nRBRRB\n5\n5 3 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 5 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 1 6 2 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nRBRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n4 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n4 1 5 1 5\nBRRBR\n4\n2 2 2 3\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 3\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 1 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -2 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n0 1\nBB\n5\n5 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 1\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -2\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 2\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 5 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 4 2 2\nBRBR\n2\n1 -2\nRB\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 -1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n4 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 0\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 1 5 2\nRBRB\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n5 1 5 1 2\nRBRRB\n4\n-1 2 -1 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 2 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 4\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n2 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n5 1 3 1 3\nRBRRB\n5\n0 1 5 1 2\nRBRRB\n4\n0 3 0 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 3 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 3\nRBRRB\n5\n3 1 6 1 10\nRBRRB\n5\n5 2 5 1 7\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 0 -1\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n0 2 6 1\nBRBR\n2\n1 1\nBB\n5\n3 1 1 4 3\nRBRRB\n5\n5 1 6 0 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 -2\nRRRR\n", "output": ["NO\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 5 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 4 2 0\nRBRRB\n5\n5 0 6 2 6\nRBRRB\n5\n5 4 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRRB\n2\n1 1\nBB\n5\n3 0 4 2 5\nRBRRB\n5\n1 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 3\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 1 5 2 4\nRBBRR\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -2 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 3 2\nBRBR\n2\n0 1\nBB\n5\n5 1 4 2 5\nRBRRB\n5\n3 1 5 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRQB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 3 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 1\nRRBBR\n5\n4 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nRBRB\n2\n1 -3\nBR\n4\n-2 -1 4 1\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -4\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 1 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 4 2 2\nBRBR\n2\n1 -2\nRB\n4\n-4 -1 0 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 0 5 2\nBRBR\n2\n1 1\nBB\n5\n3 0 4 7 5\nBRRBR\n5\n4 1 3 1 4\nRBRRB\n5\n5 -2 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nRB\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\n"]}, {"input": "8\n4\n4 4 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 4 9\nRBRRB\n5\n3 1 3 1 1\nRBRRB\n5\n5 1 5 0 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 0 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 0\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 5\nBRRBR\n5\n4 1 2 0 4\nRBRRB\n5\n5 1 4 1 2\nRBRRB\n4\n3 2 2 4\nBRBR\n2\n1 -2\nBR\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBBRR\n2\n1 1\nBB\n5\n6 1 4 2 5\nBRRBR\n5\n0 1 3 1 6\nRBRRB\n5\n5 1 9 0 5\nRBRRA\n4\n2 3 2 2\nBRBR\n2\n1 -3\nBR\n4\n-4 -1 4 0\nRRRR\n", "output": ["NO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n0 1 6 1\nBRBR\n2\n1 1\nBB\n5\n3 0 5 2 0\nRBRRB\n5\n5 1 3 1 5\nRBRRB\n5\n5 2 5 1 5\nRBRRB\n4\n3 2 2 1\nBRBR\n2\n2 -2\nBR\n4\n-2 -1 2 0\nRRRR\n", "output": ["NO\nNO\nNO\nYES\nNO\nYES\nYES\nYES\n"]}, {"input": "8\n4\n2 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 3 9\nRBRRB\n5\n3 1 3 1 5\nRBRRB\n5\n5 1 0 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n0 -4\nRB\n4\n-1 -1 4 0\nRRRR\n", "output": ["YES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\n"]}, {"input": "8\n4\n1 2 5 2\nBRBR\n2\n1 4\nBB\n5\n3 1 4 2 5\nBRRBR\n5\n4 1 6 1 4\nRBRRB\n5\n5 1 5 1 10\nRBRRA\n4\n2 2 2 2\nBRBR\n2\n1 -3\nBR\n4\n-2 -1 4 0\nRRRR\n", "output": ["YES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\n"]}], "task_id": "codecontest/101", "repair_prompt": ["You are given an array of integers a of length n; the elements of the array can be either different or the same, and each element of the array is colored either blue or red, with no unpainted elements, and one of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1, or you can select any red element and increase its value by 1. Situations in which there are no elements of some color at all are also possible. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n? In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given an array of integers a of length n; the elements of the array can be either different or the same. Each element of the array is colored either blue or red, with no unpainted elements. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1, or you can select any red element and increase its value by 1. Situations in which there are no elements of some color at all are also possible. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n? In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given an array of integers a of length n; the elements of the array can be either different or the same, and each element of the array is colored either blue or red, with no unpainted elements, and one of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1, or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n? In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def can_transform_to_permutation(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a, colors = case\n        blue_elements = []\n        red_elements = []\n\n        for i in range(n):\n            if colors[i] == 'B':\n                blue_elements.append(a[i])\n            else:\n                red_elements.append(a[i])\n\n        # Sort blue elements in ascending order and red elements in descending order\n        blue_elements.sort()\n        red_elements.sort(reverse=True)\n\n        possible = True\n\n        # Check if blue elements can cover the range [1, len(blue_elements)]\n        for i in range(len(blue_elements)):\n            if blue_elements[i] < i + 1:\n                possible = False\n                break\n\n        # Check if red elements can cover the range [n - len(red_elements) + 1, n]\n        for i in range(len(red_elements)):\n            if red_elements[i] > n - i:\n                possible = False\n                break\n\n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def can_transform_to_permutation(n, a, colors):\n    blue = []\n    red = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue.append(a[i])\n        else:\n            red.append(a[i])\n    \n    blue.sort()\n    red.sort(reverse=True)\n    \n    # Check blue elements\n    for i in range(len(blue)):\n        if blue[i] < i + 1:\n            return \"NO\"\n    \n    # Check red elements\n    for i in range(len(red)):\n        if red[i] > n - i:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    # Separate blue and red elements\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort blue elements in ascending order and red elements in descending order\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n    \n    # Check if blue elements can cover numbers from 1 to n without going below 1\n    for i in range(len(blue_elements)):\n        if blue_elements[i] < i + 1:\n            return \"NO\"\n    \n    # Check if red elements can cover numbers from 1 to n without exceeding n\n    for i in range(len(red_elements)):\n        if red_elements[i] > n - i:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_form_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_transform_to_permutation(n, a, colors):\n    # Separate elements into blue and red lists\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort blue elements in descending order and red elements in ascending order\n    blue_elements.sort(reverse=True)\n    red_elements.sort()\n    \n    # Check if we can form a permutation from 1 to n\n    for i in range(1, n + 1):\n        if blue_elements and blue_elements[-1] >= i:\n            blue_elements.pop()\n        elif red_elements and red_elements[-1] <= i:\n            red_elements.pop()\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    blue_elements.sort()\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit in the permutation\n    for i in range(len(blue_elements)):\n        if blue_elements[i] < i + 1:\n            return False\n    \n    # Check if red elements can be increased to fit in the permutation\n    for i in range(len(red_elements)):\n        if red_elements[i] > n - len(red_elements) + i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_transform_to_permutation(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a, colors = case\n        blue_list = []\n        red_list = []\n        \n        for i in range(n):\n            if colors[i] == 'B':\n                blue_list.append(a[i])\n            else:\n                red_list.append(a[i])\n        \n        blue_list.sort()\n        red_list.sort(reverse=True)\n        \n        possible = True\n        \n        # Check blue elements\n        for i in range(len(blue_list)):\n            if blue_list[i] < i + 1:\n                possible = False\n                break\n        \n        # Check red elements\n        for i in range(len(red_list)):\n            if red_list[i] > n - i:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_permutation(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a, colors = case\n        possible = True\n        \n        # Create a list of tuples (value, color) and sort it\n        elements = sorted(zip(a, colors))\n        \n        # Check if we can form a permutation from 1 to n\n        for i in range(n):\n            value, color = elements[i]\n            target = i + 1  # We need to form a permutation from 1 to n\n            \n            if color == 'B':\n                # Blue elements can only be decreased\n                if value < target:\n                    possible = False\n                    break\n            elif color == 'R':\n                # Red elements can only be increased\n                if value > target:\n                    possible = False\n                    break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_form_permutation(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_transform_to_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n\n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n\n    # Check if blue elements can be decreased to fit the permutation\n    for i in range(len(blue_elements)):\n        if blue_elements[i] < i + 1:\n            return \"NO\"\n\n    # Check if red elements can be increased to fit the permutation\n    for i in range(len(red_elements)):\n        if red_elements[i] > n - i:\n            return \"NO\"\n\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n\n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_transform_to_permutation(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a, colors = test_cases[i]\n        \n        blue = []\n        red = []\n        \n        for j in range(n):\n            if colors[j] == 'B':\n                blue.append(a[j])\n            else:\n                red.append(a[j])\n        \n        blue.sort()\n        red.sort(reverse=True)\n        \n        possible = True\n        \n        # Check blue elements\n        for idx, value in enumerate(blue):\n            if value < idx + 1:\n                possible = False\n                break\n        \n        # Check red elements\n        for idx, value in enumerate(red):\n            if value > n - idx:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def can_form_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    blue_elements.sort()\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit within the range [1, n]\n    for i in range(len(blue_elements)):\n        if blue_elements[i] > n:\n            return False\n        if blue_elements[i] < i + 1:\n            return False\n    \n    # Check if red elements can be increased to fit within the range [1, n]\n    for i in range(len(red_elements)):\n        if red_elements[i] < 1:\n            return False\n        if red_elements[i] > n - len(red_elements) + i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_transform_to_permutation(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a, colors = case\n        blue_elements = []\n        red_elements = []\n\n        for i in range(n):\n            if colors[i] == 'B':\n                blue_elements.append(a[i])\n            else:\n                red_elements.append(a[i])\n\n        # Sort blue elements in ascending order and red elements in descending order\n        blue_elements.sort()\n        red_elements.sort(reverse=True)\n\n        possible = True\n\n        # Check if blue elements can cover the range [1, len(blue_elements)]\n        for i in range(len(blue_elements)):\n            if blue_elements[i] < i + 1:\n                possible = False\n                break\n\n        # Check if red elements can cover the range [n - len(red_elements) + 1, n]\n        for i in range(len(red_elements)):\n            if red_elements[i] > n - i:\n                possible = False\n                break\n\n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the length of the array.\",\n        \"Read the array of integers a of length n.\",\n        \"Read the string of colors of length n, consisting of 'B' and 'R'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, initialize two lists to track the possible range of values for blue and red elements.\",\n        \"Iterate over the array and the color string simultaneously.\",\n        \"For each element, if it is blue, ensure it can be decreased to a value within the range [1, n].\",\n        \"For each element, if it is red, ensure it can be increased to a value within the range [1, n].\",\n        \"Check if the combined ranges of blue and red elements can cover all numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the array can be transformed into a permutation, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, determine if the array can be transformed into a permutation of numbers from 1 to n by checking the possible ranges for blue and red elements.\",\n    \"Output 'YES' if the transformation is possible, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation of numbers from 1 to n means that the array should contain each number from 1 to n exactly once, but the order does not matter.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that it is possible to make no changes at all if the array already satisfies the condition, or make as many changes as needed to achieve the permutation.\n    'from 1 to n': This indicates that the target permutation should include all integers starting from 1 up to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the second subproblem should be considered simultaneously:\n    - \"For each element, if it is blue, ensure it can be decreased to a value within the range [1, n].\"\n    - \"For each element, if it is red, ensure it can be increased to a value within the range [1, n].\"\n    These steps can be implemented in a single loop that checks each element and its color, adjusting the possible range for blue and red elements accordingly.\n\n# [edge case]\n    1. Input: 1, [1], \"B\" = YES\n       Explanation: The array already contains the permutation [1], so no steps are needed.\n    2. Input: 3, [3, 3, 3], \"RRR\" = NO\n       Explanation: All elements are red and cannot be increased to form the permutation [1, 2, 3].\n    3. Input: 2, [2, 1], \"BR\" = YES\n       Explanation: The array can be transformed into [1, 2] by decreasing the first element (blue) and increasing the second element (red).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the combined ranges of blue and red elements can cover all numbers from 1 to n should suffice.\n\nYES", "Round_0": {"code": "def can_transform_to_permutation(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a, colors = case\n        blue_elements = []\n        red_elements = []\n\n        for i in range(n):\n            if colors[i] == 'B':\n                blue_elements.append(a[i])\n            else:\n                red_elements.append(a[i])\n\n        # Sort blue elements in ascending order and red elements in descending order\n        blue_elements.sort()\n        red_elements.sort(reverse=True)\n\n        possible = True\n\n        # Check if blue elements can cover the range [1, len(blue_elements)]\n        for i in range(len(blue_elements)):\n            if blue_elements[i] < i + 1:\n                possible = False\n                break\n\n        # Check if red elements can cover the range [n - len(red_elements) + 1, n]\n        for i in range(len(red_elements)):\n            if red_elements[i] > n - i:\n                possible = False\n                break\n\n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of test cases, and for each test case, extract the array length, the array elements, and the color string.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the color string c.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"steps\": [\n        \"For each test case, initialize two lists: one for blue elements and one for red elements.\",\n        \"Separate the elements of the array into blue and red lists based on the color string.\",\n        \"Sort the blue list in ascending order and the red list in descending order.\",\n        \"Check if the smallest element in the blue list is greater than or equal to 1 and the largest element in the red list is less than or equal to n.\",\n        \"Iterate through the sorted blue list and ensure each element can be decreased to match the required permutation values from 1 to n.\",\n        \"Iterate through the sorted red list and ensure each element can be increased to match the required permutation values from 1 to n.\",\n        \"If both conditions are satisfied, the array can be transformed into a permutation; otherwise, it cannot.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the data for each test case.\",\n    \"For each test case, separate the array elements into blue and red lists based on their colors.\",\n    \"Sort the blue list in ascending order and the red list in descending order.\",\n    \"Check the feasibility of transforming the array into a permutation by ensuring the blue elements can be decreased and the red elements can be increased to match the permutation values.\",\n    \"Output 'YES' or 'NO' for each test case based on the feasibility check.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this requirement, a permutation refers to rearranging the elements of the array such that it contains all numbers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that the transformation can be achieved without any operations or with multiple operations.\n    'from 1 to n': This indicates that the target permutation should include all integers starting from 1 up to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Sort the blue list in ascending order and the red list in descending order\" and \"Check if the smallest element in the blue list is greater than or equal to 1 and the largest element in the red list is less than or equal to n\" should be considered simultaneously. This is because sorting and checking the boundary conditions are part of the same logical operation to determine if the transformation is feasible.\n\n# [edge case]\n    Case 1: n = 1, a = [1], c = 'B'\n    Expected output: YES\n    Explanation: The array already contains the permutation [1], so no operations are needed.\n\n    Case 2: n = 2, a = [2, 1], c = 'BR'\n    Expected output: YES\n    Explanation: The array can be transformed into [1, 2] by decreasing the first element (blue) and increasing the second element (red).\n\n    Case 3: n = 3, a = [3, 3, 3], c = 'RRR'\n    Expected output: NO\n    Explanation: All elements are red and cannot be decreased, and they are all greater than n, making it impossible to form a permutation of [1, 2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and checking boundary conditions should suffice to handle these cases.\n\nYES", "Round_0": {"code": "def can_transform_to_permutation(n, a, colors):\n    blue = []\n    red = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue.append(a[i])\n        else:\n            red.append(a[i])\n    \n    blue.sort()\n    red.sort(reverse=True)\n    \n    # Check blue elements\n    for i in range(len(blue)):\n        if blue[i] < i + 1:\n            return \"NO\"\n    \n    # Check red elements\n    for i in range(len(red)):\n        if red[i] > n - i:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, identify the minimum and maximum values that can be achieved by the blue and red elements respectively.\",\n        \"Check if the blue elements can be decreased to cover all numbers from 1 to n without going below 1.\",\n        \"Check if the red elements can be increased to cover all numbers from 1 to n without exceeding n.\",\n        \"Ensure that the combined operations on blue and red elements can result in a permutation of numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the array and color pattern to determine if a permutation from 1 to n is possible.\",\n    \"Implement logic to check the feasibility of transforming the array into a permutation using the allowed operations.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates that the array should contain all integers starting from 1 up to n.\n    Implementation: Ensure that the final array contains all numbers from 1 to n without any missing or duplicate numbers.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the second subproblem should be considered simultaneously:\n    - \"Check if the blue elements can be decreased to cover all numbers from 1 to n without going below 1.\"\n    - \"Check if the red elements can be increased to cover all numbers from 1 to n without exceeding n.\"\n    These checks can be implemented in a single loop that iterates through the array and evaluates the feasibility of transforming it into a permutation.\n\n# [edge case]\n    Case 1: n = 1, a = [1], colors = ['B']\n    Expected output: YES\n    Explanation: The array already contains the permutation [1].\n    \n    Case 2: n = 3, a = [3, 3, 3], colors = ['R', 'R', 'R']\n    Expected output: NO\n    Explanation: All elements are red and cannot be decreased to form the permutation [1, 2, 3].\n    \n    Case 3: n = 2, a = [1, 2], colors = ['B', 'R']\n    Expected output: YES\n    Explanation: The array already contains the permutation [1, 2].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should be able to handle these cases by checking the feasibility of transforming the array into a permutation.\n\nYES", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    # Separate blue and red elements\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort blue elements in ascending order and red elements in descending order\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n    \n    # Check if blue elements can cover numbers from 1 to n without going below 1\n    for i in range(len(blue_elements)):\n        if blue_elements[i] < i + 1:\n            return \"NO\"\n    \n    # Check if red elements can cover numbers from 1 to n without exceeding n\n    for i in range(len(red_elements)):\n        if red_elements[i] > n - i:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_form_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"Identify the range of numbers needed for a valid permutation, which is from 1 to n.\",\n        \"Separate the elements of the array into two lists based on their color: blue and red.\",\n        \"For blue elements, check if they can be decreased to fit within the permutation range.\",\n        \"For red elements, check if they can be increased to fit within the permutation range.\",\n        \"Ensure that each number from 1 to n can be represented exactly once using the available operations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, determine if the transformation is possible and output 'YES' or 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store results for each test case.\",\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, perform the following:\",\n    \"  - Separate the array elements into blue and red lists based on their color.\",\n    \"  - Check if the blue elements can be decreased to fit within the permutation range.\",\n    \"  - Check if the red elements can be increased to fit within the permutation range.\",\n    \"  - Verify if a valid permutation can be formed using the available operations.\",\n    \"  - Append 'YES' or 'NO' to the results list based on the possibility of transformation.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this requirement, a permutation refers to a rearrangement of numbers from 1 to n such that each number appears exactly once. The task is to determine if the given array can be transformed into such a permutation using the allowed operations on blue and red elements.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates the range of numbers that must be present in the array after transformation. It means the array should contain all integers starting from 1 up to n, inclusive.\n    '0 or more steps': This means that the transformation can be achieved without any operations or with multiple operations.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps related to checking blue and red elements should be considered simultaneously:\n    - \"Check if the blue elements can be decreased to fit within the permutation range.\"\n    - \"Check if the red elements can be increased to fit within the permutation range.\"\n    These checks can be done in a single iteration over the array, where each element is evaluated based on its color and adjusted accordingly.\n\n# [edge case] \n    Case 1: n = 1, a = [1], colors = \"B\" => YES\n    Explanation: The array already contains the permutation [1], so no operations are needed.\n\n    Case 2: n = 2, a = [2, 1], colors = \"RR\" => NO\n    Explanation: Both elements are red and need to be increased, but they already form a valid permutation. However, the requirement is to check if they can be transformed, and since they are already valid, no transformation is needed.\n\n    Case 3: n = 3, a = [3, 3, 3], colors = \"BBB\" => NO\n    Explanation: All elements are blue and need to be decreased, but they cannot be transformed into a permutation of [1, 2, 3] because there are not enough distinct values.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that:\n    - Blue elements can be decreased to a value within the range [1, n].\n    - Red elements can be increased to a value within the range [1, n].\n    - Each number from 1 to n is represented exactly once.\n\n    ```python\n    def can_transform_to_permutation(n,", "Round_0": {"code": "def can_transform_to_permutation(n, a, colors):\n    # Separate elements into blue and red lists\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort blue elements in descending order and red elements in ascending order\n    blue_elements.sort(reverse=True)\n    red_elements.sort()\n    \n    # Check if we can form a permutation from 1 to n\n    for i in range(1, n + 1):\n        if blue_elements and blue_elements[-1] >= i:\n            blue_elements.pop()\n        elif red_elements and red_elements[-1] <= i:\n            red_elements.pop()\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the array length, the array elements, and their corresponding colors.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the length of the array.\",\n        \"Read the array of integers a of length n.\",\n        \"Read the string of colors of length n, consisting of 'B' and 'R'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"steps\": [\n        \"For each test case, initialize two lists to track the minimum and maximum possible values for each position in the permutation.\",\n        \"Iterate over the array elements and their colors:\",\n        \"If the element is blue ('B'), ensure it can be decreased to a value between 1 and n.\",\n        \"If the element is red ('R'), ensure it can be increased to a value between 1 and n.\",\n        \"Check if the constraints allow forming a permutation of numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the array can be transformed into a permutation, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n    \"Output 'YES' if the transformation is possible, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all integers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This indicates that the transformation can involve any number of operations, including none.\n    'from 1 to n': This specifies the range of numbers that must appear in the array as a permutation.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations\" should be considered simultaneously. Specifically, the logic for checking if blue elements can be decreased and red elements can be increased should be integrated into a single loop that processes each element and its color.\n\n# [edge case] \n    Test case with all elements already forming a permutation: \n    Input: 3, [1, 2, 3], 'BRB'\n    Expected output: YES\n    Explanation: The array already forms a permutation of numbers from 1 to 3.\n\n    Test case with all elements being the same and colored blue:\n    Input: 3, [3, 3, 3], 'BBB'\n    Expected output: NO\n    Explanation: All elements are the same and cannot be decreased to form a permutation of numbers from 1 to 3.\n\n    Test case with negative numbers:\n    Input: 3, [-1, -2, -3], 'RRR'\n    Expected output: NO\n    Explanation: Negative numbers cannot be increased to form a permutation of numbers from 1 to 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that:\n    - Blue elements can be decreased to a value between 1 and n.\n    - Red elements can be increased to a value between 1 and n.\n    - The final array can form a permutation of numbers from 1 to n.\n\n    Example code snippet:\n    ```python\n    def can_form_permutation(n, a, colors):\n        min_possible = [1] * n\n        max_possible = [n] * n\n        \n        for i in range(n):\n            if colors[i] == 'B':\n                if a[i] < min_possible[i]:\n                    return False\n            elif colors[i] == '", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    blue_elements.sort()\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit in the permutation\n    for i in range(len(blue_elements)):\n        if blue_elements[i] < i + 1:\n            return False\n    \n    # Check if red elements can be increased to fit in the permutation\n    for i in range(len(red_elements)):\n        if red_elements[i] > n - len(red_elements) + i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, initialize two lists: one for blue elements and one for red elements.\",\n        \"Iterate through the array and separate elements into blue and red lists based on their color.\",\n        \"Sort the blue list in ascending order and the red list in descending order.\",\n        \"Check if the smallest element in the blue list is greater than or equal to 1 and the largest element in the red list is less than or equal to n.\",\n        \"Ensure that the number of elements in the blue list that can be decreased to fit within the range [1, n] and the number of elements in the red list that can be increased to fit within the range [1, n] are sufficient to cover all numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the array can be transformed into a permutation, output 'YES'. Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the elements into blue and red lists based on their color.\",\n    \"Sort the blue list in ascending order and the red list in descending order.\",\n    \"Check the conditions for transforming the array into a permutation of numbers from 1 to n.\",\n    \"Output 'YES' if the transformation is possible, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this requirement, a permutation of numbers from 1 to n means that the array should contain each number from 1 to n exactly once, but the order does not matter.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that the transformation can be achieved without any steps or with multiple steps.\n    'from 1 to n': This indicates that the array should contain all integers starting from 1 up to n, inclusive.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps of sorting the blue and red lists and checking the conditions for transformation should be considered simultaneously. Specifically, after sorting, the conditions for the smallest blue element and the largest red element should be checked in one logical block to determine if the transformation is possible.\n\n# [edge case] \n    1. Input: 1, [1], 'B' = YES\n       Explanation: The array already contains the permutation [1], so no steps are needed.\n    2. Input: 2, [2, 1], 'BR' = YES\n       Explanation: The array can be transformed into [1, 2] by decreasing the blue element 2 to 1.\n    3. Input: 3, [3, 3, 3], 'RRR' = NO\n       Explanation: All elements are red and greater than 3, making it impossible to form a permutation of [1, 2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already a permutation or where all elements are of one color and cannot be adjusted to fit the permutation.\n    ```python\n    if all(color == 'B' for color in colors) and min(blue_list) > 1:\n        return \"NO\"\n    if all(color == 'R' for color in colors) and max(red_list) < n:\n        return \"NO\"\n    ```\n\nYES", "Round_0": {"code": "def can_transform_to_permutation(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a, colors = case\n        blue_list = []\n        red_list = []\n        \n        for i in range(n):\n            if colors[i] == 'B':\n                blue_list.append(a[i])\n            else:\n                red_list.append(a[i])\n        \n        blue_list.sort()\n        red_list.sort(reverse=True)\n        \n        possible = True\n        \n        # Check blue elements\n        for i in range(len(blue_list)):\n            if blue_list[i] < i + 1:\n                possible = False\n                break\n        \n        # Check red elements\n        for i in range(len(red_list)):\n            if red_list[i] > n - i:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the array length, the array elements, and their corresponding colors.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine if it is possible to transform the array into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"output\": \"A boolean value indicating whether the transformation is possible for each test case.\"\n    },\n    {\n      \"description\": \"Output the result for each test case as 'YES' or 'NO' based on the boolean value obtained in the previous step.\",\n      \"output\": \"A list of strings ('YES' or 'NO') corresponding to each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read and parse the input data to extract the number of test cases and the details for each test case.\",\n      \"details\": \"Use standard input reading methods to capture the input and store it in a structured format for further processing.\"\n    },\n    {\n      \"step\": \"Iterate over each test case and perform the following operations:\",\n      \"details\": [\n        \"Initialize a list to track the required numbers from 1 to n.\",\n        \"For each element in the array, check its color and determine if it can be adjusted to fit into the required permutation.\",\n        \"For blue elements, ensure they can be decreased to fit within the range of required numbers.\",\n        \"For red elements, ensure they can be increased to fit within the range of required numbers.\",\n        \"If all elements can be adjusted to form a permutation, mark the test case as possible ('YES'), otherwise mark it as not possible ('NO').\"\n      ]\n    },\n    {\n      \"step\": \"Output the results for all test cases.\",\n      \"details\": \"Print 'YES' or 'NO' for each test case based on the feasibility determined in the previous step.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this requirement, a permutation refers to rearranging the elements of the array such that it contains all numbers from 1 to n exactly once, in any order.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that the transformation can be achieved without any operations or with multiple operations.\n    'from 1 to n': This indicates that the target permutation should include all integers starting from 1 up to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to checking and adjusting the elements based on their color should be considered simultaneously. Specifically:\n    - \"For each element in the array, check its color and determine if it can be adjusted to fit into the required permutation.\"\n    - \"For blue elements, ensure they can be decreased to fit within the range of required numbers.\"\n    - \"For red elements, ensure they can be increased to fit within the range of required numbers.\"\n    These steps can be implemented in a single loop that iterates over the array and applies the necessary checks and adjustments based on the color of each element.\n\n# [edge case]\n    Case 1: n = 1, a = [1], colors = ['B']\n    Expected output: YES\n    Explanation: The array already contains the permutation [1], so no steps are needed.\n\n    Case 2: n = 2, a = [2, 1], colors = ['R', 'B']\n    Expected output: YES\n    Explanation: The array can be transformed into [1, 2] by decreasing the second element (blue) and increasing the first element (red).\n\n    Case 3: n = 3, a = [3, 3, 3], colors = ['B', 'B', 'B']\n    Expected output: NO\n    Explanation: All elements are blue and cannot be decreased to form the permutation [1, 2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that:\n    - Blue elements can be decreased to a value within the range [1, n].\n    - Red elements can be increased to a value within the range [1, n].\n    This can be implemented by iterating over the array and checking each element's color and value against the required range.\n\n```python\ndef can_form_per", "Round_0": {"code": "def can_form_permutation(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a, colors = case\n        possible = True\n        \n        # Create a list of tuples (value, color) and sort it\n        elements = sorted(zip(a, colors))\n        \n        # Check if we can form a permutation from 1 to n\n        for i in range(n):\n            value, color = elements[i]\n            target = i + 1  # We need to form a permutation from 1 to n\n            \n            if color == 'B':\n                # Blue elements can only be decreased\n                if value < target:\n                    possible = False\n                    break\n            elif color == 'R':\n                # Red elements can only be increased\n                if value > target:\n                    possible = False\n                    break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_form_permutation(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the array length, the array elements, and their corresponding colors.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the length of the array.\",\n        \"Read the array of integers a of length n.\",\n        \"Read the string of colors of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"steps\": [\n        \"For each test case, initialize two lists: one for blue elements and one for red elements.\",\n        \"Separate the elements into blue and red lists based on their color.\",\n        \"Sort the blue list in non-decreasing order and the red list in non-increasing order.\",\n        \"Check if the smallest blue element is greater than or equal to 1 and the largest red element is less than or equal to n.\",\n        \"Iterate through the sorted blue list and ensure each element can be decreased to match the required permutation value.\",\n        \"Iterate through the sorted red list and ensure each element can be increased to match the required permutation value.\",\n        \"If both conditions are satisfied, the array can be transformed into a permutation; otherwise, it cannot.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary data for each test case.\",\n    \"For each test case, separate the elements into blue and red lists based on their color.\",\n    \"Sort the blue list in non-decreasing order and the red list in non-increasing order.\",\n    \"Check the feasibility of transforming the array into a permutation of numbers from 1 to n using the sorted lists.\",\n    \"Output 'YES' or 'NO' based on whether the transformation is possible for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation of numbers from 1 to n means that the array should contain all numbers from 1 to n exactly once, in any order.\n\n    'colored blue or red'\n    Explanation: Each element in the array is associated with a color, which determines the operation that can be applied to it (decrease for blue, increase for red).\n\n# [phrase showing quantity relationship]\n    'from 1 to n'\n    Explanation: The array should be transformed to contain all integers from 1 to n. This implies a range of values that must be present in the final array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps related to sorting and checking conditions for blue and red elements should be considered simultaneously:\n    - \"Sort the blue list in non-decreasing order and the red list in non-increasing order.\"\n    - \"Check if the smallest blue element is greater than or equal to 1 and the largest red element is less than or equal to n.\"\n    These steps are interdependent and should be implemented in a single code block to ensure the transformation feasibility.\n\n# [edge case]\n    Case 1: n = 1, a = [1], colors = ['B']\n    Expected output: YES\n    Explanation: The array already contains the permutation [1].\n\n    Case 2: n = 2, a = [2, 2], colors = ['R', 'R']\n    Expected output: NO\n    Explanation: Both elements are red and cannot be decreased to form the permutation [1, 2].\n\n    Case 3: n = 3, a = [3, 3, 3], colors = ['B', 'B', 'B']\n    Expected output: NO\n    Explanation: All elements are blue and cannot be increased to form the permutation [1, 2, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Check if the smallest blue element is greater than or equal to 1.\n    - Check if the largest red element is less than or equal to n.\n    - Ensure that the transformation is possible by iterating through sorted lists and checking feasibility.\n\nYES", "Round_0": {"code": "def can_transform_to_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n\n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n\n    blue_elements.sort()\n    red_elements.sort(reverse=True)\n\n    # Check if blue elements can be decreased to fit the permutation\n    for i in range(len(blue_elements)):\n        if blue_elements[i] < i + 1:\n            return \"NO\"\n\n    # Check if red elements can be increased to fit the permutation\n    for i in range(len(red_elements)):\n        if red_elements[i] > n - i:\n            return \"NO\"\n\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n\n        result = can_transform_to_permutation(n, a, colors)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the array length, the array elements, and the color string.\",\n      \"steps\": [\n        \"Read the integer t from the input, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors c.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n using the allowed operations.\",\n      \"steps\": [\n        \"For each test case, initialize two lists: one for blue elements and one for red elements.\",\n        \"Separate the elements of the array into blue and red lists based on the color string.\",\n        \"Sort the blue list in ascending order and the red list in descending order.\",\n        \"Check if the smallest blue element is greater than or equal to 1 and the largest red element is less than or equal to n.\",\n        \"Iterate through the sorted blue and red lists to ensure that each element can be adjusted to fit into the permutation range [1, n].\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the array can be transformed into a permutation, output 'YES'. Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, separate the array elements into blue and red lists based on their colors.\",\n    \"Sort the blue list in ascending order and the red list in descending order.\",\n    \"Check the feasibility of transforming the array into a permutation of numbers from 1 to n using the sorted lists.\",\n    \"Output 'YES' if the transformation is possible, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this requirement, a permutation refers to a rearrangement of numbers from 1 to n such that each number appears exactly once. The task is to determine if the given array can be transformed into such a permutation using the allowed operations on blue and red elements.\n\n# [phrase showing quantity relationship]\n    'from 1 to n': This indicates that the target permutation should include all integers starting from 1 up to n, inclusive.\n    '0 or more steps': This means that it is possible to achieve the permutation without making any changes, or by making a series of changes.\n\n# [degree adverb]\n    'no elements of some color at all': This implies that it is possible for the array to have elements of only one color, which affects how we can manipulate the array.\n\n# [code logic]\n    The steps of sorting the blue list in ascending order and the red list in descending order should be considered simultaneously with checking the feasibility of transforming the array into a permutation. This is because the sorted order directly affects the ability to adjust elements to fit into the permutation range [1, n].\n\n# [edge case]\n    Case 1: n = 1, a = [1], colors = \"B\" => YES\n    Explanation: The array is already a permutation of [1], and no operations are needed.\n\n    Case 2: n = 2, a = [2, 1], colors = \"RR\" => NO\n    Explanation: Both elements are red, and increasing them would exceed the range [1, 2].\n\n    Case 3: n = 3, a = [3, 3, 3], colors = \"BBB\" => NO\n    Explanation: All elements are blue and cannot be decreased to fit into the range [1, 3].\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already a permutation or where all elements are of one color and cannot be adjusted to fit the permutation range.\n    ```\n    for i in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        colors = input().strip()\n        \n        blue = []\n        red = []\n        \n        for j in range(n):\n            if colors[j] == 'B':\n                blue.append(a[j])\n            else:\n                red.append(a[j])\n        \n        blue.sort()\n        red.sort(reverse=True)\n        \n", "Round_0": {"code": "def can_transform_to_permutation(t, test_cases):\n    results = []\n    \n    for i in range(t):\n        n, a, colors = test_cases[i]\n        \n        blue = []\n        red = []\n        \n        for j in range(n):\n            if colors[j] == 'B':\n                blue.append(a[j])\n            else:\n                red.append(a[j])\n        \n        blue.sort()\n        red.sort(reverse=True)\n        \n        possible = True\n        \n        # Check blue elements\n        for idx, value in enumerate(blue):\n            if value < idx + 1:\n                possible = False\n                break\n        \n        # Check red elements\n        for idx, value in enumerate(red):\n            if value > n - idx:\n                possible = False\n                break\n        \n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, the array of integers a, and the string of colors.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"Identify the range of numbers needed for a valid permutation (1 to n).\",\n        \"Separate the elements of the array into two lists based on their color: blue and red.\",\n        \"Check if the blue elements can be decreased to fit within the range and if the red elements can be increased to fit within the range.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the array can be transformed into a permutation, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store results for each test case.\",\n    \"Iterate over each test case and perform the following:\",\n    \"Parse the input to extract n, array a, and color string.\",\n    \"Separate the elements into blue and red lists based on their color.\",\n    \"Check if the blue elements can be decreased and red elements can be increased to form a permutation of numbers from 1 to n.\",\n    \"Store 'YES' or 'NO' in the results list based on the check.\",\n    \"Print the results for all test cases.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this requirement, a permutation refers to rearranging the elements of the array such that it contains all numbers from 1 to n exactly once.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that the transformation can be achieved without any steps or with multiple steps.\n    'from 1 to n': This indicates that the target permutation should include all integers starting from 1 up to n.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps of separating elements into blue and red lists and checking if they can be adjusted to form a permutation should be considered simultaneously. This can be implemented using a single loop to iterate through the array, checking each element's color and adjusting it accordingly.\n\n# [edge case] \n    Case 1: n = 1, a = [1], colors = \"B\" = YES\n    Explanation: The array already contains the permutation [1], so no steps are needed.\n    \n    Case 2: n = 3, a = [3, 3, 3], colors = \"RRR\" = NO\n    Explanation: All elements are red and cannot be increased to form the permutation [1, 2, 3].\n    \n    Case 3: n = 2, a = [2, 1], colors = \"BR\" = YES\n    Explanation: The array can be transformed into [1, 2] by decreasing the first element (blue) and increasing the second element (red).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, we need to ensure that:\n    - Blue elements can be decreased to a value within the range [1, n].\n    - Red elements can be increased to a value within the range [1, n].\n    - Check if the final array can be a permutation of numbers from 1 to n.\n\n    Example code snippet:\n    ```python\n    for i in range(n):\n        if colors[i] == 'B' and a[i] > n:\n            a[i] = n\n        elif colors[i] == 'R' and a[i] < 1:\n            a[i] = 1\n    ```\n\nYES", "Round_0": {"code": "def can_form_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == 'B':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    blue_elements.sort()\n    red_elements.sort()\n    \n    # Check if blue elements can be decreased to fit within the range [1, n]\n    for i in range(len(blue_elements)):\n        if blue_elements[i] > n:\n            return False\n        if blue_elements[i] < i + 1:\n            return False\n    \n    # Check if red elements can be increased to fit within the range [1, n]\n    for i in range(len(red_elements)):\n        if red_elements[i] < 1:\n            return False\n        if red_elements[i] > n - len(red_elements) + i + 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        \n        if can_form_permutation(n, a, colors):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the length of the array.\",\n        \"Read the array of integers a of length n.\",\n        \"Read the string of colors of length n, consisting of 'B' and 'R'.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array can be transformed into a permutation of numbers from 1 to n.\",\n      \"steps\": [\n        \"For each test case, initialize two lists to track the possible range of values for blue and red elements.\",\n        \"Iterate over the array and the color string simultaneously.\",\n        \"For each element, if it is blue, ensure it can be decreased to a value within the range [1, n].\",\n        \"For each element, if it is red, ensure it can be increased to a value within the range [1, n].\",\n        \"Check if the combined ranges of blue and red elements can cover all numbers from 1 to n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the array can be transformed into a permutation, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, determine if the array can be transformed into a permutation of numbers from 1 to n by checking the possible ranges for blue and red elements.\",\n    \"Output 'YES' if the transformation is possible, otherwise output 'NO'.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: In the context of this problem, a permutation of numbers from 1 to n means that the array should contain each number from 1 to n exactly once, but the order does not matter.\n\n# [phrase showing quantity relationship]\n    '0 or more steps': This means that it is possible to make no changes at all if the array already satisfies the condition, or make as many changes as needed to achieve the permutation.\n    'from 1 to n': This indicates that the target permutation should include all integers starting from 1 up to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the second subproblem should be considered simultaneously:\n    - \"For each element, if it is blue, ensure it can be decreased to a value within the range [1, n].\"\n    - \"For each element, if it is red, ensure it can be increased to a value within the range [1, n].\"\n    These steps can be implemented in a single loop that checks each element and its color, adjusting the possible range for blue and red elements accordingly.\n\n# [edge case]\n    1. Input: 1, [1], \"B\" = YES\n       Explanation: The array already contains the permutation [1], so no steps are needed.\n    2. Input: 3, [3, 3, 3], \"RRR\" = NO\n       Explanation: All elements are red and cannot be increased to form the permutation [1, 2, 3].\n    3. Input: 2, [2, 1], \"BR\" = YES\n       Explanation: The array can be transformed into [1, 2] by decreasing the first element (blue) and increasing the second element (red).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the combined ranges of blue and red elements can cover all numbers from 1 to n should suffice.\n\nYES", "Round_0": {"code": "def can_transform_to_permutation(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a, colors = case\n        blue_elements = []\n        red_elements = []\n\n        for i in range(n):\n            if colors[i] == 'B':\n                blue_elements.append(a[i])\n            else:\n                red_elements.append(a[i])\n\n        # Sort blue elements in ascending order and red elements in descending order\n        blue_elements.sort()\n        red_elements.sort(reverse=True)\n\n        possible = True\n\n        # Check if blue elements can cover the range [1, len(blue_elements)]\n        for i in range(len(blue_elements)):\n            if blue_elements[i] < i + 1:\n                possible = False\n                break\n\n        # Check if red elements can cover the range [n - len(red_elements) + 1, n]\n        for i in range(len(red_elements)):\n            if red_elements[i] > n - i:\n                possible = False\n                break\n\n        if possible:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        colors = data[index]\n        index += 1\n        test_cases.append((n, a, colors))\n    \n    results = can_transform_to_permutation(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, false, false, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 359, "prompt": "You are given an array of integers a of length n; the elements of the array can be either different or the same, and each element of the array is colored either blue or red, with no unpainted elements, and one of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1, or you can select any red element and increase its value by 1. Situations in which there are no elements of some color at all are also possible. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n? In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of input data sets in the test.\n\nThe description of each set of input data consists of three lines. The first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 \u2264 a_i \u2264 10^9) \u2014 the array elements themselves.\n\nThe third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.\n\nIt is guaranteed that the sum of n over all input sets does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.\n\nYou can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\n\nExample\n\nInput\n\n\n8\n4\n1 2 5 2\nBRBR\n2\n1 1\nBB\n5\n3 1 4 2 5\nRBRRB\n5\n3 1 3 1 3\nRBRRB\n5\n5 1 5 1 5\nRBRRB\n4\n2 2 2 2\nBRBR\n2\n1 -2\nBR\n4\n-2 -1 4 0\nRRRR\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\n\nNote\n\nIn the first test case of the example, the following sequence of moves can be performed:\n\n  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; \n  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; \n  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. \n\n\n\nWe got that a is a permutation. Hence the answer is YES.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 79}
