{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n). It is a mathematical calculation that involves dividing the total sum by the number of elements in the array. Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements, which is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == total_sum / n\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == total_sum * (n - 2) / n\n        # a[i] + a[j] == total_sum * 2 / n\n        \n        if total_sum * 2 % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = total_sum * 2 // n\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "completions": ["import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # If all elements are equal, we can remove any pair\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives: a[i] + a[j] == 2 * mean\n        \n        target_sum = 2 * mean\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there exists a number such that num + other_num == target_sum\n            count += freq[target_sum - num]\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] + a[j] == target_sum:\n                    count += 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that has been seen before\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Record the occurrence of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are equal\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        element_count = defaultdict(int)\n        \n        for num in a:\n            element_count[num] += 1\n        \n        for i in range(n):\n            element_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                element_count[a[j]] -= 1\n                \n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                \n                if remaining_sum == target_sum:\n                    count += 1\n                \n                element_count[a[j]] += 1\n            element_count[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are equal\n        if all(x == a[0] for x in a):\n            # If all elements are equal, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        target_sum = (n - 2) * mean\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for value in a:\n            value_count[value] -= 1\n            needed_value = target_sum - (total_sum - value)\n            if needed_value in value_count:\n                count += value_count[needed_value]\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "from collections import defaultdict\nimport sys\n\ndef count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    freq = defaultdict(int)\n    \n    for num in a:\n        freq[num] += 1\n    \n    for num in a:\n        target = 2 * mean - num\n        if target in freq:\n            count += freq[target]\n            if target == num:\n                count -= 1\n    \n    return count // 2\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = count_valid_pairs(n, a)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the condition:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        count = {}\n        valid_pairs = 0\n        \n        for num in a:\n            if target_sum - num in count:\n                valid_pairs += count[target_sum - num]\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def find_valid_pairs(test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = mean * (n - 2)\n\n        # Dictionary to count occurrences of each element\n        count = {}\n        for num in a:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            count[a[i]] -= 1  # Remove current element from count\n            for j in range(i + 1, n):\n                count[a[j]] -= 1  # Remove second element from count\n\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n\n                # Check if the remaining sum equals the target sum\n                if remaining_sum == target_sum:\n                    valid_pairs += 1\n\n                count[a[j]] += 1  # Add back the second element to count\n\n            count[a[i]] += 1  # Add back the first element to count\n\n        results.append(valid_pairs)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == total_sum / n\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == total_sum * (n - 2) / n\n        # a[i] + a[j] == total_sum * 2 / n\n        \n        if total_sum * 2 % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = total_sum * 2 // n\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to count pairs without checking each pair explicitly.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum and mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs\",\n      \"details\": \"For each element a[i], calculate the required value that a[j] must have to maintain the mean. Use a hashmap to track occurrences of elements to efficiently find valid pairs.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by summing all elements in a set and dividing by the number of elements. In this requirement, the mean of the array before and after removing two elements must remain the same.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This indicates the calculation of the mean, which is the total sum of elements divided by the number of elements.\n    'exactly two elements': This specifies that precisely two elements must be removed from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the total sum and mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. This can be done by calculating the mean and then using a hashmap to efficiently find pairs that satisfy the condition in one pass through the array.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 3\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    \n    Input: 3\n           4\n           1 2 3 4\n    Output: 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n    \n    Input: 3\n           5\n           5 5 5 5 5\n    Output: 10\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should use a hashmap to store the frequency of each element and calculate the required value for each pair to maintain the mean. This will allow us to count valid pairs efficiently without explicitly checking each pair.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == total_sum / n\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == total_sum * (n - 2) / n\n        # a[i] + a[j] == total_sum * 2 / n\n        \n        if total_sum * 2 % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = total_sum * 2 // n\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to reduce the number of checks needed.\",\n        \"Implement efficient data structures to store and retrieve necessary information quickly.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Iterate over all pairs of elements (i, j) in the array:\",\n    \"Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"Check if the mean of the remaining elements equals the initial mean.\",\n    \"Count and store the number of valid pairs.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by dividing the sum of its elements by the number of elements. It represents the average value of the array.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'sum divided by n': This is the formula for calculating the mean, where 'sum' is the total of all elements and 'n' is the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be implemented simultaneously for efficiency. Specifically, the calculation of the sum of remaining elements and checking if the mean remains the same should be done in one loop to avoid redundant calculations.\n\n# [edge case]\n    Test case with all elements equal: [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, maintaining the mean.\n    \n    Test case with no valid pairs: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to maintain the mean.\n    \n    Test case with minimum elements: [1, 1, 1] = 0\n    Explanation: With only three elements, removing any two will not maintain the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    Implement a check for arrays where all elements are equal, as this simplifies the pair counting.\n    ```python\n    if all(x == array[0] for x in array):\n        return comb(n, 2)  # Combination formula to count pairs\n    ```\n\nYES", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # If all elements are equal, we can remove any pair\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives: a[i] + a[j] == 2 * mean\n        \n        target_sum = 2 * mean\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there exists a number such that num + other_num == target_sum\n            count += freq[target_sum - num]\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # If all elements are equal, we can remove any pair\n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying gives: a[i] + a[j] == 2 * mean\n        \n        target_sum = 2 * mean\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            # Check if there exists a number such that num + other_num == target_sum\n            count += freq[target_sum - num]\n            freq[num] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the complexity of finding valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Input Parsing\",\n      \"action\": \"Read the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Initial Mean Calculation\",\n      \"action\": \"For each test case, calculate the sum of the array and determine the initial mean k.\"\n    },\n    {\n      \"step\": \"Pair Identification\",\n      \"action\": \"Iterate over all pairs of elements in the array and check if their removal keeps the mean unchanged.\"\n    },\n    {\n      \"step\": \"Optimization\",\n      \"action\": \"Implement efficient algorithms to reduce the number of checks needed for pair identification, possibly using hash maps or prefix sums.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"action\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain the same even after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count the number of valid pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Initial Mean Calculation\" and \"Pair Identification\" should be considered simultaneously. \n    Explanation: While iterating over pairs, we can simultaneously check if removing them maintains the mean, which can be optimized using mathematical properties.\n\n# [edge case]\n    1. Input: 3\n       Array: [1, 1, 1]\n       Expected Output: 0\n       Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n       \n    2. Input: 4\n       Array: [0, 0, 0, 0]\n       Expected Output: 6\n       Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n       \n    3. Input: 5\n       Array: [1, 2, 3, 4, 5]\n       Expected Output: 0\n       Explanation: No pair of elements can be removed to maintain the mean of the remaining elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Explanation: Specifically, we need to handle cases where the array length is minimal (n=3) or where all elements are the same.\n    ```python\n    if n == 3:\n        print(0)\n        continue\n    if all(x == a[0] for x in a):\n        print(n * (n - 1) // 2)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        count = 0\n        seen = {}\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in seen:\n                count += seen[complement]\n            \n            if num in seen:\n                seen[num] += 1\n            else:\n                seen[num] = 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"details\": \"Compute the sum of the array and divide by the number of elements to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal maintains the mean.\",\n      \"details\": \"For each pair of elements (i, j), check if removing them keeps the mean of the remaining elements equal to the initial mean k.\"\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to reduce the complexity of finding valid pairs.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases and for each test case, read the number of elements and the array itself.\"\n    },\n    {\n      \"step\": \"Calculate initial mean\",\n      \"details\": \"For each test case, compute the sum of the array and calculate the mean k.\"\n    },\n    {\n      \"step\": \"Find valid pairs\",\n      \"details\": \"Iterate over all pairs of elements (i, j) and check if their removal keeps the mean unchanged. Use efficient methods to reduce the number of checks.\"\n    },\n    {\n      \"step\": \"Output results\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. The task is to find pairs of elements whose removal keeps this mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate initial mean\" and \"Find valid pairs\" should be considered simultaneously. After calculating the mean, the logic to find valid pairs can be integrated into a single loop or function to efficiently check each pair.\n\n# [edge case] \n    Test case with all elements equal: If all elements are the same, any pair can be removed without changing the mean.\n    Example: [8, 8, 8, 8] = 6 pairs\n    Explanation: Any two elements can be removed, and the mean remains unchanged.\n\n    Test case with minimum elements: If n = 3, only one pair can be removed.\n    Example: [1, 1, 1] = 1 pair\n    Explanation: Only one pair exists, and removing them keeps the mean unchanged.\n\n    Test case with distinct elements: If all elements are distinct, it might be impossible to find a valid pair.\n    Example: [1, 2, 3] = 0 pairs\n    Explanation: Removing any pair changes the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For arrays with all equal elements, a simple combinatorial calculation can be used to count pairs.\n    - For arrays with distinct elements, a check can be added to quickly return 0 if no valid pairs exist.\n\nYES", "Round_0": {"code": "def find_valid_pairs(t, test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] + a[j] == target_sum:\n                    count += 1\n        \n        results.append(count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = find_valid_pairs(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the mathematical mean k of the original array a.\",\n      \"steps\": [\n        \"Sum all elements of the array a.\",\n        \"Divide the sum by the number of elements n to get the mean k.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (a[i], a[j]) where i < j, calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals k.\",\n        \"Count the number of such pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the solution to handle constraints efficiently.\",\n      \"steps\": [\n        \"Use a hashmap or dictionary to store and quickly access the frequency of elements or required values.\",\n        \"Avoid recalculating sums and means for every pair by using mathematical transformations or properties.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  Read the integer n and the array a of n elements.\",\n    \"  Calculate the mean k of the array a.\",\n    \"  Initialize a counter to zero for counting valid pairs.\",\n    \"  Use a hashmap to store the frequency of elements or required values.\",\n    \"  Iterate over each element a[i] and for each subsequent element a[j] (i < j), check if removing them keeps the mean unchanged.\",\n    \"  Update the counter for each valid pair found.\",\n    \"  Output the counter value for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is used to determine if removing two elements from the array keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all possible pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan related to calculating the mean and checking pairs should be considered simultaneously. Specifically, the steps:\n    - \"Calculate the mean k of the array a.\"\n    - \"Iterate over each element a[i] and for each subsequent element a[j] (i < j), check if removing them keeps the mean unchanged.\"\n    These steps can be optimized by calculating the mean once and using it to check each pair without recalculating the mean for each pair.\n\n# [edge case]\n    1. Input: 3, [1, 1, 1] = 0\n       Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n    2. Input: 4, [0, 0, 0, 0] = 6\n       Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    3. Input: 5, [1, 2, 3, 4, 5] = 0\n       Explanation: No two elements can be removed to maintain the mean because the elements are distinct and not symmetrically distributed around the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array size is minimal (n=3) or where all elements are the same.\n    ```python\n    if n == 3:\n        print(0)\n        continue\n    if all(x == a[0] for x in a):\n        print(n * (n - 1) // 2)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying, we get:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        # Count valid pairs\n        valid_pairs = 0\n        \n        for num in a:\n            # Check if there is a complement that has been seen before\n            complement = target_sum - num\n            if complement in count:\n                valid_pairs += count[complement]\n            \n            # Record the occurrence of the current number\n            count[num] += 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for valid pairs.\",\n        \"Implement efficient data structures or algorithms to reduce the complexity of finding pairs.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"  Read the number of elements and the array.\",\n    \"  Calculate the initial mean of the array.\",\n    \"  Initialize a counter for valid pairs.\",\n    \"  Iterate over all pairs of elements (i, j) with i < j:\",\n    \"    Calculate the sum of the remaining elements after removing a[i] and a[j].\",\n    \"    Check if the mean of the remaining elements equals the initial mean.\",\n    \"    If valid, increment the counter.\",\n    \"  Output the counter for the current test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This indicates the calculation of the mean, where the sum of elements is divided by the number of elements.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the sum of the remaining elements after removing a[i] and a[j]\" and \"Check if the mean of the remaining elements equals the initial mean\" should be implemented simultaneously. This can be done by calculating the sum of the remaining elements and immediately checking the condition in one code block.\n\n# [edge case]\n    Input: 3\n    3\n    1 1 1\n    Explanation: All elements are equal, so any pair can be removed without changing the mean. Expected output is 3.\n    \n    Input: 4\n    1 2 3 4\n    Explanation: No pair can be removed to keep the mean unchanged. Expected output is 0.\n    \n    Input: 5\n    5 5 5 5 5\n    Explanation: All elements are equal, so any pair can be removed without changing the mean. Expected output is 10.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should check if all elements are equal initially, which allows for a quick determination of the number of valid pairs without further calculations.\n    ```python\n    if all(x == a[0] for x in a):\n        return (n * (n - 1)) // 2\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are equal\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        element_count = defaultdict(int)\n        \n        for num in a:\n            element_count[num] += 1\n        \n        for i in range(n):\n            element_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                element_count[a[j]] -= 1\n                \n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                \n                if remaining_sum == target_sum:\n                    count += 1\n                \n                element_count[a[j]] += 1\n            element_count[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are equal\n        if all(x == a[0] for x in a):\n            results.append((n * (n - 1)) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        count = 0\n        target_sum = mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of elements\n        from collections import defaultdict\n        element_count = defaultdict(int)\n        \n        for num in a:\n            element_count[num] += 1\n        \n        for i in range(n):\n            element_count[a[i]] -= 1\n            for j in range(i + 1, n):\n                element_count[a[j]] -= 1\n                \n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n                \n                if remaining_sum == target_sum:\n                    count += 1\n                \n                element_count[a[j]] += 1\n            element_count[a[i]] += 1\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Implement efficient data structures or algorithms to reduce the complexity of finding valid pairs.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and the arrays for each test case.\"\n    },\n    {\n      \"step\": \"Process each test case.\",\n      \"details\": [\n        \"Calculate the initial mean of the array.\",\n        \"Iterate over all pairs of elements to check if their removal keeps the mean unchanged.\",\n        \"Count the number of valid pairs for each test case.\"\n      ]\n    },\n    {\n      \"step\": \"Output results.\",\n      \"details\": \"Print the number of valid pairs for each test case.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array while maintaining the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This phrase describes the calculation of the mean, where the sum of elements is divided by the number of elements (n).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the subproblem \"Identify pairs of elements whose removal keeps the mean unchanged\" should be considered simultaneously. Specifically, for each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j], and check if the mean of the remaining elements equals the initial mean. This can be implemented in a single loop iterating over pairs.\n\n# [edge case] \n    Input: 3\n           3\n           1 1 1\n    Output: 3\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3\n           5\n           1 1 1 1 1\n    Output: 10\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 1\n           3\n           1 2 3\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should check if all elements are equal, in which case any pair can be removed, and the number of pairs is calculated using combination formula C(n, 2) = n*(n-1)/2.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Check if all elements are equal\n        if all(x == a[0] for x in a):\n            # If all elements are equal, any pair can be removed\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # Calculate the number of valid pairs\n        target_sum = (n - 2) * mean\n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for value in a:\n            value_count[value] -= 1\n            needed_value = target_sum - (total_sum - value)\n            if needed_value in value_count:\n                count += value_count[needed_value]\n        \n        results.append(count // 2)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing a[i] and a[j].\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Implement efficient search or counting techniques to handle constraints.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Iterate over all pairs of elements to check if their removal keeps the mean unchanged.\",\n    \"Count and store the number of valid pairs for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count all unique pairs of indices where the first index is less than the second.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps to calculate the initial mean and to check pairs for mean equality should be considered simultaneously. Specifically, the calculation of the mean and the checking of pairs can be optimized by using mathematical properties to avoid recalculating the mean for each pair.\n\n# [edge case] \n    Test case with all elements equal, e.g., [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains unchanged.\n    \n    Test case with no possible pairs, e.g., [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged because the elements are too distinct.\n    \n    Test case with minimum elements, e.g., [1, 1, 1] = 1\n    Explanation: Only one pair can be removed, and the mean remains unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    - Use a dictionary to count occurrences of each element.\n    - Use mathematical properties to determine valid pairs without iterating over all possible pairs.\n    - Example code snippet:\n    ```python\n    from collections import defaultdict\n\n    def count_valid_pairs(n, a):\n        total_sum = sum(a)\n        mean = total_sum / n\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in a:\n            freq[num] += 1\n        \n        for num in a:\n            target = 2 * mean - num\n            if target in freq:\n                count += freq[target]\n                if target == num:\n                    count -= 1\n        \n        return count // 2\n\n    # Read input and process each test case\n    ```\n\nYES", "Round_0": {"code": "from collections import defaultdict\nimport sys\n\ndef count_valid_pairs(n, a):\n    total_sum = sum(a)\n    mean = total_sum / n\n    count = 0\n    freq = defaultdict(int)\n    \n    for num in a:\n        freq[num] += 1\n    \n    for num in a:\n        target = 2 * mean - num\n        if target in freq:\n            count += freq[target]\n            if target == num:\n                count -= 1\n    \n    return count // 2\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = count_valid_pairs(n, a)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing these two.\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for unchanged mean.\",\n        \"Implement efficient search or counting techniques to handle constraints.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements (i, j) in the array:\",\n    \"Calculate the sum of the remaining elements after removing the pair.\",\n    \"Check if the mean of the remaining elements equals the initial mean.\",\n    \"If valid, increment the counter.\",\n    \"Output the counter for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This means that we need to remove precisely two elements from the array.\n    'equal to k': This means that the mean of the remaining elements should be the same as the initial mean of the array.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the sum of the remaining elements after removing the pair\" and \"Check if the mean of the remaining elements equals the initial mean\" should be implemented simultaneously. This can be done by calculating the sum of the remaining elements and directly checking if the mean condition holds in one code block.\n\n# [edge case] \n    Test case with all elements equal: [4, 4, 4, 4] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains unchanged.\n\n    Test case with only three elements: [1, 2, 3] = 0\n    Explanation: Removing any two elements will leave only one element, which cannot have a mean equal to the original mean.\n\n    Test case with large numbers: [10^9, 10^9, 10^9, 10^9] = 6\n    Explanation: Similar to the first edge case, any pair can be removed since all elements are equal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array has only three elements or all elements are equal.\n    ```python\n    if n == 3:\n        print(0)\n        continue\n    if all(x == a[0] for x in a):\n        print(n * (n - 1) // 2)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the condition:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        count = {}\n        valid_pairs = 0\n        \n        for num in a:\n            if target_sum - num in count:\n                valid_pairs += count[target_sum - num]\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 97)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if n == 3:\n            results.append(0)\n            continue\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        if all(x == a[0] for x in a):\n            results.append(n * (n - 1) // 2)\n            continue\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean\n        # Simplifying the condition:\n        # total_sum - a[i] - a[j] == mean * (n - 2)\n        # a[i] + a[j] == total_sum - mean * (n - 2)\n        \n        target_sum = total_sum - mean * (n - 2)\n        \n        # Use a dictionary to count occurrences of each element\n        count = {}\n        valid_pairs = 0\n        \n        for num in a:\n            if target_sum - num in count:\n                valid_pairs += count[target_sum - num]\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        results.append(valid_pairs)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean of the array.\",\n      \"steps\": [\n        \"Sum all elements of the array.\",\n        \"Divide the sum by the number of elements to get the mean.\"\n      ]\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"steps\": [\n        \"For each pair of elements (i, j), calculate the sum of the remaining elements after removing these two.\",\n        \"Check if the mean of the remaining elements equals the initial mean.\"\n      ]\n    },\n    {\n      \"description\": \"Optimize the search for valid pairs.\",\n      \"steps\": [\n        \"Use mathematical properties to simplify the condition for mean equality.\",\n        \"Implement efficient search techniques to handle constraints.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following:\",\n    \"Read the number of elements and the array.\",\n    \"Calculate the initial mean of the array.\",\n    \"Initialize a counter for valid pairs.\",\n    \"Iterate over all pairs of elements in the array.\",\n    \"For each pair, check if their removal keeps the mean unchanged using optimized conditions.\",\n    \"Increment the counter for each valid pair found.\",\n    \"Output the counter for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by dividing the sum of all elements by the number of elements. The requirement is to find pairs of elements whose removal does not change this mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': This indicates that we need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': This specifies that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps for calculating the initial mean and checking pairs should be implemented simultaneously for efficiency. Specifically, the calculation of the mean and the checking of pairs can be optimized using mathematical properties to avoid recalculating the mean for each pair.\n\n# [edge case]\n    Case 1: All elements are the same, e.g., [8, 8, 8, 8] = 6\n    Explanation: Any pair of elements can be removed since all elements are equal, and the mean remains unchanged.\n    \n    Case 2: Array with distinct elements, e.g., [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged because the elements are distinct and removal affects the mean.\n    \n    Case 3: Array with possible valid pairs, e.g., [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions 1 and 3 or positions 4 and 5 keeps the mean unchanged.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should include:\n    - A check for arrays where all elements are the same, allowing any pair to be removed.\n    - Efficient calculation using mathematical properties to avoid recalculating the mean for each pair.\n\nYES", "Round_0": {"code": "def find_valid_pairs(test_cases):\n    results = []\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = mean * (n - 2)\n\n        # Dictionary to count occurrences of each element\n        count = {}\n        for num in a:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            count[a[i]] -= 1  # Remove current element from count\n            for j in range(i + 1, n):\n                count[a[j]] -= 1  # Remove second element from count\n\n                # Calculate the sum of the remaining elements\n                remaining_sum = total_sum - a[i] - a[j]\n\n                # Check if the remaining sum equals the target sum\n                if remaining_sum == target_sum:\n                    valid_pairs += 1\n\n                count[a[j]] += 1  # Add back the second element to count\n\n            count[a[i]] += 1  # Add back the first element to count\n\n        results.append(valid_pairs)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    results = find_valid_pairs(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the initial mean k of the array a.\",\n      \"details\": \"Sum all elements of the array a and divide by n to get the mean k.\"\n    },\n    {\n      \"description\": \"Identify pairs of elements whose removal keeps the mean unchanged.\",\n      \"details\": \"For each pair of elements (a[i], a[j]), check if removing them keeps the mean of the remaining elements equal to k.\"\n    },\n    {\n      \"description\": \"Efficiently count valid pairs.\",\n      \"details\": \"Use mathematical properties and efficient data structures to count pairs without checking each pair explicitly.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data\",\n      \"details\": \"Parse the number of test cases t and for each test case, read n and the array a.\"\n    },\n    {\n      \"step\": \"Calculate the total sum and mean k for each test case\",\n      \"details\": \"Compute the sum of the array and divide by n to get the mean k.\"\n    },\n    {\n      \"step\": \"Iterate over each element to find valid pairs\",\n      \"details\": \"For each element a[i], calculate the required value that a[j] must have to maintain the mean. Use a hashmap to track occurrences of elements to efficiently find valid pairs.\"\n    },\n    {\n      \"step\": \"Output the result for each test case\",\n      \"details\": \"For each test case, output the number of valid pairs found.\"\n    }\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean, often referred to as the average, is calculated by summing all elements in a set and dividing by the number of elements. In this requirement, the mean of the array before and after removing two elements must remain the same.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This indicates the calculation of the mean, which is the total sum of elements divided by the number of elements.\n    'exactly two elements': This specifies that precisely two elements must be removed from the array.\n    'number of pairs of positions [i, j] (i < j)': This indicates that we need to count pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps \"Calculate the total sum and mean k for each test case\" and \"Iterate over each element to find valid pairs\" should be considered simultaneously. This can be done by calculating the mean and then using a hashmap to efficiently find pairs that satisfy the condition in one pass through the array.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 3\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n    \n    Input: 3\n           4\n           1 2 3 4\n    Output: 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n    \n    Input: 3\n           5\n           5 5 5 5 5\n    Output: 10\n    Explanation: All elements are the same, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n    The code should use a hashmap to store the frequency of each element and calculate the required value for each pair to maintain the mean. This will allow us to count valid pairs efficiently without explicitly checking each pair.\n\nYES", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        mean_k = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == mean_k\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == mean_k * (n - 2)\n        # a[i] + a[j] == total_sum - mean_k * (n - 2)\n        \n        target_sum = total_sum - mean_k * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        total_sum = sum(a)\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) == total_sum / n\n        # Simplifying the equation:\n        # total_sum - a[i] - a[j] == total_sum * (n - 2) / n\n        # a[i] + a[j] == total_sum * 2 / n\n        \n        if total_sum * 2 % n != 0:\n            results.append(0)\n            continue\n        \n        target_sum = total_sum * 2 // n\n        \n        # Use a hashmap to count occurrences of each element\n        from collections import defaultdict\n        count = defaultdict(int)\n        \n        for num in a:\n            count[num] += 1\n        \n        pair_count = 0\n        \n        for num in a:\n            count[num] -= 1  # Remove current element from count\n            complement = target_sum - num\n            if complement in count:\n                pair_count += count[complement]\n        \n        results.append(pair_count // 2)  # Each pair is counted twice\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}], "scores": [], "pass_results": [false, true, false, false, true, false, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 84, "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.e. sum divided by n), and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Ensure that the constraints are efficiently handled to optimize the solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 71}
