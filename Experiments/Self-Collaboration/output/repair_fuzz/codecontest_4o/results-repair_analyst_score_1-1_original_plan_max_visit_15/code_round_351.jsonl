{"name": "1582_A. Luntik and Concerts", "description": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "tags": ["math"], "difficulty": 7, "id": 1582, "sample_io": [{"input": "4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}], "test_list": [{"input": "4\n1 1 1\n2 1 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 5\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 1 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 4\n2 2 2\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n4 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 8\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 7\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 5\n1 2 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n2 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 3 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 1 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n3 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 4 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 3\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 0\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 1\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 5\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 1 1\n4 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 2 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 5 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 6\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 6\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 3\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 3\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n2 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 2\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 0\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 4 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 6\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 3 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n4 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n4 2 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 0\n5 2 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n12 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n4 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 0 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 4 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 10\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n2 4 5\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n11 4 9\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n9 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 6\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 1 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n1 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n3 1 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 4 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 0\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 4 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 1\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n2 3 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n4 1 2\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 7 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n6 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 0\n4 3 2\n3 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n3 4 5\n1 1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n2 2 0\n0 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 8\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 13\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 1\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 1\n0 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 6 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n4 3 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 2 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 5 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 10\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 2 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 1 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n3 2 1\n1 4 0\n1 1 0\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 3\n2 2 1\n3 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 4\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 8 5\n2 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n2 1 1\n3 3 1\n6 4 3\n1 1 3\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 2\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}], "task_id": "codecontest/28", "repair_prompt": ["Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts, and he wants that every song should be included to exactly one concert to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert to make the absolute difference of durations of the concerts as small as possible, and the duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this problem\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_duration + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "completions": ["def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        elif a + b + c == 1:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach\n        # We want to find a subset of songs that is as close as possible to half of the total duration\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible duration close to half_duration\n        best_duration = 0\n        for j in range(half_duration + 1):\n            if dp[j]:\n                best_duration = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_duration)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is odd, the minimal difference is 1\n        # If total duration is even, the minimal difference is 0\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 0 and b == 0:\n            results.append(c * 3)\n            continue\n        if a == 0 and c == 0:\n            results.append(b * 2)\n            continue\n        if b == 0 and c == 0:\n            results.append(a * 1)\n            continue\n        \n        # Dynamic programming approach\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        max_possible_duration = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_duration = i\n        \n        minimal_diff = abs(total_duration - 2 * max_possible_duration)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a + 2 * b + 3 * c\n        \n        # The minimal possible difference can be determined by checking the parity of the total duration\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to target\n        for i in range(target, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach\n        # We will use a set to keep track of possible sums we can achieve\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal possible difference\n        min_diff = float('inf')\n        for s in possible_sums:\n            diff = abs(total_duration - 2 * s)\n            if diff < min_diff:\n                min_diff = diff\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(total_duration)\n            continue\n        \n        # Calculate minimal possible difference\n        # We need to find a subset of songs that sum up to half of the total_duration\n        # or as close as possible to it.\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total_duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible durations of one concert\n        possible_durations = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the minimal possible difference\n        min_difference = float('inf')\n        for duration in possible_durations:\n            difference = abs(total_duration - 2 * duration)\n            min_difference = min(min_difference, difference)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this problem\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_duration + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, attempt to distribute the songs into two groups such that the absolute difference between the total durations of the two groups is minimized.\",\n        \"Use a dynamic programming approach or a greedy algorithm to find the optimal distribution of songs.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in minutes between the durations of the two concerts.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in durations between two concerts using an appropriate algorithm.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The absolute difference between two values is the non-negative difference between them, calculated as |x - y|. In this requirement, it refers to the difference in total durations of the two concerts.\n\n    'minimal possible difference'\n    Explanation: This means finding the smallest possible value of the absolute difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its respective duration (1, 2, or 3).\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates the need to find the smallest possible value. In code, this often involves optimization techniques such as dynamic programming or greedy algorithms to minimize the difference.\n\n# [code logic]\n    The steps in the plan related to parsing input and calculating total duration can be implemented sequentially. However, the step to determine the minimal possible difference in durations between two concerts should be implemented using a single algorithmic approach, such as dynamic programming or a greedy algorithm, to ensure the solution is efficient and correct.\n\n# [edge case]\n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it must be assigned to one concert.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: If there are no songs, the difference is 0 as there are no durations to compare.\n\n    Edge Case 3: (1, 1, 1) = 0\n    Explanation: As given in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when there are no songs or when the distribution is straightforward.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this problem\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_duration + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this problem\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_duration + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total duration as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, use a method to distribute songs into two groups such that the absolute difference between the sum of durations of the two groups is minimized.\",\n        \"Consider using a dynamic programming approach or a greedy algorithm to achieve the optimal distribution.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the calculated minimal possible difference.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"Implement an algorithm to distribute songs into two concerts to minimize the duration difference.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The absolute difference between two numbers is the non-negative difference between them, calculated as |x - y|. In this requirement, it refers to the difference in total durations of the two concerts.\n\n    'minimal possible difference'\n    Explanation: This means finding the smallest possible value of the absolute difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its respective duration (1, 2, or 3).\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates the need to find the smallest possible value. In code, this typically involves optimization techniques such as dynamic programming or greedy algorithms to minimize the difference.\n\n# [code logic]\n    The steps in the plan are sequential and do not require simultaneous implementation. However, the step involving the distribution of songs into two groups to minimize the difference is complex and may involve a combination of dynamic programming or greedy strategies.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1, as it can only be placed in one concert.\n\n    0 0 0 = 0\n    Explanation: With no songs, the difference is 0, as both concerts have a duration of 0.\n\n    1 1 1 = 0\n    Explanation: As given in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when the number of songs is very small or zero.\n    Example code for handling edge cases:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return min(a, b * 2, c * 3)\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # This is a variation of the subset sum problem\n        max_possible_sum = total_duration // 2\n        dp = [False] * (max_possible_sum + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_sum, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_sum, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_sum, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_sum + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the list of song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference between the durations of two concerts. This involves finding a subset of songs whose total duration is as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference of durations'\n    This refers to the non-negative difference between the total durations of two concerts, which is calculated as the absolute value of the difference between the sums of song durations in each concert.\n\n# [phrase showing quantity relationship]\n    'minimal possible difference'\n    This means finding the smallest possible value for the absolute difference between the durations of the two concerts.\n\n# [degree adverb] \n    'minimal'\n    This indicates that the goal is to achieve the smallest possible difference between the durations of the two concerts.\n\n# [code logic]\n    The step of calculating the total duration and the step of using dynamic programming to find the minimal difference should be considered simultaneously. The dynamic programming approach should be implemented in a way that it directly uses the total duration calculated.\n\n# [edge case] \n    Test case: 1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it can only be placed in one concert.\n    \n    Test case: 0 0 0 = 0\n    Explanation: With no songs, the difference is 0 as both concerts have a duration of 0.\n    \n    Test case: 1 1 1 = 0\n    Explanation: As explained in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n        if a == 0 and b == 0 and c == 0:\n            print(0)\n        elif a + b + c == 1:\n            print(1)\n        else:\n            # (dynamic programming logic to find minimal difference)\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        elif a + b + c == 1:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach\n        # We want to find a subset of songs that is as close as possible to half of the total duration\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible duration close to half_duration\n        best_duration = 0\n        for j in range(half_duration + 1):\n            if dp[j]:\n                best_duration = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_duration)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, use a method to partition the songs into two groups such that the absolute difference between their durations is minimized.\",\n        \"Consider using dynamic programming or a greedy approach to find the optimal partition.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the calculated minimal possible difference.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"Implement an algorithm to partition the songs into two concerts with minimal duration difference.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference of durations'\n    Explanation: This refers to the absolute value of the difference in total durations of songs assigned to two different concerts. The goal is to minimize this difference.\n\n    'partition the songs'\n    Explanation: This means dividing the songs into two groups (concerts) such that each song is included in exactly one concert.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its respective duration (1, 2, or 3).\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates the smallest possible value. In this context, it refers to the smallest possible difference in durations between the two concerts. In code, this can be implemented by iterating through possible partitions and keeping track of the smallest difference found.\n\n# [code logic]\n    The steps for calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, while calculating the total duration, the logic for partitioning the songs should be integrated to minimize the difference.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it must be assigned to one concert, leaving the other concert with a duration of 0.\n\n    0 0 0 = 0\n    Explanation: With no songs, the difference is 0 as both concerts have a duration of 0.\n\n    1 1 1 = 0\n    Explanation: As given in the example, one possible partition is one one-minute song and one two-minute song in one concert, and one three-minute song in the other, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the number of songs is very small or zero.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n    elif a + b + c == 1:\n        print(min(a, b, c))\n    else:\n        # Implement the logic for partitioning the songs\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If total duration is odd, the minimal difference is 1\n        # If total duration is even, the minimal difference is 0\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference in durations between two concerts. This involves finding a subset of songs that can be assigned to one concert such that the absolute difference between the total durations of the two concerts is minimized.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate groups of songs that need to be formed.\n    'absolute difference': means the non-negative difference between the total durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute songs', 'two-minute songs', 'three-minute songs': these phrases indicate the duration of each type of song.\n    Implementation: Use the values a, b, and c to calculate the total duration of songs for each concert.\n\n# [degree adverb]\n    'minimal': means the smallest possible value.\n    Implementation: Use optimization techniques, such as dynamic programming, to minimize the difference between the two concerts.\n\n# [code logic]\n    The step of calculating the total duration and determining the minimal possible difference should be considered simultaneously. This involves using the total duration to find the optimal distribution of songs between the two concerts.\n\n# [edge case]\n    Test case: 1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it can only be placed in one concert.\n    \n    Test case: 0 0 0 = 0\n    Explanation: With no songs, the difference is 0 as both concerts have a duration of 0.\n    \n    Test case: 1 1 0 = 1\n    Explanation: With one one-minute song and one two-minute song, the minimal difference is 1 by placing the one-minute song in one concert and the two-minute song in the other.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Code for handling edge cases:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a == 0 and b == 0:\n        return c * 3\n    if a == 0 and c == 0:\n        return b * 2\n    if b == 0 and c == 0:\n        return a * 1\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 0 and b == 0:\n            results.append(c * 3)\n            continue\n        if a == 0 and c == 0:\n            results.append(b * 2)\n            continue\n        if b == 0 and c == 0:\n            results.append(a * 1)\n            continue\n        \n        # Dynamic programming approach\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        max_possible_duration = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_duration = i\n        \n        minimal_diff = abs(total_duration - 2 * max_possible_duration)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 0 and b == 0:\n            results.append(c * 3)\n            continue\n        if a == 0 and c == 0:\n            results.append(b * 2)\n            continue\n        if b == 0 and c == 0:\n            results.append(a * 1)\n            continue\n        \n        # Dynamic programming approach\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        for _ in range(b):\n            for j in range(half_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        for _ in range(c):\n            for j in range(half_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        max_possible_duration = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_duration = i\n        \n        minimal_diff = abs(total_duration - 2 * max_possible_duration)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) representing the number of one-minute, two-minute, and three-minute songs for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, use a dynamic programming approach to find the minimal possible difference in durations between two concerts. This involves trying to partition the songs into two groups such that the absolute difference in their total durations is minimized.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The absolute difference between two values is the non-negative difference between them, calculated as |value1 - value2|. In this context, it refers to the difference in durations between two concerts.\n\n    'concert duration'\n    Explanation: The duration of a concert is the sum of the durations of all songs included in that concert.\n\n# [phrase showing quantity relationship]\n    'minimal possible difference'\n    Explanation: This means finding the smallest absolute difference between the durations of the two concerts. In code, this can be implemented by iterating through possible partitions of songs and calculating the difference in durations, aiming to minimize it.\n\n# [degree adverb]\n    'minimal'\n    Explanation: Refers to the smallest possible value. In this context, it means the smallest possible difference in concert durations. In code, this can be implemented by keeping track of the smallest difference found during the partitioning process.\n\n# [code logic]\n    The steps of calculating the total duration and determining the minimal possible difference should be considered simultaneously. The dynamic programming approach involves partitioning the songs into two groups while calculating the total duration and minimizing the difference in one code block.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With one one-minute song and no other songs, the minimal difference is 1, as the song can only be placed in one concert.\n\n    0 0 0 = 0\n    Explanation: With no songs, the difference is 0, as both concerts have a duration of 0.\n\n    1 1 1 = 0\n    Explanation: As explained in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return max(a, b, c)\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a + 2 * b + 3 * c\n        # We need to find the closest sum to total_duration // 2\n        # Using a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal difference\n        half_duration = total_duration // 2\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a + 2 * b + 3 * c\n        \n        # The minimal possible difference can be determined by checking the parity of the total duration\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each duration for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read three integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, attempt to distribute the songs into two groups such that the absolute difference between the total durations of the two groups is minimized.\",\n        \"Use a dynamic programming approach or a greedy algorithm to find the optimal distribution of songs.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in minutes between the durations of the two concerts.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in durations between two concerts using an appropriate algorithm.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The requirement is to minimize the absolute difference in the total duration of songs between two concerts. This means we need to find a way to distribute the songs such that the difference in total time between the two concerts is as small as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In the code, this can be implemented by multiplying the number of each type of song by its respective duration to get the total duration.\n\n# [degree adverb]\n    'minimal possible'\n    Explanation: This indicates that the goal is to achieve the smallest possible difference in concert durations. In code, this can be implemented by using an algorithm that tries to balance the total durations of the two concerts as closely as possible.\n\n# [code logic]\n    The steps in the plan related to parsing input and calculating total duration can be implemented sequentially. However, the step to determine the minimal possible difference in durations between two concerts should be implemented using a dynamic programming approach or a greedy algorithm, which may involve simultaneous consideration of multiple possibilities to find the optimal solution.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With one one-minute song and no other songs, the minimal difference is 1, as one concert will have the song and the other will have none.\n    \n    0 0 0 = 0\n    Explanation: With no songs, the difference is 0, as both concerts have a duration of 0.\n    \n    1 1 1 = 0\n    Explanation: As given in the example, one possible distribution is one one-minute song and one two-minute song in one concert, and one three-minute song in the other, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should include checks for cases where there are no songs or only one type of song, and handle them appropriately to ensure the minimal difference is calculated correctly.\n    \n    Example code snippet:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a == 0 and b == 0:\n        return c * 3\n    if a == 0 and c == 0:\n        return b * 2\n    if b == ", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to target\n        for i in range(target, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest sum to total_duration // 2\n        target = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to target\n        dp = [False] * (target + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest sum to target\n        for i in range(target, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * closest_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, attempt to distribute the songs into two groups such that the absolute difference between the total durations of the two groups is minimized.\",\n        \"Use a dynamic programming approach or a greedy algorithm to find the optimal distribution of songs.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in minutes between the durations of the two concerts.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in durations between two concerts using an appropriate algorithm.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimal possible difference'\n    Explanation: The requirement is to distribute the songs into two concerts such that the absolute difference in their total durations is minimized. This involves partitioning the songs in a way that balances the total time as closely as possible between the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. The total duration of songs is calculated by multiplying the number of each type of song by its respective duration (1, 2, or 3 minutes).\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates that the goal is to achieve the smallest possible difference in the total durations of the two concerts. In code, this can be implemented by iterating through possible distributions and keeping track of the smallest difference found.\n\n# [code logic]\n    The steps for parsing input and calculating total duration can be implemented sequentially. However, the step to determine the minimal possible difference in durations between two concerts may require a more complex algorithm, such as dynamic programming or a greedy approach, which should be implemented in a single code block to ensure the logic is cohesive.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1, as it must be placed in one concert, leaving the other empty.\n    \n    0 0 0 = 0\n    Explanation: With no songs, the difference is 0, as both concerts have a duration of 0.\n    \n    1 1 1 = 0\n    Explanation: As given in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the number of songs is very small or zero.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        print(0)\n        continue\n    if a + b + c == 1:\n        print(1)\n        continue\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach\n        # We will use a set to keep track of possible sums we can achieve\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the minimal possible difference\n        min_diff = float('inf')\n        for s in possible_sums:\n            diff = abs(total_duration - 2 * s)\n            if diff < min_diff:\n                min_diff = diff\n        \n        results.append(min_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the minimal possible difference in durations between the two concerts.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs by summing up the durations: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a dynamic programming approach or a greedy strategy to partition the songs into two groups such that the absolute difference in their total durations is minimized.\",\n    \"Output the minimal possible difference in durations for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts'\n    Explanation: In the requirement, concerts refer to two separate groups where songs are distributed. The goal is to balance the total duration of songs in each concert.\n\n    'absolute difference'\n    Explanation: This refers to the non-negative difference between the total durations of the two concerts. The task is to minimize this value.\n\n# [phrase showing quantity relationship]\n    'as small as possible': This means the goal is to minimize the absolute difference between the durations of the two concerts.\n\n# [degree adverb] \n    'minimal': This indicates that the solution should aim for the smallest possible difference in durations between the two concerts.\n\n# [code logic]\n    The steps for calculating the total duration and determining the minimal possible difference should be considered simultaneously. Specifically, after calculating the total duration, the logic for partitioning the songs should immediately follow to ensure the difference is minimized.\n\n# [edge case] \n    1 0 0 = 1\n    Explanation: With only one one-minute song, the best we can do is assign it to one concert, resulting in a difference of 1 minute.\n    \n    0 0 0 = 0\n    Explanation: With no songs, the difference is naturally 0 as both concerts have a duration of 0.\n    \n    1 1 1 = 0\n    Explanation: As given in the example, one possible distribution is one one-minute song and one two-minute song in one concert, and the three-minute song in the other, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the number of songs is extremely low or zero.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return a * 1 + b * 2 + c * 3\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge cases\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(total_duration)\n            continue\n        \n        # Calculate minimal possible difference\n        # We need to find a subset of songs that sum up to half of the total_duration\n        # or as close as possible to it.\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total_duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Sum the durations of all one-minute, two-minute, and three-minute songs.\"\n    },\n    {\n      \"description\": \"Determine the possible ways to distribute songs into two concerts.\",\n      \"details\": \"Explore combinations of songs that can be split into two groups.\"\n    },\n    {\n      \"description\": \"Calculate the duration of each concert for each distribution.\",\n      \"details\": \"Sum the durations of songs in each concert for every possible distribution.\"\n    },\n    {\n      \"description\": \"Find the minimal possible difference between the durations of the two concerts.\",\n      \"details\": \"Compute the absolute difference between the durations of the two concerts and find the minimum value.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  - Read the number of one-minute, two-minute, and three-minute songs.\",\n    \"  - Calculate the total duration of all songs.\",\n    \"  - Generate all possible distributions of songs into two concerts.\",\n    \"  - For each distribution, calculate the duration of each concert.\",\n    \"  - Compute the absolute difference between the durations of the two concerts.\",\n    \"  - Track the minimal difference found across all distributions.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The absolute difference between two values is the non-negative difference between them, calculated as |value1 - value2|. In this context, it refers to the difference in durations between the two concerts.\n\n    'minimal possible difference'\n    Explanation: This means finding the smallest absolute difference between the durations of the two concerts after distributing all songs.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, they can be represented as constants or variables that denote the duration of each song type (1, 2, and 3 minutes respectively).\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates the need to find the smallest possible value. In code, this can be implemented by iterating through possible distributions and keeping track of the smallest difference found.\n\n# [code logic]\n    The steps \"Generate all possible distributions of songs into two concerts\" and \"For each distribution, calculate the duration of each concert\" should be considered simultaneously. This can be implemented using a recursive function or dynamic programming to explore combinations and calculate durations in one code block.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, the minimal difference is 1, as it can only be placed in one concert.\n    \n    0 0 0 = 0\n    Explanation: With no songs, the difference is 0, as both concerts have a duration of 0.\n    \n    1 1 1 = 0\n    Explanation: As shown in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    Specifically, handle cases where there are no songs or only one type of song:\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    if a + b + c == 1:\n        return max(1, 2, 3)  # Depending on which song type is present\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible durations of one concert\n        possible_durations = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the minimal possible difference\n        min_difference = float('inf')\n        for duration in possible_durations:\n            difference = abs(total_duration - 2 * duration)\n            min_difference = min(min_difference, difference)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        \n        # Initialize a set to store possible durations of one concert\n        possible_durations = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the minimal possible difference\n        min_difference = float('inf')\n        for duration in possible_durations:\n            difference = abs(total_duration - 2 * duration)\n            min_difference = min(min_difference, difference)\n        \n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of songs of each type for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers a, b, c from the subsequent lines, representing the number of one-minute, two-minute, and three-minute songs respectively.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"steps\": [\n        \"For each test case, compute the total duration of all songs as total_duration = a * 1 + b * 2 + c * 3.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts.\",\n      \"steps\": [\n        \"For each test case, attempt to distribute the songs into two groups such that the absolute difference between the total durations of the two groups is minimized.\",\n        \"Use a dynamic programming approach or a greedy algorithm to find the optimal distribution of songs.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimal possible difference for each test case.\",\n      \"steps\": [\n        \"For each test case, print the minimal possible difference in minutes between the durations of the two concerts.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs.\",\n    \"For each test case, determine the minimal possible difference in durations between two concerts using an appropriate algorithm.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The absolute difference between two values is the non-negative difference between them, calculated as |x - y|. In this requirement, it refers to the difference in total durations of the two concerts.\n\n    'minimal possible difference'\n    Explanation: This means finding the smallest possible value of the absolute difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, this can be represented by multiplying the count of each type of song by its respective duration (1, 2, or 3).\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates the need to find the smallest possible value. In code, this often involves optimization techniques such as dynamic programming or greedy algorithms to minimize the difference.\n\n# [code logic]\n    The steps in the plan related to parsing input and calculating total duration can be implemented sequentially. However, the step to determine the minimal possible difference in durations between two concerts should be implemented using a single algorithmic approach, such as dynamic programming or a greedy algorithm, to ensure the solution is efficient and correct.\n\n# [edge case]\n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, the minimal difference is 1 since it must be assigned to one concert.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: If there are no songs, the difference is 0 as there are no durations to compare.\n\n    Edge Case 3: (1, 1, 1) = 0\n    Explanation: As given in the example, the songs can be distributed to achieve a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases, especially when there are no songs or when the distribution is straightforward.\n    ```python\n    if a == 0 and b == 0 and c == 0:\n        return 0\n    ```\n\nYES", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this problem\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_duration + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # We need to find the closest sum to total_duration // 2\n        # Using a dynamic programming approach to solve this problem\n        max_possible_duration = total_duration // 2\n        dp = [False] * (max_possible_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(max_possible_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(max_possible_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(max_possible_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the best possible sum close to total_duration // 2\n        best_sum = 0\n        for j in range(max_possible_duration + 1):\n            if dp[j]:\n                best_sum = j\n        \n        # Calculate the minimal possible difference\n        min_difference = abs(total_duration - 2 * best_sum)\n        results.append(min_difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 351, "prompt": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "mutate_method": "condense_two2one", "save_node": true, "parent_index": 189}
