{"name": "1586_H. Omkar and Tours", "description": "Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.\n\nEvery city has an enjoyment value e. Each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled. (In other words, they pay max t over all the roads on which they traveled.) If a vehicle traverses no roads, they pay 0 toll.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. (Keep in mind that a tour group with v vehicles can travel only on roads with capacity \u2265 v.) Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "tags": ["data structures", "dsu", "sortings", "trees"], "difficulty": 14, "id": 1586, "sample_io": [{"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 8\n2 8\n2 3\n2 1\n1 0\n"]}], "test_list": [{"input": "2 6\n1 2\n1 2 2 1\n1 1\n2 1\n3 1\n1 2\n2 2\n3 2\n", "output": ["2 1\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 3\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n3 0\n"]}, {"input": "8 64\n1 1 1 1 1 1 1 1\n6 1 31 60\n1 3 3 8\n1 2 4 27\n4 1 41 27\n7 1 6 39\n1 5 28 46\n1 8 8 55\n55 6\n24 1\n28 1\n46 4\n15 6\n52 4\n58 4\n19 1\n55 8\n59 8\n18 2\n18 7\n26 1\n41 3\n48 4\n41 7\n46 6\n42 8\n44 4\n56 4\n13 1\n46 6\n1 2\n34 5\n47 6\n18 5\n35 8\n26 6\n57 7\n35 2\n27 3\n26 2\n39 2\n11 5\n23 1\n1 2\n54 3\n47 5\n48 2\n13 8\n40 6\n7 6\n38 2\n35 5\n6 6\n19 3\n10 6\n64 1\n2 3\n31 2\n1 6\n59 7\n47 3\n38 7\n18 4\n6 6\n27 7\n13 5\n63 8\n10 8\n11 4\n30 6\n2 2\n34 5\n", "output": ["1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 9\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 5\n1 2 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 1\n1 2\n2 2\n3 2\n", "output": ["2 0\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 2\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 13\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 13\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n2 1\n1 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n5 1\n5 1\n"]}, {"input": "2 2\n4 0\n1 2 4 3\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 0 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n3 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 0 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n6 1\n6 1\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 1 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n3 1\n4 1\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 2 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n10 1\n7 2\n", "output": ["7 0\n1 0\n"]}, {"input": "5 5\n1 0 9 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n9 1\n9 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 4\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n5 1\n"]}, {"input": "2 2\n8 1\n1 2 4 3\n10 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["9 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 4\n10 1\n4 2\n", "output": ["7 0\n7 4\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n6 1\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 2 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n2 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 2\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "2 2\n11 3\n1 2 4 9\n10 1\n5 2\n", "output": ["11 0\n3 0\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n3 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "2 1\n4 0\n1 2 4 9\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 3\n2 2 3 3 0\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n0 0\n3 2\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 2\n5 1\n"]}, {"input": "5 5\n1 2 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n8 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 6\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 7\n3 0\n5 3\n"]}, {"input": "5 2\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n"]}, {"input": "2 2\n5 2\n1 2 4 9\n10 1\n5 2\n", "output": ["5 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 13\n1 3 2 8\n2 4 3 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 13\n3 0\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 7\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 1 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n3 1\n3 1\n4 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n4 1 0 5 6\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["6 11\n6 0\n5 4\n"]}, {"input": "2 2\n8 2\n1 2 4 4\n10 1\n5 2\n", "output": ["8 0\n2 0\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 2\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 2\n4 1\n6 2\n"]}, {"input": "5 2\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 0 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 2\n", "output": ["3 1\n3 0\n4 7\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 2\n4 5\n4 2\n", "output": ["4 7\n3 0\n4 7\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 2 1\n2 5 1 1\n4 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 0\n2 1\n3 2\n5 1\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 4\n1 3 1 6\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 6\n3 0\n5 3\n"]}, {"input": "2 2\n8 2\n1 2 8 4\n10 1\n5 2\n", "output": ["8 0\n8 4\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 1 2\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 1\n6 2\n"]}, {"input": "5 2\n9 2 0 5 2\n1 2 4 7\n1 3 1 3\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 3\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 9\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 9\n3 0\n3 2\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n2 0\n5 1\n"]}, {"input": "2 1\n8 2\n1 2 8 4\n10 1\n5 2\n", "output": ["8 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n1 3\n7 5\n6 3\n", "output": ["3 9\n3 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 2\n"]}, {"input": "5 3\n4 4 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n4 0\n5 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n3 0\n0 0\n"]}, {"input": "5 3\n10 0 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["10 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 3\n4 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 3\n"]}, {"input": "5 3\n4 9 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["9 11\n4 0\n5 1\n"]}, {"input": "5 3\n4 9 0 5 4\n1 2 4 14\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["9 14\n4 0\n5 1\n"]}, {"input": "2 2\n7 3\n1 2 4 9\n10 2\n5 2\n", "output": ["3 0\n3 0\n"]}, {"input": "8 64\n1 1 1 1 1 1 1 1\n6 1 31 60\n1 3 3 8\n1 2 4 27\n4 1 41 27\n7 1 6 39\n1 5 28 46\n1 8 8 55\n55 6\n24 1\n28 1\n46 4\n15 6\n52 4\n58 4\n19 1\n55 8\n59 8\n18 2\n18 7\n26 1\n41 3\n48 4\n41 7\n46 6\n42 8\n44 4\n56 4\n13 1\n46 6\n1 2\n34 5\n47 6\n18 5\n35 8\n26 6\n57 7\n35 2\n27 3\n26 2\n39 2\n11 5\n23 1\n1 2\n54 3\n47 5\n48 2\n13 8\n40 6\n7 6\n38 2\n35 5\n6 6\n19 3\n10 6\n64 1\n2 3\n41 2\n1 6\n59 7\n47 3\n38 7\n18 4\n6 6\n27 7\n13 5\n63 8\n10 8\n11 4\n30 6\n2 2\n34 5\n", "output": ["1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 2 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 8\n2 8\n2 3\n2 1\n1 0\n"]}, {"input": "5 5\n2 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 0 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["0 0\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 5\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n5 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 9\n10 2\n5 2\n", "output": ["2 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 0\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 14\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 14\n3 0\n5 3\n"]}, {"input": "5 3\n7 4 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["7 11\n2 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n13 2\n", "output": ["5 11\n2 0\n2 0\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 2\n1 2\n2 2\n2 2\n", "output": ["2 0\n2 1\n2 0\n2 0\n2 0\n2 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 1\n1 4\n7 5\n8 2\n", "output": ["5 0\n3 0\n5 4\n"]}, {"input": "5 3\n4 1 0 5 4\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n4 0\n5 4\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 4\n", "output": ["5 11\n2 0\n5 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 2\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n5 2\n"]}, {"input": "2 2\n8 1\n1 2 4 3\n10 2\n2 2\n", "output": ["1 0\n8 3\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 1\n", "output": ["4 8\n3 0\n4 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 4\n2 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n4 1\n"]}, {"input": "5 5\n1 1 5 2 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n2 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 5 1\n2 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 0\n6 1\n"]}, {"input": "2 2\n9 3\n1 2 4 9\n10 1\n5 2\n", "output": ["9 0\n3 0\n"]}, {"input": "2 2\n5 4\n1 2 4 9\n10 1\n5 2\n", "output": ["5 0\n4 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n3 4 15 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 3\n3 0\n2 0\n"]}, {"input": "5 3\n2 2 0 5 1\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 8\n1 0\n5 4\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n4 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n1 1\n6 1\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 2\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 0\n5 1\n"]}, {"input": "5 3\n2 2 0 3 5\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n5 0\n2 7\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 9\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n1 5\n6 2\n", "output": ["3 9\n3 2\n3 2\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 6\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 6\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 3\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n10 1\n7 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 3\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 1\n1 2\n2 2\n2 2\n", "output": ["2 0\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 2\n1 2 4 5\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "2 2\n8 0\n1 2 4 3\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 4\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n8 1\n1 2 4 0\n10 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n5 3\n"]}, {"input": "2 2\n8 1\n1 2 4 0\n9 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n4 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n3 1\n2 2\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n10 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n2 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 2 3 1 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 15 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 2\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 1\n1 2 4 5\n10 1\n5 2\n", "output": ["7 0\n1 0\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 2 1\n4 1\n5 1\n6 1\n8 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n12 1\n7 2\n", "output": ["7 0\n1 0\n"]}, {"input": "2 2\n8 0\n1 2 4 4\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n14 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 4 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n2 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n5 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n10 1\n5 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "2 1\n4 0\n1 2 4 13\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 5\n1 2 6 -1 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n8 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 12 3\n2 5 1 1\n1 3\n7 5\n8 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 2\n", "output": ["2 1\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 7\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 4 1\n4 1\n5 1\n6 1\n8 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 11\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 4 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 0\n1 3\n7 5\n6 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 1 1\n2 5 1 1\n4 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 0\n2 1\n3 2\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n1 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n2 2\n", "output": ["4 0\n"]}, {"input": "5 3\n5 0 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n2 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 2\n4 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 2\n"]}, {"input": "5 3\n4 5 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n4 0\n5 1\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n16 1\n2 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 6 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n16 1\n0 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 6 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n1 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "5 3\n2 2 3 3 3\n1 4 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n5 1\n5 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 4\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 6\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n2 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 2\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 3 1\n2 5 0 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n3 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 5\n1 0 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n2 1\n1 0\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n5 1\n7 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 0 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 3 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 0 11\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 6 0 5\n1 2 4 0\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n6 1\n6 1\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n10 2\n7 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 5\n1 0 9 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n6 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n9 1\n9 1\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 6 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}], "task_id": "codecontest/43", "repair_prompt": ["Omkar is hosting tours of his home country, Omkarland! There are n cities in Omkarland, and unusually, there are exactly n-1 bidirectional roads connecting the cities to each other, ensuring that any city is accessible from any other city via the road network.\n\nEvery city has an enjoyment value e, and each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: vehicles pay only the highest toll of any single road on which they traveled if they traverse multiple roads on a single journey, and they pay 0 toll if they traverse no roads.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay, so for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Omkar is hosting tours of his home country, Omkarland! There are n cities in Omkarland, and unusually, there are exactly n-1 bidirectional roads connecting the cities to each other. This network of roads ensures that any city is accessible from any other city via the road network.\n\nEvery city has an enjoyment value e, and each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: vehicles pay only the highest toll of any single road on which they traveled if they traverse multiple roads on a single journey, and they pay 0 toll if they traverse no roads.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. So for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Omkar is hosting tours of his home country, Omkarland! There are n cities in Omkarland, and unusually, there are exactly n-1 bidirectional roads connecting the cities to each other, ensuring that any city is accessible from any other city via the road network. Every city has an enjoyment value e, and each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t, whereas the toll system in Omkarland has an interesting quirk: vehicles pay only the highest toll of any single road on which they traveled if they traverse multiple roads on a single journey, and they pay 0 toll if they traverse no roads. Omkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay, so for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.) In the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, toll))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        tour_groups.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, tour_groups\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, num_vehicles):\n    max_enjoyment = enjoyment_values[start_city]\n    max_toll = 0\n    \n    visited = [False] * len(enjoyment_values)\n    queue = deque([(start_city, 0)])\n    visited[start_city] = True\n    \n    while queue:\n        current_city, current_toll = queue.popleft()\n        \n        for neighbor, capacity, toll in graph[current_city]:\n            if not visited[neighbor] and num_vehicles <= capacity:\n                visited[neighbor] = True\n                queue.append((neighbor, max(current_toll, toll)))\n                max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                max_toll = max(max_toll, current_toll, toll)\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, tour_groups = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for num_vehicles, start_city in tour_groups:\n        max_enjoyment, max_toll = bfs_max_enjoy\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            visited[current] = True\n            \n            if enjoyment_values[current] > max_enjoyment:\n                max_enjoyment = enjoyment_values[current]\n                max_toll = current_max_toll\n            elif enjoyment_values[current] == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    def bfs_max_enjoyment_and_toll(start, vehicles):\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= vehicles:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for vehicles, start in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(start, vehicles)\n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            city, current_max_toll = queue.popleft()\n            \n            if visited[city]:\n                continue\n            \n            visited[city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment_values[city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    roads = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        roads[a].append((b, c, t))\n        roads[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in roads[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for vehicles, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            \n            if visited[current_city]:\n                continue\n            \n            visited[current_city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and vehicles <= capacity:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            city, current_max_toll = queue.popleft()\n            \n            if visited[city]:\n                continue\n            visited[city] = True\n            \n            max_enjoyment = max(max_enjoyment, enjoyment_values[city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            if visited[current]:\n                continue\n            visited[current] = True\n            \n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, toll))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get the number of cities (n) and number of groups (q).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from a starting city for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\",\n        \"Filter reachable cities based on road capacity constraints.\",\n        \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for the journey from the starting city to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, find the shortest path from the starting city to the city with maximum enjoyment value.\",\n        \"Determine the highest toll encountered on this path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information.\",\n    \"Construct a graph representation of the cities and roads.\",\n    \"For each tour group, determine the maximum enjoyment value reachable from the starting city.\",\n    \"Calculate the maximum toll per vehicle for the journey to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads can be traversed in both directions, meaning if there's a road from city A to city B, you can travel from A to B and from B to A.\n\n    'enjoyment value'\n    Explanation: Each city has a value representing how enjoyable it is for the tour group. The goal is to reach the city with the highest enjoyment value.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at the same time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road. The group pays the highest toll of any road they travel on during their journey.\n\n    'shortest path'\n    Explanation: The path between two cities that minimizes the number of roads traveled, not necessarily the path with the least toll.\n\n# [phrase showing quantity relationship]\n    'n-1 bidirectional roads': Indicates that the number of roads is one less than the number of cities, forming a tree structure.\n    \n    'maximum number of vehicles': Refers to the capacity constraint on each road.\n    \n    'highest toll': The maximum toll value encountered on the path from the starting city to the destination city.\n\n# [degree adverb]\n    'maximum enjoyment value': The highest enjoyment value among the cities that can be reached from the starting city.\n    \n    'maximum toll': The highest toll encountered on the path from the starting city to the city with the maximum enjoyment value.\n\n# [code logic]\n    The steps for determining the maximum enjoyment value and calculating the maximum toll per vehicle should be considered simultaneously for each tour group. This involves traversing the graph to find reachable cities and calculating the tolls in one traversal.\n\n# [edge case]\n    1. If all roads have a capacity less than the number of vehicles in the tour group, the group cannot travel, and the toll is 0.\n       Example: For a tour group of size 10 starting at city 1, if all roads have a capacity of 5, the output should be the enjoyment value of city 1 and toll 0.\n    \n    2. If the starting city is the only city with the maximum enjoyment value, the toll is 0.\n       Example: For a tour group starting at city 1 with the highest enjoyment value, the output should be the enjoyment value of city 1 and toll 0.\n    \n    3. If multiple cities have the same maximum enjoyment value, the toll should be", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, toll))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 149)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, toll))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"For each tour group, determine the set of cities that can be reached from the starting city, considering the capacity constraints of the roads.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each tour group, find the city with the maximum enjoyment value that is reachable from the starting city.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each tour group, calculate the maximum toll that would be incurred on the shortest path to any city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each tour group, perform a breadth-first search (BFS) or depth-first search (DFS) from the starting city to find all reachable cities, considering road capacity constraints.\",\n    \"Identify the city with the maximum enjoyment value among the reachable cities for each tour group.\",\n    \"For each reachable city with the maximum enjoyment value, determine the shortest path from the starting city and calculate the maximum toll incurred.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads': Roads that allow travel in both directions between cities.\n    'enjoyment value': A numerical value representing how enjoyable a city is.\n    'capacity': Maximum number of vehicles a road can support.\n    'toll': Cost associated with traveling on a road.\n    'shortest path': The path between two cities with the least number of roads or lowest cumulative toll.\n\n# [phrase showing quantity relationship]\n    'maximum number of vehicles': Refers to the road capacity, which limits the number of vehicles that can travel on a road.\n    'highest toll': The maximum toll among all roads traveled in a journey.\n    'maximum enjoyment value': The highest enjoyment value among reachable cities.\n\n# [degree adverb]\n    'maximum': Refers to the highest possible enjoyment value or toll.\n    'highest': Refers to the largest toll among roads traveled.\n\n# [code logic]\n    The steps \"Determine Maximum Enjoyment\" and \"Calculate Maximum Toll\" should be considered simultaneously for each tour group. This can be implemented by first identifying the reachable cities and then calculating both the maximum enjoyment and the maximum toll in one traversal of the graph.\n\n# [edge case]\n    Case 1: All cities have the same enjoyment value.\n    Input: 3 1\n           5 5 5\n           1 2 3 4\n           2 3 3 4\n           1 1\n    Expected Output: 5 0\n    Explanation: All cities have the same enjoyment value, and the starting city is the only reachable city due to capacity constraints.\n\n    Case 2: Road capacity is less than the number of vehicles.\n    Input: 3 1\n           1 2 3\n           1 2 1 5\n           2 3 1 5\n           3 1\n    Expected Output: 3 0\n    Explanation: The tour group cannot move due to road capacity constraints, so they stay in the starting city.\n\n    Case 3: Multiple cities with the same maximum enjoyment value.\n    Input: 4 1\n           3 3 3 2\n           1 2 2 3\n           2 3 2 3\n           3 4 2 3\n           2 1\n    Expected Output: 3 3\n    Explanation: Multiple cities have the same maximum enjoyment value", "Round_0": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        tour_groups.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, tour_groups\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, num_vehicles):\n    max_enjoyment = enjoyment_values[start_city]\n    max_toll = 0\n    \n    visited = [False] * len(enjoyment_values)\n    queue = deque([(start_city, 0)])\n    visited[start_city] = True\n    \n    while queue:\n        current_city, current_toll = queue.popleft()\n        \n        for neighbor, capacity, toll in graph[current_city]:\n            if not visited[neighbor] and num_vehicles <= capacity:\n                visited[neighbor] = True\n                queue.append((neighbor, max(current_toll, toll)))\n                max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                max_toll = max(max_toll, current_toll, toll)\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, tour_groups = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for num_vehicles, start_city in tour_groups:\n        max_enjoyment, max_toll = bfs_max_enjoy", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 146)"}, "Round_1": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        tour_groups.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, tour_groups\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, num_vehicles):\n    max_enjoyment = enjoyment_values[start_city]\n    max_toll = 0\n    \n    visited = [False] * len(enjoyment_values)\n    queue = deque([(start_city, 0)])\n    visited[start_city] = True\n    \n    while queue:\n        current_city, current_toll = queue.popleft()\n        \n        for neighbor, capacity, toll in graph[current_city]:\n            if not visited[neighbor] and num_vehicles <= capacity:\n                visited[neighbor] = True\n                queue.append((neighbor, max(current_toll, toll)))\n                max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                max_toll = max(max_toll, current_toll, toll)\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, tour_groups = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for num_vehicles, start_city in tour_groups:\n        max_enjoyment, max_toll = bfs_max_enjoy"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from a starting city for each tour group.\",\n      \"steps\": [\n        \"Perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\",\n        \"Filter reachable cities based on road capacity constraints.\",\n        \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each reachable city with maximum enjoyment value, find the shortest path from the starting city.\",\n        \"Determine the highest toll encountered on the shortest path.\",\n        \"Ensure the number of vehicles does not exceed road capacities on the path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group information.\",\n    \"Construct a graph using adjacency lists to represent cities and roads.\",\n    \"For each tour group, perform graph traversal to find reachable cities and determine the maximum enjoyment value.\",\n    \"Calculate the maximum toll per vehicle for the shortest path to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads that allow travel in both directions between two cities.\n\n    'enjoyment value'\n    Explanation: A numerical value representing how enjoyable a city is for the tour group.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at the same time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road, where the group pays only the highest toll encountered on their journey.\n\n    'shortest path'\n    Explanation: The path between two cities that involves the least number of roads or the least total toll.\n\n# [phrase showing quantity relationship]\n    'n-1 bidirectional roads': Indicates that the number of roads is one less than the number of cities, forming a tree structure.\n    \n    'maximum number of vehicles': Refers to the capacity constraint on each road.\n    \n    'highest toll': The maximum toll value encountered on a path, which determines the reimbursement cost.\n\n# [degree adverb]\n    'maximum enjoyment value': The highest enjoyment value among the cities that can be reached from the starting city.\n    \n    'maximum toll': The highest toll encountered on the shortest path to a city with the maximum enjoyment value.\n\n# [code logic]\n    The steps in the plan related to graph traversal and toll calculation should be considered simultaneously:\n    - \"Perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\"\n    - \"Filter reachable cities based on road capacity constraints.\"\n    - \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n    - \"For each reachable city with maximum enjoyment value, find the shortest path from the starting city.\"\n    - \"Determine the highest toll encountered on the shortest path.\"\n    These steps can be integrated into a single traversal process that checks both enjoyment values and tolls.\n\n# [edge case]\n    Edge Case 1: All cities have the same enjoyment value.\n    Input: \n    ```\n    3 1\n    5 5 5\n    1 2 10 3\n    2 3 10 2\n    1 1\n    ```\n    Expected Output: `5 3`\n    Explanation: All cities have the same enjoyment value, so the maximum toll is the highest toll on any path.\n\n    Edge Case 2: The starting city is isolated due to capacity constraints.\n    Input:\n    ```\n    3 1\n   ", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            visited[current] = True\n            \n            if enjoyment_values[current] > max_enjoyment:\n                max_enjoyment = enjoyment_values[current]\n                max_toll = current_max_toll\n            elif enjoyment_values[current] == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 146)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            visited[current] = True\n            \n            if enjoyment_values[current] > max_enjoyment:\n                max_enjoyment = enjoyment_values[current]\n                max_toll = current_max_toll\n            elif enjoyment_values[current] == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values, roads, and tour group details.\",\n      \"output\": \"Structured data containing cities, roads, and queries.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists.\",\n      \"output\": \"Graph data structure representing the cities and roads.\"\n    },\n    {\n      \"description\": \"For each query, determine the set of cities that can be reached from the starting city given the vehicle capacity constraints.\",\n      \"output\": \"Reachable cities for each query.\"\n    },\n    {\n      \"description\": \"For each query, find the city with the maximum enjoyment value among the reachable cities.\",\n      \"output\": \"Maximum enjoyment value for each query.\"\n    },\n    {\n      \"description\": \"For each query, calculate the maximum toll that needs to be reimbursed per vehicle for the journey to the city with the maximum enjoyment value.\",\n      \"output\": \"Maximum toll per vehicle for each query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, roads, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each query, perform a breadth-first search (BFS) or depth-first search (DFS) from the starting city to determine all reachable cities considering the vehicle capacity constraints.\",\n    \"For each query, iterate over the reachable cities to find the city with the maximum enjoyment value.\",\n    \"For each query, determine the maximum toll encountered on the shortest path to the city with the maximum enjoyment value.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads that allow travel in both directions between two cities.\n\n    'enjoyment value'\n    Explanation: A numerical value representing how enjoyable a city is for the tour group.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can be on a road at any given time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road, where the group pays only the highest toll encountered on their journey.\n\n    'shortest path'\n    Explanation: The path between two cities that involves the fewest roads or the least total distance.\n\n# [phrase showing quantity relationship]\n    'n-1 bidirectional roads'\n    Explanation: There are exactly one less road than the number of cities, ensuring a connected graph.\n    Implementation: This implies a tree structure, which can be represented using adjacency lists.\n\n    'maximum enjoyment value'\n    Explanation: The highest enjoyment value among the cities that can be reached.\n    Implementation: Use a max function to find the city with the highest enjoyment value.\n\n    'maximum toll'\n    Explanation: The highest toll encountered on the path from the starting city to the city with the maximum enjoyment value.\n    Implementation: Track the maximum toll encountered during the path traversal.\n\n# [degree adverb]\n    'maximum'\n    Explanation: Refers to the highest value in a set, such as the highest enjoyment value or the highest toll.\n    Implementation: Use max() function to determine the maximum value.\n\n# [code logic]\n    The steps for determining reachable cities and calculating maximum enjoyment and toll should be implemented simultaneously for each query.\n    Implementation: Use a BFS or DFS to explore reachable cities and simultaneously track the maximum enjoyment and toll.\n\n# [edge case]\n    1. All cities have the same enjoyment value.\n       Explanation: The output should be the enjoyment value and the maximum toll on any path.\n       Example: If all cities have an enjoyment value of 5, the output should reflect the maximum toll encountered.\n\n    2. The starting city is isolated due to capacity constraints.\n       Explanation: The group cannot move, so the enjoyment value is that of the starting city, and the toll is 0.\n       Example: If a group starts at a city with no outgoing roads due to capacity, the output should be the city's enjoyment value and 0 toll.\n\n    3. The tour group size exceeds all road capacities.\n       Explanation: The group cannot travel, so the enjoyment value is that of the", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get the number of cities (n) and number of groups (q).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from each starting city for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a graph traversal (e.g., BFS or DFS) starting from the given city.\",\n        \"Track the maximum enjoyment value encountered during the traversal.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, find the shortest path to each city with maximum enjoyment value using a graph traversal.\",\n        \"Determine the maximum toll encountered on the shortest path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group information.\",\n    \"Construct a graph using adjacency lists to represent cities and roads.\",\n    \"For each tour group, perform a graph traversal to find the maximum enjoyment value reachable from the starting city.\",\n    \"For each tour group, calculate the maximum toll per vehicle for the shortest path to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads that allow travel in both directions between two cities.\n\n    'enjoyment value'\n    Explanation: A numerical value representing how enjoyable a city is for the tour group.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at the same time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road, but only the highest toll on a journey is paid.\n\n    'shortest path'\n    Explanation: The path between two cities that involves the least number of roads or the least total toll.\n\n# [phrase showing quantity relationship]\n    'n-1 bidirectional roads': Indicates that the number of roads is exactly one less than the number of cities, forming a tree structure.\n    \n    'maximum number of vehicles': Refers to the capacity of a road, which limits the number of vehicles that can travel on it simultaneously.\n\n# [degree adverb]\n    'maximum enjoyment value': Refers to the highest enjoyment value among the cities that can be reached from the starting city.\n    \n    'highest toll': Refers to the largest toll value encountered on any road during a journey.\n\n# [code logic]\n    The steps for determining the maximum enjoyment value and calculating the maximum toll per vehicle should be implemented simultaneously for each tour group. This can be done by performing a graph traversal (e.g., BFS) that simultaneously tracks the maximum enjoyment value and the highest toll encountered.\n\n# [edge case]\n    1. All cities have the same enjoyment value.\n       Explanation: The maximum enjoyment value will be the same for any reachable city, and the toll will depend on the path taken.\n       \n    2. The starting city is isolated due to capacity constraints.\n       Explanation: If the number of vehicles exceeds the capacity of all connecting roads, the group cannot leave the starting city, resulting in a toll of 0.\n       \n    3. The starting city has the highest enjoyment value.\n       Explanation: The group does not need to travel, so the toll is 0, and the enjoyment value is that of the starting city.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the starting city is isolated due to capacity constraints.\n    ```python\n    def handle_isolated_city(v, x, capacities):\n        # Check if the starting city is isolated due to capacity constraints\n        for road in graph[x]:\n            if capacities[road] >= v:\n", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    def bfs_max_enjoyment_and_toll(start, vehicles):\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= vehicles:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for vehicles, start in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(start, vehicles)\n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 147)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    def bfs_max_enjoyment_and_toll(start, vehicles):\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= vehicles:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for vehicles, start in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(start, vehicles)\n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from each starting city for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a traversal (e.g., BFS or DFS) from the starting city to find all reachable cities considering road capacities.\",\n        \"Track the maximum enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll cost per vehicle for the journey from the starting city to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each reachable city with maximum enjoyment value, determine the shortest path from the starting city.\",\n        \"Identify the highest toll on the shortest path and calculate the reimbursement cost per vehicle.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll cost per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent cities and roads.\",\n    \"For each tour group, perform a graph traversal to find reachable cities and determine the maximum enjoyment value.\",\n    \"Calculate the maximum toll cost per vehicle for the journey to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads connect cities in both directions, meaning travel can occur from city A to city B and vice versa.\n\n    'enjoyment value'\n    Explanation: Each city has a numerical value representing how enjoyable it is for the tour group.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at any given time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road, but only the highest toll on any road traveled is paid.\n\n    'shortest path'\n    Explanation: The path between two cities that minimizes the number of roads traveled.\n\n# [phrase showing quantity relationship]\n    'maximum number of vehicles'\n    Explanation: Refers to the road capacity, which limits the number of vehicles that can travel on a road simultaneously. In code, this can be implemented by checking if the number of vehicles in a tour group does not exceed the road's capacity.\n\n    'highest toll'\n    Explanation: The maximum toll value among all roads traveled in a journey. In code, this can be implemented by tracking the maximum toll encountered during the traversal.\n\n# [degree adverb]\n    'maximum enjoyment value'\n    Explanation: The highest enjoyment value among all cities reachable from the starting city. In code, this can be implemented by comparing enjoyment values of reachable cities and selecting the largest.\n\n# [code logic]\n    The steps for determining the maximum enjoyment value and calculating the maximum toll cost per vehicle should be considered simultaneously for each tour group. This involves traversing the graph to find reachable cities and simultaneously tracking the maximum enjoyment value and the highest toll.\n\n# [edge case]\n    Case 1: When the starting city is isolated due to road capacity limitations.\n    Example: If a tour group starts at a city with no roads that can accommodate the number of vehicles, the expected output is the enjoyment value of the starting city and a toll of 0.\n\n    Case 2: When all roads have the same toll value.\n    Example: If all roads have a toll of 5, the expected output for the toll reimbursement is 5, regardless of the path taken.\n\n    Case 3: When multiple cities have the same maximum enjoyment value.\n    Example: If cities 3 and 4 both have the highest enjoyment value of 10, the expected output should reflect the maximum toll for any path to either city.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n   ", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            city, current_max_toll = queue.popleft()\n            \n            if visited[city]:\n                continue\n            \n            visited[city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment_values[city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 145)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            city, current_max_toll = queue.popleft()\n            \n            if visited[city]:\n                continue\n            \n            visited[city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment_values[city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from a starting city for each tour group.\",\n      \"steps\": [\n        \"Perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\",\n        \"Filter reachable cities based on road capacity constraints.\",\n        \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll cost per vehicle for the journey from the starting city to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each reachable city, determine the shortest path from the starting city using Dijkstra's algorithm or BFS.\",\n        \"Track the maximum toll encountered on the shortest path.\",\n        \"Ensure the path respects the road capacity constraints.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll cost per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information.\",\n    \"Construct a graph representation of the cities and roads.\",\n    \"For each tour group, perform graph traversal to find reachable cities and determine the maximum enjoyment value.\",\n    \"Calculate the maximum toll cost per vehicle for the journey to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads that allow travel in both directions between two cities.\n\n    'enjoyment value'\n    Explanation: A numerical value representing how enjoyable a city is for the tour group.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at one time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road, where the group pays the highest toll of any road traveled.\n\n    'shortest path'\n    Explanation: The path between two cities that minimizes the number of roads traveled.\n\n# [phrase showing quantity relationship]\n    'exactly n-1 bidirectional roads'\n    Explanation: The number of roads is one less than the number of cities, forming a tree structure.\n    Implementation: Ensure the graph is a tree with n-1 edges.\n\n    'maximum enjoyment value'\n    Explanation: The highest enjoyment value among the cities reachable from the starting city.\n    Implementation: Use a traversal algorithm to find the city with the highest enjoyment value.\n\n    'maximum number of vehicles'\n    Explanation: The capacity constraint on roads, limiting the number of vehicles that can travel simultaneously.\n    Implementation: Filter paths based on road capacity.\n\n# [degree adverb]\n    'maximum enjoyment value'\n    Explanation: The highest possible enjoyment value among reachable cities.\n    Implementation: Use a traversal algorithm to find the city with the highest enjoyment value.\n\n    'maximum toll'\n    Explanation: The highest toll encountered on the path from the starting city to the city with maximum enjoyment.\n    Implementation: Track the highest toll during pathfinding.\n\n# [code logic]\n    The steps in the plan related to graph traversal and pathfinding should be implemented simultaneously:\n    - \"Perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\"\n    - \"Filter reachable cities based on road capacity constraints.\"\n    - \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n    - \"For each reachable city, determine the shortest path from the starting city using Dijkstra's algorithm or BFS.\"\n    - \"Track the maximum toll encountered on the shortest path.\"\n    These steps can be combined into a single traversal and pathfinding routine.\n\n# [edge case]\n    Edge Case 1: All cities have the same enjoyment value.\n    Input: 5 1\n           2 2 2 2 2\n           1 2 4 7\n           1 3 ", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    roads = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        roads[a].append((b, c, t))\n        roads[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in roads[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"For each query, determine the set of cities that can be reached from the starting city given the vehicle capacity constraints on the roads.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each query, find the city with the maximum enjoyment value that is reachable from the starting city.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each query, calculate the maximum toll that would be incurred on the shortest path to any city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each query, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, queries, enjoyment values, roads, and tour groups.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each query, perform a breadth-first search (BFS) or depth-first search (DFS) from the starting city to find all reachable cities considering the road capacity constraints.\",\n    \"Identify the city with the maximum enjoyment value among the reachable cities.\",\n    \"For each reachable city with the maximum enjoyment value, determine the shortest path from the starting city and calculate the maximum toll on that path.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads': Roads can be traversed in both directions between cities.\n    'enjoyment value': A numerical value representing how enjoyable a city is.\n    'capacity': Maximum number of vehicles a road can support.\n    'toll': Cost associated with traveling on a road.\n    'shortest path': The path between two cities with the minimum number of roads or minimum toll.\n\n# [phrase showing quantity relationship]\n    'maximum number': Refers to the capacity of the road, which limits the number of vehicles that can travel on it.\n    'highest toll': The maximum toll among all roads traversed in a journey.\n    'maximum enjoyment value': The highest enjoyment value among reachable cities.\n\n# [degree adverb]\n    'maximum': Refers to the highest enjoyment value or toll that can be incurred.\n    'highest': Refers to the largest toll among roads traversed.\n\n# [code logic]\n    The steps \"Determine Maximum Enjoyment\" and \"Calculate Maximum Toll\" should be considered simultaneously for each query. Once the reachable cities are identified, both the maximum enjoyment and the maximum toll can be calculated in the same traversal.\n\n# [edge case]\n    Case 1: When all roads have a capacity less than the number of vehicles in the tour group, the group cannot move, and the enjoyment value is that of the starting city with a toll of 0.\n    Case 2: When all cities have the same enjoyment value, the maximum enjoyment value is that value, and the toll is the highest toll on any path.\n    Case 3: When the starting city is the only city with the maximum enjoyment value, the toll is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where road capacities restrict movement.\n        if all(road_capacity < vehicles for road_capacity in road_capacities):\n            return enjoyment_values[starting_city], 0\n        (other code)\n\nYES", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for vehicles, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            \n            if visited[current_city]:\n                continue\n            \n            visited[current_city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and vehicles <= capacity:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 148)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for vehicles, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            \n            if visited[current_city]:\n                continue\n            \n            visited[current_city] = True\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and vehicles <= capacity:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get the number of cities (n) and number of groups (q).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from the starting city for each tour group.\",\n      \"steps\": [\n        \"Perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\",\n        \"Filter reachable cities based on road capacity constraints.\",\n        \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for the journey from the starting city to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each reachable city, determine the shortest path from the starting city.\",\n        \"Identify the highest toll on the shortest path.\",\n        \"Ensure the number of vehicles does not exceed road capacities on the path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information.\",\n    \"Construct a graph representation of the cities and roads.\",\n    \"For each tour group, perform graph traversal to find reachable cities and determine the maximum enjoyment value.\",\n    \"Calculate the maximum toll per vehicle for the journey to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads can be traversed in both directions, meaning if there's a road from city A to city B, you can travel from A to B and from B to A.\n\n    'enjoyment value'\n    Explanation: Each city has a value representing how enjoyable it is for the tour group. The goal is to reach the city with the highest enjoyment value.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at the same time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road. The group pays the highest toll of any road they travel on during their journey.\n\n    'shortest path'\n    Explanation: The path between two cities that involves the least number of roads or the least total toll cost.\n\n# [phrase showing quantity relationship]\n    'n-1 bidirectional roads': Indicates that the number of roads is one less than the number of cities, forming a tree structure.\n    \n    'maximum number of vehicles': Refers to the capacity constraint on each road.\n    \n    'highest toll': The maximum toll value encountered on the path from the starting city to the destination city.\n\n# [degree adverb]\n    'maximum enjoyment value': The highest enjoyment value among the cities that can be reached from the starting city.\n    \n    'maximum toll': The highest toll that needs to be paid per vehicle on the journey.\n\n# [code logic]\n    The steps in the plan related to graph traversal and toll calculation should be considered simultaneously. Specifically:\n    - \"Perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\"\n    - \"Filter reachable cities based on road capacity constraints.\"\n    - \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n    - \"For each reachable city, determine the shortest path from the starting city.\"\n    - \"Identify the highest toll on the shortest path.\"\n    These steps can be combined into a single traversal process that checks both reachability and toll constraints.\n\n# [edge case]\n    1. All cities have the same enjoyment value.\n       Explanation: The output should be the enjoyment value and the highest toll on any path from the starting city.\n       Example: If all cities have an enjoyment value of 5, and the highest toll on any path is 3, the output should be \"5 3\".\n\n    2. The starting city is isolated due to capacity constraints.\n       Explanation:", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            city, current_max_toll = queue.popleft()\n            \n            if visited[city]:\n                continue\n            visited[city] = True\n            \n            max_enjoyment = max(max_enjoyment, enjoyment_values[city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use adjacency lists to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from each starting city for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\",\n        \"Filter reachable cities based on road capacity constraints.\",\n        \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for the journey from the starting city to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, find the shortest path from the starting city to the city with maximum enjoyment value.\",\n        \"Determine the highest toll encountered on this path.\",\n        \"Ensure the number of vehicles does not exceed road capacities along the path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group information.\",\n    \"Construct a graph representation of the cities and roads using adjacency lists.\",\n    \"For each tour group, perform a graph traversal to find reachable cities and determine the maximum enjoyment value.\",\n    \"Calculate the maximum toll per vehicle for the journey to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads that allow travel in both directions between two cities.\n\n    'enjoyment value'\n    Explanation: A numerical value representing how enjoyable a city is for the tour group.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at the same time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road, but only the highest toll on a journey is paid.\n\n    'shortest path'\n    Explanation: The path between two cities that involves the least number of roads or the least total toll.\n\n# [phrase showing quantity relationship]\n    'n-1 bidirectional roads'\n    Explanation: There are exactly one less road than the number of cities, ensuring a connected graph.\n    Implementation: Ensure the graph is connected with n-1 edges.\n\n    'maximum enjoyment value'\n    Explanation: The highest enjoyment value among the cities that can be reached.\n    Implementation: Use a traversal algorithm to find the city with the highest enjoyment value.\n\n    'maximum number of vehicles'\n    Explanation: The capacity constraint on roads.\n    Implementation: Check road capacities during traversal to ensure they are not exceeded.\n\n# [degree adverb]\n    'maximum enjoyment value'\n    Explanation: The highest possible enjoyment value among reachable cities.\n    Implementation: Use a max function to determine the highest enjoyment value.\n\n    'highest toll'\n    Explanation: The largest toll value encountered on a path.\n    Implementation: Track the maximum toll value during path traversal.\n\n# [code logic]\n    The steps in subproblem 3 and 4 should be considered simultaneously:\n    - While performing the traversal to find reachable cities, also track the path to calculate the maximum toll.\n    - This can be done using a modified BFS or DFS that keeps track of the path and tolls.\n\n# [edge case]\n    1. All cities have the same enjoyment value.\n       Explanation: The output should be the enjoyment value and the highest toll on any path.\n       Example: If all cities have an enjoyment value of 5, the output should be 5 and the highest toll encountered.\n\n    2. A tour group starts in a city with no outgoing roads due to capacity constraints.\n       Explanation: The group cannot move, so the enjoyment value is that of the starting city, and the toll is 0.\n       Example: If a group starts in a city with no available roads, the output should be the city's enjoyment value and 0.\n\n   ", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            if visited[current]:\n                continue\n            visited[current] = True\n            \n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 147)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            if visited[current]:\n                continue\n            visited[current] = True\n            \n            max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and v <= capacity:\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get the number of cities (n) and number of groups (q).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the number of vehicles and starting city for each tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable from a starting city for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a traversal (e.g., BFS or DFS) from the starting city to find all reachable cities.\",\n        \"Filter reachable cities based on road capacity constraints.\",\n        \"Identify the city with the maximum enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll per vehicle for the journey from the starting city to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, find the shortest path from the starting city to the city with maximum enjoyment value.\",\n        \"Determine the highest toll encountered on this path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information.\",\n    \"Construct a graph representation of the cities and roads.\",\n    \"For each tour group, determine the maximum enjoyment value reachable from the starting city.\",\n    \"Calculate the maximum toll per vehicle for the journey to the city with maximum enjoyment value.\",\n    \"Output the results for each tour group.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'bidirectional roads'\n    Explanation: Roads can be traversed in both directions, meaning if there's a road from city A to city B, you can travel from A to B and from B to A.\n\n    'enjoyment value'\n    Explanation: Each city has a value representing how enjoyable it is for the tour group. The goal is to reach the city with the highest enjoyment value.\n\n    'capacity'\n    Explanation: The maximum number of vehicles that can travel on a road at the same time.\n\n    'toll'\n    Explanation: The cost associated with traveling on a road. The group pays the highest toll of any road they travel on during their journey.\n\n    'shortest path'\n    Explanation: The path between two cities that minimizes the number of roads traveled, not necessarily the path with the least toll.\n\n# [phrase showing quantity relationship]\n    'n-1 bidirectional roads': Indicates that the number of roads is one less than the number of cities, forming a tree structure.\n    \n    'maximum number of vehicles': Refers to the capacity constraint on each road.\n    \n    'highest toll': The maximum toll value encountered on the path from the starting city to the destination city.\n\n# [degree adverb]\n    'maximum enjoyment value': The highest enjoyment value among the cities that can be reached from the starting city.\n    \n    'maximum toll': The highest toll encountered on the path from the starting city to the city with the maximum enjoyment value.\n\n# [code logic]\n    The steps for determining the maximum enjoyment value and calculating the maximum toll per vehicle should be considered simultaneously for each tour group. This involves traversing the graph to find reachable cities and calculating the tolls in one traversal.\n\n# [edge case]\n    1. If all roads have a capacity less than the number of vehicles in the tour group, the group cannot travel, and the toll is 0.\n       Example: For a tour group of size 10 starting at city 1, if all roads have a capacity of 5, the output should be the enjoyment value of city 1 and toll 0.\n    \n    2. If the starting city is the only city with the maximum enjoyment value, the toll is 0.\n       Example: For a tour group starting at city 1 with the highest enjoyment value, the output should be the enjoyment value of city 1 and toll 0.\n    \n    3. If multiple cities have the same maximum enjoyment value, the toll should be", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, toll))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 149)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities and maximum enjoyment value\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and v <= capacity:\n                    visited[neighbor] = True\n                    queue.append((neighbor, toll))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 145, "prompt": "Omkar is hosting tours of his home country, Omkarland! There are n cities in Omkarland, and unusually, there are exactly n-1 bidirectional roads connecting the cities to each other, ensuring that any city is accessible from any other city via the road network.\n\nEvery city has an enjoyment value e, and each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: vehicles pay only the highest toll of any single road on which they traveled if they traverse multiple roads on a single journey, and they pay 0 toll if they traverse no roads.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay, so for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 117}
