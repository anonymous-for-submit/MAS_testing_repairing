{"name": "1586_B. Omkar and Heavenly Tree", "description": "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. \n\nA tree with n nodes is an connected undirected graph with n nodes and n-1 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree: \n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c. \n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "tags": ["brute force", "constructive algorithms", "trees"], "difficulty": 8, "id": 1586, "sample_io": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "test_list": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n6 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n7 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n6 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n7 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n4 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n7 4\n1 1 3\n3 2 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n8 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 7 4\n13 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 2\n5 7 10\n4 5 4\n6 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 1 4\n3 6 0\n5 5 7\n5 5 4\n8 3\n2 2 -1\n6 2 4\n3 4 10\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 1 2\n10 2 5\n6 6 7\n6 5 4\n5 3\n1 1 0\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 2 20\n6 3 4\n9 0\n0 1 1\n4 3 4\n2 4 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n"]}, {"input": "2\n11 4\n-1 4 1\n3 7 5\n5 2 22\n2 5 1\n10 1\n2 2 1\n5 1 3\n4 2 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 5\n5 6 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 0 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n23 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 0\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n13 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n24 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n2 1\n2 3\n2 4\n"]}, {"input": "2\n21 4\n1 2 3\n4 1 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 13\n3 14\n3 15\n3 16\n3 17\n3 18\n3 19\n3 20\n3 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n4 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n"]}, {"input": "2\n9 4\n2 2 6\n3 4 10\n-1 6 7\n6 5 4\n8 3\n1 4 0\n1 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 2 1\n3 1 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n9 4\n1 4 3\n3 4 17\n5 6 12\n8 5 8\n9 3\n1 1 0\n3 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n"]}, {"input": "2\n9 4\n1 4 3\n3 1 17\n5 6 12\n8 5 15\n5 3\n1 1 0\n3 3 7\n3 5 7\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 1 1\n3 7 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n27 4\n1 3 3\n4 2 2\n5 7 10\n4 9 4\n6 0\n1 2 -1\n2 6 4\n4 1 8\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 27\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 2 22\n2 1 4\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 1 22\n2 5 1\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n9 4\n-1 4 1\n0 7 9\n5 2 22\n2 5 1\n10 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 7\n5 1 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 -1 12\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n2 13\n2 14\n2 15\n2 16\n2 17\n2 18\n2 19\n2 20\n2 21\n2 22\n2 23\n2 24\n2 25\n2 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n0 4 2\n1 10 9\n5 2 22\n2 5 1\n19 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n"]}, {"input": "2\n24 4\n1 4 3\n1 4 7\n5 6 17\n1 13 4\n6 0\n1 3 0\n2 1 4\n7 -1 21\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n7 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 3\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 12\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n0 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 6 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 5\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 7\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n8 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n4 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 4\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n5 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n4 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 -1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 0\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n12 4\n1 2 6\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n2 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 1\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 18\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 3 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "task_id": "codecontest/37", "repair_prompt": ["Lord Omkar wants a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to build the tree. However, Lord Omkar has made m (1 \u2264 m < n) limitations to make sure that the tree becomes as divine as possible.\n\nA tree with n nodes is an connected undirected graph with n nodes and n-1 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Lord Omkar wants a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to build the tree. However, Lord Omkar has made m (1 \u2264 m < n) limitations to make sure that the tree becomes as divine as possible.\n\nA tree with n nodes is a connected undirected graph with n nodes and n-1 edges. Note that for any two nodes, there is exactly one simple path between them. The simple path is a path between two nodes that does not contain any node more than once. \n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Lord Omkar wants a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to build the tree. However, Lord Omkar has made m (1 \u2264 m < n) limitations to make sure that the tree becomes as divine as possible. A tree with n nodes is an connected undirected graph with n nodes and n-1 edges, and note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # We can choose any node as the central node, let's choose node 1\n        central_node = 1\n        \n        # Connect all other nodes to the central node\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a central node that is not the middle node in any restriction\n        # We can use any node that is not b in any (a, b, c) restriction\n        # Since m < n, there is always at least one such node\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        \n        # Choose a node that is not restricted\n        central_node = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        # Construct the tree using the central node\n        edges = []\n        for node in range(1, n + 1):\n            if node != central_node:\n                edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restricted_nodes = set()\n        \n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            restricted_nodes.add(b)\n        \n        # Find a node that is not restricted as a middle node\n        root = None\n        for node in range(1, n + 1):\n            if node not in restricted_nodes:\n                root = node\n                break\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root\n        # or choose a node that is involved in the least number of restrictions.\n        # For simplicity, we can choose node 1 as the root and connect it to all other nodes.\n        \n        # We will connect all nodes to the root except one node\n        # This ensures that no node b can be on the path between any two other nodes\n        # because all paths will go through the root\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((1, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a node that is not a middle node in any restriction\n        middle_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in middle_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a central node that is not restricted\n        # We can choose node 1 as the central node and connect all other nodes to it\n        # This will satisfy all restrictions because no node b can be on the path between any two other nodes\n        central_node = 1\n        \n        # Create the tree by connecting all nodes to the central node\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # We can choose any node as the root, but let's choose node 1 for simplicity.\n        # However, to ensure the restrictions are met, we need to analyze the restrictions.\n        \n        # Find a node that is not 'b' in any restriction, as 'b' cannot be on the path between 'a' and 'c'.\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        \n        # Choose a node that is not restricted as the root\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        # Connect all other nodes to the root node\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # However, a simpler approach is to choose a node that is involved in the least number of restrictions.\n        # We can choose node 1 as the root and connect it to all other nodes.\n        \n        # Construct the tree\n        edges = []\n        # Find a node that is not b in any restriction\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Choose a central node that is not involved in any restriction as b\n        # If all nodes are involved, choose any node as central\n        involved_as_b = set(b for _, b, _ in restrictions)\n        central_node = next((node for node in range(1, n + 1) if node not in involved_as_b), 1)\n        \n        # Construct the tree using the central node\n        edges = []\n        for node in range(1, n + 1):\n            if node != central_node:\n                edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a node that is not a middle node in any restriction\n        middle_nodes = set(b for _, b, _ in restrictions)\n        root = next(i for i in range(1, n + 1) if i not in middle_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # We can choose any node as the central node, let's choose node 1\n        central_node = 1\n        \n        # Connect all other nodes to the central node\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Identify a central node that can be used to connect other nodes without violating any restrictions.\",\n        \"Iteratively connect nodes to the central node while ensuring that no restriction is violated.\",\n        \"Ensure that the constructed graph is a tree (connected and has n-1 edges).\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges'\n    Explanation: This indicates that the tree must have exactly n nodes and n-1 edges, which is a fundamental property of trees.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the step \"Iteratively connect nodes to the central node while ensuring that no restriction is violated,\" the logic for checking restrictions and connecting nodes should be handled simultaneously. This can be done using a loop that iterates over nodes and checks restrictions before adding edges.\n\n# [edge case] \n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between 1 and 3, so we connect 1 to 3 and 3 to 2.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected Output: 1 3, 3 2, 3 4\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 4 cannot be on the path between 3 and 1. Connecting 1 to 3, 3 to 2, and 3 to 4 satisfies both restrictions.\n\n    Edge Case 3: n = 5, m = 0\n    Expected Output: 1 2, 2 3, 3 4, 4 5\n    Explanation: With no restrictions, a simple linear connection satisfies the tree structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iteratively connecting nodes while checking restrictions should naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # We can choose any node as the central node, let's choose node 1\n        central_node = 1\n        \n        # Connect all other nodes to the central node\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a central node that can be used to construct a tree that satisfies all restrictions. This node should not appear as the middle node in any restriction.\",\n      \"output\": \"A central node for each test case that can be used to construct the tree.\"\n    },\n    {\n      \"description\": \"Construct the tree using the identified central node by connecting it to all other nodes, ensuring that the tree satisfies the restrictions.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree.\"\n    },\n    {\n      \"description\": \"Format the output to match the required output format, which includes printing the edges for each test case.\",\n      \"output\": \"Formatted output for each test case, listing the edges of the tree.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, iterate through the restrictions to determine a suitable central node that does not violate any restrictions.\",\n    \"Using the central node, construct a tree by connecting it to all other nodes, ensuring that no restriction is violated.\",\n    \"Output the edges of the constructed tree for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n    'restriction': A condition that specifies a node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes': The tree must have exactly n nodes.\n    'n-1 edges': The tree must have exactly n-1 edges to be a valid tree.\n    '1 \u2264 m < n': The number of restrictions is less than the number of nodes.\n\n# [degree adverb]\n    'most trusted': Implies the solution must be optimal and meet all restrictions.\n\n# [code logic]\n    The steps of identifying a central node and constructing the tree should be considered simultaneously. Once a central node is identified, it can be connected to all other nodes in one code block to form the tree.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = (1, 2, 3)\n    Expected output: 1 3, 3 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, so 1 and 3 are directly connected, and 3 is connected to 2.\n    \n    Case 2: n = 4, m = 2, restrictions = (1, 2, 3), (3, 4, 1)\n    Expected output: 1 3, 3 4, 1 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 4 cannot be on the path between 3 and 1. Thus, 1 is connected to 3, 3 to 4, and 1 to 2.\n    \n    Case 3: n = 5, m = 3, restrictions = (1, 2, 3), (2, 3, 4), (3, 4, 5)\n    Expected output: 1 3, 3 4, 4 5, 1 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, node 3 cannot be on the path between 2 and 4, and node 4 cannot be on the path between 3 and 5. Thus, 1 is connected to 3, 3 to", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a central node that is not the middle node in any restriction\n        # We can use any node that is not b in any (a, b, c) restriction\n        # Since m < n, there is always at least one such node\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        \n        # Choose a node that is not restricted\n        central_node = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        # Construct the tree using the central node\n        edges = []\n        for node in range(1, n + 1):\n            if node != central_node:\n                edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a central node that can be used as a root for the tree. This node should not be part of any restriction as the middle node (b) in the restrictions.\",\n      \"output\": \"A selected root node for each test case that satisfies the restriction conditions.\"\n    },\n    {\n      \"description\": \"Construct a tree by connecting the root node to all other nodes directly, ensuring that the restrictions are satisfied.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree satisfying all restrictions.\"\n    },\n    {\n      \"description\": \"Format the output for each test case by listing the edges of the tree in the required format.\",\n      \"output\": \"Formatted output for each test case, ready to be printed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, analyze the restrictions to determine a suitable root node that is not restricted as a middle node in any path.\",\n    \"Construct the tree by connecting the root node to all other nodes, ensuring that no restriction is violated.\",\n    \"Output the edges of the constructed tree for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'more than': In the context of restrictions, it means that node b cannot be part of the path between nodes a and c.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the selection of the root node and the construction of the tree can be considered together. Specifically, once a suitable root node is identified, the tree can be constructed by connecting this root to all other nodes directly.\n\n# [edge case] \n    Case 1: n = 3, m = 1, restriction = (1, 2, 3)\n    Expected output: 1 3, 3 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, so 3 is chosen as the root and connected to both 1 and 2.\n\n    Case 2: n = 4, m = 2, restrictions = (1, 2, 3), (3, 4, 1)\n    Expected output: 1 3, 3 2, 3 4\n    Explanation: Node 3 is chosen as the root because it is not restricted as a middle node in any path.\n\n    Case 3: n = 5, m = 3, restrictions = (1, 2, 3), (2, 3, 4), (3, 4, 5)\n    Expected output: 1 3, 3 2, 3 4, 3 5\n    Explanation: Node 3 is chosen as the root because it is not restricted as a middle node in any path.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of selecting a root node that is not restricted as a middle node and connecting it to all other nodes directly will handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restricted_nodes = set()\n        \n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            restricted_nodes.add(b)\n        \n        # Find a node that is not restricted as a middle node\n        root = None\n        for node in range(1, n + 1):\n            if node not in restricted_nodes:\n                root = node\n                break\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 97)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restricted_nodes = set()\n        \n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            restricted_nodes.add(b)\n        \n        # Find a node that is not restricted as a middle node\n        root = None\n        for node in range(1, n + 1):\n            if node not in restricted_nodes:\n                root = node\n                break\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, determine a root node for the tree. This can be any node, but choosing a node that simplifies the construction of the tree is beneficial.\",\n      \"output\": \"A selected root node for each test case.\"\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the given restrictions for each test case. This involves ensuring that for each restriction (a, b, c), node b is not on the simple path between nodes a and c.\",\n      \"output\": \"A list of edges for each test case that form a valid tree satisfying all restrictions.\"\n    },\n    {\n      \"description\": \"Output the edges of the tree for each test case in the required format.\",\n      \"output\": \"Formatted output of the edges for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, select a root node for the tree.\",\n    \"Iteratively add edges to construct the tree while ensuring that all restrictions are satisfied. This can be done by strategically connecting nodes to avoid placing restricted nodes on certain paths.\",\n    \"Once a valid tree is constructed for a test case, store the edges.\",\n    \"After processing all test cases, output the edges for each tree in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges. It has no cycles, and there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node (b) cannot lie on the simple path between two other nodes (a and c).\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges'\n    Explanation: This indicates that the tree must have exactly n-1 edges to connect n nodes without forming cycles. In code, this means ensuring the output has exactly n-1 edges for each test case.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the construction of the tree (step 3) involves iteratively adding edges while checking restrictions. This step is complex and may require simultaneous consideration of multiple restrictions to ensure a valid tree structure.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = (1, 2, 3)\n    Expected output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between nodes 1 and 3. The tree can be constructed by directly connecting 1 to 3 and 3 to 2.\n\n    Case 2: n = 4, m = 2, restrictions = (1, 2, 3), (3, 4, 1)\n    Expected output: 1 3, 3 2, 3 4\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 4 cannot be on the path between 3 and 1. The tree can be constructed by connecting 1 to 3, 3 to 2, and 3 to 4.\n\n    Case 3: n = 5, m = 3, restrictions = (1, 2, 3), (2, 3, 4), (3, 4, 5)\n    Expected output: 1 3, 3 4, 4 5, 3 2\n    Explanation: The restrictions require careful placement of edges to ensure no restricted node lies on the specified paths. The tree can be constructed by connecting 1 to 3,", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root\n        # or choose a node that is involved in the least number of restrictions.\n        # For simplicity, we can choose node 1 as the root and connect it to all other nodes.\n        \n        # We will connect all nodes to the root except one node\n        # This ensures that no node b can be on the path between any two other nodes\n        # because all paths will go through the root\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((1, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 94)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root\n        # or choose a node that is involved in the least number of restrictions.\n        # For simplicity, we can choose node 1 as the root and connect it to all other nodes.\n        \n        # We will connect all nodes to the root except one node\n        # This ensures that no node b can be on the path between any two other nodes\n        # because all paths will go through the root\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((1, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, determine a root node that can be used to construct the tree. This node should not be part of any restriction as the middle node (b) in the restrictions.\",\n      \"output\": \"A selected root node for each test case that satisfies the restriction conditions.\"\n    },\n    {\n      \"description\": \"Construct the tree by connecting the root node to all other nodes directly, ensuring that the restrictions are satisfied.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree satisfying all restrictions.\"\n    },\n    {\n      \"description\": \"Format the output for each test case by listing the edges of the tree in the required format.\",\n      \"output\": \"Formatted output for each test case, listing the edges of the tree.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, identify a suitable root node that is not restricted as a middle node in any of the given restrictions.\",\n    \"Construct the tree by connecting the root node to all other nodes, ensuring that the restrictions are not violated.\",\n    \"Output the edges of the constructed tree for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node (b) cannot lie on the simple path between two other nodes (a and c).\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates that the tree must have exactly n-1 edges to be a valid tree with n nodes.\n    '1 \u2264 m < n': This specifies that the number of restrictions (m) is at least 1 and less than the number of nodes (n).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    The steps in the plan are sequential and do not require simultaneous execution. Each step builds upon the previous one, from parsing input to constructing the tree and formatting the output.\n\n# [edge case]\n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3\n    Explanation: The only possible edge that satisfies the restriction is between nodes 1 and 3.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 2, 4)]\n    Expected Output: 1 3, 3 4\n    Explanation: Node 2 cannot be on the path between 1 and 3 or between 3 and 4, so it is excluded from the direct connections.\n\n    Edge Case 3: n = 5, m = 4, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 1)]\n    Expected Output: 1 3, 3 5, 5 4\n    Explanation: Each restriction excludes a node from being on the path between two others, leading to a specific tree structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of selecting a root node that is not a middle node in any restriction and connecting it to all other nodes should inherently handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a node that is not a middle node in any restriction\n        middle_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in middle_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 92)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a node that is not a middle node in any restriction\n        middle_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in middle_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases, where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, determine a strategy to construct a tree that satisfies all the given restrictions.\",\n      \"output\": \"A method to construct a tree for each test case that adheres to the restrictions, ensuring that no restricted node lies on the path between the specified nodes.\"\n    },\n    {\n      \"description\": \"Implement a function to construct the tree using the strategy determined in the previous step.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree satisfying the restrictions.\"\n    },\n    {\n      \"description\": \"Format the output to match the required output format, ensuring that each test case's result is printed correctly.\",\n      \"output\": \"Formatted output for each test case, listing the edges of the constructed tree.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"Iterate over each test case and apply a strategy to construct a valid tree:\",\n    \"  - Identify a central node that can be used to connect other nodes while respecting the restrictions.\",\n    \"  - Connect nodes to the central node or other nodes in a way that avoids placing restricted nodes on paths between specified nodes.\",\n    \"For each test case, generate the list of edges that form the tree.\",\n    \"Output the edges for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n    'restriction': A condition that specifies a node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes': The tree must have exactly n nodes.\n    'n-1 edges': The tree must have exactly n-1 edges to be a valid tree.\n    '1 \u2264 m < n': The number of restrictions is less than the number of nodes.\n\n# [degree adverb]\n    'most trusted': Implies the solution must be optimal and meet all restrictions.\n\n# [code logic]\n    The steps in the plan should be implemented simultaneously:\n    - Identifying a central node and connecting other nodes should be done in one code block to ensure the tree structure is valid and meets all restrictions.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = (1, 2, 3)\n    Expected output: 1 3, 3 2\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3, so the tree must connect 1 to 3 and 3 to 2.\n    \n    Case 2: n = 4, m = 2, restrictions = (1, 2, 3), (3, 4, 1)\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3, and node 4 cannot be on the path between nodes 3 and 1. The tree must connect 1 to 3, 3 to 4, and 4 to 2.\n    \n    Case 3: n = 5, m = 3, restrictions = (1, 2, 3), (2, 3, 4), (4, 5, 1)\n    Expected output: 1 3, 3 4, 4 5, 5 2\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3, node 3 cannot be on the path between nodes 2 and 4, and node 5 cannot be on the path between nodes 4 and 1. The tree must connect 1 to 3", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a central node that is not restricted\n        # We can choose node 1 as the central node and connect all other nodes to it\n        # This will satisfy all restrictions because no node b can be on the path between any two other nodes\n        central_node = 1\n        \n        # Create the tree by connecting all nodes to the central node\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 90)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Strategy: Choose a central node that is not restricted\n        # We can choose node 1 as the central node and connect all other nodes to it\n        # This will satisfy all restrictions because no node b can be on the path between any two other nodes\n        central_node = 1\n        \n        # Create the tree by connecting all nodes to the central node\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a node that can serve as a root for the tree such that it does not violate any restrictions.\",\n      \"output\": \"A selected root node for each test case that satisfies the restrictions.\"\n    },\n    {\n      \"description\": \"Construct a tree for each test case starting from the selected root node, ensuring that the tree satisfies all given restrictions.\",\n      \"output\": \"A list of edges for each test case that form a valid tree satisfying the restrictions.\"\n    },\n    {\n      \"description\": \"Format the output for each test case as specified, with each edge represented by two integers indicating the connected nodes.\",\n      \"output\": \"Formatted output for each test case, ready to be printed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, analyze the restrictions to determine a suitable root node that does not violate any restrictions.\",\n    \"Construct a tree starting from the chosen root node, ensuring that no restriction is violated by the placement of edges.\",\n    \"Output the edges of the constructed tree for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'simple path'\n    Explanation: A simple path is a path between two nodes that does not contain any node more than once.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges': This indicates that the tree must have exactly n-1 edges for n nodes.\n    '1 \u2264 m < n': This indicates that the number of restrictions is at least 1 and less than the number of nodes.\n\n# [degree adverb]\n    'exactly one simple path': This means there is only one path between any two nodes without repeating nodes.\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but the selection of a root node and the construction of the tree should be considered together to ensure that the tree satisfies all restrictions. This can be done by iterating over nodes and checking restrictions simultaneously.\n\n# [edge case]\n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between 1 and 3, which is satisfied by directly connecting 1 to 3 and 3 to 2.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected Output: 1 3, 3 2, 3 4\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 4 cannot be on the path between 3 and 1. The tree structure satisfies both restrictions.\n\n    Edge Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (4, 5, 1)]\n    Expected Output: 1 3, 3 2, 3 4, 4 5\n    Explanation: The tree structure ensures that none of the restricted nodes lie on the specified paths", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # We can choose any node as the root, but let's choose node 1 for simplicity.\n        root = 1\n        \n        # Connect all other nodes to the root node\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # We can choose any node as the root, but let's choose node 1 for simplicity.\n        # However, to ensure the restrictions are met, we need to analyze the restrictions.\n        \n        # Find a node that is not 'b' in any restriction, as 'b' cannot be on the path between 'a' and 'c'.\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        \n        # Choose a node that is not restricted as the root\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        # Connect all other nodes to the root node\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    for edges in results:\n        for u, v in edges:\n            print(u, v)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the number of nodes, number of restrictions, and the restrictions themselves.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a node that can serve as a root for the tree such that it does not violate any restrictions.\",\n      \"output\": \"A selected root node for each test case that satisfies the restrictions.\"\n    },\n    {\n      \"description\": \"Construct a tree for each test case starting from the selected root node, ensuring that the tree satisfies all given restrictions.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree.\"\n    },\n    {\n      \"description\": \"Format the output for each test case as specified, with each edge represented by two integers indicating the connected nodes.\",\n      \"output\": \"Formatted output for each test case, ready to be printed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, analyze the restrictions to determine a suitable root node that does not violate any restrictions.\",\n    \"Construct a tree starting from the chosen root node, ensuring that no restriction is violated by the placement of edges.\",\n    \"For each test case, output the list of edges that form the tree, ensuring the output format matches the requirements.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n    'simple path': A path between two nodes that does not contain any node more than once.\n    'restriction': A condition that specifies a node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes': Indicates the number of nodes in the tree.\n    'n-1 edges': Indicates the number of edges required to form a tree with n nodes.\n    '1 \u2264 m < n': Indicates the number of restrictions is less than the number of nodes.\n\n# [degree adverb]\n    'most trusted': Implies the highest level of trust or reliability, but does not directly affect the coding logic.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially, as each step builds upon the previous one. Parsing the input, selecting a root node, constructing the tree, and formatting the output are distinct tasks that need to be completed in order.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The simple path between nodes 1 and 3 is 1, 3, which does not contain node 2.\n\n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: The simple path between nodes 1 and 3 is 1, 3, which does not contain node 2. The simple path between nodes 3 and 1 is 3, 1, which does not contain node 4.\n\n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected output: 1 3, 3 4, 4 5, 5 2\n    Explanation: The simple path between nodes 1 and 3 is 1, 3, which does not contain node 2. The simple path between nodes 2 and 4", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # However, a simpler approach is to choose a node that is involved in the least number of restrictions.\n        # We can choose node 1 as the root and connect it to all other nodes.\n        \n        # Construct the tree\n        edges = []\n        root = 1\n        for node in range(2, n + 1):\n            edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # However, a simpler approach is to choose a node that is involved in the least number of restrictions.\n        # We can choose node 1 as the root and connect it to all other nodes.\n        \n        # Construct the tree\n        edges = []\n        # Find a node that is not b in any restriction\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a central node that can be used to construct a tree that satisfies all restrictions.\",\n      \"output\": \"A central node for each test case that can be used to construct the tree.\"\n    },\n    {\n      \"description\": \"Construct the tree for each test case using the central node identified, ensuring that the tree satisfies all given restrictions.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree satisfying the restrictions.\"\n    },\n    {\n      \"description\": \"Format the output for each test case as specified, with each edge represented by two integers.\",\n      \"output\": \"Formatted output for each test case, ready to be printed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, determine a suitable central node that can be used to construct the tree.\",\n    \"Using the central node, construct the tree by connecting it to all other nodes, ensuring that no restriction is violated.\",\n    \"Output the constructed tree for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n    'restriction': A condition that specifies a node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes': Refers to the number of nodes in the tree.\n    'n-1 edges': Refers to the number of edges in the tree, which is always one less than the number of nodes.\n    'exactly one simple path': Indicates that there is a unique path between any two nodes in the tree.\n\n# [degree adverb]\n    'most trusted': Implies the highest level of trust or reliability, but does not directly affect the coding logic.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially, but the construction of the tree using the central node should ensure that all restrictions are considered simultaneously. This involves checking each restriction while connecting nodes to the central node.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The path between 1 and 3 does not include 2, satisfying the restriction.\n    \n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 4, 4 2\n    Explanation: The path between 1 and 3 does not include 2, and the path between 3 and 4 does not include 1.\n    \n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected output: 1 3, 3 5, 5 4, 4 2\n    Explanation: Each path satisfies the respective restrictions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    The code should ensure that while constructing the tree, each restriction is checked to avoid placing the restricted node on the path between the specified nodes. This can be done by strategically choosing a central node and connecting other nodes in a way that respects", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Choose a central node that is not involved in any restriction as b\n        # If all nodes are involved, choose any node as central\n        involved_as_b = set(b for _, b, _ in restrictions)\n        central_node = next((node for node in range(1, n + 1) if node not in involved_as_b), 1)\n        \n        # Construct the tree using the central node\n        edges = []\n        for node in range(1, n + 1):\n            if node != central_node:\n                edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Choose a central node that is not involved in any restriction as b\n        # If all nodes are involved, choose any node as central\n        involved_as_b = set(b for _, b, _ in restrictions)\n        central_node = next((node for node in range(1, n + 1) if node not in involved_as_b), 1)\n        \n        # Construct the tree using the central node\n        edges = []\n        for node in range(1, n + 1):\n            if node != central_node:\n                edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"output\": \"A structured representation of the input data, such as a list of test cases where each test case contains the number of nodes, number of restrictions, and a list of restrictions.\"\n    },\n    {\n      \"description\": \"For each test case, identify a central node that can be used as a root for the tree. This node should not be part of any restriction as the middle node.\",\n      \"output\": \"A selected root node for each test case that satisfies the restriction conditions.\"\n    },\n    {\n      \"description\": \"Construct a tree by connecting the root node to all other nodes directly, ensuring that the restrictions are satisfied.\",\n      \"output\": \"A list of edges for each test case that forms a valid tree satisfying all restrictions.\"\n    },\n    {\n      \"description\": \"Format the output to match the required output format, which includes printing the edges for each test case.\",\n      \"output\": \"A formatted string that represents the edges of the tree for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, determine a suitable root node that is not restricted as a middle node in any of the given restrictions.\",\n    \"Construct the tree by connecting the root node to all other nodes, ensuring that no restriction is violated.\",\n    \"Output the edges of the constructed tree for each test case in the specified format.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n    'restriction': A condition that specifies a node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes': The tree must have exactly n nodes.\n    'n-1 edges': The tree must have exactly n-1 edges to be a valid tree.\n    '1 \u2264 m < n': The number of restrictions is less than the number of nodes.\n\n# [degree adverb]\n    'exactly': There must be precisely one simple path between any two nodes in the tree.\n\n# [code logic]\n    The step of determining a suitable root node and constructing the tree by connecting the root node to all other nodes should be considered simultaneously. This can be done by iterating through the nodes to find a suitable root and then directly connecting it to all other nodes.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3, so we connect 1 to 3 and 3 to 2.\n    \n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output: 1 3, 3 2, 3 4\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3, and node 4 cannot be on the path between nodes 3 and 1. We connect 1 to 3, 3 to 2, and 3 to 4.\n    \n    Case 3: n = 5, m = 3, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n    Expected output: 1 3, 3 2, 3 4, 4 5\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3, node 3 cannot be on the path between nodes 2 and 4, and node 4 cannot be on the path between nodes 3 and 5", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a node that is not a middle node in any restriction\n        middle_nodes = set(b for _, b, _ in restrictions)\n        root = next(i for i in range(1, n + 1) if i not in middle_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # Find a node that is not a middle node in any restriction\n        middle_nodes = set(b for _, b, _ in restrictions)\n        root = next(i for i in range(1, n + 1) if i not in middle_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    # Output the results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of nodes, number of restrictions, and the list of restrictions.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the values of n and m.\",\n        \"For each test case, read the m restrictions, each consisting of three integers a, b, c.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a tree that satisfies the restrictions for each test case.\",\n      \"steps\": [\n        \"Identify a central node that can be used to connect other nodes without violating any restrictions.\",\n        \"Iteratively connect nodes to the central node while ensuring that no restriction is violated.\",\n        \"Ensure that the constructed graph is a tree (connected and has n-1 edges).\"\n      ]\n    },\n    {\n      \"description\": \"Output the edges of the constructed tree for each test case.\",\n      \"steps\": [\n        \"For each test case, output n-1 lines representing the edges of the tree.\",\n        \"Ensure the output format matches the required format.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, construct a tree that satisfies the given restrictions.\",\n    \"Output the edges of the constructed tree for each test case.\"\n  ]\n}\n```\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n nodes and n-1 edges'\n    Explanation: This indicates that the tree must have exactly n nodes and n-1 edges, which is a fundamental property of trees.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented in sequence, but within the step \"Iteratively connect nodes to the central node while ensuring that no restriction is violated,\" the logic for checking restrictions and connecting nodes should be handled simultaneously. This can be done using a loop that iterates over nodes and checks restrictions before adding edges.\n\n# [edge case] \n    Edge Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected Output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between 1 and 3, so we connect 1 to 3 and 3 to 2.\n\n    Edge Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected Output: 1 3, 3 2, 3 4\n    Explanation: Node 2 cannot be on the path between 1 and 3, and node 4 cannot be on the path between 3 and 1. Connecting 1 to 3, 3 to 2, and 3 to 4 satisfies both restrictions.\n\n    Edge Case 3: n = 5, m = 0\n    Expected Output: 1 2, 2 3, 3 4, 4 5\n    Explanation: With no restrictions, a simple linear connection satisfies the tree structure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iteratively connecting nodes while checking restrictions should naturally handle these cases.\n\nNO", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        # We can choose any node as the central node, let's choose node 1\n        central_node = 1\n        \n        # Connect all other nodes to the central node\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((central_node, node))\n        \n        results.append(edges)\n    \n    # Output results\n    output = []\n    for edges in results:\n        for u, v in edges:\n            output.append(f\"{u} {v}\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, true, true, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 553, "prompt": "Lord Omkar wants a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to build the tree. However, Lord Omkar has made m (1 \u2264 m < n) limitations to make sure that the tree becomes as divine as possible.\n\nA tree with n nodes is an connected undirected graph with n nodes and n-1 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 15}
