{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "repair_prompt": ["You have an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] composed entirely of zeros and ones. Remember, in this specific problem, unlike others, the indices of the array begin at zero instead of one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules:\n\n1. Initially, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d positions. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n2. Following this, each element of the array a_i is substituted with a_i \\& a^{\u2192 d}_i, where \\& is a logical \"AND\" operator.\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \\& 1, 0 \\& 0, 1 \\& 0, 1 \\& 1], that is [0, 0, 0, 1].\n\nThe process concludes when the array ceases to change. For a given array a, determine if it will consist entirely of zeros at the end of the process. If so, calculate the number of steps the process will take before it stops.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "In one step, the array a is replaced by another array of length n according to the following rules: Initially, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d positions.\n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$.\n\nYou have an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] composed entirely of zeros and ones. Remember, in this specific problem, unlike others, the indices of the array begin at zero instead of one.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You have an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] composed entirely of zeros and ones unlike others, the indices of the array begin at zero instead of one. In one step, the array a is replaced by another array of length n according to the following rules: 1. Initially, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d positions.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while any(arr):\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if arr == arr[-d:]:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()", "completions": ["def calculate_steps(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [1 if a == 1 and b == 1 else 0 for a, b in zip(arr, arr[-d:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n\nmain()", "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while True:\n            shifted_arr = cyclic_shift(arr, d)\n            new_arr = logical_and(arr, shifted_arr)\n            if new_arr == arr:\n                if all(elem == 0 for elem in arr):\n                    return steps\n                else:\n                    return -1\n            arr = new_arr\n            steps += 1\n\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        print(result)\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\ncyclic_shift_and_operation(t, test_cases)\n\nmain()", "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[1:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()", "def calculate_steps(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n\nmain()", "def calculate_steps_to_zeros(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not all_zeros(arr):\n            new_arr = logical_and(arr, cyclic_shift(arr, d))\n            steps += 1\n\n            if new_arr == arr:\n                steps = -1\n                break\n\n            arr = new_arr\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Calculate and output results\nresults = calculate_steps_to_zeros(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        seen = set()\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[(i - d) % n] & arr[i]\n            if new_arr == arr:\n                return steps\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def apply_operation(arr, d):\n        steps = 0\n        while True:\n            new_arr = [(arr[(i - d) % len(arr)] & arr[i]) for i in range(len(arr))]\n            if new_arr == arr:\n                return steps if 1 not in arr else -1\n            arr = new_arr\n            steps += 1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        result = apply_operation(arr, d)\n        results.append(result)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Get results\nresults = cyclic_shift_and_operation(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n\nmain()", "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()", "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while any(arr):\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if arr == arr[-d:]:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"Handle the case where there are still elements equal to 1 in the array after the end of the process\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, calculate the number of steps required to have an array containing only zeros\",\n    \"If there are still elements equal to 1 in the array after the end of the process, output -1\",\n    \"Output the result for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The array is shifted cyclically to the right by a certain number of positions in each step.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different subproblems and calculations.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Explanation:\n    The edge cases are based on different array sizes and initial configurations. The expected outputs are determined by the specific cyclic shifts and the resulting arrays.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while any(arr):\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if arr == arr[-d:]:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while any(arr):\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if arr == arr[-d:]:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size with cyclic shift offset for each test case\",\n    \"For each test case, calculate the number of steps after which the array will contain only zeros or -1 if there are still elements equal to 1\",\n    \"Implement the cyclic shift operation to update the array based on the given offset\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases\",\n    \"For each test case, parse the array size and cyclic shift offset\",\n    \"Parse the elements of the array for each test case\",\n    \"Implement a function to calculate the number of steps required to have only zeros in the array or return -1 if there are still elements equal to 1\",\n    \"Implement the cyclic shift operation to update the array based on the given offset\",\n    \"Print the answer for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The array is shifted to the right by a certain number of positions in a circular manner.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [1 if a == 1 and b == 1 else 0 for a, b in zip(arr, arr[-d:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 23)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [1 if a == 1 and b == 1 else 0 for a, b in zip(arr, arr[-d:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size with cyclic shift offset for each test case\",\n    \"For each test case, calculate the number of steps after which the array will contain only zeros or -1 if there are still elements equal to 1\",\n    \"Implement the cyclic shift operation to update the array based on the given offset\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case descriptions\",\n    \"step_2\": \"For each test case, calculate the number of steps required to have only zeros in the array\",\n    \"step_3\": \"Implement the cyclic shift operation to update the array based on the given offset\",\n    \"step_4\": \"Output the results for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The array is shifted cyclically to the right by a certain number of positions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the details of each test case\",\n      \"For each test case, extract the array size, cyclic shift offset, and elements of the array\",\n      \"Implement the logic to cyclically shift the array to the right by d positions\",\n      \"Implement the logic to perform element-wise logical 'AND' operation between the original array and the shifted array\",\n      \"Repeat the shifting and 'AND' operation until the array ceases to change or all elements become zeros\",\n      \"Calculate the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"high_level_steps\": [\n      \"Parse the input to extract the number of test cases and the details of each test case\",\n      \"For each test case, extract the array size, cyclic shift offset, and elements of the array\",\n      \"Initialize a counter to keep track of the number of steps taken\",\n      \"Repeat the following steps until the array contains only zeros or all elements become zeros:\",\n      \"  - Cyclically shift the array to the right by d positions\",\n      \"  - Perform element-wise logical 'AND' operation between the original array and the shifted array\",\n      \"  - Increment the counter by 1\",\n      \"If the array contains only zeros, output the number of steps taken\",\n      \"If the array still contains elements equal to 1 after all steps, output -1\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a specified number of positions.\n    'logical \"AND\" operation': It is a bitwise operation that returns 1 if both bits are 1, otherwise 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    1 1\n    0  = 0\n    Explanation: The array is already all zeros, so the expected output is 0.\n    2 1\n    1 0 = 1\n    Explanation: The array will not change as it shifts by 1 to the right, so the expected output is 1.\n    3 1\n    1 1 0 = 2\n    Explanation: The array will change as follows: [1, 1, 0] -> [0, 1, 1] -> [1, 0, 1] -> [1, 1, 0]. It takes 2 steps to reach all zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if all(elem == 0 for elem in a):\n            return 0\n        elif all(elem == 1 for elem in a):\n            return -1\n        (other code)\n\nNO", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while True:\n            shifted_arr = cyclic_shift(arr, d)\n            new_arr = logical_and(arr, shifted_arr)\n            if new_arr == arr:\n                if all(elem == 0 for elem in arr):\n                    return steps\n                else:\n                    return -1\n            arr = new_arr\n            steps += 1\n\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        print(result)\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\ncyclic_shift_and_operation(t, test_cases)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while True:\n            shifted_arr = cyclic_shift(arr, d)\n            new_arr = logical_and(arr, shifted_arr)\n            if new_arr == arr:\n                if all(elem == 0 for elem in arr):\n                    return steps\n                else:\n                    return -1\n            arr = new_arr\n            steps += 1\n\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        print(result)\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\ncyclic_shift_and_operation(t, test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros for each test case\",\n    \"Handle the case where there are still elements equal to 1 in the array after the end of the process\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, implement a function to calculate the number of steps required to have only zeros in the array\",\n    \"If there are still elements equal to 1 in the array after the end of the process, output -1\",\n    \"Output the result for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The array is shifted cyclically to the right by a certain number of positions in each step.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first case, after 1 step, the array will contain only zeros.\n    - In the second case, after 1 step, the array will contain only zeros.\n    - In the third case, after 3 steps, the array will contain only zeros.\n    - In the fourth case, the array will never contain only zeros, so the output is -1.\n    - In the fifth case, the array already contains only zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[1:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 23)"}, "Round_1": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[1:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size with cyclic shift offset for each test case\",\n    \"For each test case, calculate the number of steps after which the array will contain only zeros or -1 if there are still elements equal to 1\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases\",\n    \"For each test case, parse the input to extract the array size and cyclic shift offset\",\n    \"Parse the input to extract the elements of the array\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros or -1\",\n    \"For each test case, call the function and print the result\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The array is shifted cyclically to the right by a certain number of positions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, calculating steps, and printing results.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should handle all cases appropriately.", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 22)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the details of each test case\",\n      \"For each test case, calculate the number of steps required to transform the array into all zeros or determine if it is not possible\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases from input\",\n      \"Iterate over each test case\",\n      \"Parse the array size, cyclic shift offset, and array elements for the current test case\",\n      \"Implement the logic to calculate the number of steps required to transform the array into all zeros or determine if it is not possible\",\n      \"Output the result for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a certain offset.\n\n    'logical \"AND\" operator': It is a bitwise operator that performs the AND operation on each pair of corresponding bits of the operands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different subproblems and calculations.\n\n# [edge case] \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: The array will change as follows: [0, 1] -> [1, 0] after one step.\n\n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: The array will change as follows: [1, 1, 0, 1, 0] -> [1, 0, 0, 1, 0] -> [1, 0, 1, 0, 0] -> [0, 0, 0, 0, 0] after 3 steps.\n\n    4 2\n    0 1 0 1\n    Expected Output: -1\n    Explanation: The array will not change as it shifts by 2 to the right, so each element will be calculated as 0 & 0 or 1 & 1, thus not changing its value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should handle all scenarios appropriately.", "Round_0": {"code": "def calculate_steps_to_zeros(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not all_zeros(arr):\n            new_arr = logical_and(arr, cyclic_shift(arr, d))\n            steps += 1\n\n            if new_arr == arr:\n                steps = -1\n                break\n\n            arr = new_arr\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Calculate and output results\nresults = calculate_steps_to_zeros(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 50)"}, "Round_1": {"code": "def calculate_steps_to_zeros(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not all_zeros(arr):\n            new_arr = logical_and(arr, cyclic_shift(arr, d))\n            steps += 1\n\n            if new_arr == arr:\n                steps = -1\n                break\n\n            arr = new_arr\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Calculate and output results\nresults = calculate_steps_to_zeros(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the details of each test case\",\n      \"For each test case, perform the cyclic shift operation and logical AND operation until the array ceases to change\",\n      \"Check if the array consists entirely of zeros at the end of the process\",\n      \"Calculate the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"high-level_steps\": [\n      \"Parse the input to extract the number of test cases\",\n      \"Iterate over each test case\",\n      \"Perform the cyclic shift operation and logical AND operation until the array ceases to change\",\n      \"Check if the array consists entirely of zeros\",\n      \"Calculate the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\",\n      \"Output the result for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a specified offset.\n    'logical AND operation': It is a bitwise operation that results in 1 only if both bits are 1, otherwise 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and dependent on each other.\n\n# [edge case] \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: The array will change from [0, 1] to [1, 0] after the first step.\n    \n    3 2\n    0 1 0\n    Expected Output: 1\n    Explanation: The array will change from [0, 1, 0] to [0, 0, 0] after the first step.\n    \n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: The array will change from [1, 1, 0, 1, 0] to [0, 0, 0, 0, 0] after 3 steps.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        seen = set()\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[(i - d) % n] & arr[i]\n            if new_arr == arr:\n                return steps\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        seen = set()\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[(i - d) % n] & arr[i]\n            if new_arr == arr:\n                return steps\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the details of each test case\",\n      \"For each test case, apply the cyclic shift and logical 'AND' operation until the array consists entirely of zeros or the process stops\",\n      \"Determine the number of steps taken for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases from input\",\n      \"Iterate over each test case\",\n      \"Parse the array size, cyclic shift offset, and elements of the array for the current test case\",\n      \"Apply the cyclic shift and logical 'AND' operation until the array consists entirely of zeros or the process stops\",\n      \"Determine the number of steps taken and output the result\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': In this requirement, cyclic shift means shifting the elements of the array to the right by a certain number of positions, where the last element wraps around to the beginning.\n    'logical AND operation': Refers to performing a bitwise AND operation on each element of the array with the corresponding element of the shifted array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve processing the array in a specific order.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - For the first test case, after the first step, the array becomes [0, 0] which consists entirely of zeros, so the answer is 1.\n    - For the second test case, after the first step, the array becomes [0, 0, 0] which consists entirely of zeros, so the answer is 1.\n    - For the third test case, it takes 3 steps for the array to consist entirely of zeros.\n    - For the fourth test case, the array will never contain only zeros, so the answer is -1.\n    - For the fifth test case, the array is already [0], so the answer is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def apply_operation(arr, d):\n        steps = 0\n        while True:\n            new_arr = [(arr[(i - d) % len(arr)] & arr[i]) for i in range(len(arr))]\n            if new_arr == arr:\n                return steps if 1 not in arr else -1\n            arr = new_arr\n            steps += 1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        result = apply_operation(arr, d)\n        results.append(result)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Get results\nresults = cyclic_shift_and_operation(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 44)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def apply_operation(arr, d):\n        steps = 0\n        while True:\n            new_arr = [(arr[(i - d) % len(arr)] & arr[i]) for i in range(len(arr))]\n            if new_arr == arr:\n                return steps if 1 not in arr else -1\n            arr = new_arr\n            steps += 1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        result = apply_operation(arr, d)\n        results.append(result)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Get results\nresults = cyclic_shift_and_operation(t, test_cases)\n\n# Output results\nfor result in results:\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"Handle the case where there are still elements equal to 1 in the array after the end of the process\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, calculate the number of steps required to have an array containing only zeros\",\n    \"If there are still elements equal to 1 in the array after the end of the process, output -1\",\n    \"Output the result for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The array is shifted cyclically to the right by a certain number of positions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first case, after 1 step, the array will contain only zeros.\n    - In the second case, after 1 step, the array will contain only zeros.\n    - In the third case, after 3 steps, the array will contain only zeros.\n    - In the fourth case, the array will never contain only zeros, so the output is -1.\n    - In the fifth case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 23)"}, "Round_1": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"Handle the case where there are still elements equal to 1 in the array after the end of the process\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, calculate the number of steps required to have an array containing only zeros\",\n    \"If there are still elements equal to 1 in the array after the end of the process, output -1\",\n    \"Output the result for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The array is shifted cyclically to the right by a certain number of positions in each step.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different subproblems and calculations.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Explanation:\n    The edge cases are based on different array sizes and initial configurations. The expected outputs are determined by the specific cyclic shifts and the resulting arrays.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while any(arr):\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if arr == arr[-d:]:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while any(arr):\n        steps += 1\n        arr = arr[-d:] + arr[:-d]\n        arr = [a & b for a, b in zip(arr, arr[-d:])]\n        if arr == arr[-d:]:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n"}}], "scores": [], "pass_results": [false, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 83, "prompt": "You have an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] composed entirely of zeros and ones. Remember, in this specific problem, unlike others, the indices of the array begin at zero instead of one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules:\n\n1. Initially, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d positions. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n2. Following this, each element of the array a_i is substituted with a_i \\& a^{\u2192 d}_i, where \\& is a logical \"AND\" operator.\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \\& 1, 0 \\& 0, 1 \\& 0, 1 \\& 1], that is [0, 0, 0, 1].\n\nThe process concludes when the array ceases to change. For a given array a, determine if it will consist entirely of zeros at the end of the process. If so, calculate the number of steps the process will take before it stops.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 62}
