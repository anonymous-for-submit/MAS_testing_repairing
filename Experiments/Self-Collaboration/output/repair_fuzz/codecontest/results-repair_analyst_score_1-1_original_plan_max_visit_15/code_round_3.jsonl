{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "repair_prompt": ["Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Ensure your solution is efficient even for large grid sizes.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. The city is represented on a grid which includes telephone poles at specific points, and the project supervisor needs to calculate the sum of squared distances from each point in the grid to its nearest pole for optimal building planning.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Mr. Chanek's city can be represented as a plane and he wants to build a housing complex on it. There are telephone poles on the plane, represented by a grid of size (n + 1) \u00d7 (m + 1), and S(x, y) is the square of the Euclidean distance between the nearest pole and (x, y). What is the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m to optimize the building plan, ensuring efficiency for large grid sizes?\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n\nmain()", "completions": ["import sys\n\ndef calculate_distance(grid, n, m):\n    distances = [[float('inf') for _ in range(m+1)] for _ in range(n+1)]\n    \n    # Find the positions of telephone poles\n    poles = []\n    for i in range(n+1):\n        for j in range(m+1):\n            if grid[i][j] == '1':\n                poles.append((i, j))\n    \n    # Calculate the distance to the nearest pole for each point on the grid\n    for i in range(n+1):\n        for j in range(m+1):\n            for pole in poles:\n                x, y = pole\n                distance = (i - x)**2 + (j - y)**2\n                distances[i][j] = min(distances[i][j], distance)\n    \n    # Sum up all the calculated distances\n    total_distance = sum(sum(row) for row in distances)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_distance(n, m, grid):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n\n    result = calculate_distance(n, m, grid)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_distance(grid, n, m):\n    distances = [[float('inf') for _ in range(m+1)] for _ in range(n+1)]\n    \n    # Find the positions of telephone poles\n    poles = [(i, j) for i in range(n+1) for j in range(m+1) if grid[i][j] == '1']\n    \n    # Calculate the distance to the nearest pole for each point on the grid\n    for i in range(n+1):\n        for j in range(m+1):\n            for pole in poles:\n                distance = (i - pole[0])**2 + (j - pole[1])**2\n                distances[i][j] = min(distances[i][j], distance)\n    \n    # Sum up all the calculated distances\n    total_distance = sum(sum(row) for row in distances)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    # Read input from standard input\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n+1)]\n    \n    # Calculate the total distance\n    result = calculate_distance(grid, n, m)\n    \n    # Output the result to standard output\n    print(result)\n\nmain()", "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n\n    result = calculate_distance(grid, n, m)\n    print(result)\n\nmain()", "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point and the nearest pole\",\n    \"Sum up all the calculated distances for each point on the grid\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the grid size and positions of telephone poles\",\n    \"Iterate through each point on the grid\",\n    \"For each point, find the nearest pole and calculate the square of the Euclidean distance\",\n    \"Sum up all the calculated distances to get the final output\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance'\n    Explanation: The Euclidean distance is the straight-line distance between two points in Euclidean space.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through the grid, finding the nearest pole, calculating distances, and summing them up.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). The sum of all S(x, y) for each point is (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Input\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output\n    36\n    Explanation: In this case, the sum of all S(x, y) for each point is 36.\n\n    Input\n    1 1\n    1\n    1\n    Output\n    0\n    Explanation: In this case, the nearest telephone pole is at (0, 0), so the sum of all S(x, y) for each point is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should handle all cases efficiently.", "Round_0": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 31)"}, "Round_1": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point on the grid and the nearest pole\",\n    \"Sum up all the calculated distances to get the final result\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"step_2\": \"Iterate through each point on the grid and calculate the distance to the nearest pole\",\n    \"step_3\": \"Sum up all the calculated distances to get the final result\",\n    \"step_4\": \"Output the final result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance': The Euclidean distance is the straight-line distance between two points in Euclidean space. In this context, it represents the distance between a point on the grid and the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they are dependent on each other. \n    Step 1: Parse the input to get the size of the grid and the positions of telephone poles.\n    Step 2: Iterate through each point on the grid and calculate the distance to the nearest pole.\n    Step 3: Sum up all the calculated distances to get the final result.\n    Step 4: Output the final result.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    0 0\n    1\n    Output:\n    0\n    Explanation: When there is only one pole at (0, 0), the sum of distances for all points is 0.\n\n    Edge Case 2:\n    Input:\n    1 1\n    10\n    01\n    Output:\n    2\n    Explanation: The nearest pole for (0, 0) is at (0, 0) with distance 0, and for (1, 1) is at (1, 1) with distance 0. The sum is 0 + 2 = 2.\n\n    Edge Case 3:\n    Input:\n    2 2\n    101\n    010\n    101\n    Output:\n    12\n    Explanation: The sum of distances for all points is 12.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic should cover all scenarios.", "Round_0": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    distances = [[float('inf') for _ in range(m+1)] for _ in range(n+1)]\n    \n    # Find the positions of telephone poles\n    poles = []\n    for i in range(n+1):\n        for j in range(m+1):\n            if grid[i][j] == '1':\n                poles.append((i, j))\n    \n    # Calculate the distance to the nearest pole for each point on the grid\n    for i in range(n+1):\n        for j in range(m+1):\n            for pole in poles:\n                x, y = pole\n                distance = (i - x)**2 + (j - y)**2\n                distances[i][j] = min(distances[i][j], distance)\n    \n    # Sum up all the calculated distances\n    total_distance = sum(sum(row) for row in distances)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 38)"}, "Round_1": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    distances = [[float('inf') for _ in range(m+1)] for _ in range(n+1)]\n    \n    # Find the positions of telephone poles\n    poles = []\n    for i in range(n+1):\n        for j in range(m+1):\n            if grid[i][j] == '1':\n                poles.append((i, j))\n    \n    # Calculate the distance to the nearest pole for each point on the grid\n    for i in range(n+1):\n        for j in range(m+1):\n            for pole in poles:\n                x, y = pole\n                distance = (i - x)**2 + (j - y)**2\n                distances[i][j] = min(distances[i][j], distance)\n    \n    # Sum up all the calculated distances\n    total_distance = sum(sum(row) for row in distances)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles in the grid\",\n    \"Calculate the squared distance from each point in the grid to its nearest pole\",\n    \"Sum up the squared distances for all points in the grid\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"step_2\": \"Iterate through each point in the grid and calculate the squared distance to the nearest pole\",\n    \"step_3\": \"Sum up all the squared distances to get the final output\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'squared distances'\n    Explanation: The squared distance refers to the square of the Euclidean distance between two points on a plane.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different calculations and iterations.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). The sum of squared distances is (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Input\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output\n    36\n    Explanation: The calculation for this case follows the same logic as above.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 32)"}, "Round_1": {"code": "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles in the grid\",\n    \"Calculate the squared distance from each point in the grid to its nearest pole\",\n    \"Sum up the squared distances for all points in the grid\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"step_2\": \"Iterate through each point in the grid and calculate the squared distance to the nearest pole\",\n    \"step_3\": \"Sum up all the squared distances to get the final output\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'squared distances'\n    Explanation: The squared distance refers to the square of the Euclidean distance between two points on a plane.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different calculations and iterations.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). The nearest pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). The sum of squared distances is (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Input\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output\n    36\n    Explanation: The calculation follows the same logic as above.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 32)"}, "Round_1": {"code": "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point and the nearest pole\",\n    \"Sum up all the calculated distances for each point on the grid\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the grid size and positions of telephone poles\",\n    \"Iterate through each point on the grid\",\n    \"For each point, find the nearest pole and calculate the square of the Euclidean distance\",\n    \"Sum up all the calculated distances to get the final output\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance'\n    Explanation: The Euclidean distance is the straight-line distance between two points in Euclidean space.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through the grid, finding the nearest pole, calculating distances, and summing them up.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: In this case, the nearest telephone pole for each point is calculated and the sum of the squared Euclidean distances is 18.\n\n    Input\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output\n    36\n    Explanation: The sum of squared Euclidean distances for this grid is 36.\n\n    Input\n    1 1\n    1\n    Output\n    2\n    Explanation: The sum of squared Euclidean distances for this grid is 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 32)"}, "Round_1": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point and the nearest pole\",\n    \"Sum up all the calculated distances for each point on the grid\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"Iterate through each point on the grid\",\n    \"For each point, calculate the square of the Euclidean distance to the nearest pole\",\n    \"Sum up all the calculated distances for each point\",\n    \"Output the final sum\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance'\n    Explanation: The Euclidean distance is the straight-line distance between two points in Euclidean space.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through points, calculating distances, summing up distances, and outputting the result.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). The sum of all S(x, y) for each point is calculated as (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Input\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output\n    36\n    Explanation: The sum of all S(x, y) for each point in this case is 36.\n\n    Input\n    3 3\n    100\n    010\n    001\n    000\n    Output\n    14\n    Explanation: The sum of all S(x, y) for each point in this case is 14.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 31)"}, "Round_1": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point and the nearest pole\",\n    \"Sum up all the calculated distances for each point on the grid\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"Iterate through each point on the grid and calculate the square of the Euclidean distance to the nearest pole\",\n    \"Sum up all the calculated distances to get the final output\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance'\n    Explanation: The Euclidean distance is the straight-line distance between two points in Euclidean space.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through each point, and summing up the distances.\n\n# [edge case] \n    Input\n    0 0\n    1\n    Output\n    0\n    Explanation: When there is only one pole at (0, 0), the sum of distances for all points is 0.\n    \n    Input\n    1 1\n    10\n    01\n    Output\n    2\n    Explanation: The nearest pole for (0, 0) is at (0, 1) with distance 1, and for (1, 1) is at (1, 0) with distance 1. Sum = 1 + 1 = 2.\n    \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: Detailed explanation provided in the requirement.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should handle all cases effectively.", "Round_0": {"code": "import sys\n\ndef calculate_distance(n, m, grid):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n\n    result = calculate_distance(n, m, grid)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 31)"}, "Round_1": {"code": "import sys\n\ndef calculate_distance(n, m, grid):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n\n    result = calculate_distance(n, m, grid)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point on the grid and the nearest pole\",\n    \"Sum up all the calculated distances to get the final result\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"step_2\": \"Iterate through each point on the grid and calculate the distance to the nearest pole\",\n    \"step_3\": \"Sum up all the calculated distances to get the final result\",\n    \"step_4\": \"Output the final result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance': It is the straight-line distance between two points in Euclidean space. In this context, it represents the distance between a point on the grid and the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different calculations and operations.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation:\n    In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m is calculated as (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the calculations for all grid sizes.", "Round_0": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    distances = [[float('inf') for _ in range(m+1)] for _ in range(n+1)]\n    \n    # Find the positions of telephone poles\n    poles = [(i, j) for i in range(n+1) for j in range(m+1) if grid[i][j] == '1']\n    \n    # Calculate the distance to the nearest pole for each point on the grid\n    for i in range(n+1):\n        for j in range(m+1):\n            for pole in poles:\n                distance = (i - pole[0])**2 + (j - pole[1])**2\n                distances[i][j] = min(distances[i][j], distance)\n    \n    # Sum up all the calculated distances\n    total_distance = sum(sum(row) for row in distances)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    # Read input from standard input\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n+1)]\n    \n    # Calculate the total distance\n    result = calculate_distance(grid, n, m)\n    \n    # Output the result to standard output\n    print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles in the grid\",\n    \"Calculate the squared distance from each point in the grid to its nearest pole\",\n    \"Sum up the squared distances for all points in the grid\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"step_2\": \"Iterate through each point in the grid and calculate the squared distance to the nearest pole\",\n    \"step_3\": \"Sum up all the squared distances to get the final output\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'squared distance'\n    Explanation: The squared distance refers to the square of the Euclidean distance between two points on a plane.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they are dependent on each other.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). The nearest pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). The sum of squared distances is (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Input\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output\n    36\n    Explanation: The calculation follows the same logic as above.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 32)"}, "Round_1": {"code": "import sys\n\ndef calculate_squared_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x - i) ** 2 + (y - j) ** 2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n\n    result = calculate_squared_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point on the grid and the nearest pole\",\n    \"Sum up all the calculated distances to get the final result\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to get the size of the grid and the positions of telephone poles\",\n    \"step_2\": \"Iterate through each point on the grid and calculate the distance to the nearest pole\",\n    \"step_3\": \"Sum up all the calculated distances to get the final result\",\n    \"step_4\": \"Output the final result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance': The Euclidean distance is the straight-line distance between two points in Euclidean space. In this context, it represents the distance between a point on the grid and the nearest telephone pole.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different calculations and operations.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation:\n    In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m is calculated as (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n\n    result = calculate_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 31)"}, "Round_1": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n\n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n\n    result = calculate_distance(grid, n, m)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the positions of telephone poles on the grid\",\n    \"Calculate the square of the Euclidean distance between each point and the nearest pole\",\n    \"Sum up all the calculated distances for each point on the grid\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the grid size and positions of telephone poles\",\n    \"Iterate through each point on the grid\",\n    \"For each point, find the nearest pole and calculate the square of the Euclidean distance\",\n    \"Sum up all the calculated distances to get the final output\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Euclidean distance'\n    Explanation: The Euclidean distance is the straight-line distance between two points in Euclidean space.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through the grid, finding the nearest pole, calculating distances, and summing them up.\n\n# [edge case] \n    Input\n    2 2\n    101\n    000\n    000\n    Output\n    18\n    Explanation: In this case, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). The sum of all S(x, y) for each point is (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n\n    Input\n    5 4\n    10010\n    00000\n    01000\n    00001\n    00100\n    00010\n    Output\n    36\n    Explanation: In this case, the sum of all S(x, y) for each point is 36.\n\n    Input\n    1 1\n    1\n    1\n    Output\n    0\n    Explanation: In this case, the nearest telephone pole is at (0, 0), so the sum of all S(x, y) for each point is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should handle all cases efficiently.", "Round_0": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 31)"}, "Round_1": {"code": "import sys\n\ndef calculate_distance(grid, n, m):\n    def nearest_pole_distance(x, y):\n        min_distance = float('inf')\n        for i in range(n+1):\n            for j in range(m+1):\n                if grid[i][j] == 1:\n                    min_distance = min(min_distance, (x-i)**2 + (y-j)**2)\n        return min_distance\n\n    total_distance = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            total_distance += nearest_pole_distance(i, j)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n+1)]\n    \n    result = calculate_distance(grid, n, m)\n    print(result)\n"}}], "scores": [], "pass_results": [true, false, true, true, true, true, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 3, "prompt": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}. Ensure your solution is efficient even for large grid sizes.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 3}
