{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i and a difficulty b_i (both are integers from 1 to n); all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to calculate the number of methods to choose three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i and a difficulty b_i (both are integers from 1 to n); all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Calculate the number of methods to choose three problems for the problemset, considering cases where n is small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp, the coach of the Berland State University programming teams, has n problems that none of his students have seen yet. Monocarp wants to select exactly 3 problems from n problems, ensuring that either the topics or difficulties of the selected problems are different. Calculate the number of methods to choose three problems for the problem set, considering edge cases where n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate over each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize lists to store topics and difficulties\n    topics = []\n    difficulties = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.append(a)\n        difficulties.append(b)\n    \n    # Initialize a counter for valid selections\n    count = 0\n    \n    # Calculate the number of ways to select three training problems\n    for comb in combinations(range(n), 3):\n        selected_topics = set([topics[i] for i in comb])\n        selected_difficulties = set([difficulties[i] for i in comb])\n        \n        if len(selected_topics) == 3 or len(selected_difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current test case\n    print(count)\n\nmain()", "completions": ["def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics:\n            print(n * (n - 1) * (n - 2) // 6)\n        else:\n            print(n * (n - 1) * (n - 2) // 2)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    def count_unique_topics_and_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_ways_to_select(problems):\n        topics, difficulties = count_unique_topics_and_difficulties(problems)\n        total_ways = 0\n        for topic, count_topic in topics.items():\n            for difficulty, count_difficulty in difficulties.items():\n                if (count_topic > 1 and count_difficulty > 1) or (count_topic > 2) or (count_difficulty > 2):\n                    total_ways += count_topic * count_difficulty * (count_topic - 1) // 2 * (count_difficulty - 1) // 2\n        return total_ways\n\n    results = []\n    for problems in testcases:\n        ways = calculate_ways_to_select(problems)\n        results.append(ways)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = count_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            pairs += arr[i] * (arr[i] - 1) // 2\n        return pairs\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n\n        total_pairs_topics = count_pairs(list(topics.values()))\n        total_pairs_difficulties = count_pairs(list(difficulties.values()))\n\n        total_problems = len(problems)\n        ways = total_pairs_topics + total_pairs_difficulties - (total_problems * (total_problems - 1) // 2)\n        results.append(ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            pairs += arr[i] * (arr[i] - 1) // 2\n        return pairs\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n\n        total_ways = count_pairs(list(topics.values())) + count_pairs(list(difficulties.values()))\n        for topic_count in topics.values():\n            total_ways -= topic_count * (topic_count - 1) // 2\n        for difficulty_count in difficulties.values():\n            total_ways -= difficulty_count * (difficulty_count - 1) // 2\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n    for result in results:\n        print(result)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a].append(i)\n            difficulties[b].append(i)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        for topic_list in topics.values():\n            total_ways -= len(topic_list) * (len(topic_list) - 1) * (len(topic_list) - 2) // 6\n        \n        for difficulty_list in difficulties.values():\n            total_ways -= len(difficulty_list) * (len(difficulty_list) - 1) * (len(difficulty_list) - 2) // 6\n        \n        for topic_list in topics.values():\n            for difficulty_list in difficulties.values():\n                common_problems = len(set(topic_list) & set(difficulty_list))\n                total_ways += common_problems * (common_problems - 1) * (common_problems - 2) // 6\n        \n        print(total_ways)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_unique_topics_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_combinations(n):\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for problems in testcases:\n        topics, difficulties = count_unique_topics_difficulties(problems)\n        unique_topics = len(topics)\n        unique_difficulties = len(difficulties)\n        if unique_topics >= 3 or unique_difficulties >= 3:\n            results.append(calculate_combinations(len(problems)))\n        else:\n            results.append(0)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways(n, problems):\n    topics_count = defaultdict(int)\n    difficulties_count = defaultdict(int)\n    for topic, difficulty in problems:\n        topics_count[topic] += 1\n        difficulties_count[difficulty] += 1\n    \n    total_ways = 0\n    for topic, count in topics_count.items():\n        total_ways += count * (count - 1) * (count - 2) // 6\n    \n    for difficulty, count in difficulties_count.items():\n        total_ways += count * (count - 1) * (count - 2) // 6\n    \n    for topic, topic_count in topics_count.items():\n        for difficulty, difficulty_count in difficulties_count.items():\n            total_ways -= topic_count * (topic_count - 1) // 2 * difficulty_count\n    \n    return total_ways\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    ways = calculate_ways(n, problems)\n    print(ways)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a].append(i)\n            difficulties[b].append(i)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        for topic in topics.values():\n            total_ways -= len(topic) * (len(topic) - 1) * (len(topic) - 2) // 6\n        \n        for difficulty in difficulties.values():\n            total_ways -= len(difficulty) * (len(difficulty) - 1) * (len(difficulty) - 2) // 6\n        \n        for topic in topics.values():\n            for difficulty in difficulties.values():\n                common = len(set(topic) & set(difficulty))\n                total_ways += common * (common - 1) * (common - 2) // 6\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways(testcases)\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_ways = min(n, min(len(topics), len(difficulties)) + max(0, n - max(len(topics), len(difficulties)))\n        \n        print(num_ways)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate over each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize lists to store topics and difficulties\n    topics = []\n    difficulties = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.append(a)\n        difficulties.append(b)\n    \n    # Initialize a counter for valid selections\n    count = 0\n    \n    # Calculate the number of ways to select three training problems\n    for comb in combinations(range(n), 3):\n        selected_topics = set([topics[i] for i in comb])\n        selected_difficulties = set([difficulties[i] for i in comb])\n        \n        if len(selected_topics) == 3 or len(selected_difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current test case\n    print(count)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each test case\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics and difficulties'\n    Explanation: The requirement states that the selected problems should have either different topics or different difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, calculating combinations, and outputting results.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: All problems have different topics and difficulties, so there is only one way to select three problems.\n\n    Input\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output\n    0\n    Explanation: All problems have the same topic but different difficulties, so it's not possible to select three problems meeting the requirements.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: All problems have different topics and difficulties, so there are four ways to select three problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate over each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize lists to store topics and difficulties\n    topics = []\n    difficulties = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.append(a)\n        difficulties.append(b)\n    \n    # Initialize a counter for valid selections\n    count = 0\n    \n    # Calculate the number of ways to select three training problems\n    for comb in combinations(range(n), 3):\n        selected_topics = set([topics[i] for i in comb])\n        selected_difficulties = set([difficulties[i] for i in comb])\n        \n        if len(selected_topics) == 3 or len(selected_difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current test case\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 40)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate over each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize lists to store topics and difficulties\n    topics = []\n    difficulties = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.append(a)\n        difficulties.append(b)\n    \n    # Initialize a counter for valid selections\n    count = 0\n    \n    # Calculate the number of ways to select three training problems\n    for comb in combinations(range(n), 3):\n        selected_topics = set([topics[i] for i in comb])\n        selected_difficulties = set([difficulties[i] for i in comb])\n        \n        if len(selected_topics) == 3 or len(selected_difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current test case\n    print(count)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Handle edge cases where the number of problems n might be small\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting 3 problems based on topics and difficulties, ensuring they are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    Test Case 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output: 3\n    Explanation: Three possible sets of problems can be selected: (1, 2, 4), (1, 3, 4), (2, 3, 4).\n\n    Test Case 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output: 10\n    Explanation: There are 10 ways to select 3 problems satisfying the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics:\n            print(n * (n - 1) * (n - 2) // 6)\n        else:\n            print(n * (n - 1) * (n - 2) // 2)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 27)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics:\n            print(n * (n - 1) * (n - 2) // 6)\n        else:\n            print(n * (n - 1) * (n - 2) // 2)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"Read the topic and difficulty of each problem for each testcase\",\n    \"Calculate the number of ways to select three training problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"Step 2\": \"For each testcase, read the topic and difficulty of each problem\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose 3 problems from a given set of problems, ensuring that either the topics or difficulties are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this edge case, all problems have unique topics and difficulties, so there is only one way to select 3 problems.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: In this edge case, all problems have the same topic but different difficulties, making it impossible to select 3 problems with different topics or difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this edge case, all problems have unique topics and difficulties, allowing for 4 ways to select 3 problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    def count_unique_topics_and_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_ways_to_select(problems):\n        topics, difficulties = count_unique_topics_and_difficulties(problems)\n        total_ways = 0\n        for topic, count_topic in topics.items():\n            for difficulty, count_difficulty in difficulties.items():\n                if (count_topic > 1 and count_difficulty > 1) or (count_topic > 2) or (count_difficulty > 2):\n                    total_ways += count_topic * count_difficulty * (count_topic - 1) // 2 * (count_difficulty - 1) // 2\n        return total_ways\n\n    results = []\n    for problems in testcases:\n        ways = calculate_ways_to_select(problems)\n        results.append(ways)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = count_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 45)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    def count_unique_topics_and_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_ways_to_select(problems):\n        topics, difficulties = count_unique_topics_and_difficulties(problems)\n        total_ways = 0\n        for topic, count_topic in topics.items():\n            for difficulty, count_difficulty in difficulties.items():\n                if (count_topic > 1 and count_difficulty > 1) or (count_topic > 2) or (count_difficulty > 2):\n                    total_ways += count_topic * count_difficulty * (count_topic - 1) // 2 * (count_difficulty - 1) // 2\n        return total_ways\n\n    results = []\n    for problems in testcases:\n        ways = calculate_ways_to_select(problems)\n        results.append(ways)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = count_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems. Each problem has a unique combination of topic and difficulty.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input data and calculating the result.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this edge case, all problems have different topics and difficulties, so there is only one way to select three problems.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: In this edge case, all problems have the same topic but different difficulties, so it's not possible to select three problems that meet the requirements.\n\n    Input:\n    1\n    3\n    1 1\n    2 1\n    3 1\n    Output:\n    0\n    Explanation: In this edge case, all problems have the same difficulty but different topics, so it's not possible to select three problems that meet the requirements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            pairs += arr[i] * (arr[i] - 1) // 2\n        return pairs\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n\n        total_pairs_topics = count_pairs(list(topics.values()))\n        total_pairs_difficulties = count_pairs(list(difficulties.values()))\n\n        total_problems = len(problems)\n        ways = total_pairs_topics + total_pairs_difficulties - (total_problems * (total_problems - 1) // 2)\n        results.append(ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 44)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            pairs += arr[i] * (arr[i] - 1) // 2\n        return pairs\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n\n        total_pairs_topics = count_pairs(list(topics.values()))\n        total_pairs_difficulties = count_pairs(list(difficulties.values()))\n\n        total_problems = len(problems)\n        ways = total_pairs_topics + total_pairs_difficulties - (total_problems * (total_problems - 1) // 2)\n        results.append(ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of testcases from input\",\n    \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Calculate the number of ways to select three training problems based on the given conditions\",\n    \"Output the result for each testcase\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concepts include the topics and difficulties of the problems, as well as the process of selecting problems based on certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. All steps should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: In this edge case, there are only 3 problems with different topics and difficulties, so there is only 1 way to select three training problems.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: In this edge case, all problems have different topics and difficulties, so there are 4 ways to select three training problems.\n\n    Input\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output\n    0\n    Explanation: In this edge case, there are no sets of three problems that satisfy the conditions, so the output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            pairs += arr[i] * (arr[i] - 1) // 2\n        return pairs\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n\n        total_ways = count_pairs(list(topics.values())) + count_pairs(list(difficulties.values()))\n        for topic_count in topics.values():\n            total_ways -= topic_count * (topic_count - 1) // 2\n        for difficulty_count in difficulties.values():\n            total_ways -= difficulty_count * (difficulty_count - 1) // 2\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 43)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        pairs = 0\n        for i in range(len(arr)):\n            pairs += arr[i] * (arr[i] - 1) // 2\n        return pairs\n\n    results = []\n    for problems in testcases:\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n\n        total_ways = count_pairs(list(topics.values())) + count_pairs(list(difficulties.values()))\n        for topic_count in topics.values():\n            total_ways -= topic_count * (topic_count - 1) // 2\n        for difficulty_count in difficulties.values():\n            total_ways -= difficulty_count * (difficulty_count - 1) // 2\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n    for result in results:\n        print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"Read the topic and difficulty of each problem for each testcase\",\n    \"Calculate the number of ways to select three training problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"Step 2\": \"For each testcase, read the topic and difficulty of each problem\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose 3 problems from a given set of problems, ensuring that either the topics or difficulties of the selected problems are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different subproblems and calculations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this edge case, there is only one way to select 3 problems as all problems have different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    6\n    Explanation: There are multiple ways to select 3 problems with different topics or difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to calculate the number of ways already considers different scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a].append(i)\n            difficulties[b].append(i)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        for topic_list in topics.values():\n            total_ways -= len(topic_list) * (len(topic_list) - 1) * (len(topic_list) - 2) // 6\n        \n        for difficulty_list in difficulties.values():\n            total_ways -= len(difficulty_list) * (len(difficulty_list) - 1) * (len(difficulty_list) - 2) // 6\n        \n        for topic_list in topics.values():\n            for difficulty_list in difficulties.values():\n                common_problems = len(set(topic_list) & set(difficulty_list))\n                total_ways += common_problems * (common_problems - 1) * (common_problems - 2) // 6\n        \n        print(total_ways)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 38)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a].append(i)\n            difficulties[b].append(i)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        for topic_list in topics.values():\n            total_ways -= len(topic_list) * (len(topic_list) - 1) * (len(topic_list) - 2) // 6\n        \n        for difficulty_list in difficulties.values():\n            total_ways -= len(difficulty_list) * (len(difficulty_list) - 1) * (len(difficulty_list) - 2) // 6\n        \n        for topic_list in topics.values():\n            for difficulty_list in difficulties.values():\n                common_problems = len(set(topic_list) & set(difficulty_list))\n                total_ways += common_problems * (common_problems - 1) * (common_problems - 2) // 6\n        \n        print(total_ways)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the given requirements\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of testcases from input\",\n    \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Calculate the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concepts involve the topics and difficulties of the problems, and the process of selecting problems based on certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different calculations and conditions.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this edge case, there is only one way to select three problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all problems have different topics and difficulties, so there are 4 ways to select three problems.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    3\n    Explanation: There are 3 ways to select three problems: (1, 2, 3), (1, 2, 4), (1, 2, 5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_unique_topics_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_combinations(n):\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for problems in testcases:\n        topics, difficulties = count_unique_topics_difficulties(problems)\n        unique_topics = len(topics)\n        unique_difficulties = len(difficulties)\n        if unique_topics >= 3 or unique_difficulties >= 3:\n            results.append(calculate_combinations(len(problems)))\n        else:\n            results.append(0)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 41)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_unique_topics_difficulties(problems):\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        for topic, difficulty in problems:\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        return topics, difficulties\n\n    def calculate_combinations(n):\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for problems in testcases:\n        topics, difficulties = count_unique_topics_difficulties(problems)\n        unique_topics = len(topics)\n        unique_difficulties = len(difficulties)\n        if unique_topics >= 3 or unique_difficulties >= 3:\n            results.append(calculate_combinations(len(problems)))\n        else:\n            results.append(0)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        testcases.append(problems)\n\n    results = calculate_ways_to_select_problems(testcases)\n\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each test case\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concepts involve the topics and difficulties of the problems, and the process of selecting problems based on certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different subproblems and calculations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select three problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: Here, all problems have different topics and difficulties, so there are four ways to select three problems.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: None of the sets of three problems satisfy the conditions of having different topics or difficulties.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways(n, problems):\n    topics_count = defaultdict(int)\n    difficulties_count = defaultdict(int)\n    for topic, difficulty in problems:\n        topics_count[topic] += 1\n        difficulties_count[difficulty] += 1\n    \n    total_ways = 0\n    for topic, count in topics_count.items():\n        total_ways += count * (count - 1) * (count - 2) // 6\n    \n    for difficulty, count in difficulties_count.items():\n        total_ways += count * (count - 1) * (count - 2) // 6\n    \n    for topic, topic_count in topics_count.items():\n        for difficulty, difficulty_count in difficulties_count.items():\n            total_ways -= topic_count * (topic_count - 1) // 2 * difficulty_count\n    \n    return total_ways\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    ways = calculate_ways(n, problems)\n    print(ways)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 35)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways(n, problems):\n    topics_count = defaultdict(int)\n    difficulties_count = defaultdict(int)\n    for topic, difficulty in problems:\n        topics_count[topic] += 1\n        difficulties_count[difficulty] += 1\n    \n    total_ways = 0\n    for topic, count in topics_count.items():\n        total_ways += count * (count - 1) * (count - 2) // 6\n    \n    for difficulty, count in difficulties_count.items():\n        total_ways += count * (count - 1) * (count - 2) // 6\n    \n    for topic, topic_count in topics_count.items():\n        for difficulty, difficulty_count in difficulties_count.items():\n            total_ways -= topic_count * (topic_count - 1) // 2 * difficulty_count\n    \n    return total_ways\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    ways = calculate_ways(n, problems)\n    print(ways)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"Read the topic and difficulty of each problem for each testcase\",\n    \"Calculate the number of ways to select three training problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"Step 2\": \"For each testcase, read the topic and difficulty of each problem\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose 3 problems from a given set of problems, ensuring that either the topics or difficulties are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this edge case, there are only 3 problems with different topics and difficulties, so there is only 1 way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this edge case, all problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    10\n    Explanation: In this edge case, there are multiple ways to select 3 problems with different topics or difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a].append(i)\n            difficulties[b].append(i)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        for topic in topics.values():\n            total_ways -= len(topic) * (len(topic) - 1) * (len(topic) - 2) // 6\n        \n        for difficulty in difficulties.values():\n            total_ways -= len(difficulty) * (len(difficulty) - 1) * (len(difficulty) - 2) // 6\n        \n        for topic in topics.values():\n            for difficulty in difficulties.values():\n                common = len(set(topic) & set(difficulty))\n                total_ways += common * (common - 1) * (common - 2) // 6\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 38)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(list)\n        difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics[a].append(i)\n            difficulties[b].append(i)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        for topic in topics.values():\n            total_ways -= len(topic) * (len(topic) - 1) * (len(topic) - 2) // 6\n        \n        for difficulty in difficulties.values():\n            total_ways -= len(difficulty) * (len(difficulty) - 1) * (len(difficulty) - 2) // 6\n        \n        for topic in topics.values():\n            for difficulty in difficulties.values():\n                common = len(set(topic) & set(difficulty))\n                total_ways += common * (common - 1) * (common - 2) // 6\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    calculate_ways(testcases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Implement the logic to check if the topics or difficulties of the selected problems are different\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Implement a function to calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Implement logic to check if the topics or difficulties of the selected problems are different\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems that Monocarp has to select from.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they are all distinct tasks.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: In this case, there is only one way to select three problems as all topics and difficulties are different.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: In this case, all topics and difficulties are different, so there are 4 ways to select three problems.\n\n    Input\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output\n    10\n    Explanation: In this case, all topics and difficulties are different, so there are 10 ways to select three problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to check if the topics or difficulties of the selected problems are different should cover all scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_ways = min(n, min(len(topics), len(difficulties))\n                     + max(0, n - max(len(topics), len(difficulties)))\n        \n        print(num_ways)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 17)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_ways = min(n, min(len(topics), len(difficulties)) + max(0, n - max(len(topics), len(difficulties)))\n        \n        print(num_ways)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each test case\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics and difficulties'\n    Explanation: The requirement states that the selected problems should have either different topics or different difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, calculating combinations, and outputting results.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: All problems have different topics and difficulties, so there is only one way to select three problems.\n\n    Input\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output\n    0\n    Explanation: All problems have the same topic but different difficulties, so it's not possible to select three problems meeting the requirements.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: All problems have different topics and difficulties, so there are four ways to select three problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate over each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize lists to store topics and difficulties\n    topics = []\n    difficulties = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.append(a)\n        difficulties.append(b)\n    \n    # Initialize a counter for valid selections\n    count = 0\n    \n    # Calculate the number of ways to select three training problems\n    for comb in combinations(range(n), 3):\n        selected_topics = set([topics[i] for i in comb])\n        selected_difficulties = set([difficulties[i] for i in comb])\n        \n        if len(selected_topics) == 3 or len(selected_difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current test case\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 40)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate over each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize lists to store topics and difficulties\n    topics = []\n    difficulties = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics.append(a)\n        difficulties.append(b)\n    \n    # Initialize a counter for valid selections\n    count = 0\n    \n    # Calculate the number of ways to select three training problems\n    for comb in combinations(range(n), 3):\n        selected_topics = set([topics[i] for i in comb])\n        selected_difficulties = set([difficulties[i] for i in comb])\n        \n        if len(selected_topics) == 3 or len(selected_difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current test case\n    print(count)\n"}}], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 137, "prompt": "Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i and a difficulty b_i (both are integers from 1 to n); all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to calculate the number of methods to choose three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 108}
