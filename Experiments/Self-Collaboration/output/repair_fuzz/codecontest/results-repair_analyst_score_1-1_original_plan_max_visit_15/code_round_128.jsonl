{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n); all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to calculate the number of methods to choose three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp decided to select exactly 3 problems from n problems for the problem set, ensuring that the difficulties of all three selected problems are different. In addition, he also made sure that the topics of all three selected problems are different to enhance the training session diversity. Calculate the number of methods to choose three problems for the problem set, considering edge cases where the number of problems n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams where problems should satisfy at least one of two conditions; calculate the number of methods to choose three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = [list(map(int, input().split())) for _ in range(n)]  # Read the details of each problem\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or\n                        problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]):\n                        count += 1\n        print(count)\n\ncalculate_ways_to_select_problems()\n\nmain()", "completions": ["def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]:\n                        count += 1\n\n        print(count)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for the number of ways to select three problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        valid = True\n        for problem in comb:\n            if problem[0] in topics or problem[1] in difficulties:\n                valid = False\n                break\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if valid:\n            count += 1\n    \n    # Output the total number of ways for the current testcase\n    print(count)\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics or n == num_difficulties:\n            print(n*(n-1)*(n-2)//6)\n        else:\n            print(min(n, num_topics, num_difficulties))\n\ncalculate_ways_to_select_problems()\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        # Calculate the number of ways to select three problems\n        ways = min(n, min(num_topics, num_difficulties))\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        problems.append((topic, difficulty))\n\n    count = 0\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        valid = True\n        for problem in comb:\n            if problem[0] in topics or problem[1] in difficulties:\n                valid = False\n                break\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if valid:\n            count += 1\n\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for the number of ways to select three training problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets either of the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        for prob in comb:\n            topics.add(prob[0])\n            difficulties.add(prob[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        count = defaultdict(int)\n        for a, b in arr:\n            count[(a, b)] += 1\n        return count\n\n    def count_unique_pairs(arr):\n        count = defaultdict(int)\n        for a, b in arr:\n            count[a] += 1\n            count[b] += 1\n        return count\n\n    def nCr(n, r):\n        if r > n:\n            return 0\n        numerator = 1\n        for i in range(n, n - r, -1):\n            numerator *= i\n        denominator = 1\n        for i in range(1, r + 1):\n            denominator *= i\n        return numerator // denominator\n\n    results = []\n    for problems in testcases:\n        topics_difficulties = [tuple(map(int, input().split())) for _ in range(problems)]\n        pairs_count = count_pairs(topics_difficulties)\n        unique_count = count_unique_pairs(topics_difficulties)\n\n        total_ways = 0\n        for count in pairs_count.values():\n            total_ways += nCr(count, 3)\n\n        for count in unique_count.values():\n            total_ways -= nCr(count, 3)\n\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = [int(input()) for _ in range(t)]\n    output = calculate_ways_to_select_problems(testcases)\n    for result in output:\n        print(result)\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics or n == num_difficulties:\n            print(n*(n-1)*(n-2)//6)\n        else:\n            print(n*(n-1)*(n-2)//6 - (n-num_topics)*(n-num_difficulties)*(n-2)//2)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Calculate the number of ways to select 3 problems with different topics and difficulties\n    ways = 0\n    for comb in combinations(problems, 3):\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            ways += 1\n    \n    # Output the result\n    print(ways)\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = [list(map(int, input().split())) for _ in range(n)]  # Read the details of each problem\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or\n                        problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]):\n                        count += 1\n        print(count)\n\ncalculate_ways_to_select_problems()\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Read the number of testcases from input\",\n    \"step_2\": \"For each testcase, read the number of problems and their details\",\n    \"step_3\": \"Calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"step_4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of problems': Refers to the total number of problems that Monocarp has for the training session.\n    'topic and difficulty of the problem': Each problem is defined by its topic and difficulty level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three training problems as all problems have unique topics and difficulties.\n\n    Input:\n    2\n    3\n    1 1\n    2 2\n    3 3\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    10\n    Explanation: In the first case, there is only one way to select three problems. In the second case, there are multiple ways to select three problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = [list(map(int, input().split())) for _ in range(n)]  # Read the details of each problem\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or\n                        problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]):\n                        count += 1\n        print(count)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 22)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = [list(map(int, input().split())) for _ in range(n)]  # Read the details of each problem\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or\n                        problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]):\n                        count += 1\n        print(count)\n\ncalculate_ways_to_select_problems()\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Read the number of testcases from input\",\n    \"step_2\": \"For each testcase, read the number of problems and their details\",\n    \"step_3\": \"Calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"step_4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of problems': Refers to the total number of problems that Monocarp has for the training session.\n    'topic and difficulty of the problem': Each problem is defined by its topic and difficulty level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three training problems as all problems have different topics and difficulties.\n\n    Input:\n    2\n    3\n    1 1\n    2 2\n    3 3\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    3\n    3\n    Explanation: In both cases, there are three ways to select three training problems, as all problems have different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: There are four ways to select three training problems, as all problems have different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]:\n                        count += 1\n\n        print(count)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 26)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]:\n                        count += 1\n\n        print(count)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the number of testcases and the number of problems in each testcase\",\n    \"For each problem set, determine the number of ways to select three problems that meet the requirements\",\n    \"Ensure that the difficulties and topics of the selected problems are different\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics/difficulties\",\n    \"Step 3\": \"For each problem set, calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the total number of ways for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose 3 problems from a given set, ensuring their difficulties and topics are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, calculating combinations, and outputting results.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: With only 3 problems and all having different topics and difficulties, it's not possible to select 3 problems meeting the requirements.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    0\n    Explanation: With 4 problems and all having different topics and difficulties, it's still not possible to select 3 problems meeting the requirements.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    1\n    Explanation: With 5 problems and all having different topics and difficulties, there is only 1 way to select 3 problems meeting the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of the main code should cover these scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for the number of ways to select three problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        valid = True\n        for problem in comb:\n            if problem[0] in topics or problem[1] in difficulties:\n                valid = False\n                break\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if valid:\n            count += 1\n    \n    # Output the total number of ways for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 42)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize a counter for the number of ways to select three problems\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        valid = True\n        for problem in comb:\n            if problem[0] in topics or problem[1] in difficulties:\n                valid = False\n                break\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if valid:\n            count += 1\n    \n    # Output the total number of ways for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"Read the topic and difficulty of each problem for each testcase\",\n    \"Calculate the number of ways to select three training problems that meet either of the requirements described in the statement\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and store them in a list\",\n    \"Step 3\": \"For each problem in the list, store the topic and difficulty in separate lists\",\n    \"Step 4\": \"Calculate the number of ways to select three training problems that meet the requirements\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select 3 problems that meet the given conditions of having different topics or difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they are outlined in the plan.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: In this edge case, there are only 3 problems with different topics and difficulties, so there is only 1 way to select 3 problems.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: In this edge case, all problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output\n    10\n    Explanation: In this edge case, all problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics or n == num_difficulties:\n            print(n*(n-1)*(n-2)//6)\n        else:\n            print(min(n, num_topics, num_difficulties))\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 29)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics or n == num_difficulties:\n            print(n*(n-1)*(n-2)//6)\n        else:\n            print(min(n, num_topics, num_difficulties))\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the given requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the given requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting three problems that meet specific requirements based on their topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: When there are only 3 problems with different topics and difficulties, there is only one way to select three problems.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: When there are 4 problems with different topics and difficulties, all combinations of selecting three problems are valid.\n\n    Input\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output\n    10\n    Explanation: When there are 5 problems with different topics and difficulties, there are 10 ways to select three problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        # Calculate the number of ways to select three problems\n        ways = min(n, min(num_topics, num_difficulties))\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 27)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        # Calculate the number of ways to select three problems\n        ways = min(n, min(num_topics, num_difficulties))\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the number of testcases and the number of problems in each testcase\",\n    \"For each problem set, determine the number of ways to select three problems that meet the requirements\",\n    \"Ensure that the difficulties and topics of the selected problems are different\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics/difficulties\",\n    \"Step 3\": \"For each problem set, calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the total number of ways for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose 3 problems from a given set of problems, ensuring differences in difficulty and topic.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, calculating combinations, and outputting results.\n\n# [edge case] \n    Edge Case 1:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: With only 3 problems and all having different topics and difficulties, it's not possible to select 3 problems.\n    \n    Edge Case 2:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    0\n    Explanation: With 4 problems but all having different topics and difficulties, it's still not possible to select 3 problems.\n    \n    Edge Case 3:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    1\n    Explanation: With 5 problems, there is only one way to select 3 problems that meet the requirements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        (other code)\n\nNO", "Round_0": {"code": "from itertools import combinations\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        problems.append((topic, difficulty))\n\n    count = 0\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        valid = True\n        for problem in comb:\n            if problem[0] in topics or problem[1] in difficulties:\n                valid = False\n                break\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if valid:\n            count += 1\n\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 33)"}, "Round_1": {"code": "from itertools import combinations\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        topic, difficulty = map(int, input().split())\n        problems.append((topic, difficulty))\n\n    count = 0\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        valid = True\n        for problem in comb:\n            if problem[0] in topics or problem[1] in difficulties:\n                valid = False\n                break\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if valid:\n            count += 1\n\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of problems': Refers to the total count of problems that Monocarp has for the training session.\n    'topic and difficulty of a problem': Each problem is defined by its topic and difficulty level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented sequentially as they involve different aspects of processing the input and calculating the output.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three training problems when all problems have unique topics and difficulties.\n\n    Edge Case 2:\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: It is not possible to select three training problems that meet either of the requirements when all problems have the same topic but different difficulties.\n\n    Edge Case 3:\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have unique topics and difficulties, allowing for four possible ways to select three training problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nYES", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for the number of ways to select three training problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets either of the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        for prob in comb:\n            topics.add(prob[0])\n            difficulties.add(prob[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 43)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize a counter for the number of ways to select three training problems\n    count = 0\n    \n    # Generate all possible combinations of 3 problems\n    problem_combinations = combinations(problems, 3)\n    \n    # Check each combination if it meets either of the requirements\n    for comb in problem_combinations:\n        topics = set()\n        difficulties = set()\n        for prob in comb:\n            topics.add(prob[0])\n            difficulties.add(prob[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"Read the topic and difficulty of each problem for each testcase\",\n    \"Calculate the number of ways to select three training problems that meet either of the requirements described in the statement\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"step_2\": \"For each testcase, read the topic and difficulty of each problem\",\n    \"step_3\": \"Calculate the number of ways to select three training problems that meet either of the requirements described in the statement\",\n    \"step_4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The problems are characterized by their topics and difficulties, and the selection of problems should consider these attributes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input data and calculating the result.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: With only 3 problems and all different topics and difficulties, there is only 1 way to select 3 problems.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output\n    10\n    Explanation: There are multiple ways to select 3 problems satisfying the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        count = defaultdict(int)\n        for a, b in arr:\n            count[(a, b)] += 1\n        return count\n\n    def count_unique_pairs(arr):\n        count = defaultdict(int)\n        for a, b in arr:\n            count[a] += 1\n            count[b] += 1\n        return count\n\n    def nCr(n, r):\n        if r > n:\n            return 0\n        numerator = 1\n        for i in range(n, n - r, -1):\n            numerator *= i\n        denominator = 1\n        for i in range(1, r + 1):\n            denominator *= i\n        return numerator // denominator\n\n    results = []\n    for problems in testcases:\n        topics_difficulties = [tuple(map(int, input().split())) for _ in range(problems)]\n        pairs_count = count_pairs(topics_difficulties)\n        unique_count = count_unique_pairs(topics_difficulties)\n\n        total_ways = 0\n        for count in pairs_count.values():\n            total_ways += nCr(count, 3)\n\n        for count in unique_count.values():\n            total_ways -= nCr(count, 3)\n\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = [int(input()) for _ in range(t)]\n    output = calculate_ways_to_select_problems(testcases)\n    for result in output:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 53)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_ways_to_select_problems(testcases):\n    def count_pairs(arr):\n        count = defaultdict(int)\n        for a, b in arr:\n            count[(a, b)] += 1\n        return count\n\n    def count_unique_pairs(arr):\n        count = defaultdict(int)\n        for a, b in arr:\n            count[a] += 1\n            count[b] += 1\n        return count\n\n    def nCr(n, r):\n        if r > n:\n            return 0\n        numerator = 1\n        for i in range(n, n - r, -1):\n            numerator *= i\n        denominator = 1\n        for i in range(1, r + 1):\n            denominator *= i\n        return numerator // denominator\n\n    results = []\n    for problems in testcases:\n        topics_difficulties = [tuple(map(int, input().split())) for _ in range(problems)]\n        pairs_count = count_pairs(topics_difficulties)\n        unique_count = count_unique_pairs(topics_difficulties)\n\n        total_ways = 0\n        for count in pairs_count.values():\n            total_ways += nCr(count, 3)\n\n        for count in unique_count.values():\n            total_ways -= nCr(count, 3)\n\n        results.append(total_ways)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = [int(input()) for _ in range(t)]\n    output = calculate_ways_to_select_problems(testcases)\n    for result in output:\n        print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet the given requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Calculate the number of ways to select three training problems that meet the given requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting 3 problems based on different topics or difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Input\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output\n    1\n    Explanation: With only 3 problems and all different topics and difficulties, there is only 1 way to select 3 problems.\n\n    Input\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output\n    10\n    Explanation: All problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics or n == num_difficulties:\n            print(n*(n-1)*(n-2)//6)\n        else:\n            print(n*(n-1)*(n-2)//6 - (n-num_topics)*(n-num_difficulties)*(n-2)//2)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 27)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Number of testcases\n    for _ in range(t):\n        n = int(input())  # Number of problems\n        topics = set()\n        difficulties = set()\n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        num_topics = len(topics)\n        num_difficulties = len(difficulties)\n        \n        if n == num_topics or n == num_difficulties:\n            print(n*(n-1)*(n-2)//6)\n        else:\n            print(n*(n-1)*(n-2)//6 - (n-num_topics)*(n-num_difficulties)*(n-2)//2)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Identify the number of testcases and the number of problems in each testcase\",\n    \"For each problem set, determine the number of ways to select three problems that meet the requirements\",\n    \"Ensure that the difficulties and topics of the selected problems are different\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics/difficulties\",\n    \"Step 3\": \"For each problem set, calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to choose 3 problems from a given set, ensuring differences in difficulty and topic.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, calculating combinations, and outputting results.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: With only 3 problems and all having different topics and difficulties, there is only 1 way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, allowing for 4 possible combinations of 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: With 5 problems, there are 10 ways to select 3 problems with different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for selecting problems already accounts for different topics and difficulties.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Create a set of unique topics and difficulties\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    \n    # Calculate the number of ways to select 3 problems with different topics and difficulties\n    valid_problems = [(a, b) for a, b in problems if a in topics and b in difficulties]\n    ways = 0\n    for comb in combinations(valid_problems, 3):\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            ways += 1\n    \n    # Output the result\n    print(ways)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the topics and difficulties of each problem\n    problems = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Calculate the number of ways to select 3 problems with different topics and difficulties\n    ways = 0\n    for comb in combinations(problems, 3):\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            ways += 1\n    \n    # Output the result\n    print(ways)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Read the number of testcases from input\",\n    \"step_2\": \"For each testcase, read the number of problems and their details\",\n    \"step_3\": \"Calculate the number of ways to select three training problems that meet either of the requirements\",\n    \"step_4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of problems': Refers to the total number of problems that Monocarp has for the training session.\n    'topic and difficulty of the problem': Each problem is defined by its topic and difficulty level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three training problems as all problems have unique topics and difficulties.\n\n    Input:\n    2\n    3\n    1 1\n    2 2\n    3 3\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    10\n    Explanation: In the first case, there is only one way to select three problems. In the second case, there are multiple ways to select three problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = [list(map(int, input().split())) for _ in range(n)]  # Read the details of each problem\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or\n                        problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]):\n                        count += 1\n        print(count)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 22)"}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())  # Read the number of testcases\n    for _ in range(t):\n        n = int(input())  # Read the number of problems\n        problems = [list(map(int, input().split())) for _ in range(n)]  # Read the details of each problem\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if (problems[i][0] == problems[j][0] or problems[i][0] == problems[k][0] or problems[j][0] == problems[k][0] or\n                        problems[i][1] == problems[j][1] or problems[i][1] == problems[k][1] or problems[j][1] == problems[k][1]):\n                        count += 1\n        print(count)\n\ncalculate_ways_to_select_problems()\n"}}], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 128, "prompt": "Monocarp is the coach of the Berland State University programming teams and decided to create a set of problems for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n); all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to calculate the number of methods to choose three problems for the problemset. Make sure to consider edge cases where the number of problems n might be small.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "condense_two2one", "save_node": true, "parent_index": 101}
