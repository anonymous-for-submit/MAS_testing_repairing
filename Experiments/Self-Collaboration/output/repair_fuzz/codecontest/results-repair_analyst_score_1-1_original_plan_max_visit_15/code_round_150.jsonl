{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet. Each of these problems is defined by its topic and difficulty: the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), with all problems being different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp decided to select exactly 3 problems from n problems for the problemset, ensuring that the topics of all three selected problems are different. This means that each problem will have a unique topic and difficulty compared to the others. \n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions: the topics of all three selected problems are different or the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams, selecting exactly 3 problems from the given set of n problems.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Parse input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Find all combinations of 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count valid combinations\n    count = 0\n    for combo in combinations_3:\n        if meets_requirements(combo):\n            count += 1\n    \n    print(count)\n\nmain()", "completions": ["from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics:\n            same_topic += topics[topic] * (topics[topic] - 1) * (topics[topic] - 2) // 6\n        for difficulty in difficulties:\n            same_difficulty += difficulties[difficulty] * (difficulties[difficulty] - 1) * (difficulties[difficulty] - 2) // 6\n        \n        same_topic_and_difficulty = 0\n        for topic in topics:\n            same_topic_and_difficulty += topics[topic] * (topics[topic] - 1) // 2 * (n - topics[topic])\n        \n        ways = total_ways - same_topic - same_difficulty + same_topic_and_difficulty\n        print(ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Parse the input to extract the number of testcases and the number of problems in each testcase\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    \n    # For each testcase, read the topic and difficulty of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Identify all possible combinations of selecting 3 problems from the given set\n    combinations_list = list(combinations(problems, 3))\n    \n    # Check if the selected problems meet the requirements described in the statement\n    def check_requirements(combination):\n        topics = set()\n        difficulties = set()\n        for problem in combination:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        return len(topics) == 3 or len(difficulties) == 3\n    \n    # Count the number of ways to select three training problems that meet the requirements\n    count = sum(1 for comb in combinations_list if check_requirements(comb))\n    \n    # Output the result\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Generate all possible combinations of selecting 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count the number of ways to select three training problems that meet the requirements\n    count = 0\n    for comb in combinations_3:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result\n    print(count)\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n\nmain()", "from itertools import combinations\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\ncount_ways_to_select_problems()\n\nmain()", "import itertools\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        combinations = list(itertools.combinations(problems, 3))\n        count = 0\n        for comb in combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                count += 1\n        \n        print(count)\n\ncount_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select three problems\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Input parsing\ntestcases = int(input())\ncalculate_ways(testcases)\n\nmain()", "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Parse input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Find all combinations of 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count valid combinations\n    count = 0\n    for combo in combinations_3:\n        if meets_requirements(combo):\n            count += 1\n    \n    print(count)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each test case, iterate through all possible combinations of three problems\",\n    \"Step 4\": \"Check if the selected three problems meet the requirements (different topics or different difficulties)\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics', 'different difficulties'\n    Explanation: The core concept is to select 3 problems from a set of problems ensuring that the topics or difficulties of the selected problems are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through combinations, checking requirements, and counting valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: All three problems have different topics and difficulties, so there is only one way to select the problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All four problems have different topics and difficulties, so there are four ways to select the problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All five problems have different topics and difficulties, so there are ten ways to select the problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through combinations and check requirements covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Parse input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Find all combinations of 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count valid combinations\n    count = 0\n    for combo in combinations_3:\n        if meets_requirements(combo):\n            count += 1\n    \n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 37)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Parse input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Find all combinations of 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count valid combinations\n    count = 0\n    for combo in combinations_3:\n        if meets_requirements(combo):\n            count += 1\n    \n    print(count)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Read the number of testcases\",\n    \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Determine the number of ways to select three problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each testcase, calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic': The topic of a problem, represented by an integer from 1 to n.\n    'difficulty': The difficulty of a problem, represented by an integer from 1 to n.\n    'selecting problems': Selecting exactly 3 problems that meet certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    testcase 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output: 3\n    Explanation: Three possible sets of three problems are: (1, 2, 4), (1, 3, 4), (2, 3, 4).\n    \n    testcase 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output: 10\n    Explanation: There are 10 ways to select three problems that meet the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics:\n            same_topic += topics[topic] * (topics[topic] - 1) * (topics[topic] - 2) // 6\n        for difficulty in difficulties:\n            same_difficulty += difficulties[difficulty] * (difficulties[difficulty] - 1) * (difficulties[difficulty] - 2) // 6\n        \n        same_topic_and_difficulty = 0\n        for topic in topics:\n            same_topic_and_difficulty += topics[topic] * (topics[topic] - 1) // 2 * (n - topics[topic])\n        \n        ways = total_ways - same_topic - same_difficulty + same_topic_and_difficulty\n        print(ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 38)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics:\n            same_topic += topics[topic] * (topics[topic] - 1) * (topics[topic] - 2) // 6\n        for difficulty in difficulties:\n            same_difficulty += difficulties[difficulty] * (difficulties[difficulty] - 1) * (difficulties[difficulty] - 2) // 6\n        \n        same_topic_and_difficulty = 0\n        for topic in topics:\n            same_topic_and_difficulty += topics[topic] * (topics[topic] - 1) // 2 * (n - topics[topic])\n        \n        ways = total_ways - same_topic - same_difficulty + same_topic_and_difficulty\n        print(ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Read the number of testcases\",\n    \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Determine the number of ways to select three problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each testcase, calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic': The topic of a problem, represented by an integer from 1 to n.\n    'difficulty': The difficulty of a problem, represented by an integer from 1 to n.\n    'selecting problems': Selecting exactly 3 problems that meet certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    testcase 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output: 3\n    Explanation: There are 3 ways to select 3 problems that meet the requirements.\n    testcase 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output: 10\n    Explanation: There are 10 ways to select 3 problems that meet the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 35)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Read the number of testcases\",\n    \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Determine the number of ways to select three problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each testcase, calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic': The topic of a problem, represented by an integer from 1 to n.\n    'difficulty': The difficulty of a problem, represented by an integer from 1 to n.\n    'selecting problems': Selecting exactly 3 problems that meet certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    testcase 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output: 3\n    Explanation: There are 3 ways to select 3 problems that meet the requirements.\n    testcase 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output: 10\n    Explanation: There are 10 ways to select 3 problems that meet the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 35)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"For each testcase, read the topic and difficulty of each problem\",\n    \"Identify all possible combinations of selecting 3 problems from the given set\",\n    \"Check if the selected problems meet the requirements described in the statement\",\n    \"Count the number of ways to select three training problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"step_2\": \"For each testcase, read the topic and difficulty of each problem\",\n    \"step_3\": \"Identify all possible combinations of selecting 3 problems from the given set\",\n    \"step_4\": \"Check if the selected problems meet the requirements described in the statement\",\n    \"step_5\": \"Count the number of ways to select three training problems that meet the requirements\",\n    \"step_6\": \"Output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting exactly 3 problems': This means that the task is to choose 3 problems from a given set of problems.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous implementation.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems when all problems have different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All combinations of selecting 3 problems are valid in this case.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are 10 ways to select 3 problems from 5 distinct problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Parse the input to extract the number of testcases and the number of problems in each testcase\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    \n    # For each testcase, read the topic and difficulty of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Identify all possible combinations of selecting 3 problems from the given set\n    combinations_list = list(combinations(problems, 3))\n    \n    # Check if the selected problems meet the requirements described in the statement\n    def check_requirements(combination):\n        topics = set()\n        difficulties = set()\n        for problem in combination:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        return len(topics) == 3 or len(difficulties) == 3\n    \n    # Count the number of ways to select three training problems that meet the requirements\n    count = sum(1 for comb in combinations_list if check_requirements(comb))\n    \n    # Output the result\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 42)"}, "Round_1": {"code": "from itertools import combinations\n\n# Parse the input to extract the number of testcases and the number of problems in each testcase\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    \n    # For each testcase, read the topic and difficulty of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Identify all possible combinations of selecting 3 problems from the given set\n    combinations_list = list(combinations(problems, 3))\n    \n    # Check if the selected problems meet the requirements described in the statement\n    def check_requirements(combination):\n        topics = set()\n        difficulties = set()\n        for problem in combination:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        return len(topics) == 3 or len(difficulties) == 3\n    \n    # Count the number of ways to select three training problems that meet the requirements\n    count = sum(1 for comb in combinations_list if check_requirements(comb))\n    \n    # Output the result\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems in each testcase\",\n    \"For each testcase, extract the topic and difficulty of each problem\",\n    \"Find all possible combinations of selecting 3 problems from the given set\",\n    \"Check if the selected problems meet the requirements described in the statement\",\n    \"Count the number of ways to select three training problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"steps\": [\n      \"Read the number of testcases from input\",\n      \"For each testcase, read the number of problems and extract the topic and difficulty of each problem\",\n      \"Generate all possible combinations of selecting 3 problems from the given set\",\n      \"Check if the selected problems meet the requirements (either of the requirements described in the statement)\",\n      \"Count the number of ways to select three training problems that meet the requirements\",\n      \"Output the result\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting 3 problems': Refers to the process of choosing exactly 3 problems from a given set of problems.\n    'topic and difficulty of the problem': Each problem is defined by its topic and difficulty level.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems in this case.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All combinations of selecting 3 problems are valid in this case.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All combinations of selecting 3 problems are valid in this case.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Generate all possible combinations of selecting 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count the number of ways to select three training problems that meet the requirements\n    count = 0\n    for comb in combinations_3:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 41)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Initialize a list to store the topics and difficulties of each problem\n    problems = []\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Generate all possible combinations of selecting 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count the number of ways to select three training problems that meet the requirements\n    count = 0\n    for comb in combinations_3:\n        topics = set()\n        difficulties = set()\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the result\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Read the number of testcases\",\n    \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Determine the number of ways to select three problems that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each testcase, calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topic': The topic of a problem, represented by an integer from 1 to n.\n    'difficulty': The difficulty of a problem, represented by an integer from 1 to n.\n    'selecting problems': Selecting exactly 3 problems that meet certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    testcase 1:\n    4\n    2 4\n    3 4\n    2 1\n    1 3\n    Output: 3\n    Explanation: There are 3 ways to select 3 problems that meet the requirements: (1, 2, 4), (1, 3, 4), (2, 3, 4).\n    \n    testcase 2:\n    5\n    1 5\n    2 4\n    3 3\n    4 2\n    5 1\n    Output: 10\n    Explanation: There are 10 ways to select 3 problems that meet the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 35)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            topic, difficulty = map(int, input().split())\n            topics[topic] += 1\n            difficulties[difficulty] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic = same_difficulty = 0\n        for topic in topics.values():\n            same_topic += topic * (topic - 1) * (topic - 2) // 6\n        for difficulty in difficulties.values():\n            same_difficulty += difficulty * (difficulty - 1) * (difficulty - 2) // 6\n        \n        total_ways -= same_topic + same_difficulty\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each test case, iterate through all possible combinations of three problems\",\n    \"Step 4\": \"Check if the selected three problems meet the requirements (different topics or different difficulties)\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics', 'different difficulties'\n    Explanation: The core concept is to select 3 problems from a set of problems ensuring that the topics or difficulties of the selected problems are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through combinations, checking requirements, and counting valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: All three problems have different topics and difficulties, so there is only one way to select the problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All four problems have different topics and difficulties, so there are four ways to select the problems.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    2 1\n    Output:\n    0\n    Explanation: None of the combinations satisfy the requirements of having different topics or difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through combinations and check requirements covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 32)"}, "Round_1": {"code": "from itertools import combinations\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the number of problems for each testcase\",\n    \"For each testcase, create a list of tuples containing the topic and difficulty of each problem\",\n    \"Generate all possible combinations of 3 problems for each testcase\",\n    \"Check if each combination meets the requirements described in the statement\",\n    \"Count the number of combinations that meet the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"steps\": [\n      \"Read the number of testcases from input\",\n      \"For each testcase, read the number of problems and create a list of tuples containing the topic and difficulty of each problem\",\n      \"Generate all possible combinations of 3 problems using itertools.combinations\",\n      \"Iterate through each combination and check if it meets the requirements\",\n      \"Count the number of combinations that meet the requirements and print the result\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting exactly 3 problems': The requirement specifies that Monocarp needs to choose exactly 3 problems from the given set of problems.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different subproblems and tasks.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems when all problems have different topics and difficulties.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: It is not possible to select 3 problems with the same topic.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: There are 4 ways to select 3 problems when all problems have different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to generate combinations and check requirements should cover all scenarios.", "Round_0": {"code": "import itertools\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        combinations = list(itertools.combinations(problems, 3))\n        count = 0\n        for comb in combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                count += 1\n        \n        print(count)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import itertools\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        combinations = list(itertools.combinations(problems, 3))\n        count = 0\n        for comb in combinations:\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) == 3 or len(difficulties) == 3:\n                count += 1\n        \n        print(count)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each test case, iterate through all possible combinations of three problems\",\n    \"Step 4\": \"Check if the selected three problems meet the requirements (different topics or different difficulties)\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics', 'different difficulties'\n    Explanation: The core concept is to select 3 problems from a set of problems ensuring that the topics or difficulties of the selected problems are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they involve parsing input, iterating through combinations, checking requirements, and counting valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: All problems have different topics and difficulties, so there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    2 1\n    Output:\n    0\n    Explanation: No set of 3 problems have either different topics or different difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select three problems\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Input parsing\ntestcases = int(input())\ncalculate_ways(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 34)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select three problems\ndef calculate_ways(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if meets_requirements(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Input parsing\ntestcases = int(input())\ncalculate_ways(testcases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given requirements\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"For each test case, iterate through all possible combinations of three problems\",\n    \"Step 4\": \"Check if the selected three problems meet the requirements (different topics or different difficulties)\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics', 'different difficulties'\n    Explanation: The core concept is to select 3 problems from a set of problems ensuring that the topics or difficulties of the selected problems are different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, iterating through combinations, checking requirements, and counting valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: All three problems have different topics and difficulties, so there is only one way to select the problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All four problems have different topics and difficulties, so there are four ways to select the problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All five problems have different topics and difficulties, so there are ten ways to select the problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through combinations and check requirements covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Parse input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Find all combinations of 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count valid combinations\n    count = 0\n    for combo in combinations_3:\n        if meets_requirements(combo):\n            count += 1\n    \n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 37)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef meets_requirements(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Parse input\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Find all combinations of 3 problems\n    combinations_3 = list(combinations(problems, 3))\n    \n    # Count valid combinations\n    count = 0\n    for combo in combinations_3:\n        if meets_requirements(combo):\n            count += 1\n    \n    print(count)\n"}}], "scores": [], "pass_results": [true, true, true, true, false, true, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 150, "prompt": "Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet. Each of these problems is defined by its topic and difficulty: the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), with all problems being different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 81}
