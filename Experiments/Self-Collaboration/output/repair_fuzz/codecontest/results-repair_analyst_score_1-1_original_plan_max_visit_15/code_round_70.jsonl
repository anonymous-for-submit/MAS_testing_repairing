{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "repair_prompt": ["You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. You need to consider the most efficient way to simulate this process to arrive at the solution.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "It means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$. This representation allows for a cyclic shift of the array a to the right by d cells before applying the logical \"AND\" operator to each element. \n\nYou are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, and you need to determine if the process will end with the array consisting of only zeros, and if so, find the number of steps it will take to reach that point efficiently.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, and determine whether it will consist of only zeros at the end of the process.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] & arr[i] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()", "completions": ["def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    while tuple(arr) not in seen:\n        seen.add(tuple(arr))\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[i] & arr[(i - d) % n]\n        arr = new_arr\n        steps += 1\n        if all(val == 0 for val in arr):\n            return steps\n    return -1\n\n# Input\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    steps = calculate_steps(n, d, arr)\n    results.append(steps)\n\n# Output\nfor res in results:\n    print(res)\n\nmain()", "# Function to determine the number of steps after which the array will contain only zeros\ndef determine_steps(t, test_cases):\n    result = []\n    \n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        \n        steps = 0\n        while 1 in arr:\n            steps += 1\n            arr = arr[d:] + arr[:d]\n            arr = [a & b for a, b in zip(arr, arr[1:])]\n            \n            if steps > n:\n                steps = -1\n                break\n        \n        result.append(steps)\n    \n    return result\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresult = determine_steps(t, test_cases)\nfor res in result:\n    print(res)\n\nmain()", "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    while tuple(arr) not in seen:\n        seen.add(tuple(arr))\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[i] & arr[(i - d) % n]\n        if new_arr.count(1) == 0:\n            return steps\n        arr = new_arr\n        steps += 1\n    return -1\n\n# Input\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    steps = calculate_steps(n, d, arr)\n    results.append(steps)\n\n# Output\nfor res in results:\n    print(res)\n\nmain()", "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    \n    while True:\n        if all(x == 0 for x in arr):\n            return steps\n        if tuple(arr) in seen:\n            return -1\n        \n        seen.add(tuple(arr))\n        steps += 1\n        \n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[i]\n        \n        arr = new_arr\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    result = calculate_steps(n, d, arr)\n    print(result)\n\nmain()", "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == n:\n        return -1\n    if d == 1:\n        return arr.index(1) + 1\n    steps = 0\n    for i in range(n):\n        if arr[i] == 1:\n            steps += 1\n            for j in range(i, min(i + d, n)):\n                arr[j] &= 0\n    return steps\n\ndef cyclic_shift_and_operation(t, test_cases):\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = calculate_steps(n, d, arr)\n        results.append(result)\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "# Function to calculate the number of steps required to reach an array consisting of only zeros\ndef calculate_steps(n, d, arr):\n    # Initialize a counter for steps\n    steps = 0\n    \n    # Iterate through the array to perform cyclic shift and logical 'AND' operation\n    while True:\n        # Perform cyclic shift to the right by d cells\n        new_arr = arr[-d:] + arr[:-d]\n        \n        # Perform logical 'AND' operation on each element of the array\n        arr = [new_arr[i] & arr[i] for i in range(n)]\n        \n        # Increment the step counter\n        steps += 1\n        \n        # Check if the array consists of only zeros\n        if all(val == 0 for val in arr):\n            return steps\n        \n        # Check if the array remains the same after cyclic shift\n        if arr == new_arr:\n            return -1\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the array size and cyclic shift offset\n    n, d = map(int, input().split())\n    \n    # Read the elements of the array\n    arr = list(map(int, input().split()))\n    \n    # Calculate the number of steps required\n    result = calculate_steps(n, d, arr)\n    \n    # Output the result\n    print(result)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        seen = set()\n        steps = 0\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[i] & arr[(i - d) % n]\n            if new_arr.count(1) == 0:\n                return steps\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    while tuple(arr) not in seen:\n        seen.add(tuple(arr))\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[i]\n        arr = new_arr\n        steps += 1\n        if all(val == 0 for val in arr):\n            return steps\n    return -1\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = []\nfor n, d, arr in test_cases:\n    steps = calculate_steps(n, d, arr)\n    results.append(steps)\n\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        while steps < n:\n            all_zeros = all(val == 0 for val in arr)\n            if all_zeros:\n                return steps\n            if steps == n:\n                return -1\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[(i + d) % n] = arr[i] & arr[(i + d) % n]\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        result = calculate_steps(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] & arr[i] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"Handle the case where there are still elements equal to 1 in the array after the end of the process\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"step_2\": \"For each test case, implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"step_3\": \"Handle the case where there are still elements equal to 1 in the array after the end of the process\",\n    \"step_4\": \"Output the results for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'array of zeroes and ones only'\n    Explanation: The array consists of only 0s and 1s.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan covers all scenarios.", "Round_0": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] & arr[i] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] & arr[i] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, simulate the process of cyclic shifting and logical AND operation until the array stops changing\",\n    \"Check if the final array consists of only zeros or if there are still elements equal to 1\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases\",\n    \"Step 2\": \"For each test case, parse the array size, cyclic shift offset, and elements of the array\",\n    \"Step 3\": \"Simulate the process of cyclic shifting and logical AND operation until the array stops changing\",\n    \"Step 4\": \"Check if the final array consists of only zeros or if there are still elements equal to 1\",\n    \"Step 5\": \"Output the number of steps after which the array will contain only zeros for the first time or -1 if there are still elements equal to 1\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a certain number of positions.\n    'logical AND operation': It is a bitwise operation that results in 1 only if both bits are 1, otherwise, it results in 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n    Explanation:\n    - In the first test case, the array will change in 1 step to contain only zeros.\n    - In the second test case, the array will change in 1 step to contain only zeros.\n    - In the third test case, the array will change in 3 steps to contain only zeros.\n    - In the fourth test case, the array will never contain only zeros.\n    - In the fifth test case, the array already contains only zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle all cases.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        seen = set()\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[i] & arr[(i - d) % n]\n            arr = new_arr\n            steps += 1\n            if all(val == 0 for val in arr):\n                return steps\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    while tuple(arr) not in seen:\n        seen.add(tuple(arr))\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[i] & arr[(i - d) % n]\n        arr = new_arr\n        steps += 1\n        if all(val == 0 for val in arr):\n            return steps\n    return -1\n\n# Input\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    steps = calculate_steps(n, d, arr)\n    results.append(steps)\n\n# Output\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size and cyclic shift offset for each test case\",\n    \"For each test case, apply the cyclic shift operation to the array elements\",\n    \"Check if the array contains only zeros after each shift operation\",\n    \"Count the number of steps taken to reach an array with only zeros or determine if it is not possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases\",\n    \"step_2\": \"For each test case, parse the array size and cyclic shift offset\",\n    \"step_3\": \"Parse the array elements for each test case\",\n    \"step_4\": \"Apply the cyclic shift operation to the array elements\",\n    \"step_5\": \"Check if the array contains only zeros after each shift operation\",\n    \"step_6\": \"Count the number of steps taken to reach an array with only zeros or determine if it is not possible\",\n    \"step_7\": \"Output the results for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: It refers to shifting the elements of the array in a circular manner, where the last element moves to the first position.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as per the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "# Function to determine the number of steps after which the array will contain only zeros\ndef determine_steps(t, test_cases):\n    result = []\n    \n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        \n        steps = 0\n        while 1 in arr:\n            steps += 1\n            arr = arr[d:] + arr[:d]\n            arr = [a & b for a, b in zip(arr, arr[1:])]\n            \n            if steps > n:\n                steps = -1\n                break\n        \n        result.append(steps)\n    \n    return result\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresult = determine_steps(t, test_cases)\nfor res in result:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 45)"}, "Round_1": {"code": "# Function to determine the number of steps after which the array will contain only zeros\ndef determine_steps(t, test_cases):\n    result = []\n    \n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        \n        steps = 0\n        while 1 in arr:\n            steps += 1\n            arr = arr[d:] + arr[:d]\n            arr = [a & b for a, b in zip(arr, arr[1:])]\n            \n            if steps > n:\n                steps = -1\n                break\n        \n        result.append(steps)\n    \n    return result\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresult = determine_steps(t, test_cases)\nfor res in result:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, simulate the process of cyclic shifting and logical AND operations until the array stops changing or all elements become zeros\",\n    \"Count the number of steps taken to reach the final array state\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases\",\n    \"step_2\": \"Iterate over each test case\",\n    \"step_3\": {\n      \"substep_1\": \"Extract the array size and cyclic shift offset\",\n      \"substep_2\": \"Extract the elements of the array\",\n      \"substep_3\": \"Simulate the process of cyclic shifting and logical AND operations until the array stops changing or all elements become zeros\",\n      \"substep_4\": \"Count the number of steps taken to reach the final array state\",\n      \"substep_5\": \"Output the number of steps or -1 if the array never contains only zeros\"\n    }\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a certain number of positions.\n    'logical AND operations': It involves performing a bitwise AND operation on corresponding bits of two arrays.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        seen = set()\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[i] & arr[(i - d) % n]\n            if new_arr.count(1) == 0:\n                return steps\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    while tuple(arr) not in seen:\n        seen.add(tuple(arr))\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[i] & arr[(i - d) % n]\n        if new_arr.count(1) == 0:\n            return steps\n        arr = new_arr\n        steps += 1\n    return -1\n\n# Input\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    steps = calculate_steps(n, d, arr)\n    results.append(steps)\n\n# Output\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size with cyclic shift offset for each test case\",\n    \"For each test case, calculate the number of steps required to reach an array consisting of only zeros or determine if it's not possible\",\n    \"Apply the cyclic shift operation and logical 'AND' operator to each element of the array until all elements are zeros or a cycle is detected\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case descriptions\",\n    \"step_2\": \"Iterate through each test case description\",\n    \"step_3\": {\n      \"substep_1\": \"Apply cyclic shift operation to the array based on the given offset\",\n      \"substep_2\": \"Apply logical 'AND' operator to each element of the array\",\n      \"substep_3\": \"Repeat steps 3.1 and 3.2 until all elements are zeros or a cycle is detected\",\n      \"substep_4\": \"Count the number of steps taken to reach an array consisting of only zeros or determine if it's not possible\"\n    },\n    \"step_4\": \"Output the number of steps for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': Refers to shifting the elements of an array in a circular manner by a specified offset.\n    'logical \"AND\" operator': Refers to performing a logical AND operation on corresponding bits of the elements in the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n    Explanation:\n    - In the first test case, after the first step, the array becomes [0, 0], which consists of only zeros. Hence, it takes 1 step.\n    - In the second test case, after the first step, the array becomes [0, 0, 0], which consists of only zeros. Hence, it takes 1 step.\n    - In the third test case, it takes 3 steps to reach an array consisting of only zeros as explained in the prompt.\n    - In the fourth test case, the array will never contain only zeros as explained in the prompt, so the output is -1.\n    - In the fifth test case, the array is already [0], so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan covers all scenarios.", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    \n    while True:\n        if all(x == 0 for x in arr):\n            return steps\n        if tuple(arr) in seen:\n            return -1\n        \n        seen.add(tuple(arr))\n        steps += 1\n        \n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[i]\n        \n        arr = new_arr\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    result = calculate_steps(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 33)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    \n    while True:\n        if all(x == 0 for x in arr):\n            return steps\n        if tuple(arr) in seen:\n            return -1\n        \n        seen.add(tuple(arr))\n        steps += 1\n        \n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[i]\n        \n        arr = new_arr\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    result = calculate_steps(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Apply the logical 'AND' operator to each element of the array\",\n    \"Check if the array consists of only zeros\",\n    \"Calculate the number of steps it will take to reach the point where the array consists of only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input data for each test case\",\n    \"step_2\": \"Implement the cyclic shift operation on the array\",\n    \"step_3\": \"Apply the logical 'AND' operator to each element of the array\",\n    \"step_4\": \"Check if the array consists of only zeros\",\n    \"step_5\": \"Calculate the number of steps it will take to reach the point where the array consists of only zeros\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: It means shifting the elements of the array circularly by a certain offset.\n\n    'logical \"AND\" operator'\n    Explanation: It means performing a logical AND operation on each element of the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    2 1\n    0 1\n    Output: 1\n    Explanation: After the first step, the array becomes [0, 0] which consists of only zeros.\n    \n    5 2\n    1 1 0 1 0\n    Output: 3\n    Explanation: After 3 steps, the array becomes [0, 0, 0, 0, 0] which consists of only zeros.\n    \n    4 2\n    0 1 0 1\n    Output: -1\n    Explanation: The array will not change as it shifts by 2 to the right, so each element will be calculated as 0 & 0 or 1 & 1, thus not changing its value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should handle all cases effectively.", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == n:\n        return -1\n    if d == 1:\n        return arr.index(1) + 1\n    steps = 0\n    for i in range(n):\n        if arr[i] == 1:\n            steps += 1\n            for j in range(i, min(i + d, n)):\n                arr[j] &= 0\n    return steps\n\ndef cyclic_shift_and_operation(t, test_cases):\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = calculate_steps(n, d, arr)\n        results.append(result)\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 43)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == n:\n        return -1\n    if d == 1:\n        return arr.index(1) + 1\n    steps = 0\n    for i in range(n):\n        if arr[i] == 1:\n            steps += 1\n            for j in range(i, min(i + d, n)):\n                arr[j] &= 0\n    return steps\n\ndef cyclic_shift_and_operation(t, test_cases):\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = calculate_steps(n, d, arr)\n        results.append(result)\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size with cyclic shift offset for each test case\",\n    \"For each test case, calculate the number of steps required to reach an array consisting of only zeros or determine if it's not possible\",\n    \"Implement the logical 'AND' operation on each element of the array after cyclic shifting\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case descriptions\",\n    \"step_2\": \"Iterate through each test case description\",\n    \"step_3\": \"For each test case, perform the cyclic shift operation on the array\",\n    \"step_4\": \"Apply the logical 'AND' operation on each element of the array\",\n    \"step_5\": \"Check if the array consists of only zeros or if there are still elements equal to 1\",\n    \"step_6\": \"Output the number of steps required or -1 accordingly\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: It refers to shifting the elements of an array in a circular manner by a certain offset.\n\n    'logical \"AND\" operator'\n    Explanation: It refers to performing the AND operation on each element of the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, iterating through test cases, performing operations, and checking conditions.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, the array will change in 1 step to contain only zeros.\n    - In the second test case, the array will change in 1 step to contain only zeros.\n    - In the third test case, the array will change in 3 steps to contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "# Function to calculate the number of steps required to reach an array consisting of only zeros\ndef calculate_steps(n, d, arr):\n    # Initialize a counter for steps\n    steps = 0\n    \n    # Iterate through the array to perform cyclic shift and logical 'AND' operation\n    while True:\n        # Perform cyclic shift to the right by d cells\n        new_arr = arr[-d:] + arr[:-d]\n        \n        # Perform logical 'AND' operation on each element of the array\n        arr = [new_arr[i] & arr[i] for i in range(n)]\n        \n        # Increment the step counter\n        steps += 1\n        \n        # Check if the array consists of only zeros\n        if all(val == 0 for val in arr):\n            return steps\n        \n        # Check if the array remains the same after cyclic shift\n        if arr == new_arr:\n            return -1\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the array size and cyclic shift offset\n    n, d = map(int, input().split())\n    \n    # Read the elements of the array\n    arr = list(map(int, input().split()))\n    \n    # Calculate the number of steps required\n    result = calculate_steps(n, d, arr)\n    \n    # Output the result\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "# Function to calculate the number of steps required to reach an array consisting of only zeros\ndef calculate_steps(n, d, arr):\n    # Initialize a counter for steps\n    steps = 0\n    \n    # Iterate through the array to perform cyclic shift and logical 'AND' operation\n    while True:\n        # Perform cyclic shift to the right by d cells\n        new_arr = arr[-d:] + arr[:-d]\n        \n        # Perform logical 'AND' operation on each element of the array\n        arr = [new_arr[i] & arr[i] for i in range(n)]\n        \n        # Increment the step counter\n        steps += 1\n        \n        # Check if the array consists of only zeros\n        if all(val == 0 for val in arr):\n            return steps\n        \n        # Check if the array remains the same after cyclic shift\n        if arr == new_arr:\n            return -1\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the array size and cyclic shift offset\n    n, d = map(int, input().split())\n    \n    # Read the elements of the array\n    arr = list(map(int, input().split()))\n    \n    # Calculate the number of steps required\n    result = calculate_steps(n, d, arr)\n    \n    # Output the result\n    print(result)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases, array size, cyclic shift offset, and array elements\",\n      \"Simulate the process of cyclic shifting and logical 'AND' operation on the array until it consists of only zeros or the process reaches a stable state\",\n      \"Count the number of steps taken to reach the final state or determine if the array will never consist of only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Simulate the process of cyclic shifting and logical 'AND' operation on the array until it reaches a stable state or consists of only zeros\",\n      \"Count the number of steps taken to reach the final state or determine if the array will never consist of only zeros\",\n      \"Output the number of steps or -1 based on the result of the simulation\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a specified number of cells.\n    'logical \"AND\" operation': It is a bitwise operation that returns 1 for each bit position where both operands have a bit value of 1, otherwise returns 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and dependent on each other.\n\n# [edge case] \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: The array will change as follows: [0, 1] -> [1, 0] after one step.\n    \n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: The array will change as follows: [1, 1, 0, 1, 0] -> [1, 0, 1, 1, 0] -> [1, 0, 0, 1, 0] -> [0, 0, 1, 0, 0]. It takes 3 steps to reach [0, 0, 0, 0, 0].\n    \n    4 2\n    0 1 0 1\n    Expected Output: -1\n    Explanation: The array will not change as it shifts by 2 to the right, so each element will be calculated as 0 & 0 or 1 & 1, thus not changing its value. The array will never contain only zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        seen = set()\n        steps = 0\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[i] & arr[(i - d) % n]\n            if new_arr.count(1) == 0:\n                return steps\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        seen = set()\n        steps = 0\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[i] & arr[(i - d) % n]\n            if new_arr.count(1) == 0:\n                return steps\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, simulate the process of cyclic shifting and logical AND operation until the array stops changing\",\n    \"Check if the final array consists of only zeros or if there are still elements equal to 1\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases\",\n    \"step_2\": \"For each test case, parse the array size, cyclic shift offset, and elements of the array\",\n    \"step_3\": \"Simulate the process of cyclic shifting and logical AND operation until the array stops changing\",\n    \"step_4\": \"Check if the final array consists of only zeros or if there are still elements equal to 1\",\n    \"step_5\": \"Output the number of steps after which the array will contain only zeros or -1 if there are still elements equal to 1\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a certain number of positions.\n    'logical AND operation': It is a binary operation that takes two equal-length binary representations and performs the logical AND operation on each pair of corresponding bits.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    5 1\n    1 1 1 1 1\n    Output\n    1\n    Explanation: The array will change as follows: [1, 1, 1, 1, 1] -> [1, 1, 1, 1, 1] (no change after cyclic shift and logical AND operation), so the answer is 1.\n    \n    4 2\n    0 0 0 0\n    Output\n    0\n    Explanation: The array already consists of only zeros, so the answer is 0.\n    \n    3 1\n    1 0 1\n    Output\n    2\n    Explanation: The array will change as follows: [1, 0, 1] -> [1, 1, 0] -> [1, 0, 0] -> [0, 0, 0], so the answer is 2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        seen = set()\n        while tuple(arr) not in seen:\n            seen.add(tuple(arr))\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[i] = arr[(i - d) % n] & arr[i]\n            arr = new_arr\n            steps += 1\n            if all(val == 0 for val in arr):\n                return steps\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        steps = calculate_steps(n, d, arr)\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    steps = 0\n    seen = set()\n    while tuple(arr) not in seen:\n        seen.add(tuple(arr))\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[i]\n        arr = new_arr\n        steps += 1\n        if all(val == 0 for val in arr):\n            return steps\n    return -1\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = []\nfor n, d, arr in test_cases:\n    steps = calculate_steps(n, d, arr)\n    results.append(steps)\n\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the test case descriptions\",\n      \"For each test case, extract the array size, cyclic shift offset, and the array elements\",\n      \"Implement a function to calculate the number of steps after which the array will contain only zeros or return -1 if there are still elements equal to 1\"\n    ],\n    \"high-level_steps\": [\n      \"Parse the input to extract the number of test cases and test case descriptions\",\n      \"For each test case, extract the array size, cyclic shift offset, and the array elements\",\n      \"Implement a function to perform the cyclic shift operation on the array elements\",\n      \"Implement a function to calculate the element-by-element 'AND' operation between the original array and the shifted array\",\n      \"Repeat the cyclic shift and 'AND' operation until all elements in the array are zeros or a maximum number of steps is reached\",\n      \"Output the number of steps taken or -1 if there are still elements equal to 1\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': Refers to shifting the elements of the array in a circular manner by a specified offset.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        while steps < n:\n            all_zeros = all(val == 0 for val in arr)\n            if all_zeros:\n                return steps\n            if steps == n:\n                return -1\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[(i + d) % n] = arr[i] & arr[(i + d) % n]\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        result = calculate_steps(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_steps(n, d, arr):\n        steps = 0\n        while steps < n:\n            all_zeros = all(val == 0 for val in arr)\n            if all_zeros:\n                return steps\n            if steps == n:\n                return -1\n            new_arr = [0] * n\n            for i in range(n):\n                new_arr[(i + d) % n] = arr[i] & arr[(i + d) % n]\n            arr = new_arr\n            steps += 1\n        return -1\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        result = calculate_steps(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"Handle the case where there are still elements equal to 1 in the array after the end of the process\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"step_2\": \"For each test case, implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"step_3\": \"Handle the case where there are still elements equal to 1 in the array after the end of the process\",\n    \"step_4\": \"Output the results for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'array of zeroes and ones only'\n    Explanation: The array consists of only 0s and 1s.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan covers all scenarios.", "Round_0": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] & arr[i] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_steps_to_zeros(n, d, arr):\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        arr = [arr[(i - d) % n] & arr[i] for i in range(n)]\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps_to_zeros(n, d, arr)\n    print(result)\n"}}], "scores": [], "pass_results": [false, false, false, true, false, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 70, "prompt": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. You need to consider the most efficient way to simulate this process to arrive at the solution.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 4}
