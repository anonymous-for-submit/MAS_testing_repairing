{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "repair_prompt": ["Monocarp's array a is made up of n integers, where k is the average value of these elements (note that k might not be an integer). Monocarp is interested in removing exactly two entries from array a in a way that keeps the mean of the leftover (n - 2) items unchanged at k, which represents the mean of an n-sized array, defined by the sum of the elements divided by their count (i.e., sum divided by n). Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the arithmetic mean of (n - 2) remaining elements is the same as k (that is, it is identical to the mean value of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is interested in removing exactly two entries from array a in a way that keeps the mean of the leftover (n - 2) items unchanged at k, which represents the mean of an n-sized array, defined by the sum of the elements divided by their count.Specifically, your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the arithmetic mean of (n - 2) remaining elements is the same as k. \n\nMonocarp's array a is made up of n integers, where k is the average value of these elements (note that k might not be an integer). Monocarp is interested in removing exactly two entries from array a in a way that keeps the mean of the leftover (n - 2) items unchanged at k, which represents the mean of an n-sized array, defined by the sum of the elements divided by their count (i.e., sum divided by n). Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the arithmetic mean of (n - 2) remaining elements is the same as k (that is, it is identical to the mean value of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp's array a is made up of n integers, where k is the average value of these elements and wants to remove exactly two entries in a way that keeps the mean of the leftover items unchanged at k. Calculate the number of pairs of positions [i, j] (i < j) such that if these elements are deleted, the arithmetic mean of remaining elements is the same as k.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\n# Function to calculate the average value of elements in the array\ndef calculate_average(arr):\n    return sum(arr) / len(arr)\n\n# Function to count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\ndef count_pairs(arr, k):\n    pairs_count = 0\n    for i, j in combinations(range(len(arr)), 2):\n        remaining_sum = sum(arr) - arr[i] - arr[j]\n        remaining_count = len(arr) - 2\n        if remaining_sum / remaining_count == k:\n            pairs_count += 1\n    return pairs_count\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the sequence of integers in the array\n    arr = list(map(int, input().split()))\n    # Calculate the average value of the elements in the array\n    k = calculate_average(arr)\n    # Count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\n    result = count_pairs(arr, k)\n    # Print the final count of pairs for the current testcase\n    print(result)\n\nmain()", "completions": ["t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == k:\n                count += 1\n    \n    print(count)\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n\nmain()", "from collections import defaultdict\n\ndef calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def count_pairs(arr, mean):\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in arr:\n            count += freq[2 * mean - num]\n            freq[num] += 1\n        \n        return count\n    \n    results = []\n    \n    for _ in range(t):\n        n = testcases[_][0]\n        arr = testcases[_][1]\n        \n        mean = calculate_mean(arr)\n        pairs = count_pairs(arr, mean)\n        \n        results.append(pairs)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\n# Calculate and output results\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n\nmain()", "from collections import defaultdict\n\ndef calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def calculate_pairs_helper(arr, mean):\n        count = 0\n        prefix_sum = defaultdict(int)\n        prefix_sum[0] = 1\n        cur_sum = 0\n        \n        for i in range(len(arr)):\n            cur_sum += arr[i]\n            count += prefix_sum[cur_sum - 2 * mean]\n            prefix_sum[cur_sum] += 1\n        \n        return count\n    \n    results = []\n    \n    for _ in range(t):\n        n = testcases[_][0]\n        arr = testcases[_][1]\n        \n        mean = calculate_mean(arr)\n        pairs = calculate_pairs_helper(arr, mean)\n        results.append(pairs)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\n# Calculate and output results\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n\nmain()", "def calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def find_pairs(n, arr):\n        count = 0\n        mean = calculate_mean(arr)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                new_mean = calculate_mean(new_arr)\n                if new_mean == mean:\n                    count += 1\n        \n        return count\n    \n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        pairs = find_pairs(n, arr)\n        results.append(pairs)\n    \n    return results\n\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (sum(arr) - arr[i] - arr[j]) / (n - 2) == mean:\n                count += 1\n    \n    print(count)\n\nmain()", "def calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def find_pairs(n, arr):\n        count = 0\n        mean = calculate_mean(arr)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                new_mean = calculate_mean(new_arr)\n                if new_mean == mean:\n                    count += 1\n        \n        return count\n    \n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        pairs = find_pairs(n, arr)\n        results.append(pairs)\n    \n    return results\n\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\nresults = calculate_pairs(t, testcases)\n\nfor res in results:\n    print(res)\n\nmain()", "from itertools import combinations\n\n# Function to calculate the average value of elements in the array\ndef calculate_average(arr):\n    return sum(arr) / len(arr)\n\n# Function to count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\ndef count_pairs(arr, k):\n    pairs_count = 0\n    for i, j in combinations(range(len(arr)), 2):\n        remaining_sum = sum(arr) - arr[i] - arr[j]\n        remaining_count = len(arr) - 2\n        if remaining_sum / remaining_count == k:\n            pairs_count += 1\n    return pairs_count\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the sequence of integers in the array\n    arr = list(map(int, input().split()))\n    # Calculate the average value of the elements in the array\n    k = calculate_average(arr)\n    # Count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\n    result = count_pairs(arr, k)\n    # Print the final count of pairs for the current testcase\n    print(result)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Calculate the average value of the elements in the array\",\n      \"Identify pairs of positions [i, j] where removing elements will keep the mean unchanged\",\n      \"Count the number of such pairs\"\n    ],\n    \"steps\": [\n      \"Read the number of testcases (t)\",\n      \"For each testcase:\",\n      \"  Read the number of elements in the array (n)\",\n      \"  Read the sequence of integers in the array (a)\",\n      \"  Calculate the average value of the elements in the array (k)\",\n      \"  Initialize a counter for the number of pairs\",\n      \"  Iterate through all pairs of positions [i, j] (i < j):\",\n      \"    Calculate the mean of the remaining elements after removing elements at positions i and j\",\n      \"    If the mean is equal to k, increment the counter\",\n      \"  Print the final count of pairs for the current testcase\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': It refers to the sum of all elements divided by the total number of elements in the array.\n\n    'pairs of positions': Refers to combinations of two positions in the array where elements can be removed.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as there are no steps that need to be executed simultaneously.\n\n# [edge case] \n    Input\n    4\n    4\n    8 8 8 8\n    Output\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all elements are equal, and the mean will remain unchanged.\n\n    Input\n    3\n    50 20 10\n    Output\n    0\n    Explanation:\n    There is no way to delete two elements such that the mean remains unchanged.\n\n    Input\n    5\n    1 4 7 3 5\n    Output\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "from itertools import combinations\n\n# Function to calculate the average value of elements in the array\ndef calculate_average(arr):\n    return sum(arr) / len(arr)\n\n# Function to count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\ndef count_pairs(arr, k):\n    pairs_count = 0\n    for i, j in combinations(range(len(arr)), 2):\n        remaining_sum = sum(arr) - arr[i] - arr[j]\n        remaining_count = len(arr) - 2\n        if remaining_sum / remaining_count == k:\n            pairs_count += 1\n    return pairs_count\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the sequence of integers in the array\n    arr = list(map(int, input().split()))\n    # Calculate the average value of the elements in the array\n    k = calculate_average(arr)\n    # Count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\n    result = count_pairs(arr, k)\n    # Print the final count of pairs for the current testcase\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 38)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to calculate the average value of elements in the array\ndef calculate_average(arr):\n    return sum(arr) / len(arr)\n\n# Function to count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\ndef count_pairs(arr, k):\n    pairs_count = 0\n    for i, j in combinations(range(len(arr)), 2):\n        remaining_sum = sum(arr) - arr[i] - arr[j]\n        remaining_count = len(arr) - 2\n        if remaining_sum / remaining_count == k:\n            pairs_count += 1\n    return pairs_count\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the sequence of integers in the array\n    arr = list(map(int, input().split()))\n    # Calculate the average value of the elements in the array\n    k = calculate_average(arr)\n    # Count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\n    result = count_pairs(arr, k)\n    # Print the final count of pairs for the current testcase\n    print(result)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Calculate the average value of the elements in the array\",\n    \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n    \"Count the number of such pairs\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Calculate the average value of the elements in the array\",\n    \"step_2\": \"Iterate through all pairs of positions [i, j] (i < j)\",\n    \"step_3\": \"Remove the elements at positions i and j and calculate the new mean of the remaining elements\",\n    \"step_4\": \"If the new mean is equal to the original mean, increment the count of valid pairs\",\n    \"step_5\": \"Output the total count of valid pairs\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': The average value of the elements in the array, denoted as 'k', may not be an integer. It is calculated as the sum of all elements divided by the count of elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Input:\n    4\n    4\n    8 8 8 8\n    Output:\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all of them are equal, and the mean will remain unchanged.\n\n    Input:\n    3\n    50 20 10\n    Output:\n    0\n    Explanation:\n    There is no way to delete two elements such that the mean doesn't change.\n\n    Input:\n    5\n    1 4 7 3 5\n    Output:\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or the elements at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the edge cases.", "Round_0": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == k:\n                count += 1\n    \n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 25)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == k:\n                count += 1\n    \n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Calculate the average value of the elements in the array\",\n    \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n    \"Count the number of such pairs\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases (t)\",\n    \"Step 2\": \"For each testcase, read the number of elements in the array (n)\",\n    \"Step 3\": \"Read the sequence of integers representing the array\",\n    \"Step 4\": \"Calculate the average value (k) of the elements in the array\",\n    \"Step 5\": \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n    \"Step 6\": \"Count the number of such pairs\",\n    \"Step 7\": \"Output the total number of pairs for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': The average value of the elements in the array, denoted as 'k', may not be an integer. It is calculated as the sum of all elements divided by the count of elements.\n\n    'pairs of positions': Refers to the combinations of two positions [i, j] in the array where removing the elements at those positions will keep the mean unchanged at 'k'.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    4\n    4\n    8 8 8 8\n    Output:\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all elements are equal, and removing any pair will not change the mean.\n\n    Input:\n    3\n    50 20 10\n    Output:\n    0\n    Explanation:\n    There is no way to delete two elements such that the mean remains unchanged.\n\n    Input:\n    5\n    1 4 7 3 5\n    Output:\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or the elements at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to identify pairs of positions and count them is sufficient to handle the given requirements.", "Round_0": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 23)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Calculate the average value of the elements in the array\",\n      \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\"\n    ],\n    \"major_steps\": [\n      \"Parse the input to get the number of test cases\",\n      \"For each test case, parse the input to get the number of elements in the array and the array itself\",\n      \"Calculate the average value of the elements in the array\",\n      \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n      \"Output the number of pairs of positions for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': The average value of the elements in the array represents the mean value of all the integers in the array.\n    'pairs of positions': Refers to the combinations of two positions in the array where elements can be removed to maintain the mean unchanged.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All major steps should be implemented step by step as they involve different calculations and operations.\n\n# [edge case] \n    Input\n    4\n    4\n    8 8 8 8\n    Output\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all of them are equal, and the mean will remain unchanged.\n    \n    Input\n    3\n    50 20 10\n    Output\n    0\n    Explanation:\n    There is no way to delete two elements so the mean doesn't change.\n    \n    Input\n    5\n    1 4 7 3 5\n    Output\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or the elements at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to calculate the pairs of positions can be implemented based on the original plan.", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def count_pairs(arr, mean):\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in arr:\n            count += freq[2 * mean - num]\n            freq[num] += 1\n        \n        return count\n    \n    results = []\n    \n    for _ in range(t):\n        n = testcases[_][0]\n        arr = testcases[_][1]\n        \n        mean = calculate_mean(arr)\n        pairs = count_pairs(arr, mean)\n        \n        results.append(pairs)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\n# Calculate and output results\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def count_pairs(arr, mean):\n        count = 0\n        freq = defaultdict(int)\n        \n        for num in arr:\n            count += freq[2 * mean - num]\n            freq[num] += 1\n        \n        return count\n    \n    results = []\n    \n    for _ in range(t):\n        n = testcases[_][0]\n        arr = testcases[_][1]\n        \n        mean = calculate_mean(arr)\n        pairs = count_pairs(arr, mean)\n        \n        results.append(pairs)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\n# Calculate and output results\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Calculate the average value of the elements in the array\",\n      \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\"\n    ],\n    \"major_steps\": [\n      \"Read the number of testcases (t)\",\n      \"For each testcase:\",\n      \"  Read the number of elements in the array (n)\",\n      \"  Read the sequence of integers in the array (a)\",\n      \"  Calculate the average value of the elements in the array\",\n      \"  Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n      \"  Print the number of pairs of positions [i, j] that satisfy the condition\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': It refers to the sum of all elements divided by the total number of elements in the array.\n\n    'pairs of positions': Refers to combinations of two positions in the array where elements can be removed to maintain the average value.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input\n    4\n    4\n    8 8 8 8\n    Output\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all of them are equal, and the mean will remain unchanged.\n\n    Input\n    3\n    50 20 10\n    Output\n    0\n    Explanation:\n    There is no way to delete two elements so the mathematical mean doesn't change.\n\n    Input\n    5\n    1 4 7 3 5\n    Output\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or the elements at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.", "Round_0": {"code": "from collections import defaultdict\n\ndef calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def calculate_pairs_helper(arr, mean):\n        count = 0\n        prefix_sum = defaultdict(int)\n        prefix_sum[0] = 1\n        cur_sum = 0\n        \n        for i in range(len(arr)):\n            cur_sum += arr[i]\n            count += prefix_sum[cur_sum - 2 * mean]\n            prefix_sum[cur_sum] += 1\n        \n        return count\n    \n    results = []\n    \n    for _ in range(t):\n        n = testcases[_][0]\n        arr = testcases[_][1]\n        \n        mean = calculate_mean(arr)\n        pairs = calculate_pairs_helper(arr, mean)\n        results.append(pairs)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\n# Calculate and output results\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 50)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def calculate_pairs_helper(arr, mean):\n        count = 0\n        prefix_sum = defaultdict(int)\n        prefix_sum[0] = 1\n        cur_sum = 0\n        \n        for i in range(len(arr)):\n            cur_sum += arr[i]\n            count += prefix_sum[cur_sum - 2 * mean]\n            prefix_sum[cur_sum] += 1\n        \n        return count\n    \n    results = []\n    \n    for _ in range(t):\n        n = testcases[_][0]\n        arr = testcases[_][1]\n        \n        mean = calculate_mean(arr)\n        pairs = calculate_pairs_helper(arr, mean)\n        results.append(pairs)\n    \n    return results\n\n# Input\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\n# Calculate and output results\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Calculate the average value of the elements in the array\",\n    \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n    \"Count the number of such pairs\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases (t)\",\n    \"Step 2\": \"For each testcase, read the number of elements in the array (n)\",\n    \"Step 3\": \"Read the sequence of integers representing the array\",\n    \"Step 4\": \"Calculate the average value (k) of the elements in the array\",\n    \"Step 5\": \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n    \"Step 6\": \"Count the number of such pairs\",\n    \"Step 7\": \"Output the total number of pairs for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': The average value of the elements in the array, denoted as 'k', may not be an integer. It is calculated as the sum of all elements divided by the count of elements.\n\n    'pairs of positions': Refers to the combinations of two positions [i, j] in the array where removing the elements at those positions will keep the mean unchanged at 'k'.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    4\n    4\n    8 8 8 8\n    Output:\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all elements are equal, and removing any pair will not change the mean.\n\n    Input:\n    3\n    50 20 10\n    Output:\n    0\n    Explanation:\n    There is no way to delete two elements such that the mean remains unchanged.\n\n    Input:\n    5\n    1 4 7 3 5\n    Output:\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or the elements at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to identify pairs of positions and count them is sufficient to handle the given requirements.", "Round_0": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 23)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Calculate the mean of the original array\",\n    \"Identify all pairs of positions [i, j] (i < j) in the array\",\n    \"Check if removing elements at positions i and j will keep the mean unchanged\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Calculate the mean of the original array\",\n    \"step_2\": \"Iterate through all pairs of positions [i, j] (i < j) in the array\",\n    \"step_3\": \"Remove elements at positions i and j, calculate the mean of the remaining elements\",\n    \"step_4\": \"Check if the mean of the remaining elements is equal to the original mean\",\n    \"step_5\": \"Count the number of pairs where the mean remains unchanged\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mean': The average value of the elements in the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Edge Case 1:\n    4\n    8 8 8 8\n    Output:\n    6\n    Explanation: Any pair of elements can be removed since all of them are equal, resulting in the same mean.\n    \n    Edge Case 2:\n    3\n    50 20 10\n    Output:\n    0\n    Explanation: There is no way to delete two elements such that the mean changes.\n    \n    Edge Case 3:\n    5\n    1 4 7 3 5\n    Output:\n    2\n    Explanation: It is possible to delete the elements at positions 1 and 3, or positions 4 and 5.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def find_pairs(n, arr):\n        count = 0\n        mean = calculate_mean(arr)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                new_mean = calculate_mean(new_arr)\n                if new_mean == mean:\n                    count += 1\n        \n        return count\n    \n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        pairs = find_pairs(n, arr)\n        results.append(pairs)\n    \n    return results\n\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 43)"}, "Round_1": {"code": "def calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def find_pairs(n, arr):\n        count = 0\n        mean = calculate_mean(arr)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                new_mean = calculate_mean(new_arr)\n                if new_mean == mean:\n                    count += 1\n        \n        return count\n    \n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        pairs = find_pairs(n, arr)\n        results.append(pairs)\n    \n    return results\n\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\nresults = calculate_pairs(t, testcases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Calculate the average value of the elements in the array\",\n    \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n    \"Count the number of such pairs\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases (t)\",\n    \"Step 2\": \"For each testcase, read the number of elements in the array (n)\",\n    \"Step 3\": \"Read the sequence of integers representing the array\",\n    \"Step 4\": \"Calculate the average value (k) of the elements in the array\",\n    \"Step 5\": \"Identify pairs of positions [i, j] where removing the elements at those positions will keep the mean unchanged\",\n    \"Step 6\": \"Count the number of such pairs\",\n    \"Step 7\": \"Output the total number of pairs for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': The average value of the elements in the array, denoted as 'k', may not be an integer. It is calculated as the sum of the elements divided by their count.\n\n    'pairs of positions': Refers to the combinations of two positions [i, j] in the array where removing the elements at those positions will keep the mean unchanged at 'k'.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they involve different calculations and operations.\n\n# [edge case] \n    Input\n    4\n    4\n    8 8 8 8\n    Output\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all of them are equal, and the mean will remain unchanged.\n\n    Input\n    3\n    50 20 10\n    Output\n    0\n    Explanation:\n    There is no way to delete two elements such that the mean of the remaining elements remains unchanged.\n\n    Input\n    5\n    1 4 7 3 5\n    Output\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or the elements at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of identifying pairs of positions and calculating the mean covers all scenarios.", "Round_0": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 23)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    total_sum = sum(arr)\n    k = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == k:\n                count += 1\n    \n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Calculate the mean of the original array\",\n    \"Identify all pairs of positions [i, j] (i < j) in the array\",\n    \"Check if removing elements at positions i and j will keep the mean unchanged\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Calculate the mean of the original array\",\n    \"step_2\": \"Iterate through all pairs of positions [i, j] (i < j) in the array\",\n    \"step_3\": \"Remove elements at positions i and j, calculate the mean of the remaining elements\",\n    \"step_4\": \"Check if the mean of the remaining elements is equal to the original mean\",\n    \"step_5\": \"Count the number of pairs where the mean remains unchanged\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mean': The average value of the elements in the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as they are sequential and do not require simultaneous implementation.\n\n# [edge case] \n    Edge Case 1:\n    4\n    8 8 8 8\n    Output:\n    6\n    Explanation: Any pair of elements can be removed since all of them are equal, resulting in the same mean.\n    \n    Edge Case 2:\n    3\n    50 20 10\n    Output:\n    0\n    Explanation: There is no way to delete two elements such that the mean changes.\n    \n    Edge Case 3:\n    5\n    1 4 7 3 5\n    Output:\n    2\n    Explanation: It is possible to delete the elements at positions 1 and 3, or positions 4 and 5.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (sum(arr) - arr[i] - arr[j]) / (n - 2) == mean:\n                count += 1\n    \n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 22)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    mean = sum(arr) / n\n    count = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (sum(arr) - arr[i] - arr[j]) / (n - 2) == mean:\n                count += 1\n    \n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Calculate the mean of the original array\",\n    \"Identify all pairs of positions [i, j] (i < j) in the array\",\n    \"Check if removing elements at positions i and j will keep the mean unchanged\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Calculate the mean of the original array\",\n    \"Step 2\": \"Iterate through all pairs of positions [i, j] (i < j) in the array\",\n    \"Step 3\": \"Remove elements at positions i and j and calculate the mean of the remaining elements\",\n    \"Step 4\": \"Check if the mean of the remaining elements is equal to the original mean\",\n    \"Step 5\": \"Count the number of pairs where the mean remains unchanged\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mean': The average value of the elements in the array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Input:\n    4\n    4\n    8 8 8 8\n    Output:\n    6\n    Explanation: Any pair of elements can be removed since all of them are equal.\n\n    Input:\n    3\n    50 20 10\n    Output:\n    0\n    Explanation: There is no way to delete two elements so the mean doesn't change.\n\n    Input:\n    5\n    1 4 7 3 5\n    Output:\n    2\n    Explanation: It is possible to delete the elements at positions 1 and 3, or the elements at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def find_pairs(n, arr):\n        count = 0\n        mean = calculate_mean(arr)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                new_mean = calculate_mean(new_arr)\n                if new_mean == mean:\n                    count += 1\n        \n        return count\n    \n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        pairs = find_pairs(n, arr)\n        results.append(pairs)\n    \n    return results\n\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\nresults = calculate_pairs(t, testcases)\n\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 44)"}, "Round_1": {"code": "def calculate_pairs(t, testcases):\n    def calculate_mean(arr):\n        return sum(arr) / len(arr)\n    \n    def find_pairs(n, arr):\n        count = 0\n        mean = calculate_mean(arr)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                new_arr = arr[:i] + arr[i+1:j] + arr[j+1:]\n                new_mean = calculate_mean(new_arr)\n                if new_mean == mean:\n                    count += 1\n        \n        return count\n    \n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        pairs = find_pairs(n, arr)\n        results.append(pairs)\n    \n    return results\n\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    testcases.append((n, arr))\n\nresults = calculate_pairs(t, testcases)\n\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Calculate the average value of the elements in the array\",\n      \"Identify pairs of positions [i, j] where removing elements will keep the mean unchanged\",\n      \"Count the number of such pairs\"\n    ],\n    \"steps\": [\n      \"Read the number of testcases (t)\",\n      \"For each testcase:\",\n      \"  Read the number of elements in the array (n)\",\n      \"  Read the sequence of integers in the array (a)\",\n      \"  Calculate the average value of the elements in the array (k)\",\n      \"  Initialize a counter for the number of pairs\",\n      \"  Iterate through all pairs of positions [i, j] (i < j):\",\n      \"    Calculate the mean of the remaining elements after removing elements at positions i and j\",\n      \"    If the mean is equal to k, increment the counter\",\n      \"  Print the final count of pairs for the current testcase\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'average value': It refers to the sum of all elements divided by the total number of elements in the array.\n\n    'pairs of positions': Refers to combinations of two positions in the array where elements can be removed.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as there are no steps that need to be executed simultaneously.\n\n# [edge case] \n    Input\n    4\n    4\n    8 8 8 8\n    Output\n    6\n    Explanation:\n    In this case, any pair of elements can be removed since all elements are equal, and the mean will remain unchanged.\n\n    Input\n    3\n    50 20 10\n    Output\n    0\n    Explanation:\n    There is no way to delete two elements such that the mean remains unchanged.\n\n    Input\n    5\n    1 4 7 3 5\n    Output\n    2\n    Explanation:\n    It is possible to delete the elements at positions 1 and 3, or at positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "from itertools import combinations\n\n# Function to calculate the average value of elements in the array\ndef calculate_average(arr):\n    return sum(arr) / len(arr)\n\n# Function to count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\ndef count_pairs(arr, k):\n    pairs_count = 0\n    for i, j in combinations(range(len(arr)), 2):\n        remaining_sum = sum(arr) - arr[i] - arr[j]\n        remaining_count = len(arr) - 2\n        if remaining_sum / remaining_count == k:\n            pairs_count += 1\n    return pairs_count\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the sequence of integers in the array\n    arr = list(map(int, input().split()))\n    # Calculate the average value of the elements in the array\n    k = calculate_average(arr)\n    # Count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\n    result = count_pairs(arr, k)\n    # Print the final count of pairs for the current testcase\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 38)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to calculate the average value of elements in the array\ndef calculate_average(arr):\n    return sum(arr) / len(arr)\n\n# Function to count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\ndef count_pairs(arr, k):\n    pairs_count = 0\n    for i, j in combinations(range(len(arr)), 2):\n        remaining_sum = sum(arr) - arr[i] - arr[j]\n        remaining_count = len(arr) - 2\n        if remaining_sum / remaining_count == k:\n            pairs_count += 1\n    return pairs_count\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of elements in the array\n    n = int(input())\n    # Read the sequence of integers in the array\n    arr = list(map(int, input().split()))\n    # Calculate the average value of the elements in the array\n    k = calculate_average(arr)\n    # Count the number of pairs of positions [i, j] where removing elements will keep the mean unchanged\n    result = count_pairs(arr, k)\n    # Print the final count of pairs for the current testcase\n    print(result)\n"}}], "scores": [], "pass_results": [true, false, true, false, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 187, "prompt": "Monocarp's array a is made up of n integers, where k is the average value of these elements (note that k might not be an integer). Monocarp is interested in removing exactly two entries from array a in a way that keeps the mean of the leftover (n - 2) items unchanged at k, which represents the mean of an n-sized array, defined by the sum of the elements divided by their count (i.e., sum divided by n). Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the arithmetic mean of (n - 2) remaining elements is the same as k (that is, it is identical to the mean value of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 143}
