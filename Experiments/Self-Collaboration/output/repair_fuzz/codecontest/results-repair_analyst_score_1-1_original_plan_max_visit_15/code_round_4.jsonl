{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "repair_prompt": ["You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Analyze the algorithm's complexity to provide further insights into its performance.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "It means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$. This representation allows for a cyclic shift to the right by d cells. \n\nYou are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given an array a[0 \u2026 n - 1] of zeroes and ones only, and in one step, the array a is replaced by another array of length n according to certain rules mentioned above.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    if 1 in arr[:d]:\n        return 1\n    for i in range(d, n):\n        if arr[i] == 1:\n            return 2\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n\nmain()", "completions": ["def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Get results\nresults = cyclic_shift_and_operation(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res)\n\nmain()", "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        for i in range(n):\n            if arr[i] == 1:\n                arr[(i + d) % n] = arr[(i + d) % n] & 1\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if steps > n:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def perform_logical_and(a, a_shifted):\n        return [x & y for x, y in zip(a, a_shifted)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    def process_test_case(n, d, a):\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = calculate_cyclic_shift(a, d)\n            a = perform_logical_and(a, a_shifted)\n            steps += 1\n            if a == a_shifted:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n        result = process_test_case(n, d, a)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor result in results:\n    print(result)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if arr == arr_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        n = len(a)\n        return [a[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def calculate_steps(n, d, arr):\n    if sum(arr) == 0:\n        return 0\n    if d == 0:\n        return -1\n    if sum(arr) == n:\n        return -1\n    \n    steps = 1\n    while True:\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[(i + d) % n]\n        \n        if sum(new_arr) == 0:\n            return steps\n        if new_arr == arr:\n            return -1\n        \n        arr = new_arr\n        steps += 1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n\nmain()", "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    if 1 in arr[:d]:\n        return 1\n    for i in range(d, n):\n        if arr[i] == 1:\n            return 2\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps required for each test case\",\n    \"Handle the case where the array will never contain only zeros\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, implement a function to calculate the number of steps required to have an array containing only zeros\",\n    \"If the array will never contain only zeros, output -1\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift offset'\n    Explanation: It refers to the number of positions the array elements are shifted cyclically.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    if 1 in arr[:d]:\n        return 1\n    for i in range(d, n):\n        if arr[i] == 1:\n            return 2\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 25)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    if 1 in arr[:d]:\n        return 1\n    for i in range(d, n):\n        if arr[i] == 1:\n            return 2\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken to reach an array with only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the array size, cyclic shift offset, and array elements\",\n    \"Step 3\": \"Perform the cyclic shift operation on the array based on the given offset\",\n    \"Step 4\": \"Perform the logical 'AND' operation on each element of the array\",\n    \"Step 5\": \"Check if the array contains only zeros, if not repeat steps 3 and 4\",\n    \"Step 6\": \"Count the number of steps taken to reach an array with only zeros\",\n    \"Step 7\": \"Output the number of steps or -1 if the array never contains only zeros\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: The core concept involves shifting the elements of an array in a circular manner to the right by a specified offset.\n\n    'logical AND operation'\n    Explanation: Refers to performing a bitwise AND operation on corresponding bits of two arrays.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, the array will change in 1 step to contain only zeros.\n    - In the second test case, the array will change in 1 step to contain only zeros.\n    - In the third test case, the array will change in 3 steps to contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Get results\nresults = cyclic_shift_and_operation(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 54)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Get results\nresults = cyclic_shift_and_operation(t, test_cases)\n\n# Output results\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"Handle the case where there are still elements equal to 1 in the array after the end of the process\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"step_2\": \"For each test case, implement a function to calculate the number of steps after which the array will contain only zeros for the first time\",\n    \"step_3\": \"Handle the case where there are still elements equal to 1 in the array after the end of the process\",\n    \"step_4\": \"Output the answer to each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift offset'\n    Explanation: It refers to the number of positions the array elements are shifted cyclically.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan covers all scenarios.", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        for i in range(n):\n            if arr[i] == 1:\n                arr[(i + d) % n] = arr[(i + d) % n] & 1\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 28)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    steps = 0\n    while 1 in arr:\n        steps += 1\n        for i in range(n):\n            if arr[i] == 1:\n                arr[(i + d) % n] = arr[(i + d) % n] & 1\n        if steps > n:\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform element-wise logical AND operation on the array\",\n    \"Check if the array contains only zeros after each step\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the array size and cyclic shift offset\",\n    \"Step 3\": \"Read the elements of the array\",\n    \"Step 4\": \"Perform cyclic shift operation on the array\",\n    \"Step 5\": \"Perform element-wise logical AND operation on the array\",\n    \"Step 6\": \"Check if the array contains only zeros, if not repeat steps 4 and 5\",\n    \"Step 7\": \"Output the number of steps taken or -1 if array still contains ones\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: It means shifting the elements of the array to the right by a certain number of cells and wrapping around the array.\n\n    'element-wise logical AND operation'\n    Explanation: It means performing a logical AND operation between each element of the original array and the corresponding element after the cyclic shift.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    1 1\n    0\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n    Explanation:\n    - In the first test case, the array is already zeros, so the output is 0.\n    - In the second test case, after the first step, the array becomes [0, 0, 0] so the output is 1.\n    - In the third test case, it takes 3 steps for the array to become all zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array is already zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if steps > n:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if steps > n:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform element-wise logical AND operation on the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Determine the number of steps required for the array to contain only zeros or if it will never contain only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the array size, cyclic shift offset, and array elements\",\n    \"Step 3\": \"Perform cyclic shift operation on the array based on the given offset\",\n    \"Step 4\": \"Perform element-wise logical AND operation on the array\",\n    \"Step 5\": \"Check if the array contains only zeros\",\n    \"Step 6\": \"Repeat steps 3-5 until the array contains only zeros or determine if it will never contain only zeros\",\n    \"Step 7\": \"Output the number of steps required for the array to contain only zeros or -1 if it will never contain only zeros\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': Refers to shifting the elements of an array in a circular manner to the right by a specified number of cells.\n    'logical AND operation': Refers to performing a bitwise AND operation on corresponding bits of two arrays.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def perform_logical_and(a, a_shifted):\n        return [x & y for x, y in zip(a, a_shifted)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    def process_test_case(n, d, a):\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = calculate_cyclic_shift(a, d)\n            a = perform_logical_and(a, a_shifted)\n            steps += 1\n            if a == a_shifted:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n        result = process_test_case(n, d, a)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def calculate_cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def perform_logical_and(a, a_shifted):\n        return [x & y for x, y in zip(a, a_shifted)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    def process_test_case(n, d, a):\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = calculate_cyclic_shift(a, d)\n            a = perform_logical_and(a, a_shifted)\n            steps += 1\n            if a == a_shifted:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n        result = process_test_case(n, d, a)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor result in results:\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken to reach an array with only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the array size and cyclic shift offset\",\n    \"Step 3\": \"Read the elements of the array\",\n    \"Step 4\": \"Perform the cyclic shift operation on the array\",\n    \"Step 5\": \"Perform the logical 'AND' operation on each element of the array\",\n    \"Step 6\": \"Check if the array contains only zeros\",\n    \"Step 7\": \"Repeat steps 4-6 until the array contains only zeros or no change occurs\",\n    \"Step 8\": \"Count the number of steps taken to reach an array with only zeros or determine if it's not possible\",\n    \"Step 9\": \"Output the number of steps for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a certain number of positions.\n    'logical AND operation': It is a bitwise operation that results in 1 only if both bits are 1, otherwise, it results in 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential and dependent on each other.\n\n# [edge case] \n    Case 1: \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: The array will change from [0, 1] to [1, 0] after one step.\n    \n    Case 2:\n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: The array will change as described in the prompt, and it will contain only zeros after 3 steps.\n    \n    Case 3:\n    1 1\n    0\n    Expected Output: 0\n    Explanation: The array already contains only zeros, so the expected output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 52)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n        steps = 0\n\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform element-wise logical AND operation on the array elements\",\n    \"Check if the array contains only zeros after each step\",\n    \"Determine the number of steps required for the array to contain only zeros or if it will never contain only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input data for each test case\",\n    \"step_2\": \"Initialize a counter to keep track of the number of steps\",\n    \"step_3\": \"Repeat the following steps until the array contains only zeros or the array stops changing:\",\n    \"substeps\": [\n      \"Perform cyclic shift operation on the array by d cells to the right\",\n      \"Perform element-wise logical AND operation on the array elements\",\n      \"Check if the array contains only zeros\",\n      \"Increment the counter by 1\"\n    ],\n    \"step_4\": \"If the array contains only zeros, output the number of steps taken. If the array never contains only zeros, output -1\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: It means shifting the elements of the array to the right by a certain number of cells and wrapping around the array.\n\n    'element-wise logical AND operation'\n    Explanation: It means performing a logical AND operation between each element of the original array and the corresponding element after the cyclic shift.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    1 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n    Explanation:\n    - In the first test case, the array will change in one step to contain only zeros.\n    - In the second test case, the array will change in one step to contain only zeros.\n    - In the third test case, the array will take 3 steps to contain only zeros.\n    - In the fourth test case, the array will never contain only zeros.\n    - In the fifth test case, the array already contains only zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if arr == arr_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        n = len(arr)\n        return [arr[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(arr1, arr2):\n        return [a1 & a2 for a1, a2 in zip(arr1, arr2)]\n\n    def check_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        arr = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(arr):\n            arr_shifted = cyclic_shift(arr, d)\n            arr = logical_and(arr, arr_shifted)\n            steps += 1\n\n            if arr == arr_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d), arr)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken to reach an array with only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the array size and cyclic shift offset\",\n    \"Step 3\": \"Read the elements of the array\",\n    \"Step 4\": \"Perform the cyclic shift operation on the array\",\n    \"Step 5\": \"Perform the logical 'AND' operation on each element of the array\",\n    \"Step 6\": \"Check if the array contains only zeros\",\n    \"Step 7\": \"Repeat steps 4-6 until the array contains only zeros or the process ends\",\n    \"Step 8\": \"Count the number of steps taken to reach an array with only zeros\",\n    \"Step 9\": \"Output the number of steps or -1 if the array still contains elements equal to 1\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: The core concept involves shifting the elements of an array in a circular manner to the right by a specified offset.\n\n    'logical AND operation'\n    Explanation: Refers to performing a bitwise AND operation on corresponding bits of two arrays.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different operations on the array.\n\n# [edge case] \n    5 1\n    1 1 1 1 1\n    Expected Output: -1\n    Explanation: The array will never contain only zeros as all elements are initially set to 1.\n\n    4 2\n    0 1 0 1\n    Expected Output: -1\n    Explanation: The array will not change as it shifts by 2 to the right, so each element will be calculated as 0 & 0 or 1 & 1, thus not changing its value.\n\n    3 1\n    1 0 1\n    Expected Output: 2\n    Explanation: The array will change as follows: [1, 0, 1] -> [1, 1, 0] -> [1, 0, 0] -> [0, 0, 0]. It takes 2 steps to reach an array with only zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        n = len(a)\n        return [a[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        n = len(a)\n        return [a[(i + n - d) % n] for i in range(n)]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        a = test_cases[i][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Implement the cyclic shift operation on the array\",\n    \"Perform the logical 'AND' operation on each element of the array\",\n    \"Check if the array contains only zeros after each step\",\n    \"Count the number of steps taken to reach an array with only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the array size and cyclic shift offset\",\n    \"Step 3\": \"Read the elements of the array\",\n    \"Step 4\": \"Perform the cyclic shift operation on the array\",\n    \"Step 5\": \"Perform the logical 'AND' operation on each element of the array\",\n    \"Step 6\": \"Check if the array contains only zeros\",\n    \"Step 7\": \"Repeat steps 4-6 until the array contains only zeros or the process ends\",\n    \"Step 8\": \"Count the number of steps taken to reach an array with only zeros\",\n    \"Step 9\": \"Output the number of steps or -1 if the array never contains only zeros\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: The core concept involves shifting the elements of an array to the right by a certain offset and then performing logical 'AND' operations on the elements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as each step builds upon the previous one.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, the array will change in 1 step to contain only zeros.\n    - In the second test case, the array will change in 1 step to contain only zeros.\n    - In the third test case, the array will change in 3 steps to contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to handle the edge cases.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps required for each test case\",\n    \"Handle the case where the array will never contain only zeros\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, implement a function to calculate the number of steps required to have an array containing only zeros\",\n    \"If the array will never contain only zeros, output -1\",\n    \"Output the results for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift offset'\n    Explanation: It refers to the number of positions the array elements are shifted cyclically.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be implemented sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    if sum(arr) == 0:\n        return 0\n    if d == 0:\n        return -1\n    if sum(arr) == n:\n        return -1\n    \n    steps = 1\n    while True:\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[(i + d) % n]\n        \n        if sum(new_arr) == 0:\n            return steps\n        if new_arr == arr:\n            return -1\n        \n        arr = new_arr\n        steps += 1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 35)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    if sum(arr) == 0:\n        return 0\n    if d == 0:\n        return -1\n    if sum(arr) == n:\n        return -1\n    \n    steps = 1\n    while True:\n        new_arr = [0] * n\n        for i in range(n):\n            new_arr[i] = arr[(i - d) % n] & arr[(i + d) % n]\n        \n        if sum(new_arr) == 0:\n            return steps\n        if new_arr == arr:\n            return -1\n        \n        arr = new_arr\n        steps += 1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the number of steps required for each test case\",\n    \"Handle the case where the array will never contain only zeros\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, implement a function to calculate the number of steps required to have an array containing only zeros\",\n    \"If the array will never contain only zeros, output -1\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift offset'\n    Explanation: It refers to the number of positions the array elements are shifted cyclically.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    if 1 in arr[:d]:\n        return 1\n    for i in range(d, n):\n        if arr[i] == 1:\n            return 2\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 25)"}, "Round_1": {"code": "def calculate_steps(n, d, arr):\n    if 1 not in arr:\n        return 0\n    if d == 1:\n        return -1\n    if 1 in arr[:d]:\n        return 1\n    for i in range(d, n):\n        if arr[i] == 1:\n            return 2\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = calculate_steps(n, d, arr)\n    print(result)\n"}}], "scores": [], "pass_results": [true, false, false, true, true, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 4, "prompt": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Analyze the algorithm's complexity to provide further insights into its performance.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 4}
