{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp decided to select exactly 3 problems from n problems for the problemset, ensuring that either the topics of the three selected problems are all different or the difficulties of the three selected problems are all different. How many ways can you determine to select these three problems for the problemset?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp, the coach of the Berland State University programming teams, decided to compose a problemset for a training session using n problems that none of his students have seen yet, selecting exactly 3 problems satisfying at least one of two conditions. Determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\ndef check_topics_unique(p1, p2, p3):\n    return len(set([p1[0], p2[0], p3[0]])) == 3\n\ndef check_difficulties_unique(p1, p2, p3):\n    return len(set([p1[1], p2[1], p3[1]])) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        total_ways = 0\n        for comb in combinations(problems, 3):\n            if check_topics_unique(*comb) or check_difficulties_unique(*comb):\n                total_ways += 1\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n\nmain()", "completions": ["from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the details of each problem\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize count of valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) >= 2 or len(difficulties) >= 2:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the details of each problem\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Function to calculate the number of ways to select three problems\n    def calculate_ways(problems):\n        count = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) >= 2 or len(difficulties) >= 2:\n                count += 1\n        return count\n    \n    # Output the result for the current testcase\n    print(calculate_ways(problems))\n\nmain()", "def count_ways_to_select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        n = problems[0]\n        problems = problems[1:]\n        \n        topics = set()\n        difficulties = set()\n        \n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        num_ways = min(len(topics), 3) * min(len(difficulties), 3)\n        \n        if num_ways == 9:\n            num_ways = 8\n        \n        results.append(num_ways)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        testcases.append([n] + problems)\n    \n    results = count_ways_to_select_problems(testcases)\n    \n    for result in results:\n        print(result)\n\nmain()", "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_topics_diff = min(n, len(topics))\n        min_difficulties_diff = min(n, len(difficulties))\n        \n        result = min(min_topics_diff, 3) + min(min_difficulties_diff, 3) - 3\n        \n        print(result)\n\ncount_ways_to_select_problems()\n\nmain()", "def count_ways_to_select_problems(testcases):\n    def count_valid_combinations(topics, difficulties):\n        return len(set(topics)) + len(set(difficulties) - 1)\n\n    results = []\n    for problems in testcases:\n        n = problems[0]\n        topics = [problem[0] for problem in problems[1:]]\n        difficulties = [problem[1] for problem in problems[1:]]\n        \n        valid_combinations = count_valid_combinations(topics, difficulties)\n        results.append(valid_combinations)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append([n] + problems)\n\n    results = count_ways_to_select_problems(testcases)\n    for result in results:\n        print(result)\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic_diff = 0\n        for topic in topics.values():\n            same_topic_diff += topic * (topic - 1) // 2\n        \n        for diff in difficulties.values():\n            same_topic_diff += diff * (diff - 1) // 2\n        \n        total_ways -= same_topic_diff\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n\nmain()", "def check_topics_difficulties_unique(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [list(map(int, input().split())) for _ in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if check_topics_difficulties_unique([problems[i], problems[j], problems[k]]):\n                        count += 1\n        print(count)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n\nmain()", "def check_all_different(arr):\n    return len(set(arr)) == len(arr)\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    topics = [problems[i][0], problems[j][0], problems[k][0]]\n                    difficulties = [problems[i][1], problems[j][1], problems[k][1]]\n                    if check_all_different(topics) or check_all_different(difficulties):\n                        count += 1\n        \n        print(count)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n\nmain()", "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[j][0] == problems[k][0] or problems[i][0] == problems[k][0] or problems[i][1] == problems[j][1] or problems[j][1] == problems[k][1] or problems[i][1] == problems[k][1]:\n                        ways += 1\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\ndef check_topics_unique(p1, p2, p3):\n    return len(set([p1[0], p2[0], p3[0]])) == 3\n\ndef check_difficulties_unique(p1, p2, p3):\n    return len(set([p1[1], p2[1], p3[1]])) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        total_ways = 0\n        for comb in combinations(problems, 3):\n            if check_topics_unique(*comb) or check_difficulties_unique(*comb):\n                total_ways += 1\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Implement a function to check if the topics of the three selected problems are all different\",\n    \"Implement a function to check if the difficulties of the three selected problems are all different\",\n    \"Count the total number of ways that meet either of the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"step_2\": \"For each testcase, iterate through the list of problems and create a list of all possible combinations of 3 problems\",\n    \"step_3\": \"For each combination, check if the topics are all different or the difficulties are all different\",\n    \"step_4\": \"Count the number of combinations that meet either of the requirements\",\n    \"step_5\": \"Output the total number of ways for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set, ensuring that either the topics or difficulties of the selected problems are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all combinations of 3 problems have different topics or difficulties, so there are 4 ways to select the problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, there are multiple ways to select 3 problems with different topics or difficulties, resulting in 10 possible combinations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\ndef check_topics_unique(p1, p2, p3):\n    return len(set([p1[0], p2[0], p3[0]])) == 3\n\ndef check_difficulties_unique(p1, p2, p3):\n    return len(set([p1[1], p2[1], p3[1]])) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        total_ways = 0\n        for comb in combinations(problems, 3):\n            if check_topics_unique(*comb) or check_difficulties_unique(*comb):\n                total_ways += 1\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 30)"}, "Round_1": {"code": "from itertools import combinations\n\ndef check_topics_unique(p1, p2, p3):\n    return len(set([p1[0], p2[0], p3[0]])) == 3\n\ndef check_difficulties_unique(p1, p2, p3):\n    return len(set([p1[1], p2[1], p3[1]])) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        total_ways = 0\n        for comb in combinations(problems, 3):\n            if check_topics_unique(*comb) or check_difficulties_unique(*comb):\n                total_ways += 1\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"For each testcase, iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting exactly 3 problems satisfying at least one of two conditions'\n    Explanation: The core concept is to choose 3 problems that meet at least one of the two conditions specified.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, processing data, and outputting results.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems, which is all three problems together.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All possible combinations of selecting 3 problems are valid.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All possible combinations of selecting 3 problems are valid.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all combinations and check validity covers all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the details of each problem\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize count of valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) >= 2 or len(difficulties) >= 2:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 41)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the details of each problem\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Initialize count of valid combinations\n    count = 0\n    \n    # Generate all combinations of 3 problems\n    for comb in combinations(problems, 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the combination meets the requirements\n        for problem in comb:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        if len(topics) >= 2 or len(difficulties) >= 2:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet either of the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Implement a function to calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting exactly 3 problems satisfying at least one of two conditions'\n    Explanation: The core concept is to choose 3 problems that meet at least one of the two conditions specified.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input and calculating the output.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems when all problems have different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all 4 problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    10\n    Explanation: There are multiple ways to select 3 problems that meet the conditions based on the topics and difficulties.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the details of each problem\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Function to calculate the number of ways to select three problems\n    def calculate_ways(problems):\n        count = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) >= 2 or len(difficulties) >= 2:\n                count += 1\n        return count\n    \n    # Output the result for the current testcase\n    print(calculate_ways(problems))\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 38)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate over each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Read the details of each problem\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    \n    # Function to calculate the number of ways to select three problems\n    def calculate_ways(problems):\n        count = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            for problem in comb:\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if len(topics) >= 2 or len(difficulties) >= 2:\n                count += 1\n        return count\n    \n    # Output the result for the current testcase\n    print(calculate_ways(problems))\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a function to determine the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Apply the function to each testcase and store the results\",\n    \"Step 5\": \"Output the results for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set of problems that meet certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, determining the number of ways to select problems, and outputting the results.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: Here, all topics and difficulties are different, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, there are 10 ways to select 3 problems that meet the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine the number of ways to select problems already covers all scenarios.", "Round_0": {"code": "def count_ways_to_select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        n = problems[0]\n        problems = problems[1:]\n        \n        topics = set()\n        difficulties = set()\n        \n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        num_ways = min(len(topics), 3) * min(len(difficulties), 3)\n        \n        if num_ways == 9:\n            num_ways = 8\n        \n        results.append(num_ways)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        testcases.append([n] + problems)\n    \n    results = count_ways_to_select_problems(testcases)\n    \n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 44)"}, "Round_1": {"code": "def count_ways_to_select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        n = problems[0]\n        problems = problems[1:]\n        \n        topics = set()\n        difficulties = set()\n        \n        for problem in problems:\n            topics.add(problem[0])\n            difficulties.add(problem[1])\n        \n        num_ways = min(len(topics), 3) * min(len(difficulties), 3)\n        \n        if num_ways == 9:\n            num_ways = 8\n        \n        results.append(num_ways)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        testcases.append([n] + problems)\n    \n    results = count_ways_to_select_problems(testcases)\n    \n    for result in results:\n        print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a function to determine the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Implement logic to check if the topics or difficulties of the selected problems are different\",\n    \"Step 5\": \"Count the number of valid combinations of three problems\",\n    \"Step 6\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is about selecting exactly 3 problems from a given set of problems that satisfy certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: Here, all problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, there are 10 ways to select 3 problems satisfying the given conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios.", "Round_0": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_topics_diff = min(n, len(topics))\n        min_difficulties_diff = min(n, len(difficulties))\n        \n        result = min(min_topics_diff, 3) + min(min_difficulties_diff, 3) - 3\n        \n        print(result)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 28)"}, "Round_1": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_topics_diff = min(n, len(topics))\n        min_difficulties_diff = min(n, len(difficulties))\n        \n        result = min(min_topics_diff, 3) + min(min_difficulties_diff, 3) - 3\n        \n        print(result)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a function to determine the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Implement logic to check if the topics or difficulties of the selected problems are different\",\n    \"Step 5\": \"Count the number of valid combinations of three problems\",\n    \"Step 6\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is about selecting exactly 3 problems from a given set of problems that satisfy certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all combinations of 3 problems can be selected as each problem has a different topic and difficulty.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All combinations of 3 problems can be selected as each problem has a different topic and difficulty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def count_ways_to_select_problems(testcases):\n    def count_valid_combinations(topics, difficulties):\n        return len(set(topics)) + len(set(difficulties) - 1)\n\n    results = []\n    for problems in testcases:\n        n = problems[0]\n        topics = [problem[0] for problem in problems[1:]]\n        difficulties = [problem[1] for problem in problems[1:]]\n        \n        valid_combinations = count_valid_combinations(topics, difficulties)\n        results.append(valid_combinations)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append([n] + problems)\n\n    results = count_ways_to_select_problems(testcases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 32)"}, "Round_1": {"code": "def count_ways_to_select_problems(testcases):\n    def count_valid_combinations(topics, difficulties):\n        return len(set(topics)) + len(set(difficulties) - 1)\n\n    results = []\n    for problems in testcases:\n        n = problems[0]\n        topics = [problem[0] for problem in problems[1:]]\n        difficulties = [problem[1] for problem in problems[1:]]\n        \n        valid_combinations = count_valid_combinations(topics, difficulties)\n        results.append(valid_combinations)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    testcases = []\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        testcases.append([n] + problems)\n\n    results = count_ways_to_select_problems(testcases)\n    for result in results:\n        print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Implement the logic to check if the topics or difficulties of the selected problems are different\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"Step 2\": \"For each testcase, iterate through the list of problems and check if the topics or difficulties of the selected problems are different\",\n    \"Step 3\": \"Count the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set of problems that satisfy certain conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, iterating through problems, checking conditions, and counting ways to select problems.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, all problems have different topics and difficulties, so there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to check different topics or difficulties will cover all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic_diff = 0\n        for topic in topics.values():\n            same_topic_diff += topic * (topic - 1) // 2\n        \n        for diff in difficulties.values():\n            same_topic_diff += diff * (diff - 1) // 2\n        \n        total_ways -= same_topic_diff\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        same_topic_diff = 0\n        for topic in topics.values():\n            same_topic_diff += topic * (topic - 1) // 2\n        \n        for diff in difficulties.values():\n            same_topic_diff += diff * (diff - 1) // 2\n        \n        total_ways -= same_topic_diff\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Implement a function to check if the topics of the three selected problems are all different\",\n    \"Implement a function to check if the difficulties of the three selected problems are all different\",\n    \"Combine the results from the two functions to calculate the total number of ways to select three problems\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"step_2\": \"For each testcase, iterate through the list of problems and check if the topics or difficulties are all different for each combination of three problems\",\n    \"step_3\": \"Increment a counter for each valid combination of three problems\",\n    \"step_4\": \"Output the total number of valid combinations for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics or difficulties'\n    Explanation: The core concept is to select 3 problems where either the topics or difficulties are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, checking topics and difficulties, and calculating the total number of ways to select problems.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, all topics and difficulties are different, so there is only one way to select the 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All topics and difficulties are different, so there are 4 ways to select the 3 problems.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: All topics are the same, so there are no ways to select the 3 problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def check_topics_difficulties_unique(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [list(map(int, input().split())) for _ in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if check_topics_difficulties_unique([problems[i], problems[j], problems[k]]):\n                        count += 1\n        print(count)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 39)"}, "Round_1": {"code": "def check_topics_difficulties_unique(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [list(map(int, input().split())) for _ in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if check_topics_difficulties_unique([problems[i], problems[j], problems[k]]):\n                        count += 1\n        print(count)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Implement a function to check if the topics of three selected problems are all different\",\n    \"Implement a function to check if the difficulties of three selected problems are all different\",\n    \"Count the total number of ways that meet either of the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"step_2\": \"For each testcase, iterate through the list of problems and check if the topics or difficulties are all different for each combination of three problems\",\n    \"step_3\": \"Count the total number of ways that meet either of the requirements\",\n    \"step_4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics or difficulties'\n    Explanation: The core concept is to select 3 problems where either the topics or difficulties are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: Since all topics and difficulties are different, there is only one way to select 3 problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All topics and difficulties are different, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: All topics are the same, so there are no ways to select 3 problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def check_all_different(arr):\n    return len(set(arr)) == len(arr)\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    topics = [problems[i][0], problems[j][0], problems[k][0]]\n                    difficulties = [problems[i][1], problems[j][1], problems[k][1]]\n                    if check_all_different(topics) or check_all_different(difficulties):\n                        count += 1\n        \n        print(count)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 32)"}, "Round_1": {"code": "def check_all_different(arr):\n    return len(set(arr)) == len(arr)\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    topics = [problems[i][0], problems[j][0], problems[k][0]]\n                    difficulties = [problems[i][1], problems[j][1], problems[k][1]]\n                    if check_all_different(topics) or check_all_different(difficulties):\n                        count += 1\n        \n        print(count)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their details\",\n    \"Step 3\": \"Implement a function to calculate the number of ways to select three problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting exactly 3 problems satisfying at least one of two conditions'\n    Explanation: The core concept is to choose 3 problems that meet the given conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different subproblems and calculations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select 3 problems when all problems have different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All 4 problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    6\n    Explanation: There are multiple ways to select 3 problems that meet the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to calculate the number of ways to select 3 problems can handle different scenarios.", "Round_0": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[j][0] == problems[k][0] or problems[i][0] == problems[k][0] or problems[i][1] == problems[j][1] or problems[j][1] == problems[k][1] or problems[i][1] == problems[k][1]:\n                        ways += 1\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if problems[i][0] == problems[j][0] or problems[j][0] == problems[k][0] or problems[i][0] == problems[k][0] or problems[i][1] == problems[j][1] or problems[j][1] == problems[k][1] or problems[i][1] == problems[k][1]:\n                        ways += 1\n        \n        print(ways)\n\ncalculate_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Implement a function to check if the topics of the three selected problems are all different\",\n    \"Implement a function to check if the difficulties of the three selected problems are all different\",\n    \"Count the total number of ways that meet either of the requirements\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"step_2\": \"For each testcase, iterate through the list of problems and create a list of all possible combinations of 3 problems\",\n    \"step_3\": \"For each combination, check if the topics are all different or the difficulties are all different\",\n    \"step_4\": \"Count the number of combinations that meet either of the requirements\",\n    \"step_5\": \"Output the total number of ways for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'selecting problems'\n    Explanation: The core concept is to select exactly 3 problems from a given set, ensuring that either the topics or difficulties of the selected problems are all different.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all combinations of 3 problems have different topics or difficulties, so there are 4 ways to select the problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, there are multiple ways to select 3 problems with different topics or difficulties, resulting in 10 possible combinations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\ndef check_topics_unique(p1, p2, p3):\n    return len(set([p1[0], p2[0], p3[0]])) == 3\n\ndef check_difficulties_unique(p1, p2, p3):\n    return len(set([p1[1], p2[1], p3[1]])) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        total_ways = 0\n        for comb in combinations(problems, 3):\n            if check_topics_unique(*comb) or check_difficulties_unique(*comb):\n                total_ways += 1\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 30)"}, "Round_1": {"code": "from itertools import combinations\n\ndef check_topics_unique(p1, p2, p3):\n    return len(set([p1[0], p2[0], p3[0]])) == 3\n\ndef check_difficulties_unique(p1, p2, p3):\n    return len(set([p1[1], p2[1], p3[1]])) == 3\n\ndef count_ways_to_select_problems(testcases):\n    for _ in range(testcases):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        total_ways = 0\n        for comb in combinations(problems, 3):\n            if check_topics_unique(*comb) or check_difficulties_unique(*comb):\n                total_ways += 1\n        \n        print(total_ways)\n\nif __name__ == \"__main__\":\n    testcases = int(input())\n    count_ways_to_select_problems(testcases)\n"}}], "scores": [], "pass_results": [false, false, false, true, true, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 172, "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 81}
