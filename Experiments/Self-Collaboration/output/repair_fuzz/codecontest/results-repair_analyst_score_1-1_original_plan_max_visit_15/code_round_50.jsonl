{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The robot is positioned on a checkered rectangular board measuring n \u00d7 m (n rows and m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can initiate its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.\n\n  * If the robot moves beyond the edge of the board, it falls and breaks.\n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore).\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should initiate its movement in order to perform the maximum number of commands possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right. The robot can initiate its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot can initiate its movement in any cell, make the maximum number of steps before it breaks or stops, and complete commands successfully.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n\nmain()", "completions": ["def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n\n                if x < 0 or x >= n or y < 0 or y >= m:\n                    break\n\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                moves += 1\n                \n                if board[curr_r][curr_c] == 'R':\n                    curr_c += 1\n                elif board[curr_r][curr_c] == 'L':\n                    curr_c -= 1\n                elif board[curr_r][curr_c] == 'U':\n                    curr_r -= 1\n                elif board[curr_r][curr_c] == 'D':\n                    curr_r += 1\n                \n                curr_r = max(0, min(curr_r, len(board)-1))\n                curr_c = max(0, min(curr_c, len(board[0])-1))\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = find_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def find_starting_cell(board):\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] != '.':\n                return i+1, j+1\n\ndef find_maximum_moves(board):\n    max_moves = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] != '.':\n                max_moves = max(max_moves, abs(i - len(board)//2) + abs(j - len(board[0])//2))\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c = find_starting_cell(board)\n    d = find_maximum_moves(board)\n    \n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            for direction in directions:\n                moves = 1\n                x, y = i, j\n                while True:\n                    dx, dy = directions[board[x][y]]\n                    x, y = x + dx, y + dy\n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                    moves += 1\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def determine_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = determine_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def calculate_moves(board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            for direction in directions:\n                moves = 1\n                x, y = i, j\n                while True:\n                    dx, dy = directions[board[x][y]]\n                    x, y = x + dx, y + dy\n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                    moves += 1\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] != '#':\n                moves = dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves + 1\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != '#':\n                visited = set()\n                moves = dfs(i, j, visited)\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n            moves = 0\n            x, y = i, j\n\n            while 0 <= x < n and 0 <= y < m:\n                moves += 1\n                dx, dy = directions[board[x][y]]\n                x, y = x + dx, y + dy\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor data in input_data:\n    r, c, d = calculate_moves(data[2])\n    print(f\"{r} {c} {d}\")\n\nmain()", "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n\nmain()", "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\",\n    \"Output the starting cell coordinates and the maximum number of moves\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves the movement of a robot on a checkered rectangular board based on the symbols 'L', 'R', 'D', 'U' written on each cell.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before breaking or stopping.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, creating a function to determine maximum moves, iterating through starting cells, and outputting results.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move to the right before breaking.\n\n    Edge Case 2:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves (D -> D -> R -> U) before breaking.\n\n    Edge Case 3:\n    2 2\n    UD\n    RU\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves (D -> R -> U -> R) before breaking.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the board configurations\",\n    \"For each test case, determine the starting cell for the robot to maximize the number of moves\",\n    \"Implement a function to calculate the maximum number of moves for a given starting cell\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the board configurations\",\n    \"For each test case, iterate through each cell on the board and calculate the maximum number of moves for that cell\",\n    \"Track the maximum number of moves and the corresponding starting cell\",\n    \"Output the starting cell with the maximum number of moves for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maximum number of moves'\n    Explanation: The core concept is to find the starting cell for the robot that allows it to make the maximum number of moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of moves possible.\n    'several': Indicates that there could be multiple valid answers.\n\n# [code logic]\n    The steps in the plan should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move to the right before breaking.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves to the right before breaking.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves (D -> D -> R -> R) before breaking.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n\n                if x < 0 or x >= n or y < 0 or y >= m:\n                    break\n\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n\n                if x < 0 or x >= n or y < 0 or y >= m:\n                    break\n\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board descriptions\",\n      \"For each test case, determine the starting cell and the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board description to extract the height, width, and board layout\",\n      \"Implement a function to find the starting cell and the maximum number of moves for a given board layout\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': The robot needs to move in the board to make the maximum number of steps before stopping.\n    'starting cell': The cell from which the robot should start moving.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of moves the robot can make.\n\n# [code logic]\n    No steps should be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can make 1 move in the direction 'R'.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves in the directions 'RRL'.\n\n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot starts at cell (1, 1) and can make 4 moves in various directions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.\n\nNO", "Round_0": {"code": "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                moves += 1\n                \n                if board[curr_r][curr_c] == 'R':\n                    curr_c += 1\n                elif board[curr_r][curr_c] == 'L':\n                    curr_c -= 1\n                elif board[curr_r][curr_c] == 'U':\n                    curr_r -= 1\n                elif board[curr_r][curr_c] == 'D':\n                    curr_r += 1\n                \n                curr_r = max(0, min(curr_r, len(board)-1))\n                curr_c = max(0, min(curr_c, len(board[0])-1))\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = find_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                moves += 1\n                \n                if board[curr_r][curr_c] == 'R':\n                    curr_c += 1\n                elif board[curr_r][curr_c] == 'L':\n                    curr_c -= 1\n                elif board[curr_r][curr_c] == 'U':\n                    curr_r -= 1\n                elif board[curr_r][curr_c] == 'D':\n                    curr_r += 1\n                \n                curr_r = max(0, min(curr_r, len(board)-1))\n                curr_c = max(0, min(curr_c, len(board[0])-1))\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = find_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board descriptions\",\n      \"For each test case, determine the starting cell and the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board description and extract the height, width, and board layout\",\n      \"Iterate through each cell on the board to find the starting cell and calculate the maximum number of moves\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': Refers to the action of the robot moving in the cells of the board to make the maximum number of steps before stopping.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before stopping.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve reading input, processing each test case, determining starting cell and maximum moves, and outputting the results.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot starts at cell (1, 1) and can make 4 moves in various directions before stopping.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the input and determine the starting cell and maximum moves for each test case.", "Round_0": {"code": "def find_starting_cell(board):\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] != '.':\n                return i+1, j+1\n\ndef find_maximum_moves(board):\n    max_moves = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] != '.':\n                max_moves = max(max_moves, abs(i - len(board)//2) + abs(j - len(board[0])//2))\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c = find_starting_cell(board)\n    d = find_maximum_moves(board)\n    \n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(board):\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] != '.':\n                return i+1, j+1\n\ndef find_maximum_moves(board):\n    max_moves = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] != '.':\n                max_moves = max(max_moves, abs(i - len(board)//2) + abs(j - len(board[0])//2))\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c = find_starting_cell(board)\n    d = find_maximum_moves(board)\n    \n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and direction to maximize the number of moves\",\n      \"Implement a function to calculate the maximum number of moves from a given starting cell and direction\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell and direction\",\n      \"Implement a function to calculate the maximum number of moves from a given starting cell and direction\",\n      \"Output the results for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configurations'\n    Explanation: The board configurations consist of the dimensions of the board (height and width) and the symbols representing movement directions ('L', 'R', 'D', 'U').\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not require simultaneous implementation.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves in the right direction.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation: The robot starts at cell (4, 3) and can make 12 moves in various directions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def calculate_moves(board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            for direction in directions:\n                moves = 1\n                x, y = i, j\n                while True:\n                    dx, dy = directions[board[x][y]]\n                    x, y = x + dx, y + dy\n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                    moves += 1\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 41)"}, "Round_1": {"code": "def calculate_moves(board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            for direction in directions:\n                moves = 1\n                x, y = i, j\n                while True:\n                    dx, dy = directions[board[x][y]]\n                    x, y = x + dx, y + dy\n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                    moves += 1\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board descriptions\",\n      \"For each test case, determine the starting cell and the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board description to extract the height, width, and board layout\",\n      \"Implement a function to determine the starting cell and the maximum number of moves for the robot\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'maximum number of steps'\n    Explanation: The core concept is to determine the starting cell and the maximum number of moves the robot can make.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and major steps.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can make 1 move in the direction 'R'.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves in the directions 'RRL'.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot starts at cell (1, 1) and can make 4 moves in various directions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should cover all possible scenarios.", "Round_0": {"code": "def determine_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = determine_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 46)"}, "Round_1": {"code": "def determine_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = 0\n            visited = set()\n            curr_r, curr_c = r, c\n            \n            while (curr_r, curr_c) not in visited:\n                visited.add((curr_r, curr_c))\n                move = board[curr_r][curr_c]\n                \n                if move == 'L':\n                    curr_c -= 1\n                elif move == 'R':\n                    curr_c += 1\n                elif move == 'U':\n                    curr_r -= 1\n                elif move == 'D':\n                    curr_r += 1\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r + 1, c + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = determine_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and direction to maximize the number of moves\",\n      \"Implement a function to calculate the maximum number of moves from a given starting cell and direction\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell and direction\",\n      \"Implement a function to calculate the maximum number of moves from a given starting cell and direction\",\n      \"Output the results for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configurations'\n    Explanation: The board configurations consist of the dimensions of the board, the symbols representing directions, and the starting cell for the robot.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not require simultaneous implementation.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves in the right direction.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation: The robot starts at cell (4, 3) and can make 12 moves in various directions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def calculate_moves(board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            for direction in directions:\n                moves = 1\n                x, y = i, j\n                while True:\n                    dx, dy = directions[board[x][y]]\n                    x, y = x + dx, y + dy\n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                    moves += 1\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 41)"}, "Round_1": {"code": "def calculate_moves(board):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            for direction in directions:\n                moves = 1\n                x, y = i, j\n                while True:\n                    dx, dy = directions[board[x][y]]\n                    x, y = x + dx, y + dy\n                    if x < 0 or x >= n or y < 0 or y >= m:\n                        break\n                    moves += 1\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor n, m, board in input_data:\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\",\n    \"Output the starting cell coordinates and the maximum number of moves\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept is about determining the starting cell for the robot on a checkered board to maximize the number of moves before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': means the highest number of moves possible\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they are dependent on each other.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    1\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: In this case, the robot can only make one move from the starting cell (1, 1) to the right.\n    \n    Edge Case 2:\n    Input:\n    1\n    2 2\n    UD\n    RU\n    Output:\n    1 1 2\n    Explanation: The robot can start at cell (1, 1) and make 2 moves by going down and then up.\n    \n    Edge Case 3:\n    Input:\n    1\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    4 3 12\n    Explanation: The robot should start at cell (4, 3) to make 12 moves in total.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle all scenarios.", "Round_0": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] != '#':\n                moves = dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves + 1\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != '#':\n                visited = set()\n                moves = dfs(i, j, visited)\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] != '#':\n                moves = dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves + 1\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != '#':\n                visited = set()\n                moves = dfs(i, j, visited)\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and direction to maximize the number of moves\",\n      \"Implement a function to calculate the maximum number of moves from a given starting cell and direction\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell and direction\",\n      \"Implement a function to calculate the maximum number of moves from a given starting cell and direction\",\n      \"Output the results for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configurations'\n    Explanation: The board configurations consist of the dimensions of the board, the symbols representing directions, and the starting cell for the robot.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not require simultaneous implementation. Each step should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make one move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make three moves to the right.\n    \n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation: The robot starts at cell (4, 3) and can make a maximum of 12 moves.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if the starting cell is at the edge of the board and adjust the maximum number of moves accordingly.\n        - Handle cases where multiple starting cells can result in the same maximum number of moves.\n        - Implement logic to handle cases where there are multiple valid paths for maximizing moves.\n        (other code) \n\nNO", "Round_0": {"code": "def calculate_moves(board):\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n            moves = 0\n            x, y = i, j\n\n            while 0 <= x < n and 0 <= y < m:\n                moves += 1\n                dx, dy = directions[board[x][y]]\n                x, y = x + dx, y + dy\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor data in input_data:\n    r, c, d = calculate_moves(data[2])\n    print(f\"{r} {c} {d}\")\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board):\n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n            moves = 0\n            x, y = i, j\n\n            while 0 <= x < n and 0 <= y < m:\n                moves += 1\n                dx, dy = directions[board[x][y]]\n                x, y = x + dx, y + dy\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput_data = []\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    input_data.append((n, m, board))\n\nfor data in input_data:\n    r, c, d = calculate_moves(data[2])\n    print(f\"{r} {c} {d}\")\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\",\n    \"Output the starting cell coordinates and the maximum number of moves\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves the movement of a robot on a checkered rectangular board based on the symbols 'L', 'R', 'D', 'U' written on each cell.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before breaking or stopping.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, creating a function to determine maximum moves, iterating through starting cells, and outputting results.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move to the right before breaking.\n\n    Edge Case 2:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves to the right before breaking.\n\n    Edge Case 3:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output:\n    1 1 4\n    Explanation: The robot starts at cell (1, 1) and can make 4 moves before breaking.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the board dimensions and symbols\",\n    \"Create a function to determine the maximum number of moves the robot can make from a given starting cell\",\n    \"Iterate through all possible starting cells to find the one that yields the maximum number of moves\",\n    \"Output the starting cell coordinates and the maximum number of moves\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves the movement of a robot on a checkered rectangular board based on the symbols 'L', 'R', 'D', 'U' written on each cell.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before breaking or stopping.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, creating a function to determine maximum moves, iterating through starting cells, and outputting results.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move to the right before breaking.\n\n    Edge Case 2:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves (D -> D -> R -> U) before breaking.\n\n    Edge Case 3:\n    2 2\n    UD\n    RU\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves (D -> R -> U -> R) before breaking.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_max_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        if visited[x][y]:\n            return 0\n        \n        visited[x][y] = True\n        moves = 1\n        \n        if board[x][y] == 'L' and is_valid_move(x, y - 1):\n            moves += dfs(x, y - 1, visited)\n        if board[x][y] == 'R' and is_valid_move(x, y + 1):\n            moves += dfs(x, y + 1, visited)\n        if board[x][y] == 'U' and is_valid_move(x - 1, y):\n            moves += dfs(x - 1, y, visited)\n        if board[x][y] == 'D' and is_valid_move(x + 1, y):\n            moves += dfs(x + 1, y, visited)\n        \n        return moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n"}}], "scores": [], "pass_results": [true, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 50, "prompt": "The robot is positioned on a checkered rectangular board measuring n \u00d7 m (n rows and m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can initiate its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.\n\n  * If the robot moves beyond the edge of the board, it falls and breaks.\n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore).\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should initiate its movement in order to perform the maximum number of commands possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 12}
