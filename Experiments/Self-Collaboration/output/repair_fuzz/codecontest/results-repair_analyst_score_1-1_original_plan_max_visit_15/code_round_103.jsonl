{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "repair_prompt": ["The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is capable of moving to neighboring cells. It can move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U'. Each symbol triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command. Then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up successfully without falling off the board.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot can start its movement in any cell and executes commands strictly in order listed.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n\nmain()", "completions": ["# Function to determine the cell from which the robot should start moving\ndef determine_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_commands = 0\n        start_cell = (1, 1)\n        \n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                curr_row, curr_col = row, col\n                commands_executed = 0\n                \n                for command in commands:\n                    if command == 'L':\n                        curr_col -= 1\n                    elif command == 'R':\n                        curr_col += 1\n                    elif command == 'U':\n                        curr_row -= 1\n                    elif command == 'D':\n                        curr_row += 1\n                    \n                    if curr_row < 1 or curr_row > n or curr_col < 1 or curr_col > m:\n                        break\n                    commands_executed += 1\n                \n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    start_cell = (row, col)\n        \n        print(start_cell[0], start_cell[1])\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Determine the starting cell for each test case\ndetermine_starting_cell(t, test_cases)\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            curr_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    x, y = 1, 1\n    max_commands = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_x, curr_y = i, j\n            curr_commands = 0\n            for command in commands:\n                if command == 'L':\n                    curr_y -= 1\n                elif command == 'R':\n                    curr_y += 1\n                elif command == 'D':\n                    curr_x += 1\n                elif command == 'U':\n                    curr_x -= 1\n                \n                if curr_x < 1 or curr_x > n or curr_y < 1 or curr_y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                x, y = i, j\n    \n    return x, y\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    r, c = find_starting_cell(n, m, commands)\n    print(r, c)\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    row, col = 1, 1\n\n    for command in commands:\n        if command == 'L':\n            col -= 1\n        elif command == 'R':\n            col += 1\n        elif command == 'U':\n            row -= 1\n        elif command == 'D':\n            row += 1\n\n        if row < 1:\n            row = 1\n        elif row > n:\n            row = n\n\n        if col < 1:\n            col = 1\n        elif col > m:\n            col = m\n\n    print(row, col)\n\nmain()", "def find_starting_cell(n, m, s):\n    row, col = 1, 1\n    for move in s:\n        if move == 'L':\n            col -= 1\n        elif move == 'R':\n            col += 1\n        elif move == 'U':\n            row -= 1\n        elif move == 'D':\n            row += 1\n        \n        if row < 1:\n            row = 1\n        elif row > n:\n            row = n\n        \n        if col < 1:\n            col = 1\n        elif col > m:\n            col = m\n    \n    return row, col\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    r, c = find_starting_cell(n, m, s)\n    print(r, c)\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the cell from which the robot should start moving\",\n    \"Calculate the maximum number of commands that can be executed from each cell\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": \"For each test case, iterate through each cell on the board\",\n    \"step_4\": \"Calculate the maximum number of commands that can be executed from each cell\",\n    \"step_5\": \"Output the coordinates of the cell with the maximum number of commands\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'neighboring cells'\n    Explanation: The robot can move to adjacent cells in the board.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell, the robot can only start from that cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: The robot can start from the only two cells available.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    No extra code is needed to handle the edge cases. The logic provided in the plan is sufficient to handle different scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the cell from which the robot should start moving\",\n    \"Calculate the maximum number of commands that can be executed from each cell\",\n    \"Output the coordinates of the cell with the maximum number of commands\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": \"For each test case, iterate through each cell on the board\",\n    \"step_4\": \"Simulate the robot's movement from each cell and calculate the number of commands that can be executed\",\n    \"step_5\": \"Track the cell with the maximum number of commands executed\",\n    \"step_6\": \"Output the coordinates of the cell with the maximum number of commands\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'movement': The core concept is about the movement of the robot on a checkered rectangular board following the given commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: The robot starts at the only cell and executes the command 'L'.\n    \n    Test Case 2:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot starts at the only cell and executes the command 'L'.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot can start at cell (2, 1) to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic described in the plan should cover all scenarios.", "Round_0": {"code": "# Function to determine the cell from which the robot should start moving\ndef determine_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_commands = 0\n        start_cell = (1, 1)\n        \n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                curr_row, curr_col = row, col\n                commands_executed = 0\n                \n                for command in commands:\n                    if command == 'L':\n                        curr_col -= 1\n                    elif command == 'R':\n                        curr_col += 1\n                    elif command == 'U':\n                        curr_row -= 1\n                    elif command == 'D':\n                        curr_row += 1\n                    \n                    if curr_row < 1 or curr_row > n or curr_col < 1 or curr_col > m:\n                        break\n                    commands_executed += 1\n                \n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    start_cell = (row, col)\n        \n        print(start_cell[0], start_cell[1])\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Determine the starting cell for each test case\ndetermine_starting_cell(t, test_cases)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 99)"}, "Round_1": {"code": "# Function to determine the cell from which the robot should start moving\ndef determine_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_commands = 0\n        start_cell = (1, 1)\n        \n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                curr_row, curr_col = row, col\n                commands_executed = 0\n                \n                for command in commands:\n                    if command == 'L':\n                        curr_col -= 1\n                    elif command == 'R':\n                        curr_col += 1\n                    elif command == 'U':\n                        curr_row -= 1\n                    elif command == 'D':\n                        curr_row += 1\n                    \n                    if curr_row < 1 or curr_row > n or curr_col < 1 or curr_col > m:\n                        break\n                    commands_executed += 1\n                \n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    start_cell = (row, col)\n        \n        print(start_cell[0], start_cell[1])\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Determine the starting cell for each test case\ndetermine_starting_cell(t, test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and their descriptions\",\n    \"For each test case, extract the field dimensions and the sequence of commands\",\n    \"Determine the starting cell for the robot to perform the maximum number of commands\",\n    \"Output the coordinates of the starting cell for each test case\"\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases\",\n    \"For each test case, read the field dimensions and the sequence of commands\",\n    \"Iterate through each cell in the field to find the starting cell that maximizes the number of commands executed\",\n    \"Output the coordinates of the starting cell for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'test cases'\n    Explanation: The requirement involves processing multiple test cases with different field dimensions and command sequences.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, extracting field dimensions and commands, determining the starting cell, and outputting the coordinates.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: With only one cell and one command 'L', the robot should start at cell (1, 1) to perform the command.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: With a 1x2 field and command 'L', the robot should start at cell (1, 2) to perform the command.\n    \n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot should start at cell (2, 1) to perform the commands 'RRDLUU' and maximize the number of commands executed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            current_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the starting cell that allows the robot to execute the most commands\",\n    \"Implement a function to simulate the robot's movement based on the command sequence\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"For each test case, iterate through all possible starting cells and simulate the robot's movement to determine the maximum number of commands that can be executed\",\n    \"Output the coordinates of the starting cell that allows the robot to execute the most commands for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept is about simulating the movement of a robot on a checkered rectangular board based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, iterating through test cases, and simulating robot movement.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell on the board and a single command 'L', the robot can only start from the initial cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: The robot can start from either cell to execute the single command 'L'.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the descriptions of each test case\",\n      \"For each test case, extract the height, width, and sequence of commands\",\n      \"Determine the starting cell that will allow the robot to perform the most commands\",\n      \"Output the coordinates of the starting cell for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input from standard input\",\n      \"Parse the input to extract the number of test cases\",\n      \"For each test case, extract the height, width, and sequence of commands\",\n      \"Iterate through the field to find the starting cell that maximizes the number of commands that can be performed\",\n      \"Output the coordinates of the starting cell for each test case to standard output\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'Parse the input': Extract necessary information from the input data to process the test cases effectively.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented step by step as they are distinct tasks that need to be performed sequentially.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation:\n    The robot can only move in one cell, so it should start at that cell to perform the command.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation:\n    The robot can only move in two cells horizontally, so it should start at the second cell to perform the command.\n    \n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation:\n    The robot can move in multiple cells, and starting at cell (2, 1) allows it to perform the most commands.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find the starting cell that maximizes the number of commands is sufficient.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            curr_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            curr_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and their descriptions\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Simulate the robot's movements on the field based on the sequence of commands\",\n      \"Determine the starting cell that allows the robot to perform the most commands\"\n    ],\n    \"major_steps\": [\n      \"Read the input from standard input\",\n      \"Parse the input to extract the number of test cases\",\n      \"For each test case, extract the field dimensions and the sequence of commands\",\n      \"Simulate the robot's movements on the field based on the sequence of commands\",\n      \"Determine the starting cell that allows the robot to perform the most commands\",\n      \"Output the coordinates of the starting cell for each test case to standard output\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movements'\n    Explanation: The core concept is about simulating the movements of a robot on a field based on a sequence of commands to determine the starting cell that allows the robot to perform the most commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, simulating movements, and determining the starting cell. There are no steps that need to be implemented simultaneously.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    L\n    Expected Output: 1 1\n    Explanation: The robot starts at cell (1, 1) and performs the only command 'L'.\n    \n    Edge Case 2:\n    3 3\n    RRDLUU\n    Expected Output: 2 1\n    Explanation: The robot starts at cell (2, 1) and successfully executes the sequence of commands 'RRDLUU'.\n    \n    Edge Case 3:\n    4 3\n    LUURRDDLLLUU\n    Expected Output: 3 2\n    Explanation: The robot starts at cell (3, 2) and performs the sequence of commands 'LUURRDDLLLUU'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should be able to handle all possible scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    x, y = 1, 1\n    max_commands = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_x, curr_y = i, j\n            curr_commands = 0\n            for command in commands:\n                if command == 'L':\n                    curr_y -= 1\n                elif command == 'R':\n                    curr_y += 1\n                elif command == 'D':\n                    curr_x += 1\n                elif command == 'U':\n                    curr_x -= 1\n                \n                if curr_x < 1 or curr_x > n or curr_y < 1 or curr_y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                x, y = i, j\n    \n    return x, y\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    r, c = find_starting_cell(n, m, commands)\n    print(r, c)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    x, y = 1, 1\n    max_commands = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_x, curr_y = i, j\n            curr_commands = 0\n            for command in commands:\n                if command == 'L':\n                    curr_y -= 1\n                elif command == 'R':\n                    curr_y += 1\n                elif command == 'D':\n                    curr_x += 1\n                elif command == 'U':\n                    curr_x -= 1\n                \n                if curr_x < 1 or curr_x > n or curr_y < 1 or curr_y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                x, y = i, j\n    \n    return x, y\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    r, c = find_starting_cell(n, m, commands)\n    print(r, c)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and their descriptions\",\n    \"For each test case, extract the field dimensions and the sequence of commands\",\n    \"Determine the starting cell for the robot to perform the maximum number of commands\",\n    \"Output the coordinates of the starting cell for each test case\"\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases\",\n    \"For each test case, read the field dimensions and the sequence of commands\",\n    \"Iterate through each cell in the field to find the starting cell that maximizes the number of commands executed\",\n    \"Output the coordinates of the starting cell for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'test cases'\n    Explanation: The requirement involves processing multiple test cases with different field dimensions and command sequences.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, extracting information for each test case, determining the starting cell, and outputting the result.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: With only one cell and one command 'L', the robot should start at the initial cell.\n    \n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: With a 1x2 field and one command 'L', the robot should start at the second cell.\n    \n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot should start at cell (2, 1) to perform the maximum number of commands.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided should handle all scenarios appropriately.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            curr_commands = 0\n            x, y = i, j\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                curr_commands += 1\n            \n            if curr_commands > max_commands:\n                max_commands = curr_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and their descriptions\",\n    \"For each test case, extract the field dimensions and the sequence of commands\",\n    \"Simulate the robot's movements on the field based on the sequence of commands\",\n    \"Determine the starting cell that allows the robot to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and their descriptions\",\n    \"step_2\": \"For each test case, extract the field dimensions and the sequence of commands\",\n    \"step_3\": \"Simulate the robot's movements on the field based on the sequence of commands\",\n    \"step_4\": \"Determine the starting cell that allows the robot to perform as many commands as possible\",\n    \"step_5\": \"Output the coordinates of the starting cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movements'\n    Explanation: The core concept is about simulating the movements of a robot on a field based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they are dependent on each other.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: The robot starts at cell (1, 1) and performs the command 'L', which is not possible as it would fall off the board. Therefore, the robot should start at cell (1, 1) to perform as many commands as possible.\n\n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot starts at cell (1, 2) and performs the command 'L', which is valid as it stays within the board.\n\n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot starts at cell (2, 1) and successfully performs the sequence of commands without falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic should be able to handle all scenarios as per the requirement.", "Round_0": {"code": "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    row, col = 1, 1\n\n    for command in commands:\n        if command == 'L':\n            col -= 1\n        elif command == 'R':\n            col += 1\n        elif command == 'U':\n            row -= 1\n        elif command == 'D':\n            row += 1\n\n        if row < 1:\n            row = 1\n        elif row > n:\n            row = n\n\n        if col < 1:\n            col = 1\n        elif col > m:\n            col = m\n\n    print(row, col)\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 37)"}, "Round_1": {"code": "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n\n    row, col = 1, 1\n\n    for command in commands:\n        if command == 'L':\n            col -= 1\n        elif command == 'R':\n            col += 1\n        elif command == 'U':\n            row -= 1\n        elif command == 'D':\n            row += 1\n\n        if row < 1:\n            row = 1\n        elif row > n:\n            row = n\n\n        if col < 1:\n            col = 1\n        elif col > m:\n            col = m\n\n    print(row, col)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and their descriptions\",\n    \"For each test case, extract the field dimensions and the sequence of commands\",\n    \"Simulate the robot's movements on the field based on the sequence of commands\",\n    \"Determine the starting cell that allows the robot to perform as many commands as possible\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of test cases and their descriptions\",\n    \"Step 2\": \"For each test case, extract the field dimensions and the sequence of commands\",\n    \"Step 3\": \"Simulate the robot's movements on the field based on the sequence of commands\",\n    \"Step 4\": \"Determine the starting cell that allows the robot to perform as many commands as possible\",\n    \"Step 5\": \"Output the coordinates of the starting cell for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movements'\n    Explanation: The core concept involves simulating the movements of a robot on a field based on a sequence of commands.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve parsing input, simulating movements, and determining the starting cell.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    L\n    Output:\n    1 1\n    Explanation: The robot starts at cell (1, 1) and performs the command 'L', which is not possible as it would fall off the board. Therefore, the starting cell remains (1, 1).\n\n    Test Case 2:\n    Input:\n    1 2\n    L\n    Output:\n    1 2\n    Explanation: The robot starts at cell (1, 2) and performs the command 'L', which is valid as it stays within the board.\n\n    Test Case 3:\n    Input:\n    3 3\n    RRDLUU\n    Output:\n    2 1\n    Explanation: The robot starts at cell (2, 1) and successfully executes the sequence of commands without falling off the board.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of determining the starting cell based on the robot's movements should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, s):\n    row, col = 1, 1\n    for move in s:\n        if move == 'L':\n            col -= 1\n        elif move == 'R':\n            col += 1\n        elif move == 'U':\n            row -= 1\n        elif move == 'D':\n            row += 1\n        \n        if row < 1:\n            row = 1\n        elif row > n:\n            row = n\n        \n        if col < 1:\n            col = 1\n        elif col > m:\n            col = m\n    \n    return row, col\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    r, c = find_starting_cell(n, m, s)\n    print(r, c)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, s):\n    row, col = 1, 1\n    for move in s:\n        if move == 'L':\n            col -= 1\n        elif move == 'R':\n            col += 1\n        elif move == 'U':\n            row -= 1\n        elif move == 'D':\n            row += 1\n        \n        if row < 1:\n            row = 1\n        elif row > n:\n            row = n\n        \n        if col < 1:\n            col = 1\n        elif col > m:\n            col = m\n    \n    return row, col\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input().strip()\n    r, c = find_starting_cell(n, m, s)\n    print(r, c)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the cell from which the robot should start moving\",\n    \"Implement a function to simulate the robot's movement based on the given commands\",\n    \"Track the maximum number of commands that can be executed without falling off the board\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": \"For each test case, iterate through each cell on the board to determine the maximum number of commands that can be executed without falling off\",\n    \"step_4\": \"Output the coordinates of the cell from which the robot should start moving for each test case\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'neighboring cells'\n    Explanation: The robot can move to adjacent cells in the board by side.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell on the board, the robot can only start from that cell to execute the command.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: The robot can start from the only two cells available to execute the command.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    start_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                start_cell = (i, j)\n    \n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    start_cell = find_starting_cell(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the cell from which the robot should start moving\",\n    \"Calculate the maximum number of commands that can be executed from each cell\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": \"For each test case, iterate through each cell on the board\",\n    \"step_4\": \"Calculate the maximum number of commands that can be executed from each cell\",\n    \"step_5\": \"Output the coordinates of the cell with the maximum number of commands\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'neighboring cells'\n    Explanation: The robot can move to adjacent cells in the board.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    Test Case 1:\n    1 1\n    L\n    Output: 1 1\n    Explanation: With only one cell, the robot can only start from that cell.\n    \n    Test Case 2:\n    1 2\n    L\n    Output: 1 2\n    Explanation: The robot can start from the only two cells available.\n    \n    Test Case 3:\n    3 3\n    RRDLUU\n    Output: 2 1\n    Explanation: Starting from cell (2, 1) allows the robot to execute all commands successfully.\n    \n# [extra code for edge case]\n    No extra code is needed to handle the edge cases. The logic provided in the plan is sufficient to handle different scenarios.", "Round_0": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(n, m, commands):\n    max_commands = 0\n    best_cell = (1, 1)\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            x, y = i, j\n            current_commands = 0\n            \n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n                \n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                \n                current_commands += 1\n            \n            if current_commands > max_commands:\n                max_commands = current_commands\n                best_cell = (i, j)\n    \n    return best_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    \n    result = find_starting_cell(n, m, commands)\n    print(result[0], result[1])\n"}}], "scores": [], "pass_results": [true, false, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 103, "prompt": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is capable of moving to neighboring cells. It can move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U'. Each symbol triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command. Then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 44}
