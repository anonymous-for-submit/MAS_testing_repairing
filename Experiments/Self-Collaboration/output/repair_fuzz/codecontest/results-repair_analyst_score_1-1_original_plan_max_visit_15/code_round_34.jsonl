{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "repair_prompt": ["You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, with array indexes numbered from zero, unlike other problems. In one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells, and the elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}.\n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing, and for a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "If a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1], where a^{\u2192 d} represents a cyclic shift of array a to the right by d cells. This means the new array after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], resulting in [0, 0, 0, 1] for a. \n\nYou are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, with array indexes numbered from zero, unlike other problems. In one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells, and the elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}.\n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing, and for a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, with array indexes numbered from zero, unlike other problems, and in one step, the array a is replaced by another array of length n according to the following rules: First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells, and the elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "completions": ["def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_all_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append(((n, d), a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_wise_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef count_steps_to_zeros(n, d, arr):\n    original_arr = arr.copy()\n    steps = 0\n    while any(arr):\n        arr = cyclic_shift(arr, d)\n        arr = element_wise_and(original_arr, arr)\n        steps += 1\n        if steps > n:  # Maximum steps reached\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = count_steps_to_zeros(n, d, arr)\n    print(result)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        array = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(array):\n            new_array = cyclic_shift(array, d)\n            array = logical_and(array, new_array)\n            steps += 1\n\n            if array == new_array:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    array = list(map(int, input().split()))\n    test_cases.append((n, d, array))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_all_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        seen = set()\n        while True:\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if check_all_zeros(a):\n                results.append(steps)\n                break\n            elif tuple(a) in seen:\n                results.append(-1)\n                break\n            seen.add(tuple(a))\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_by_element_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef count_steps_to_zeros(n, d, arr):\n    original_arr = arr.copy()\n    steps = 0\n    while True:\n        shifted_arr = cyclic_shift(arr, d)\n        result_arr = element_by_element_and(original_arr, shifted_arr)\n        if all(elem == 0 for elem in result_arr):\n            return steps\n        if arr == shifted_arr:\n            return -1\n        arr = shifted_arr\n        steps += 1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print(count_steps_to_zeros(n, d, arr))\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n            if arr == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()", "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_by_element_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef steps_to_zeros(arr, d):\n    steps = 0\n    while any(arr):\n        arr = element_by_element_and(arr, cyclic_shift(arr, d))\n        steps += 1\n        if steps > len(arr):\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = steps_to_zeros(arr, d)\n    print(result)\n\nmain()", "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the element-wise logical AND operation on the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case:\",\n      \"   - Read the array size and cyclic shift offset\",\n      \"   - Read the elements of the array\",\n      \"   - Perform the cyclic shift operation on the array\",\n      \"   - Perform the element-wise logical AND operation on the array\",\n      \"   - Check if the array contains only zeros\",\n      \"   - If not, repeat the above steps until the array contains only zeros\",\n      \"   - Count the number of steps taken to reach an array with only zeros\",\n      \"   - Print the number of steps or -1 if the array never contains only zeros\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: It refers to shifting the elements of an array circularly to the right by a specified number of cells.\n\n    'element-wise logical AND operation'\n    Explanation: It involves performing a logical AND operation between each element of two arrays.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n    Explanation:\n    - For the first test case, after the first step, the array becomes [0, 0] which contains only zeros, so the answer is 1.\n    - For the second test case, after the first step, the array becomes [0, 0, 0] which contains only zeros, so the answer is 1.\n    - For the third test case, it takes 3 steps to reach an array with only zeros.\n    - For the fourth test case, the array will never contain only zeros, so the answer is -1.\n    - For the fifth test case, the array already contains only zeros, so the answer is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan covers all scenarios.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, "session_historys": [{"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical AND operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case:\",\n      \"   - Read the array size and cyclic shift offset\",\n      \"   - Read the elements of the array\",\n      \"   - Initialize a counter for the number of steps\",\n      \"   - Repeat the following steps until the array contains only zeros or it stops changing:\",\n      \"       - Perform the cyclic shift operation on the array\",\n      \"       - Perform the logical AND operation on each element of the array\",\n      \"       - Check if the array contains only zeros\",\n      \"       - Increment the step counter\",\n      \"   - If the array contains only zeros, output the number of steps taken, otherwise output -1\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: The core concept involves shifting the elements of an array in a circular manner to the right by a specified offset.\n\n    'logical AND operation'\n    Explanation: Refers to performing a bitwise AND operation on corresponding bits of two arrays.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    1 1\n    0\n    Output:\n    0\n    Explanation: The array is already all zeros, so the expected output is 0.\n\n    3 3\n    1 1 1\n    Output:\n    1\n    Explanation: After the first step, the array becomes [1, 1, 1] -> [1, 1, 1] -> [1, 1, 1]. It contains only ones after the first step.\n\n    4 2\n    1 0 1 0\n    Output:\n    -1\n    Explanation: The array will not change as it shifts by 2 to the right, so each element will be calculated as 0 & 0 or 1 & 1, thus not changing its value. The array will never contain only zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_all_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_all_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        arr = test_cases[i][2]\n\n        steps = 0\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n\n            if arr == new_arr:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the element-wise logical AND operation on the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case:\",\n      \"   - Read the array size and cyclic shift offset\",\n      \"   - Read the elements of the array\",\n      \"   - Perform the cyclic shift operation on the array\",\n      \"   - Perform the element-wise logical AND operation on the array\",\n      \"   - Check if the array contains only zeros\",\n      \"   - If not, repeat the above steps until the array contains only zeros or determine if it will never contain only zeros\",\n      \"   - Output the number of steps taken to reach an array with only zeros or -1 if it will never contain only zeros\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: It means shifting the elements of the array circularly to the right by a certain number of cells.\n\n    'element-wise logical AND operation'\n    Explanation: It refers to performing the logical AND operation between each element of the original array and the cyclically shifted array.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All major steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros.\n    - In the fifth test case, the array already contains only zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == cyclic_shift(a, d):\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the element-wise logical AND operation on the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the element-wise logical AND operation on the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\",\n      \"Output the number of steps or -1 if the array never contains only zeros\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array in a circular manner to the right by a specified number of cells.\n    Explanation: The array elements are moved to the right by a certain offset, and the elements that go beyond the end of the array are placed at the beginning.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as they are sequential in nature.\n\n# [edge case] \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: The array will change from [0, 1] to [1, 0] after the first step, resulting in [0, 0] after the logical AND operation.\n    \n    3 2\n    0 1 0\n    Expected Output: 1\n    Explanation: The array will change from [0, 1, 0] to [0, 0, 1] after the first step, resulting in [0, 0, 0] after the logical AND operation.\n    \n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: The array will change as described in the prompt, and after 3 steps, it will contain only zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append(((n, d), a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append(((n, d), a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the cyclic shift of the array to the right by d cells\",\n    \"Implement a function to calculate the element-by-element 'AND' operation between two arrays\",\n    \"Iterate through each test case, perform the cyclic shift operation until all elements in the array are zeros or a maximum number of steps is reached\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case details\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": {\n      \"substep_1\": \"Perform the cyclic shift operation on the array\",\n      \"substep_2\": \"Calculate the element-by-element 'AND' operation between the original array and the shifted array\",\n      \"substep_3\": \"Check if all elements in the array are zeros, if not repeat the cyclic shift operation\",\n      \"substep_4\": \"If all elements are zeros, output the number of steps taken, if a maximum number of steps is reached without all elements being zeros, output -1\"\n    }\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The core concept here is to shift the elements of an array to the right by a certain number of cells in a cyclic manner.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, performing cyclic shifts, calculating element-wise 'AND' operation, and iterating through test cases.\n\n# [edge case] \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: After the first shift, the array becomes [0, 0], which contains only zeros.\n    \n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: After 3 shifts, the array becomes [0, 0, 0, 0, 0], which contains only zeros.\n    \n    1 1\n    0\n    Expected Output: 0\n    Explanation: The array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_wise_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef count_steps_to_zeros(n, d, arr):\n    original_arr = arr.copy()\n    steps = 0\n    while any(arr):\n        arr = cyclic_shift(arr, d)\n        arr = element_wise_and(original_arr, arr)\n        steps += 1\n        if steps > n:  # Maximum steps reached\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = count_steps_to_zeros(n, d, arr)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 31)"}, "Round_1": {"code": "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_wise_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef count_steps_to_zeros(n, d, arr):\n    original_arr = arr.copy()\n    steps = 0\n    while any(arr):\n        arr = cyclic_shift(arr, d)\n        arr = element_wise_and(original_arr, arr)\n        steps += 1\n        if steps > n:  # Maximum steps reached\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = count_steps_to_zeros(n, d, arr)\n    print(result)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical AND operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical AND operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\",\n      \"Output the result for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: The core concept involves shifting the elements of an array in a circular manner to the right by a specified offset.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different operations on the array.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros.\n    - In the fifth test case, the array already contains only zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        array = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(array):\n            new_array = cyclic_shift(array, d)\n            array = logical_and(array, new_array)\n            steps += 1\n\n            if array == new_array:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    array = list(map(int, input().split()))\n    test_cases.append((n, d, array))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        array = test_cases[i][2]\n\n        steps = 0\n        while not check_zeros(array):\n            new_array = cyclic_shift(array, d)\n            array = logical_and(array, new_array)\n            steps += 1\n\n            if array == new_array:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    array = list(map(int, input().split()))\n    test_cases.append((n, d, array))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the logical AND operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken before the array contains only zeros or determine if it will never contain only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case, read the array size, cyclic shift offset, and array elements\",\n      \"Initialize a counter to keep track of the number of steps taken\",\n      \"Repeat the following steps until the array contains only zeros or the process reaches a loop:\",\n      \"Perform the cyclic shift operation on the array\",\n      \"Perform the logical AND operation on each element of the array\",\n      \"Check if the array contains only zeros\",\n      \"Increment the step counter\",\n      \"If the array contains only zeros, output the step counter, otherwise output -1\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: The core concept involves shifting the elements of an array in a circular manner to the right by a specified offset.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented sequentially as described in the plan. Each step is crucial for the overall functionality of the algorithm.\n\n# [edge case] \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: The array will change from [0, 1] to [1, 0] after one step, resulting in all zeros.\n\n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: The array will go through multiple transformations before reaching all zeros after 3 steps.\n\n    4 2\n    0 1 0 1\n    Expected Output: -1\n    Explanation: The array will not change as it shifts by 2 to the right, resulting in elements that will never be all zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\n# NO", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_all_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        seen = set()\n        while True:\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if check_all_zeros(a):\n                results.append(steps)\n                break\n            elif tuple(a) in seen:\n                results.append(-1)\n                break\n            seen.add(tuple(a))\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 55)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_all_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0], test_cases[i][1]\n        a = test_cases[i][2]\n\n        steps = 0\n        seen = set()\n        while True:\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if check_all_zeros(a):\n                results.append(steps)\n                break\n            elif tuple(a) in seen:\n                results.append(-1)\n                break\n            seen.add(tuple(a))\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d, a))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the cyclic shift of the array to the right by d cells\",\n    \"Implement a function to calculate the element-by-element 'AND' operation between two arrays\",\n    \"Iterate through each test case, perform the cyclic shift operation, and check if the array contains only zeros\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case details\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": {\n      \"substep_1\": \"Perform the cyclic shift operation on the array\",\n      \"substep_2\": \"Calculate the element-by-element 'AND' operation between the original array and the shifted array\",\n      \"substep_3\": \"Check if the result array contains only zeros\",\n      \"substep_4\": \"If all elements are zeros, output the number of steps taken, otherwise output -1\"\n    }\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The core concept here is to shift the elements of an array to the right by a certain number of cells in a cyclic manner.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems that build upon each other.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan covers all scenarios.", "Round_0": {"code": "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_by_element_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef count_steps_to_zeros(n, d, arr):\n    original_arr = arr.copy()\n    steps = 0\n    while True:\n        shifted_arr = cyclic_shift(arr, d)\n        result_arr = element_by_element_and(original_arr, shifted_arr)\n        if all(elem == 0 for elem in result_arr):\n            return steps\n        if arr == shifted_arr:\n            return -1\n        arr = shifted_arr\n        steps += 1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print(count_steps_to_zeros(n, d, arr))\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 32)"}, "Round_1": {"code": "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_by_element_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef count_steps_to_zeros(n, d, arr):\n    original_arr = arr.copy()\n    steps = 0\n    while True:\n        shifted_arr = cyclic_shift(arr, d)\n        result_arr = element_by_element_and(original_arr, shifted_arr)\n        if all(elem == 0 for elem in result_arr):\n            return steps\n        if arr == shifted_arr:\n            return -1\n        arr = shifted_arr\n        steps += 1\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print(count_steps_to_zeros(n, d, arr))\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the array information for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Implement the logical 'AND' operation on each element of the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros or determine if it's not possible\"\n    ],\n    \"high-level-steps\": [\n      \"Read the number of test cases\",\n      \"For each test case:\",\n      \"   Read the array size and cyclic shift offset\",\n      \"   Read the elements of the array\",\n      \"   Perform cyclic shift operation on the array\",\n      \"   Perform logical 'AND' operation on each element of the array\",\n      \"   Check if the array contains only zeros\",\n      \"   If not, repeat the above steps until the array contains only zeros or determine it's not possible\",\n      \"   Count the number of steps taken to reach the final array state\",\n      \"   Print the number of steps or -1 if the array will never contain only zeros\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift': It refers to shifting the elements of an array to the right by a certain number of cells, where the elements wrap around to the beginning of the array.\n    'logical AND operation': It is a bitwise operation that results in 1 only if both bits are 1, otherwise, it results in 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    2 1\n    0 1\n    Expected Output: 1\n    Explanation: After the first step, the array becomes [0, 0] where all elements are zeros.\n    \n    5 2\n    1 1 0 1 0\n    Expected Output: 3\n    Explanation: The array changes as follows: [1, 1, 0, 1, 0] -> [1, 0, 1, 1, 0] -> [1, 0, 0, 0, 0] after 3 steps.\n    \n    4 2\n    0 1 0 1\n    Expected Output: -1\n    Explanation: The array will not change as it shifts by 2 to the right, so each element will be calculated as 0 & 0 or 1 & 1, thus not changing its value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should cover all scenarios.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n            if arr == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 48)"}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def logical_and(arr1, arr2):\n        return [a & b for a, b in zip(arr1, arr2)]\n\n    def check_all_zeros(arr):\n        return all(val == 0 for val in arr)\n\n    def process_test_case(n, d, arr):\n        steps = 0\n        while not check_all_zeros(arr):\n            new_arr = cyclic_shift(arr, d)\n            arr = logical_and(arr, new_arr)\n            steps += 1\n            if arr == new_arr:\n                return -1\n        return steps\n\n    results = []\n    for i in range(t):\n        n, d = test_cases[i][0]\n        arr = test_cases[i][1]\n        result = process_test_case(n, d, arr)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    test_cases.append((n, d, arr))\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the array size, cyclic shift offset, and elements for each test case\",\n    \"Implement a function to calculate the cyclic shift of the array to the right by d cells\",\n    \"Implement a function to calculate the element-by-element 'AND' operation between two arrays\",\n    \"Iterate through each test case, perform the cyclic shift operation until all elements in the array are zeros or a maximum number of steps is reached\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases and test case details\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": {\n      \"substep_1\": \"Perform the cyclic shift operation on the array\",\n      \"substep_2\": \"Calculate the element-by-element 'AND' operation between the original array and the shifted array\",\n      \"substep_3\": \"Repeat steps 3.1 and 3.2 until all elements in the array are zeros or a maximum number of steps is reached\"\n    },\n    \"step_4\": \"Output the number of steps taken to reach an array with only zeros or -1 if there are still elements equal to 1\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: The core concept here is to shift the elements of an array to the right by a certain number of cells in a cyclic manner.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps do not need to be implemented simultaneously. Each step should be executed sequentially as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n    Output\n    1\n    1\n    3\n    -1\n    0\n    Explanation:\n    - In the first test case, after 1 step, the array will contain only zeros.\n    - In the second test case, after 1 step, the array will contain only zeros.\n    - In the third test case, after 3 steps, the array will contain only zeros.\n    - In the fourth test case, the array will never contain only zeros, so the output is -1.\n    - In the fifth test case, the array already contains only zeros, so the output is 0.\n\n# [extra code for edge case]\n    No extra code is needed to handle the edge cases. The logic provided in the plan covers the edge cases effectively.", "Round_0": {"code": "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_by_element_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef steps_to_zeros(arr, d):\n    steps = 0\n    while any(arr):\n        arr = element_by_element_and(arr, cyclic_shift(arr, d))\n        steps += 1\n        if steps > len(arr):\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = steps_to_zeros(arr, d)\n    print(result)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 29)"}, "Round_1": {"code": "def cyclic_shift(arr, d):\n    n = len(arr)\n    return arr[-d:] + arr[:-d]\n\ndef element_by_element_and(arr1, arr2):\n    return [a & b for a, b in zip(arr1, arr2)]\n\ndef steps_to_zeros(arr, d):\n    steps = 0\n    while any(arr):\n        arr = element_by_element_and(arr, cyclic_shift(arr, d))\n        steps += 1\n        if steps > len(arr):\n            return -1\n    return steps\n\nt = int(input())\nfor _ in range(t):\n    n, d = map(int, input().split())\n    arr = list(map(int, input().split()))\n    result = steps_to_zeros(arr, d)\n    print(result)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input data for each test case\",\n      \"Implement the cyclic shift operation on the array\",\n      \"Perform the element-wise logical AND operation on the array\",\n      \"Check if the array contains only zeros after each step\",\n      \"Count the number of steps taken to reach an array with only zeros\"\n    ],\n    \"major_steps\": [\n      \"Read the number of test cases\",\n      \"For each test case:\",\n      \"   - Read the array size and cyclic shift offset\",\n      \"   - Read the elements of the array\",\n      \"   - Perform the cyclic shift operation on the array\",\n      \"   - Perform the element-wise logical AND operation on the array\",\n      \"   - Check if the array contains only zeros\",\n      \"   - If not, repeat the above steps until the array contains only zeros\",\n      \"   - Count the number of steps taken to reach an array with only zeros\",\n      \"   - Print the number of steps or -1 if the array never contains only zeros\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift operation'\n    Explanation: It refers to shifting the elements of an array circularly to the right by a specified number of cells.\n\n    'element-wise logical AND operation'\n    Explanation: It involves performing a logical AND operation between each element of two arrays.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    All steps should be implemented step by step as described in the plan.\n\n# [edge case] \n    5\n    2 1\n    0 1\n    3 2\n    0 1 0\n    5 2\n    1 1 0 1 0\n    4 2\n    0 1 0 1\n    1 1\n    0\n\n    Output\n    1\n    1\n    3\n    -1\n    0\n\n    Explanation:\n    - For the first test case, after the first step, the array becomes [0, 0] which contains only zeros, so the answer is 1.\n    - For the second test case, after the first step, the array becomes [0, 0, 0] which contains only zeros, so the answer is 1.\n    - For the third test case, it takes 3 steps to reach an array with only zeros.\n    - For the fourth test case, the array will never contain only zeros, so the answer is -1.\n    - For the fifth test case, the array already contains only zeros, so the answer is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan covers all scenarios.", "Round_0": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def cyclic_shift_and_operation(t, test_cases):\n    def cyclic_shift(a, d):\n        return a[-d:] + a[:-d]\n\n    def logical_and(a, b):\n        return [x & y for x, y in zip(a, b)]\n\n    def check_zeros(a):\n        return all(x == 0 for x in a)\n\n    results = []\n    for _ in range(t):\n        n, d = test_cases[_][0]\n        a = test_cases[_][1]\n\n        steps = 0\n        while not check_zeros(a):\n            a_shifted = cyclic_shift(a, d)\n            a = logical_and(a, a_shifted)\n            steps += 1\n\n            if a == a_shifted:\n                steps = -1\n                break\n\n        results.append(steps)\n\n    return results\n\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, d = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, d), a)\n\n# Output\nresults = cyclic_shift_and_operation(t, test_cases)\nfor res in results:\n    print(res)\n"}}], "scores": [], "pass_results": [false, true, false, true, false, true, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 34, "prompt": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only, with array indexes numbered from zero, unlike other problems. In one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells, and the elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}.\n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing, and for a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 4}
