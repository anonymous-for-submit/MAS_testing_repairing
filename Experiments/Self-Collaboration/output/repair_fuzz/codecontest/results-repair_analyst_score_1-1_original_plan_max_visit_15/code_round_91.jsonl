{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), with all problems being different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), with all problems being different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, making sure that the topics or difficulties of the three selected problems are not the same. Your task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams where the topics and difficulties of the selected problems should be different. Determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics_difficulties.add((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all combinations of three problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()", "completions": ["from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef valid_combination(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select three problems\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if valid_combination(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n\nmain()", "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a dictionary to store the topics and difficulties of each problem\n    problems = {}\n    \n    # Read the topics and difficulties of each problem\n    for i in range(n):\n        a, b = map(int, input().split())\n        problems[i+1] = (a, b)\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all possible combinations of three problems\n    for comb in combinations(problems.keys(), 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the selected problems meet the conditions\n        for problem in comb:\n            topics.add(problems[problem][0])\n            difficulties.add(problems[problem][1])\n        \n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the total number of valid combinations for each test case\n    print(count)\n\nmain()", "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef check_problems(problem_set):\n    topics = set()\n    difficulties = set()\n    for problem in problem_set:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to solve the problem\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            if check_problems(comb):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n\nmain()", "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_val = min(n, len(topics), len(difficulties))\n        max_val = max(0, min_val - 2)\n        \n        ways = max_val * (max_val - 1) * (max_val - 2) // 6\n        print(ways)\n\ncount_ways_to_select_problems()\n\nmain()", "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        if len(topics) == n or len(difficulties) == n:\n            total_ways = n * (n - 1) * (n - 2) // 6\n        else:\n            total_ways = n * (n - 1) * (n - 2) // 6 - (n - len(topics)) * (n - len(difficulties))\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics_difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics_difficulties[(a, b)].append(i)\n        \n        total_ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if len(set([i, j, k])) == 3:\n                        total_ways += 1\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n\nmain()", "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6  # Total ways to select 3 problems without any conditions\n        \n        if len(topics) == n or len(difficulties) == n:\n            print(total_ways)  # All topics or all difficulties are different, so all combinations are valid\n        else:\n            valid_ways = 0\n            for i in range(1, n + 1):\n                for j in range(i + 1, n + 1):\n                    for k in range(j + 1, n + 1):\n                        if len(set([i, j, k])) == 3:  # Check if topics or difficulties are different\n                            valid_ways += 1\n            print(valid_ways)\n\ncount_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Function to determine the number of ways to select three problems that meet the requirements\ndef select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            valid = True\n            for problem in comb:\n                if problem[0] in topics or problem[1] in difficulties:\n                    valid = False\n                    break\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if valid:\n                valid_combinations += 1\n        results.append(valid_combinations)\n    \n    return results\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append(problems)\n\n# Determine the number of ways to select three problems for each testcase\nresults = select_problems(testcases)\n\n# Output the result for each testcase\nfor result in results:\n    print(result)\n\nmain()", "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics_difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics_difficulties[(a, b)].append(i)\n        \n        total_ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if len(set([i, j, k])) == 3:\n                        total_ways += 1\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n\nmain()", "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics_difficulties.add((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all combinations of three problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a data structure to store the topics and difficulties of each problem\",\n    \"Step 4\": \"Iterate through all possible combinations of three problems and check if they meet the requirements\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of ways to select three problems'\n    Explanation: The core concept is to determine the total number of ways to select three problems that meet the requirements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve reading input, processing data, iterating through combinations, and counting valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three problems with different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All four problems have different topics and difficulties, so there are four ways to select three problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are ten ways to select three problems with different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all combinations and count valid ones should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics_difficulties.add((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all combinations of three problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics_difficulties.add((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all combinations of three problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select 3 problems from a given set of problems, ensuring that the topics or difficulties of the selected problems are not the same.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan. There are no steps that need to be implemented simultaneously.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: Since all topics and difficulties are the same, there are no valid combinations.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    0\n    Explanation: In this case, there are no valid combinations as all topics and difficulties are the same.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are 10 valid combinations of 3 problems that meet the requirements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all combinations and check for validity covers the edge cases.", "Round_0": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef valid_combination(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select three problems\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if valid_combination(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 37)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef valid_combination(problems):\n    topics = set()\n    difficulties = set()\n    for problem in problems:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to calculate the number of ways to select three problems\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for combination in combinations(problems, 3):\n            if valid_combination(combination):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the details of each test case\",\n    \"For each test case, determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases from input\",\n    \"For each test case, read the number of problems and their topics and difficulties\",\n    \"Create a data structure to store the topics and difficulties of each problem\",\n    \"Iterate through all possible combinations of three problems\",\n    \"Check if the selected problems meet the conditions specified in the requirement\",\n    \"Count the number of valid combinations\",\n    \"Output the total number of valid combinations for each test case\"\n  ]\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties', 'selecting problems'\n    Explanation: The core concept involves selecting three problems that meet specific conditions based on their topics and difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve parsing input, determining the number of ways to select problems, and iterating through combinations to check conditions.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: All three problems have different topics and difficulties, meeting both conditions.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    2 1\n    Output:\n    0\n    Explanation: No combination of three problems meets the conditions.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All possible combinations of three problems meet the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through combinations and check conditions should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a dictionary to store the topics and difficulties of each problem\n    problems = {}\n    \n    # Read the topics and difficulties of each problem\n    for i in range(n):\n        a, b = map(int, input().split())\n        problems[i+1] = (a, b)\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all possible combinations of three problems\n    for comb in combinations(problems.keys(), 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the selected problems meet the conditions\n        for problem in comb:\n            topics.add(problems[problem][0])\n            difficulties.add(problems[problem][1])\n        \n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the total number of valid combinations for each test case\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 43)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of test cases\nt = int(input())\n\n# Iterate through each test case\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a dictionary to store the topics and difficulties of each problem\n    problems = {}\n    \n    # Read the topics and difficulties of each problem\n    for i in range(n):\n        a, b = map(int, input().split())\n        problems[i+1] = (a, b)\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all possible combinations of three problems\n    for comb in combinations(problems.keys(), 3):\n        topics = set()\n        difficulties = set()\n        \n        # Check if the selected problems meet the conditions\n        for problem in comb:\n            topics.add(problems[problem][0])\n            difficulties.add(problems[problem][1])\n        \n        if len(topics) == 3 or len(difficulties) == 3:\n            count += 1\n    \n    # Output the total number of valid combinations for each test case\n    print(count)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select 3 problems from a given set of problems, ensuring that the topics or difficulties of the selected problems are not the same.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    1. 2\n       2 4\n       3 4\n    Output: 0\n    Explanation: There are only 2 problems, so it's not possible to select 3 problems.\n    \n    2. 3\n       1 1\n       2 2\n       3 3\n    Output: 0\n    Explanation: All problems have the same topic and difficulty, so it's not possible to select 3 problems.\n    \n    3. 4\n       1 1\n       2 2\n       3 3\n       4 4\n    Output: 4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nNO", "Round_0": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef check_problems(problem_set):\n    topics = set()\n    difficulties = set()\n    for problem in problem_set:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to solve the problem\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            if check_problems(comb):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 37)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to check if a set of problems meet the requirements\ndef check_problems(problem_set):\n    topics = set()\n    difficulties = set()\n    for problem in problem_set:\n        topics.add(problem[0])\n        difficulties.add(problem[1])\n    return len(topics) == 3 or len(difficulties) == 3\n\n# Main function to solve the problem\ndef select_problems():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = []\n        for _ in range(n):\n            a, b = map(int, input().split())\n            problems.append((a, b))\n        \n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            if check_problems(comb):\n                valid_combinations += 1\n        \n        print(valid_combinations)\n\n# Run the main function\nselect_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a function to calculate the number of ways to select three problems that meet the conditions\",\n    \"Step 4\": \"Implement the logic to determine the number of ways based on the given conditions\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems. Each problem has a unique topic and difficulty.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan do not require simultaneous implementation.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select three problems as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, all topics and difficulties are different, so there are 4 ways to select three problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: In this case, there are 10 ways to select three problems satisfying the conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios.", "Round_0": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_val = min(n, len(topics), len(difficulties))\n        max_val = max(0, min_val - 2)\n        \n        ways = max_val * (max_val - 1) * (max_val - 2) // 6\n        print(ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 27)"}, "Round_1": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        min_val = min(n, len(topics), len(difficulties))\n        max_val = max(0, min_val - 2)\n        \n        ways = max_val * (max_val - 1) * (max_val - 2) // 6\n        print(ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a function to calculate the number of ways to select three problems that meet the conditions\",\n    \"Step 4\": \"Implement the logic to check if the topics or difficulties of the selected problems are different\",\n    \"Step 5\": \"Count and output the number of ways to select three problems for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The core concepts in the requirement are the topics and difficulties of the problems. Monocarp needs to select 3 problems with different topics or difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented step by step as they are. There are no steps that should be implemented simultaneously.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select 3 problems with different topics or difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All 4 problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All 5 problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios.", "Round_0": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        if len(topics) == n or len(difficulties) == n:\n            total_ways = n * (n - 1) * (n - 2) // 6\n        else:\n            total_ways = n * (n - 1) * (n - 2) // 6 - (n - len(topics)) * (n - len(difficulties))\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 30)"}, "Round_1": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        if len(topics) == n or len(difficulties) == n:\n            total_ways = n * (n - 1) * (n - 2) // 6\n        else:\n            total_ways = n * (n - 1) * (n - 2) // 6 - (n - len(topics)) * (n - len(difficulties))\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the input to get the number of testcases\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Determine the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of ways to select three problems'\n    Explanation: The core concept is to find the combinations of selecting three problems from the given set that meet the requirements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different aspects of processing the input and calculating the output.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three problems as all have different topics and difficulties.\n\n    Input:\n    1\n    3\n    1 1\n    1 2\n    1 3\n    Output:\n    0\n    Explanation: It's not possible to select three problems with different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select three problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for selecting three problems can handle these scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics_difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics_difficulties[(a, b)].append(i)\n        \n        total_ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if len(set([i, j, k])) == 3:\n                        total_ways += 1\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 62)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics_difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics_difficulties[(a, b)].append(i)\n        \n        total_ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if len(set([i, j, k])) == 3:\n                        total_ways += 1\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the given conditions\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a function to determine the number of ways to select three problems that meet the conditions\",\n    \"Step 4\": \"Implement the logic to check if the topics or difficulties of the selected problems are different\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics', 'difficulties'\n    Explanation: The problems are characterized by their topics and difficulties, and the selection of problems is based on these attributes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. Each step should be executed sequentially as outlined in the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: In this case, there is only one way to select three problems, as all topics and difficulties are different.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: Here, all topics and difficulties are different, allowing for four possible combinations.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    3\n    Explanation: In this case, there are three valid combinations based on the conditions provided.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)", "Round_0": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6  # Total ways to select 3 problems without any conditions\n        \n        if len(topics) == n or len(difficulties) == n:\n            print(total_ways)  # All topics or all difficulties are different, so all combinations are valid\n        else:\n            valid_ways = 0\n            for i in range(1, n + 1):\n                for j in range(i + 1, n + 1):\n                    for k in range(j + 1, n + 1):\n                        if len(set([i, j, k])) == 3:  # Check if topics or difficulties are different\n                            valid_ways += 1\n            print(valid_ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 34)"}, "Round_1": {"code": "def count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics = set()\n        difficulties = set()\n        \n        for _ in range(n):\n            a, b = map(int, input().split())\n            topics.add(a)\n            difficulties.add(b)\n        \n        total_ways = n * (n - 1) * (n - 2) // 6  # Total ways to select 3 problems without any conditions\n        \n        if len(topics) == n or len(difficulties) == n:\n            print(total_ways)  # All topics or all difficulties are different, so all combinations are valid\n        else:\n            valid_ways = 0\n            for i in range(1, n + 1):\n                for j in range(i + 1, n + 1):\n                    for k in range(j + 1, n + 1):\n                        if len(set([i, j, k])) == 3:  # Check if topics or difficulties are different\n                            valid_ways += 1\n            print(valid_ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input to extract the number of testcases\",\n    \"Step 2\": \"For each testcase, parse the input to extract the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Iterate through all possible combinations of 3 problems and check if they meet the requirements\",\n    \"Step 4\": \"Count the number of valid combinations\",\n    \"Step 5\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problems selection'\n    Explanation: The core concept is to select 3 problems from a given set of problems, ensuring that the topics or difficulties of the selected problems are not the same.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan. There are no steps that need to be implemented simultaneously.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    0\n    Explanation: Since all topics and difficulties are the same, it's not possible to select 3 different problems.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All problems have different topics and difficulties, so there are 4 ways to select 3 problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: All problems have different topics and difficulties, so there are 10 ways to select 3 problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all possible combinations and check for valid selections already covers the edge cases.", "Round_0": {"code": "from itertools import combinations\n\n# Function to determine the number of ways to select three problems that meet the requirements\ndef select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            valid = True\n            for problem in comb:\n                if problem[0] in topics or problem[1] in difficulties:\n                    valid = False\n                    break\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if valid:\n                valid_combinations += 1\n        results.append(valid_combinations)\n    \n    return results\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append(problems)\n\n# Determine the number of ways to select three problems for each testcase\nresults = select_problems(testcases)\n\n# Output the result for each testcase\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 44)"}, "Round_1": {"code": "from itertools import combinations\n\n# Function to determine the number of ways to select three problems that meet the requirements\ndef select_problems(testcases):\n    results = []\n    \n    for problems in testcases:\n        valid_combinations = 0\n        for comb in combinations(problems, 3):\n            topics = set()\n            difficulties = set()\n            valid = True\n            for problem in comb:\n                if problem[0] in topics or problem[1] in difficulties:\n                    valid = False\n                    break\n                topics.add(problem[0])\n                difficulties.add(problem[1])\n            if valid:\n                valid_combinations += 1\n        results.append(valid_combinations)\n    \n    return results\n\n# Parse the input to extract the number of testcases and the details of each testcase\nt = int(input())\ntestcases = []\nfor _ in range(t):\n    n = int(input())\n    problems = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        problems.append((a, b))\n    testcases.append(problems)\n\n# Determine the number of ways to select three problems for each testcase\nresults = select_problems(testcases)\n\n# Output the result for each testcase\nfor result in results:\n    print(result)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Determine the number of ways to select three training problems that meet the requirements\",\n    \"Step 4\": \"Output the result for each testcase\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of ways to select three problems'\n    Explanation: The core concept is to find the number of ways to select three problems that meet the requirements described in the statement.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    There are no steps that should be implemented simultaneously. All steps should be implemented sequentially as per the plan.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three problems as all problems have different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: In this case, each problem has a different topic and difficulty, so there are 4 ways to select three problems.\n\n    Input:\n    1\n    5\n    1 1\n    1 2\n    2 1\n    2 2\n    3 3\n    Output:\n    3\n    Explanation: There are three ways to select three problems: (1, 2, 3), (1, 2, 4), (1, 3, 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers all scenarios.", "Round_0": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics_difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics_difficulties[(a, b)].append(i)\n        \n        total_ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if len(set([i, j, k])) == 3:\n                        total_ways += 1\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 62)"}, "Round_1": {"code": "from collections import defaultdict\n\ndef count_ways_to_select_problems():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        topics_difficulties = defaultdict(list)\n        \n        for i in range(n):\n            a, b = map(int, input().split())\n            topics_difficulties[(a, b)].append(i)\n        \n        total_ways = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if len(set([i, j, k])) == 3:\n                        total_ways += 1\n        \n        print(total_ways)\n\ncount_ways_to_select_problems()\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of testcases and the details of each testcase\",\n    \"For each testcase, determine the number of ways to select three training problems that meet the requirements\",\n    \"Output the result for each testcase\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of testcases from input\",\n    \"Step 2\": \"For each testcase, read the number of problems and their topics and difficulties\",\n    \"Step 3\": \"Create a data structure to store the topics and difficulties of each problem\",\n    \"Step 4\": \"Iterate through all possible combinations of three problems and check if they meet the requirements\",\n    \"Step 5\": \"Count the number of valid combinations and output the result\"\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'number of ways to select three problems'\n    Explanation: The core concept is to determine the total number of ways to select three problems that meet the requirements.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve reading input, processing data, iterating through combinations, and counting valid combinations.\n\n# [edge case] \n    Input:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output:\n    1\n    Explanation: There is only one way to select three problems with different topics and difficulties.\n\n    Input:\n    1\n    4\n    1 1\n    2 2\n    3 3\n    4 4\n    Output:\n    4\n    Explanation: All four problems have different topics and difficulties, so there are four ways to select three problems.\n\n    Input:\n    1\n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output:\n    10\n    Explanation: There are ten ways to select three problems with different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to iterate through all combinations and count valid ones should cover all scenarios.", "Round_0": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics_difficulties.add((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all combinations of three problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 36)"}, "Round_1": {"code": "from itertools import combinations\n\n# Read the number of testcases\nt = int(input())\n\n# Iterate through each testcase\nfor _ in range(t):\n    # Read the number of problems\n    n = int(input())\n    \n    # Create a set to store unique topics and difficulties\n    topics_difficulties = set()\n    \n    # Read the topics and difficulties of each problem\n    for _ in range(n):\n        a, b = map(int, input().split())\n        topics_difficulties.add((a, b))\n    \n    # Initialize a counter for valid combinations\n    count = 0\n    \n    # Iterate through all combinations of three problems\n    for comb in combinations(topics_difficulties, 3):\n        # Check if the topics and difficulties are different\n        if len(set([topic for topic, _ in comb])) == 3 and len(set([diff for _, diff in comb])) == 3:\n            count += 1\n    \n    # Output the result for the current testcase\n    print(count)\n"}}], "scores": [], "pass_results": [false, false, false, false, true, true, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 91, "prompt": "Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), with all problems being different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "condense_two2one", "save_node": true, "parent_index": 25}
