{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The robot is located on a checkered rectangular board with dimensions n \u00d7 m (n rows and m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell contains one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will move when it enters that cell \u2014 left, right, down or up, respectively.\n\nThe robot can initiate its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.\n\n  * If the robot moves beyond the edge of the board, it falls and breaks.\n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore).\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDecide which square the robot should start its movement from to execute the maximum number of commands possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). \n\nConsider the efficiency of your solution in terms of time and space complexity.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right. The robot can initiate its movement in any cell, then moves to the adjacent square in the direction indicated on the current square in one move. \n\nThe robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops. Consider the efficiency of your solution in terms of time and space complexity.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.", "The robot is able to move from the current cell to one of the four adjacent cells denoted by 'L', 'R', 'D' or 'U' symbols. Its goal is to make the maximum number of steps before it breaks or stops. Which square should the robot start from to achieve this?\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    \n    for i in range(n):\n        for j in range(m):\n            current_cell = (i, j)\n            moves = 0\n            visited = set()\n            \n            while current_cell not in visited:\n                visited.add(current_cell)\n                moves += 1\n                next_cell = get_adjacent_cell(current_cell, board[current_cell[0]][current_cell[1]])\n                \n                if next_cell[0] < 0 or next_cell[0] >= n or next_cell[1] < 0 or next_cell[1] >= m:\n                    break\n                \n                current_cell = next_cell\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_max_moves(board, n, m)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "completions": ["def get_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_moves(board, n, m)\n    print(r, c, d)\n\nmain()", "def get_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_moves(board, n, m)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = calculate_moves(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\ndef calculate_moves(board, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    moves = 0\n    \n    while 0 <= r < len(board) and 0 <= c < len(board[0]):\n        moves += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n    \n    return moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = find_starting_cell(board)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = 0\n            visited = set()\n            x, y = i, j\n            \n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_moves(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def calculate_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Skip the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board, n, m)\n    print(r, c, d)\n\nmain()", "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, start_cell):\n    visited = set()\n    max_moves = 0\n    stack = [(start_cell, 0)]\n\n    while stack:\n        cell, moves = stack.pop()\n        if cell in visited:\n            continue\n        visited.add(cell)\n        max_moves = max(max_moves, moves)\n\n        row, col = cell\n        if 0 <= row < len(board) and 0 <= col < len(board[0]):\n            direction = board[row][col]\n            next_cell = get_adjacent_cell(cell, direction)\n            stack.append((next_cell, moves + 1))\n\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = calculate_max_moves(board, (i, j))\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef is_valid_cell(cell, n, m):\n    return 1 <= cell[0] <= n and 1 <= cell[1] <= m\n\ndef calculate_max_moves(board, n, m, start_cell):\n    visited = set()\n    max_moves = 0\n    stack = [(start_cell, 0)]\n\n    while stack:\n        cell, moves = stack.pop()\n        if cell in visited:\n            continue\n        visited.add(cell)\n        max_moves = max(max_moves, moves)\n\n        for direction in board[cell[0] - 1][cell[1] - 1]:\n            next_cell = get_adjacent_cell(cell, direction)\n            if is_valid_cell(next_cell, n, m):\n                stack.append((next_cell, moves + 1))\n\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            moves = calculate_max_moves(board, n, m, (i, j))\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i, j)\n\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = calculate_moves(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell, max_moves\n\ndef calculate_moves(board, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    moves = 0\n    \n    while 0 <= r < len(board) and 0 <= c < len(board[0]):\n        move = board[r][c]\n        if move not in directions:\n            break\n        moves += 1\n        r, c = r + directions[move][0], c + directions[move][1]\n    \n    return moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = find_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()", "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    \n    for i in range(n):\n        for j in range(m):\n            current_cell = (i, j)\n            moves = 0\n            visited = set()\n            \n            while current_cell not in visited:\n                visited.add(current_cell)\n                moves += 1\n                next_cell = get_adjacent_cell(current_cell, board[current_cell[0]][current_cell[1]])\n                \n                if next_cell[0] < 0 or next_cell[0] >= n or next_cell[1] < 0 or next_cell[1] >= m:\n                    break\n                \n                current_cell = next_cell\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_max_moves(board, n, m)\n    print(start_cell[0], start_cell[1], max_moves)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and calculate the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'adjacent square': Refers to the square that is directly next to the current square in any of the four directions (left, right, up, down).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before stopping.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and major steps.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation:\n    The robot starts at cell (1, 1) and can only make 1 move to the right before stopping.\n\n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation:\n    The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n\n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation:\n    The robot starts at cell (4, 3) and can make 12 moves in various directions before stopping.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    \n    for i in range(n):\n        for j in range(m):\n            current_cell = (i, j)\n            moves = 0\n            visited = set()\n            \n            while current_cell not in visited:\n                visited.add(current_cell)\n                moves += 1\n                next_cell = get_adjacent_cell(current_cell, board[current_cell[0]][current_cell[1]])\n                \n                if next_cell[0] < 0 or next_cell[0] >= n or next_cell[1] < 0 or next_cell[1] >= m:\n                    break\n                \n                current_cell = next_cell\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_max_moves(board, n, m)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    \n    for i in range(n):\n        for j in range(m):\n            current_cell = (i, j)\n            moves = 0\n            visited = set()\n            \n            while current_cell not in visited:\n                visited.add(current_cell)\n                moves += 1\n                next_cell = get_adjacent_cell(current_cell, board[current_cell[0]][current_cell[1]])\n                \n                if next_cell[0] < 0 or next_cell[0] >= n or next_cell[1] < 0 or next_cell[1] >= m:\n                    break\n                \n                current_cell = next_cell\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_max_moves(board, n, m)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, "session_historys": [{"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions\",\n      \"For each test case, parse the board layout and determine the maximum number of moves the robot can make\",\n      \"Find the starting cell that will result in the maximum number of moves\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves for a given starting cell\",\n      \"Iterate through all cells to find the starting cell with the maximum number of moves\",\n      \"Output the starting cell with the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves the movement of a robot on a checkered rectangular board with specific rules and constraints.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before breaking or stopping.\n\n# [code logic]\n    The steps should be implemented sequentially as there are no steps that need to be executed simultaneously.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make one move to the right.\n    \n    Edge Case 2:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves before breaking or stopping.\n\n    Edge Case 3:\n    2 2\n    UD\n    RU\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves before breaking or stopping.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find the starting cell with the maximum number of moves can be implemented efficiently without additional code.", "Round_0": {"code": "def get_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_moves(board, n, m)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_moves(board, n, m)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions\",\n      \"For each test case, parse the board layout and determine the maximum number of moves the robot can make\",\n      \"Find the starting cell that will result in the maximum number of moves\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves for a given starting cell\",\n      \"Iterate through all cells to find the starting cell with the maximum number of moves\",\n      \"Output the starting cell with the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves the movement of a robot on a checkered rectangular board with specific rules and constraints.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve different subproblems and major steps. Each step focuses on a specific aspect of the problem and contributes to the overall solution.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: In this case, the robot starts at cell (1, 1) and can only make one move to the right.\n    \n    Edge Case 2:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves in total by following the directions.\n\n    Edge Case 3:\n    2 2\n    UD\n    RU\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves in total by following the directions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The solution provided covers the scenarios effectively.", "Round_0": {"code": "def get_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_moves(board, n, m)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_moves(board, n, m)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions\",\n      \"For each test case, parse the board layout and symbols\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board dimensions and layout\",\n      \"Iterate through each cell in the board and calculate the maximum number of moves from that cell\",\n      \"Output the starting cell with the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept is about the movement of a robot on a checkered rectangular board, where the robot can move in four directions and needs to maximize the number of steps before breaking or stopping.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': means the robot needs to maximize the number of steps before breaking or stopping\n\n# [code logic]\n    The steps in the plan should be implemented step by step as they are sequential and do not require simultaneous execution.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move to the right before breaking.\n    \n    Test Case 2:\n    Input:\n    2\n    2 2\n    UD\n    RU\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves (U, R, R, U) before breaking.\n\n    Test Case 3:\n    Input:\n    4\n    4 4\n    RRRD\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation: The robot can start at cell (4, 3) and make 12 moves (R, U, U, R, U, R, U, R, U, R, U, R) before breaking.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find the starting cell with the maximum number of moves can be implemented efficiently without additional code.", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 45)"}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            x, y = i, j\n            moves = 0\n\n            while 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell for the robot to make the maximum number of moves\",\n      \"Calculate the maximum number of moves the robot can make from the starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board configuration and extract the height, width, and board layout\",\n      \"Iterate through each cell in the board to find the starting cell for the robot\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configurations'\n    Explanation: The board configurations consist of the height, width, and layout of the board where the robot can move.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented step by step as they are distinct tasks without dependencies.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: In this case, the robot can only move to the right from cell (1, 1) and make 1 move.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot can start at cell (1, 1) and make 3 moves by moving right twice and then left once.\n\n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RRRU\n    UUUR\n    RLLD\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves by moving down twice, right once, and then left once.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to find the starting cell for the robot and calculate the maximum number of moves should cover all scenarios.", "Round_0": {"code": "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = calculate_moves(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\ndef calculate_moves(board, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    moves = 0\n    \n    while 0 <= r < len(board) and 0 <= c < len(board[0]):\n        moves += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n    \n    return moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = find_starting_cell(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = calculate_moves(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\ndef calculate_moves(board, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    moves = 0\n    \n    while 0 <= r < len(board) and 0 <= c < len(board[0]):\n        moves += 1\n        dr, dc = directions[board[r][c]]\n        r, c = r + dr, c + dc\n    \n    return moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = find_starting_cell(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell for the robot to make the maximum number of moves\",\n      \"Calculate the maximum number of moves the robot can make from the starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board configuration and determine the starting cell\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configurations'\n    Explanation: The board configurations consist of a grid with symbols 'L', 'R', 'D', 'U' representing the directions the robot can move.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, determining starting cell, calculating maximum moves, and outputting results.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make 1 move in the right direction.\n    \n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation: The robot starts at cell (1, 1) and can make 3 moves by going right, right, and left.\n    \n    Test Case 3:\n    Input:\n    2 2\n    DL\n    RU\n    Output:\n    1 1 4\n    Explanation: The robot starts at cell (1, 1) and can make 4 moves by going down, left, right, and up.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic to determine the starting cell and maximum moves should cover all scenarios.", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = 0\n            visited = set()\n            x, y = i, j\n            \n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_moves(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 47)"}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = 0\n            visited = set()\n            x, y = i, j\n            \n            while (x, y) not in visited:\n                visited.add((x, y))\n                if board[x][y] == 'L':\n                    y -= 1\n                elif board[x][y] == 'R':\n                    y += 1\n                elif board[x][y] == 'U':\n                    x -= 1\n                elif board[x][y] == 'D':\n                    x += 1\n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell, max_moves\n\nt = int(input())\ninput()  # read the blank line\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_moves(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions\",\n      \"For each test case, parse the board layout and determine the maximum number of moves the robot can make\",\n      \"Find the starting cell that will result in the maximum number of moves\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves for a given starting cell\",\n      \"Iterate through all cells to find the starting cell with the maximum number of moves\",\n      \"Output the starting cell with the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'robot movement'\n    Explanation: The core concept involves the movement of a robot on a checkered rectangular board with specific rules and constraints.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before breaking or stopping.\n\n# [code logic]\n    The steps should be implemented sequentially as they involve reading input, parsing board layout, calculating moves, and finding the starting cell with the maximum moves.\n\n# [edge case] \n    Edge Case 1:\n    1 1\n    R\n    Output: 1 1 1\n    Explanation: The robot starts at cell (1, 1) and can only make one move to the right.\n    \n    Edge Case 2:\n    4 4\n    DDLU\n    RDDU\n    UUUU\n    RDLD\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves before breaking or stopping.\n\n    Edge Case 3:\n    2 2\n    UD\n    RU\n    Output: 1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves before breaking or stopping.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge cases)\n\nNO", "Round_0": {"code": "def calculate_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Skip the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board, n, m)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board, n, m):\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n    def is_valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, steps):\n        visited[x][y] = True\n        max_steps = steps\n\n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y) and not visited[new_x][new_y] and board[new_x][new_y] == board[x][y]:\n                max_steps = max(max_steps, dfs(new_x, new_y, steps + 1))\n\n        visited[x][y] = False\n        return max_steps\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, 1)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Skip the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board, n, m)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and calculate the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'adjacent square': Refers to the square that is directly next to the current square in any of the four directions (left, right, up, down).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before stopping or breaking.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and major steps. Each test case should be handled individually to determine the starting cell and calculate the maximum number of moves.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation:\n    In this case, the robot starts at cell (1, 1) and can only make 1 move to the right before stopping.\n\n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation:\n    The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n\n    Test Case 3:\n    Input:\n    2 2\n    DL\n    RU\n    Output:\n    1 1 4\n    Explanation:\n    The robot starts at cell (1, 1) and can make 4 moves in different directions before stopping.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan should be sufficient to handle the given requirements.", "Round_0": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, start_cell):\n    visited = set()\n    max_moves = 0\n    stack = [(start_cell, 0)]\n\n    while stack:\n        cell, moves = stack.pop()\n        if cell in visited:\n            continue\n        visited.add(cell)\n        max_moves = max(max_moves, moves)\n\n        row, col = cell\n        if 0 <= row < len(board) and 0 <= col < len(board[0]):\n            direction = board[row][col]\n            next_cell = get_adjacent_cell(cell, direction)\n            stack.append((next_cell, moves + 1))\n\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = calculate_max_moves(board, (i, j))\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, start_cell):\n    visited = set()\n    max_moves = 0\n    stack = [(start_cell, 0)]\n\n    while stack:\n        cell, moves = stack.pop()\n        if cell in visited:\n            continue\n        visited.add(cell)\n        max_moves = max(max_moves, moves)\n\n        row, col = cell\n        if 0 <= row < len(board) and 0 <= col < len(board[0]):\n            direction = board[row][col]\n            next_cell = get_adjacent_cell(cell, direction)\n            stack.append((next_cell, moves + 1))\n\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n\n    max_moves = 0\n    start_cell = (1, 1)\n    for i in range(n):\n        for j in range(m):\n            moves = calculate_max_moves(board, (i, j))\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and calculate the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'adjacent square': Refers to the square that is directly next to the current square in any of the four directions (left, right, up, down).\n\n    'maximum number of steps': Indicates the goal of the robot to make the most moves possible before stopping.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest or greatest number of steps the robot can make.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and major steps. Each test case should be handled individually to determine the starting cell and calculate the maximum number of moves for the robot.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation:\n    The robot starts at cell (1, 1) and can only make 1 move to the right.\n\n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation:\n    The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n\n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation:\n    The robot starts at cell (4, 3) and can make 12 moves in various directions before stopping.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef is_valid_cell(cell, n, m):\n    return 1 <= cell[0] <= n and 1 <= cell[1] <= m\n\ndef calculate_max_moves(board, n, m, start_cell):\n    visited = set()\n    max_moves = 0\n    stack = [(start_cell, 0)]\n\n    while stack:\n        cell, moves = stack.pop()\n        if cell in visited:\n            continue\n        visited.add(cell)\n        max_moves = max(max_moves, moves)\n\n        for direction in board[cell[0] - 1][cell[1] - 1]:\n            next_cell = get_adjacent_cell(cell, direction)\n            if is_valid_cell(next_cell, n, m):\n                stack.append((next_cell, moves + 1))\n\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            moves = calculate_max_moves(board, n, m, (i, j))\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i, j)\n\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef is_valid_cell(cell, n, m):\n    return 1 <= cell[0] <= n and 1 <= cell[1] <= m\n\ndef calculate_max_moves(board, n, m, start_cell):\n    visited = set()\n    max_moves = 0\n    stack = [(start_cell, 0)]\n\n    while stack:\n        cell, moves = stack.pop()\n        if cell in visited:\n            continue\n        visited.add(cell)\n        max_moves = max(max_moves, moves)\n\n        for direction in board[cell[0] - 1][cell[1] - 1]:\n            next_cell = get_adjacent_cell(cell, direction)\n            if is_valid_cell(next_cell, n, m):\n                stack.append((next_cell, moves + 1))\n\n    return max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n\n    max_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            moves = calculate_max_moves(board, n, m, (i, j))\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i, j)\n\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell for the robot to make the maximum number of moves\",\n      \"Calculate the maximum number of moves the robot can make from the starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, read the board configuration and extract the height, width, and board layout\",\n      \"Iterate through each cell in the board to find the starting cell for the robot\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'board configurations'\n    Explanation: The board configurations consist of the height, width, and layout of the board where the robot can move.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The major steps should be implemented step by step as they are distinct tasks without dependencies.\n\n# [edge case] \n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation: In this case, there is only one cell and the robot can only make one move.\n\n    Input:\n    4 4\n    DDLU\n    RRRU\n    UUUL\n    LRRD\n    Output:\n    1 1 4\n    Explanation: The robot can start at cell (1, 1) and make 4 moves in this case.\n\n    Input:\n    2 2\n    LR\n    UD\n    Output:\n    1 1 2\n    Explanation: The robot can start at cell (1, 1) and make 2 moves in this case.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = calculate_moves(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell, max_moves\n\ndef calculate_moves(board, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    moves = 0\n    \n    while 0 <= r < len(board) and 0 <= c < len(board[0]):\n        move = board[r][c]\n        if move not in directions:\n            break\n        moves += 1\n        r, c = r + directions[move][0], c + directions[move][1]\n    \n    return moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = find_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def find_starting_cell(board):\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            moves = calculate_moves(board, r, c)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (r+1, c+1)\n    \n    return start_cell, max_moves\n\ndef calculate_moves(board, r, c):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    moves = 0\n    \n    while 0 <= r < len(board) and 0 <= c < len(board[0]):\n        move = board[r][c]\n        if move not in directions:\n            break\n        moves += 1\n        r, c = r + directions[move][0], c + directions[move][1]\n    \n    return moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    start_cell, max_moves = find_starting_cell(board)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board configurations\",\n      \"For each test case, determine the starting cell and calculate the maximum number of moves the robot can make\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the board configuration and determine the starting cell\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"Output the starting cell and the maximum number of moves for each test case\"\n    ]\n  }\n}\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'adjacent square': Refers to the square that is directly next to the current square in any of the four directions (left, right, up, down).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'maximum': Indicates the highest number of steps the robot can take before stopping.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as they involve different subproblems and major steps.\n\n# [edge case] \n    Test Case 1:\n    Input:\n    1 1\n    R\n    Output:\n    1 1 1\n    Explanation:\n    The robot starts at cell (1, 1) and can only make 1 move to the right before stopping.\n\n    Test Case 2:\n    Input:\n    1 3\n    RRL\n    Output:\n    1 1 3\n    Explanation:\n    The robot starts at cell (1, 1) and can make 3 moves to the right before stopping.\n\n    Test Case 3:\n    Input:\n    4 4\n    DDLU\n    RUUD\n    URUD\n    ULLR\n    Output:\n    4 3 12\n    Explanation:\n    The robot starts at cell (4, 3) and can make 12 moves in various directions before stopping.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case) \n\nNO", "Round_0": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    \n    for i in range(n):\n        for j in range(m):\n            current_cell = (i, j)\n            moves = 0\n            visited = set()\n            \n            while current_cell not in visited:\n                visited.add(current_cell)\n                moves += 1\n                next_cell = get_adjacent_cell(current_cell, board[current_cell[0]][current_cell[1]])\n                \n                if next_cell[0] < 0 or next_cell[0] >= n or next_cell[1] < 0 or next_cell[1] >= m:\n                    break\n                \n                current_cell = next_cell\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_max_moves(board, n, m)\n    print(start_cell[0], start_cell[1], max_moves)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_adjacent_cell(cell, direction):\n    if direction == 'L':\n        return cell[0], cell[1] - 1\n    elif direction == 'R':\n        return cell[0], cell[1] + 1\n    elif direction == 'U':\n        return cell[0] - 1, cell[1]\n    elif direction == 'D':\n        return cell[0] + 1, cell[1]\n\ndef calculate_max_moves(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    \n    for i in range(n):\n        for j in range(m):\n            current_cell = (i, j)\n            moves = 0\n            visited = set()\n            \n            while current_cell not in visited:\n                visited.add(current_cell)\n                moves += 1\n                next_cell = get_adjacent_cell(current_cell, board[current_cell[0]][current_cell[1]])\n                \n                if next_cell[0] < 0 or next_cell[0] >= n or next_cell[1] < 0 or next_cell[1] >= m:\n                    break\n                \n                current_cell = next_cell\n            \n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell, max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # Read the blank line\n    n, m = map(int, input().split())\n    board = [input() for _ in range(n)]\n    \n    start_cell, max_moves = calculate_max_moves(board, n, m)\n    print(start_cell[0], start_cell[1], max_moves)\n"}}], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 100, "prompt": "The robot is located on a checkered rectangular board with dimensions n \u00d7 m (n rows and m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell contains one of the symbols 'L', 'R', 'D' or 'U', denoting the direction the robot will move when it enters that cell \u2014 left, right, down or up, respectively.\n\nThe robot can initiate its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move.\n\n  * If the robot moves beyond the edge of the board, it falls and breaks.\n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore).\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDecide which square the robot should start its movement from to execute the maximum number of commands possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). \n\nConsider the efficiency of your solution in terms of time and space complexity.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 66}
