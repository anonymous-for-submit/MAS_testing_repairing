{"task_id": "HumanEval/29", "prompt": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\t\n'''Filter an input list of strings only for ones that start with a given prefix. Ensure your function handles both lowercase and uppercase letters in the input list and prefix seamlessly.\n>>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    '''", "entry_point": "filter_by_prefix", "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n", "test": ["def check(filter_by_prefix):\n\tassert filter_by_prefix(['wbcyhow', 'othmuu', 'qstccywt', 'kzzzvqn q', 'NyK', 'boroja'], 'k') == ['kzzzvqn q']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['xdse', 'ugcr', 'ryodayvs', 'kszuzounvl', 'oYzwIJ', 'wtzwmn'], 'ry') == ['ryodayvs']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['toiqdq', 'zruhovo', 'ywpfnzjn', 'jccetilhqn', 'vjV', 'kaccrqxfh'], 'to') == ['toiqdq']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qyoihv', 'yteiiholb', 'uwu', 'a q', 'CHmYVyhgIJ', 'juvxhncva'], 'C') == ['CHmYVyhgIJ']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['fwlkekpt', 'vfm', 'hqh', 'xgnhled n xh', 'rOGoIPc', 'quiulyxju'], 'r') == ['rOGoIPc']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['peyspr', 'qvcoz', 'fmrriodo', 'kjots', 'oCgS', 'nyl'], 'n') == ['nyl']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['txy', 'usf', 'zmzujred', 'pecojrvylq', 'yJYdIxZ', 'bpmfxnkhf'], 'z') == ['zmzujred']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['fchencp', 'wmj', 'jykg', 'jftlcgnzejjx', 'fhSQ', 'hqclz'], 'wm') == ['wmj']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['zlcm', 'vjs', 'cdmwpyhhq', 'wyrhjezju', 'cGhAevMA', 'rupqmt'], 'c') == ['cdmwpyhhq', 'cGhAevMA']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'hc') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['nqgktjn', 'xtxpk', 'lkfbr', 'vmiehvntp', 'cYAkCvcpNa', 'rtoi'], 'x') == ['xtxpk']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['cpgg', 'zrjalcpcq', 'wmlssl', 'yvakkcbfgixw', 'gwIKDjSr', 'pkfxygez'], 'pk') == ['pkfxygez']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'gie') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['tyv', 'nhl', 'wazvpsyy', 'qqkonlxaxvq', 'bnhl', 'uoropiqs'], 'wa') == ['wazvpsyy']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['afu', 'pyp', 'gsrfiuns', 'rnbbkq', 'tGioT', 'qqe'], 'tG') == ['tGioT']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['irzdwce', 'bnhe', 'rkqwvkq', 'y coftmixsda', 'xbWDAJt', 'uhqao'], 'uh') == ['uhqao']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['sqys', 'uox', 'oyacj', 'vic', 'FNqEzTW', 'sdwwffrnz'], 'v') == ['vic']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['tgv', 'zoqjzxz', 'ggag', 'svcyybsowr', 'cyrevICpiBew', 'ehk'], 'eh') == ['ehk']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['mgidnv', 'fymr', 'eibxot', 'isyoucwqx', 'mVOnTZURbGo', 'ydmyf'], 'i') == ['isyoucwqx']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['ejvijw', 'eoxwtu', 'umqxd', 'sdmtayil', 'QgHN', 'ifcnud'], 'um') == ['umqxd']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['fxg', 'jukpejtka', 'rpmwg', 'ilqottxzh', 'PLG', 'bzdkq'], 'PL') == ['PLG']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['hdnssea', 'xgfsteg', 'zzneoai', 'lazplbekb', 'XZw', 'iarfshq'], 'z') == ['zzneoai']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['cqvkhvmb', 'vaa', 'wczaocewv', 'ycl', 'XgktBQUCCPDB', 'lcxq'], 'w') == ['wczaocewv']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['jyhbqgw', 'htupvoy', 'eckf', 'opbkslrajig', 'tmYxwj', 'meblapkay'], 'm') == ['meblapkay']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qqzyx', 'ovmjsvswm', 'naqo', 'usnzwotzfjcc', 'NSJBG', 'ses'], 'N') == ['NSJBG']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['bli', 'jqadqid', 'hxrer', ' elgpsxj', 'iTjWqdTbg', 'mizoj'], 'jq') == ['jqadqid']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['igzsmxi', 'oxpaalwcz', 'pzjt', 'rqdkukrz', 'xskN', 'pdyqbxmc'], 'o') == ['oxpaalwcz']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['gsoetlwn', 'ttj', 'objeem', 'tkbykjgfy', 'YbI', 'bkim'], 'Y') == ['YbI']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 's') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['casok', 'zxh', 'jub', 'dliq', 'HgnRd', 'wyulic'], 'ju') == ['jub']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['udf', 'rfghktjte', 'lobb', 'sxmkvlpy', 'HIoTNeRQWfmv', 'cgro'], 'H') == ['HIoTNeRQWfmv']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['mfwzfsmby', 'dwuzmct', 'ruthl', 'j imluth cl', 'nuvGiAJLP', 'craa'], 'm') == ['mfwzfsmby']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['seokdz', 'lpolypj', 'ppzsdn', 'uahan', 'cYuJalGKw', 'irggysg'], 'cY') == ['cYuJalGKw']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['ssbkamkk', 'lgpsyakx', 'aqmrmmuyv', 'ofhe', 'cTuIVLXWsW', 'ixf'], 'i') == ['ixf']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['dmqz', 'ttabgee', 'zihftohzc', 'deq', 'UnRUHV', 'zukgpwfv'], 'dm') == ['dmqz']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['tqlmggeoh', 'chbwix', 'gviiyy', 'tsjuuu', 'vmFVBNr', 'wwscnomb'], 'ts') == ['tsjuuu']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['lcwnaov', 'uxw', 'lkihigyv', 'dqmjseye', 'BJn', 'vrndtlalh'], 'B') == ['BJn']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'john') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qtzxo', 'viico', 'qofoy', 'xyjnzdf', 'qTQG', 'meksggu'], 'me') == ['meksggu']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['sqkfcgh', 'oixs', 'rudfiv', 'vmsmqh', 'DZEQsnr', 'yrzygmwu'], 'sq') == ['sqkfcgh']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['nsg', 'wawe', 'cqthmr', 'uwwmlsbk', 'YnQJuXrcT', 'omsppagp'], 'w') == ['wawe']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['kyuxiq', 'wyfepirq', 'cehrtir', 'wfzh', 'FrcId', 'himyfdqie'], 'k') == ['kyuxiq']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['gqbsehnje', 'qztb', 'likrhcml', 'rytnjkrgifvk', 'qbb', 'ezbppjfp'], 'l') == ['likrhcml']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['wwt', 'dgrwpdu', 'gawfftfjx', 'jjztu', 'TPqzQrODL', 'bds'], 'j') == ['jjztu']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['awshlaxo', 'gctskq', 'bowsrq', 'nnaqclkpv', 'xjEeDyISwmKk', 'cloohvs'], 'aw') == ['awshlaxo']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['szqdfjr', 'zbyjp', 'ikquotia', 'hojzypa', 'eIABxMPRoXm', 'bua'], 'eI') == ['eIABxMPRoXm']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['fcxaqtk', 'kiq', 'vyjv', 'kvr p', 'tUyaOR', 'iuddamr'], 'fc') == ['fcxaqtk']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['uanqtt', 'fmpmtbsl', 'zqplbgx', 'tchhyvij', 'bEDBxyFFDy', 'pickhvpek'], 'fm') == ['fmpmtbsl']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['zvai', 'kifq', 'hkoctip', 'dvwygdwurwv', 'LXihHXCqSoU', 'aqeahjcen'], 'h') == ['hkoctip']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['byzhtjgiz', 'onwb', 'dchcrk', 'gu utuxthdp', 'beDiG', 'uhqw'], 'u') == ['uhqw']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'c') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'qw') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['oabealcy', 'ccwuzfcoc', 'rehkhtg', 'gxakvg hani', 'UhGHg', 'zisfdy'], 'oa') == ['oabealcy']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['uvbohls', 'jbazmg', 'yxgaiuqqi', 'eqyhjffvaco', 'Jmpqhvo', 'mlyxv'], 'yx') == ['yxgaiuqqi']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['ibyvdglgi', 'wkaqgyqeh', 'inzobsq', 'etqomfbislt', 'JtEBq', 'dsrsoz'], 'e') == ['etqomfbislt']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qgiibqz', 'vykph', 'letgrjnd', 'cedd', 'MeWkrjScxDrn', 'vdxohuy'], 'c') == ['cedd']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['kblytu', 'bvvgfhhbe', 'zxjgedvs', 'nvux x', 'uhlGguXAf', 'mvial'], 'n') == ['nvux x']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['jbneyqsj', 'gviykjdu', 'pswphm', 'cnt', 'lyKbacda', 'oicpibhjx'], 'jb') == ['jbneyqsj']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['jwijiho', 'evcrpanw', 'lrkn', 'usiz', 'oYjwjgzErc', 'tpwwjq'], 't') == ['tpwwjq']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['hbarvrcrl', 'eviehxs', 'wwtdcu', 'r ono', 'GfbsHgsBFv', 'dyotymgx'], 'hb') == ['hbarvrcrl']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['pgjcmrqlw', 'ztspgrrhd', 'swsc', 'mydvh', 'oks', 'zjczfp'], 'ok') == ['oks']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['bia', 'egbiz', 'klpwxcmha', 'bdob', 'jJxddYQzNYs', 'vjp'], 'kl') == ['klpwxcmha']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['wxgbz', 'xngcbuox', 'ssxncvux', 'rdrfy', 'sJAru', 'xzvprs'], 'x') == ['xngcbuox', 'xzvprs']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'odh') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qeqokuci', 'colz', 'tpj', 'auulejia ', 'rVKO', 'znvm'], 'a') == ['auulejia ']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['cnpqa', 'uhaarqbbh', 'qobuyyx', 'xulkcyte', 'hPr', 'zqkiyijo'], 'qo') == ['qobuyyx']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'kck') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['rmffwoz', 'rcbutsfc', 'vyf', 'tkakwlrrtp', 'cFDAlaxwO', 'eoi'], 'e') == ['eoi']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['mxi', 'xtngipq', 'ngipl', 'mqrsjitry', 'GHdKrX', 'wdccw'], 'G') == ['GHdKrX']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['ikvxcd', 'mkamr', 'unpsh', 'fzdlqxm gkg', 'BKtwnDFeEBX', 'lletpc'], 'BK') == ['BKtwnDFeEBX']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['txjkaklfe', 'gksvm', 'xvhe', 'rwwmcmnjjcvx', 'rhfs', 'mnvskyq'], 'r') == ['rwwmcmnjjcvx', 'rhfs']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['muw', 'rpnwajd', 'seu', 'yjnnvaonjgci', 'BpSOmnYGSyg', 'ltyqaalcg'], 'l') == ['ltyqaalcg']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['xfu', 'ipy', 'zfz', 'fzpznw', 'FHoQrwGqZ', 'abjfkg'], 'xf') == ['xfu']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['fpwrcpro', 'hhyvnr', 'mvpncphvq', 'ttpqh', 'ZQXxpmdqP', 'vezzw'], 'v') == ['vezzw']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['flsefr', 'glfgtb', 'fdgmgvt', 'lwmg lppmxh', 'dxAHGqRsF', 'lrhgvxd'], 'g') == ['glfgtb']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['rvuscib', 'unkejbwq', 'hvsvw', 'qzgijxtkbqt', 'zbuxOcWiHonS', 'qdhzmxxwf'], 'u') == ['unkejbwq']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['btyxi', 'oku', 'rchkjlhjo', 'xtj', 'azAL', 'cfxm'], 'x') == ['xtj']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['uujdfeu', 'jmzwsdlgk', 'hxc', 'wwda', 'IsUPEstl', 'zvhglg'], 'w') == ['wwda']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['xxevx', 'vknumn', 'jqhnzqsq', 'bsc', 'uSSKZoCNFV', 'kdows'], 'uS') == ['uSSKZoCNFV']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['abvpkzf', 'fcirpc', 'gxnrata', 'dtcutzv', 'ScIYWrBEF', 'vguow'], 'gx') == ['gxnrata']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['uqfnmzuj', 'oyzhjseob', 'vizqz', 'pgc', 'tuxAjQLZ', 'qiutw'], 'vi') == ['vizqz']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'dx') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['owgus', 'jsfluk', 'axhpsdxnb', 'ujokse', 'uKLzdIVSCU', 'nyapgx'], 'uj') == ['ujokse']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['uaon', 'gykyot', 'xxbq', 'kibuvgizegwt', 'MWxf', 'byimdy'], 'u') == ['uaon']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['zlburwim', 'dzfs', 'jsj', 'cpdlqaeptiev', 'hXmqAdUOU', 'wsvuncog'], 'c') == ['cpdlqaeptiev']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['jmdmbzu', 'zgzgzqkq', 'aorlwyw', 'rbab', 'kaqkeYHk', 'vkogvkp'], 'a') == ['aorlwyw']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['cgzso', 'ivppapd', 'kkeqpfkl', ' inzrjwhfm', 'GRtJkYLV', 'tuopqbq'], 'c') == ['cgzso']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['ztdsuik', 'gcqvc', 'vjhedlu', 'smqctzfc', 'TsBKZPed', 'daqggucw'], 'zt') == ['ztdsuik']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['inefoe', 'xzsz', 'linopmjk', 'ryijajsshzv', 'gHlWOUCmA', 'xyajofu'], 'xy') == ['xyajofu']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['urfzx', 'vhmtbb', 'gqvdtr', 'jjx', 'VZgaaGz', 'esp'], 'jj') == ['jjx']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['cthx', 'evksuu', 'srblluzch', 'lqo', 'DWdb', 'nbdirmt'], 'D') == ['DWdb']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qbsmz', 'ilote', 'tob', 'ulzmxw', 'VPmoaDr', 'ywojsi'], 'to') == ['tob']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['takt', 'mtomfj', 'cdklj', 'cxajdd', 'DxahSoeqKi', 'lstxs'], 't') == ['takt']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['tglaob', 'nyi', 'itxdcu', 'bzovjkcdz', 'knXz', 'tqonafkf'], 'tg') == ['tglaob']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['vgtiqmb', 'eqmpymk', 'gzsybf', 'stdajypfavzx', 'IoUJeghCvc', 'cutliglim'], 'eq') == ['eqmpymk']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['rtndcjyk', 'oaqr', 'scebutbql', 'kmkiqgrjy', 'laBRYkQAQOIO', 'oakw'], 'la') == ['laBRYkQAQOIO']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['wawon', 'wsmuwzw', 'fuuslu', 'zeij', 'nicryZgyEFvc', 'fjp'], 'w') == ['wawon', 'wsmuwzw']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['hczszwml', 'ugp', 'lzaey', 'ziyikv', 'AclMUxFaNSQt', 'tufpegwem'], 't') == ['tufpegwem']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qxkneuoa', 'tkvgceljq', 'bilgbt', 'ofjglm', 'MqU', 'gtqvtdknr'], 'Mq') == ['MqU']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['nyaydhh', 'hkhslt', 'hfdv', 'flxfent', 'CVKIJI', 'erunhk'], 'h') == ['hkhslt', 'hfdv']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['apyhwl', 'roiy', 'lat', 'dkleltc', 'UvSqf', 'lqxywthua'], 'la') == ['lat']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['mdwukqmpo', 'oetsc', 'esfoei', 'itpxdewm', 'ajArhWSi', 'metufl'], 'it') == ['itpxdewm']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['pfdgvqag', 'hmiqxmpkj', 'efvmuanp', 'tibjohy', 'AlLcUQZWTRcQ', 'eocerqij'], 'Al') == ['AlLcUQZWTRcQ']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['moylvee', 'qaiist', 'pdcyxad', 'etfun', 'vXGPRQlcP', 'yihwxms'], 'p') == ['pdcyxad']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'rqq') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['trk', 'rnkkzfmt', 'keu', 'abtxfqezq', 'XAIdEaH', 'vjggq'], 'ke') == ['keu']", "def check(filter_by_prefix):\n\tassert filter_by_prefix([], 'b') == []", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['sywqmszik', 'gwucwa', 'oowgn', 'evxovemkzh', 'rcOPuCiS', 'uqetyh'], 'ev') == ['evxovemkzh']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['qosr', 'wtrc', 'rac', 'zmcag', 'nyUGvIfC', 'ptnnknp'], 'w') == ['wtrc']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['xkjgxyv', 'yff', 'jvwayhssp', 'qmv', 'YeGMxVUOXDrO', 'trgiwtz'], 'tr') == ['trgiwtz']", "def check(filter_by_prefix):\n\tassert filter_by_prefix(['hnrppxq', 'uxf', 'ief', 'ebuycg l', 'MyxeZXPwM', 'pbet'], 'eb') == ['ebuycg l']"], "test_case_list": ["assert filter_by_prefix(['wbcyhow', 'othmuu', 'qstccywt', 'kzzzvqn q', 'NyK', 'boroja'], 'k') == ['kzzzvqn q']", "assert filter_by_prefix(['xdse', 'ugcr', 'ryodayvs', 'kszuzounvl', 'oYzwIJ', 'wtzwmn'], 'ry') == ['ryodayvs']", "assert filter_by_prefix(['toiqdq', 'zruhovo', 'ywpfnzjn', 'jccetilhqn', 'vjV', 'kaccrqxfh'], 'to') == ['toiqdq']", "assert filter_by_prefix(['qyoihv', 'yteiiholb', 'uwu', 'a q', 'CHmYVyhgIJ', 'juvxhncva'], 'C') == ['CHmYVyhgIJ']", "assert filter_by_prefix(['fwlkekpt', 'vfm', 'hqh', 'xgnhled n xh', 'rOGoIPc', 'quiulyxju'], 'r') == ['rOGoIPc']", "assert filter_by_prefix(['peyspr', 'qvcoz', 'fmrriodo', 'kjots', 'oCgS', 'nyl'], 'n') == ['nyl']", "assert filter_by_prefix(['txy', 'usf', 'zmzujred', 'pecojrvylq', 'yJYdIxZ', 'bpmfxnkhf'], 'z') == ['zmzujred']", "assert filter_by_prefix(['fchencp', 'wmj', 'jykg', 'jftlcgnzejjx', 'fhSQ', 'hqclz'], 'wm') == ['wmj']", "assert filter_by_prefix(['zlcm', 'vjs', 'cdmwpyhhq', 'wyrhjezju', 'cGhAevMA', 'rupqmt'], 'c') == ['cdmwpyhhq', 'cGhAevMA']", "assert filter_by_prefix([], 'hc') == []", "assert filter_by_prefix(['nqgktjn', 'xtxpk', 'lkfbr', 'vmiehvntp', 'cYAkCvcpNa', 'rtoi'], 'x') == ['xtxpk']", "assert filter_by_prefix(['cpgg', 'zrjalcpcq', 'wmlssl', 'yvakkcbfgixw', 'gwIKDjSr', 'pkfxygez'], 'pk') == ['pkfxygez']", "assert filter_by_prefix([], 'gie') == []", "assert filter_by_prefix(['tyv', 'nhl', 'wazvpsyy', 'qqkonlxaxvq', 'bnhl', 'uoropiqs'], 'wa') == ['wazvpsyy']", "assert filter_by_prefix(['afu', 'pyp', 'gsrfiuns', 'rnbbkq', 'tGioT', 'qqe'], 'tG') == ['tGioT']", "assert filter_by_prefix(['irzdwce', 'bnhe', 'rkqwvkq', 'y coftmixsda', 'xbWDAJt', 'uhqao'], 'uh') == ['uhqao']", "assert filter_by_prefix(['sqys', 'uox', 'oyacj', 'vic', 'FNqEzTW', 'sdwwffrnz'], 'v') == ['vic']", "assert filter_by_prefix(['tgv', 'zoqjzxz', 'ggag', 'svcyybsowr', 'cyrevICpiBew', 'ehk'], 'eh') == ['ehk']", "assert filter_by_prefix(['mgidnv', 'fymr', 'eibxot', 'isyoucwqx', 'mVOnTZURbGo', 'ydmyf'], 'i') == ['isyoucwqx']", "assert filter_by_prefix(['ejvijw', 'eoxwtu', 'umqxd', 'sdmtayil', 'QgHN', 'ifcnud'], 'um') == ['umqxd']", "assert filter_by_prefix(['fxg', 'jukpejtka', 'rpmwg', 'ilqottxzh', 'PLG', 'bzdkq'], 'PL') == ['PLG']", "assert filter_by_prefix(['hdnssea', 'xgfsteg', 'zzneoai', 'lazplbekb', 'XZw', 'iarfshq'], 'z') == ['zzneoai']", "assert filter_by_prefix(['cqvkhvmb', 'vaa', 'wczaocewv', 'ycl', 'XgktBQUCCPDB', 'lcxq'], 'w') == ['wczaocewv']", "assert filter_by_prefix(['jyhbqgw', 'htupvoy', 'eckf', 'opbkslrajig', 'tmYxwj', 'meblapkay'], 'm') == ['meblapkay']", "assert filter_by_prefix(['qqzyx', 'ovmjsvswm', 'naqo', 'usnzwotzfjcc', 'NSJBG', 'ses'], 'N') == ['NSJBG']", "assert filter_by_prefix(['bli', 'jqadqid', 'hxrer', ' elgpsxj', 'iTjWqdTbg', 'mizoj'], 'jq') == ['jqadqid']", "assert filter_by_prefix(['igzsmxi', 'oxpaalwcz', 'pzjt', 'rqdkukrz', 'xskN', 'pdyqbxmc'], 'o') == ['oxpaalwcz']", "assert filter_by_prefix(['gsoetlwn', 'ttj', 'objeem', 'tkbykjgfy', 'YbI', 'bkim'], 'Y') == ['YbI']", "assert filter_by_prefix([], 's') == []", "assert filter_by_prefix(['casok', 'zxh', 'jub', 'dliq', 'HgnRd', 'wyulic'], 'ju') == ['jub']", "assert filter_by_prefix(['udf', 'rfghktjte', 'lobb', 'sxmkvlpy', 'HIoTNeRQWfmv', 'cgro'], 'H') == ['HIoTNeRQWfmv']", "assert filter_by_prefix(['mfwzfsmby', 'dwuzmct', 'ruthl', 'j imluth cl', 'nuvGiAJLP', 'craa'], 'm') == ['mfwzfsmby']", "assert filter_by_prefix(['seokdz', 'lpolypj', 'ppzsdn', 'uahan', 'cYuJalGKw', 'irggysg'], 'cY') == ['cYuJalGKw']", "assert filter_by_prefix(['ssbkamkk', 'lgpsyakx', 'aqmrmmuyv', 'ofhe', 'cTuIVLXWsW', 'ixf'], 'i') == ['ixf']", "assert filter_by_prefix(['dmqz', 'ttabgee', 'zihftohzc', 'deq', 'UnRUHV', 'zukgpwfv'], 'dm') == ['dmqz']", "assert filter_by_prefix(['tqlmggeoh', 'chbwix', 'gviiyy', 'tsjuuu', 'vmFVBNr', 'wwscnomb'], 'ts') == ['tsjuuu']", "assert filter_by_prefix(['lcwnaov', 'uxw', 'lkihigyv', 'dqmjseye', 'BJn', 'vrndtlalh'], 'B') == ['BJn']", "assert filter_by_prefix([], 'john') == []", "assert filter_by_prefix(['qtzxo', 'viico', 'qofoy', 'xyjnzdf', 'qTQG', 'meksggu'], 'me') == ['meksggu']", "assert filter_by_prefix(['sqkfcgh', 'oixs', 'rudfiv', 'vmsmqh', 'DZEQsnr', 'yrzygmwu'], 'sq') == ['sqkfcgh']", "assert filter_by_prefix(['nsg', 'wawe', 'cqthmr', 'uwwmlsbk', 'YnQJuXrcT', 'omsppagp'], 'w') == ['wawe']", "assert filter_by_prefix(['kyuxiq', 'wyfepirq', 'cehrtir', 'wfzh', 'FrcId', 'himyfdqie'], 'k') == ['kyuxiq']", "assert filter_by_prefix(['gqbsehnje', 'qztb', 'likrhcml', 'rytnjkrgifvk', 'qbb', 'ezbppjfp'], 'l') == ['likrhcml']", "assert filter_by_prefix(['wwt', 'dgrwpdu', 'gawfftfjx', 'jjztu', 'TPqzQrODL', 'bds'], 'j') == ['jjztu']", "assert filter_by_prefix(['awshlaxo', 'gctskq', 'bowsrq', 'nnaqclkpv', 'xjEeDyISwmKk', 'cloohvs'], 'aw') == ['awshlaxo']", "assert filter_by_prefix(['szqdfjr', 'zbyjp', 'ikquotia', 'hojzypa', 'eIABxMPRoXm', 'bua'], 'eI') == ['eIABxMPRoXm']", "assert filter_by_prefix(['fcxaqtk', 'kiq', 'vyjv', 'kvr p', 'tUyaOR', 'iuddamr'], 'fc') == ['fcxaqtk']", "assert filter_by_prefix(['uanqtt', 'fmpmtbsl', 'zqplbgx', 'tchhyvij', 'bEDBxyFFDy', 'pickhvpek'], 'fm') == ['fmpmtbsl']", "assert filter_by_prefix(['zvai', 'kifq', 'hkoctip', 'dvwygdwurwv', 'LXihHXCqSoU', 'aqeahjcen'], 'h') == ['hkoctip']", "assert filter_by_prefix(['byzhtjgiz', 'onwb', 'dchcrk', 'gu utuxthdp', 'beDiG', 'uhqw'], 'u') == ['uhqw']", "assert filter_by_prefix([], 'c') == []", "assert filter_by_prefix([], 'qw') == []", "assert filter_by_prefix(['oabealcy', 'ccwuzfcoc', 'rehkhtg', 'gxakvg hani', 'UhGHg', 'zisfdy'], 'oa') == ['oabealcy']", "assert filter_by_prefix(['uvbohls', 'jbazmg', 'yxgaiuqqi', 'eqyhjffvaco', 'Jmpqhvo', 'mlyxv'], 'yx') == ['yxgaiuqqi']", "assert filter_by_prefix(['ibyvdglgi', 'wkaqgyqeh', 'inzobsq', 'etqomfbislt', 'JtEBq', 'dsrsoz'], 'e') == ['etqomfbislt']", "assert filter_by_prefix(['qgiibqz', 'vykph', 'letgrjnd', 'cedd', 'MeWkrjScxDrn', 'vdxohuy'], 'c') == ['cedd']", "assert filter_by_prefix(['kblytu', 'bvvgfhhbe', 'zxjgedvs', 'nvux x', 'uhlGguXAf', 'mvial'], 'n') == ['nvux x']", "assert filter_by_prefix(['jbneyqsj', 'gviykjdu', 'pswphm', 'cnt', 'lyKbacda', 'oicpibhjx'], 'jb') == ['jbneyqsj']", "assert filter_by_prefix(['jwijiho', 'evcrpanw', 'lrkn', 'usiz', 'oYjwjgzErc', 'tpwwjq'], 't') == ['tpwwjq']", "assert filter_by_prefix(['hbarvrcrl', 'eviehxs', 'wwtdcu', 'r ono', 'GfbsHgsBFv', 'dyotymgx'], 'hb') == ['hbarvrcrl']", "assert filter_by_prefix(['pgjcmrqlw', 'ztspgrrhd', 'swsc', 'mydvh', 'oks', 'zjczfp'], 'ok') == ['oks']", "assert filter_by_prefix(['bia', 'egbiz', 'klpwxcmha', 'bdob', 'jJxddYQzNYs', 'vjp'], 'kl') == ['klpwxcmha']", "assert filter_by_prefix(['wxgbz', 'xngcbuox', 'ssxncvux', 'rdrfy', 'sJAru', 'xzvprs'], 'x') == ['xngcbuox', 'xzvprs']", "assert filter_by_prefix([], 'odh') == []", "assert filter_by_prefix(['qeqokuci', 'colz', 'tpj', 'auulejia ', 'rVKO', 'znvm'], 'a') == ['auulejia ']", "assert filter_by_prefix(['cnpqa', 'uhaarqbbh', 'qobuyyx', 'xulkcyte', 'hPr', 'zqkiyijo'], 'qo') == ['qobuyyx']", "assert filter_by_prefix([], 'kck') == []", "assert filter_by_prefix(['rmffwoz', 'rcbutsfc', 'vyf', 'tkakwlrrtp', 'cFDAlaxwO', 'eoi'], 'e') == ['eoi']", "assert filter_by_prefix(['mxi', 'xtngipq', 'ngipl', 'mqrsjitry', 'GHdKrX', 'wdccw'], 'G') == ['GHdKrX']", "assert filter_by_prefix(['ikvxcd', 'mkamr', 'unpsh', 'fzdlqxm gkg', 'BKtwnDFeEBX', 'lletpc'], 'BK') == ['BKtwnDFeEBX']", "assert filter_by_prefix(['txjkaklfe', 'gksvm', 'xvhe', 'rwwmcmnjjcvx', 'rhfs', 'mnvskyq'], 'r') == ['rwwmcmnjjcvx', 'rhfs']", "assert filter_by_prefix(['muw', 'rpnwajd', 'seu', 'yjnnvaonjgci', 'BpSOmnYGSyg', 'ltyqaalcg'], 'l') == ['ltyqaalcg']", "assert filter_by_prefix(['xfu', 'ipy', 'zfz', 'fzpznw', 'FHoQrwGqZ', 'abjfkg'], 'xf') == ['xfu']", "assert filter_by_prefix(['fpwrcpro', 'hhyvnr', 'mvpncphvq', 'ttpqh', 'ZQXxpmdqP', 'vezzw'], 'v') == ['vezzw']", "assert filter_by_prefix(['flsefr', 'glfgtb', 'fdgmgvt', 'lwmg lppmxh', 'dxAHGqRsF', 'lrhgvxd'], 'g') == ['glfgtb']", "assert filter_by_prefix(['rvuscib', 'unkejbwq', 'hvsvw', 'qzgijxtkbqt', 'zbuxOcWiHonS', 'qdhzmxxwf'], 'u') == ['unkejbwq']", "assert filter_by_prefix(['btyxi', 'oku', 'rchkjlhjo', 'xtj', 'azAL', 'cfxm'], 'x') == ['xtj']", "assert filter_by_prefix(['uujdfeu', 'jmzwsdlgk', 'hxc', 'wwda', 'IsUPEstl', 'zvhglg'], 'w') == ['wwda']", "assert filter_by_prefix(['xxevx', 'vknumn', 'jqhnzqsq', 'bsc', 'uSSKZoCNFV', 'kdows'], 'uS') == ['uSSKZoCNFV']", "assert filter_by_prefix(['abvpkzf', 'fcirpc', 'gxnrata', 'dtcutzv', 'ScIYWrBEF', 'vguow'], 'gx') == ['gxnrata']", "assert filter_by_prefix(['uqfnmzuj', 'oyzhjseob', 'vizqz', 'pgc', 'tuxAjQLZ', 'qiutw'], 'vi') == ['vizqz']", "assert filter_by_prefix([], 'dx') == []", "assert filter_by_prefix(['owgus', 'jsfluk', 'axhpsdxnb', 'ujokse', 'uKLzdIVSCU', 'nyapgx'], 'uj') == ['ujokse']", "assert filter_by_prefix(['uaon', 'gykyot', 'xxbq', 'kibuvgizegwt', 'MWxf', 'byimdy'], 'u') == ['uaon']", "assert filter_by_prefix(['zlburwim', 'dzfs', 'jsj', 'cpdlqaeptiev', 'hXmqAdUOU', 'wsvuncog'], 'c') == ['cpdlqaeptiev']", "assert filter_by_prefix(['jmdmbzu', 'zgzgzqkq', 'aorlwyw', 'rbab', 'kaqkeYHk', 'vkogvkp'], 'a') == ['aorlwyw']", "assert filter_by_prefix(['cgzso', 'ivppapd', 'kkeqpfkl', ' inzrjwhfm', 'GRtJkYLV', 'tuopqbq'], 'c') == ['cgzso']", "assert filter_by_prefix(['ztdsuik', 'gcqvc', 'vjhedlu', 'smqctzfc', 'TsBKZPed', 'daqggucw'], 'zt') == ['ztdsuik']", "assert filter_by_prefix(['inefoe', 'xzsz', 'linopmjk', 'ryijajsshzv', 'gHlWOUCmA', 'xyajofu'], 'xy') == ['xyajofu']", "assert filter_by_prefix(['urfzx', 'vhmtbb', 'gqvdtr', 'jjx', 'VZgaaGz', 'esp'], 'jj') == ['jjx']", "assert filter_by_prefix(['cthx', 'evksuu', 'srblluzch', 'lqo', 'DWdb', 'nbdirmt'], 'D') == ['DWdb']", "assert filter_by_prefix(['qbsmz', 'ilote', 'tob', 'ulzmxw', 'VPmoaDr', 'ywojsi'], 'to') == ['tob']", "assert filter_by_prefix(['takt', 'mtomfj', 'cdklj', 'cxajdd', 'DxahSoeqKi', 'lstxs'], 't') == ['takt']", "assert filter_by_prefix(['tglaob', 'nyi', 'itxdcu', 'bzovjkcdz', 'knXz', 'tqonafkf'], 'tg') == ['tglaob']", "assert filter_by_prefix(['vgtiqmb', 'eqmpymk', 'gzsybf', 'stdajypfavzx', 'IoUJeghCvc', 'cutliglim'], 'eq') == ['eqmpymk']", "assert filter_by_prefix(['rtndcjyk', 'oaqr', 'scebutbql', 'kmkiqgrjy', 'laBRYkQAQOIO', 'oakw'], 'la') == ['laBRYkQAQOIO']", "assert filter_by_prefix(['wawon', 'wsmuwzw', 'fuuslu', 'zeij', 'nicryZgyEFvc', 'fjp'], 'w') == ['wawon', 'wsmuwzw']", "assert filter_by_prefix(['hczszwml', 'ugp', 'lzaey', 'ziyikv', 'AclMUxFaNSQt', 'tufpegwem'], 't') == ['tufpegwem']", "assert filter_by_prefix(['qxkneuoa', 'tkvgceljq', 'bilgbt', 'ofjglm', 'MqU', 'gtqvtdknr'], 'Mq') == ['MqU']", "assert filter_by_prefix(['nyaydhh', 'hkhslt', 'hfdv', 'flxfent', 'CVKIJI', 'erunhk'], 'h') == ['hkhslt', 'hfdv']", "assert filter_by_prefix(['apyhwl', 'roiy', 'lat', 'dkleltc', 'UvSqf', 'lqxywthua'], 'la') == ['lat']", "assert filter_by_prefix(['mdwukqmpo', 'oetsc', 'esfoei', 'itpxdewm', 'ajArhWSi', 'metufl'], 'it') == ['itpxdewm']", "assert filter_by_prefix(['pfdgvqag', 'hmiqxmpkj', 'efvmuanp', 'tibjohy', 'AlLcUQZWTRcQ', 'eocerqij'], 'Al') == ['AlLcUQZWTRcQ']", "assert filter_by_prefix(['moylvee', 'qaiist', 'pdcyxad', 'etfun', 'vXGPRQlcP', 'yihwxms'], 'p') == ['pdcyxad']", "assert filter_by_prefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']", "assert filter_by_prefix([], 'rqq') == []", "assert filter_by_prefix(['trk', 'rnkkzfmt', 'keu', 'abtxfqezq', 'XAIdEaH', 'vjggq'], 'ke') == ['keu']", "assert filter_by_prefix([], 'b') == []", "assert filter_by_prefix(['sywqmszik', 'gwucwa', 'oowgn', 'evxovemkzh', 'rcOPuCiS', 'uqetyh'], 'ev') == ['evxovemkzh']", "assert filter_by_prefix(['qosr', 'wtrc', 'rac', 'zmcag', 'nyUGvIfC', 'ptnnknp'], 'w') == ['wtrc']", "assert filter_by_prefix(['xkjgxyv', 'yff', 'jvwayhssp', 'qmv', 'YeGMxVUOXDrO', 'trgiwtz'], 'tr') == ['trgiwtz']", "assert filter_by_prefix(['hnrppxq', 'uxf', 'ief', 'ebuycg l', 'MyxeZXPwM', 'pbet'], 'eb') == ['ebuycg l']"], "nl": " Filter an input list of strings only for ones that start with a given prefix.\n    ", "func": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:", "examples": ">>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    ", "completion": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty. If so, return an empty list.\n    if not strings:\n        return []\n    \n    # Convert the prefix to lowercase.\n    prefix_lower = prefix.lower()\n    \n    # Collect strings that match the prefix condition into a new list.\n    filtered_strings = [\n        string for string in strings if string.lower().startswith(prefix_lower)\n    ]\n    \n    # Return the new list containing the filtered strings.\n    return filtered_strings\n", "completions": ["from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Convert the prefix to lowercase to ensure case insensitivity\n    lower_prefix = prefix.lower()\n    \n    # Initialize an empty list to store the filtered results\n    result = []\n    \n    # Iterate over each string in the input list\n    for string in strings:\n        # Convert the string to lowercase and check if it starts with the lowercase prefix\n        if string.lower().startswith(lower_prefix):\n            # If it does, add the original string to the results list\n            result.append(string)\n    \n    # Return the results list after completing the iteration\n    return result\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Check for empty input list\n    if not strings:\n        return result\n    \n    # Iterate and compare\n    for string in strings:\n        # Convert both the string and prefix to lowercase for case-insensitive comparison\n        if string.lower().startswith(prefix.lower()):\n            # Add matching strings to result\n            result.append(string)\n    \n    # Return result list\n    return result\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Check for empty input list\n    if not strings:\n        return result\n    \n    # Iterate and compare\n    for string in strings:\n        # Convert both the string and prefix to lowercase\n        if string.lower().startswith(prefix.lower()):\n            # Add matching strings to result\n            result.append(string)\n    \n    # Return result list\n    return result\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty\n    if not strings:\n        return []\n    \n    # Normalize case\n    prefix_lower = prefix.lower()\n    strings_lower = [s.lower() for s in strings]\n    \n    # Filter strings\n    filtered_strings = [s for s, s_lower in zip(strings, strings_lower) if s_lower.startswith(prefix_lower)]\n    \n    # Return result\n    return filtered_strings\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Check for empty input list\n    if not strings:\n        return result\n    \n    # Iterate and filter\n    for string in strings:\n        if string.lower().startswith(prefix.lower()):\n            result.append(string)\n    \n    # Return result\n    return result\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty\n    if not strings:\n        return []\n    \n    # Normalize case\n    normalized_prefix = prefix.lower()\n    normalized_strings = [s.lower() for s in strings]\n    \n    # Filter strings\n    result = [s for s in strings if s.lower().startswith(normalized_prefix)]\n    \n    # Return result\n    return result\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Validate Inputs\n    if not isinstance(strings, list) or not isinstance(prefix, str):\n        raise ValueError(\"Invalid input: 'strings' must be a list and 'prefix' must be a string.\")\n    \n    # Normalize Case\n    prefix_lower = prefix.lower()\n    strings_lower = [s.lower() for s in strings]\n    \n    # Filter Strings\n    filtered_strings = [s for s, s_lower in zip(strings, strings_lower) if s_lower.startswith(prefix_lower)]\n    \n    # Return Result\n    return filtered_strings\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Handle empty input list\n    if not strings:\n        return result\n    \n    # Normalize prefix\n    normalized_prefix = prefix.lower()\n    \n    # Iterate and filter\n    for string in strings:\n        if string.lower().startswith(normalized_prefix):\n            result.append(string)\n    \n    # Return result\n    return result\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty. If so, return an empty list.\n    if not strings:\n        return []\n    \n    # Convert the prefix to lowercase.\n    prefix = prefix.lower()\n    \n    # Collect strings that match the prefix condition into a new list.\n    filtered_strings = [s for s in strings if s.lower().startswith(prefix)]\n    \n    # Return the new list containing strings that start with the given prefix.\n    return filtered_strings\n", "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty. If so, return an empty list.\n    if not strings:\n        return []\n    \n    # Convert the prefix to lowercase.\n    prefix_lower = prefix.lower()\n    \n    # Collect strings that match the prefix condition into a new list.\n    filtered_strings = [\n        string for string in strings if string.lower().startswith(prefix_lower)\n    ]\n    \n    # Return the new list containing the filtered strings.\n    return filtered_strings\n"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Handle empty input list\",\n      \"details\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"description\": \"Normalize case sensitivity\",\n      \"details\": \"Convert both the input list of strings and the prefix to lowercase to ensure case-insensitive comparison.\"\n    },\n    {\n      \"description\": \"Filter strings by prefix\",\n      \"details\": \"Iterate over the list of strings and select only those that start with the given prefix.\"\n    },\n    {\n      \"description\": \"Return the filtered list\",\n      \"details\": \"Compile the selected strings into a new list and return it as the output.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Check if the input list is empty. If so, return an empty list.\",\n    \"Convert all strings in the input list to lowercase.\",\n    \"Convert the prefix to lowercase.\",\n    \"Iterate over the list of strings and check if each string starts with the given prefix.\",\n    \"Collect strings that match the prefix condition into a new list.\",\n    \"Return the new list containing the filtered strings.\"\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty. If so, return an empty list.\n    if not strings:\n        return []\n    \n    # Convert the prefix to lowercase.\n    prefix_lower = prefix.lower()\n    \n    # Collect strings that match the prefix condition into a new list.\n    filtered_strings = [\n        string for string in strings if string.lower().startswith(prefix_lower)\n    ]\n    \n    # Return the new list containing the filtered strings.\n    return filtered_strings\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"decomposition\": [\n    \"Identify the input parameters: a list of strings and a prefix string.\",\n    \"Determine the expected output: a list of strings that start with the given prefix.\",\n    \"Ensure case insensitivity: convert both the input list and prefix to lowercase for comparison.\",\n    \"Implement filtering logic: iterate through the list and check if each string starts with the prefix.\"\n  ],\n  \"high_level_plan\": [\n    \"Define the function signature: filter_by_prefix(strings: List[str], prefix: str) -> List[str].\",\n    \"Convert the prefix to lowercase to ensure case insensitivity.\",\n    \"Initialize an empty list to store the filtered results.\",\n    \"Iterate over each string in the input list.\",\n    \"For each string, convert it to lowercase and check if it starts with the lowercase prefix.\",\n    \"If it does, add the original string to the results list.\",\n    \"Return the results list after completing the iteration.\"\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Convert the prefix to lowercase to ensure case insensitivity\n    lower_prefix = prefix.lower()\n    \n    # Initialize an empty list to store the filtered results\n    result = []\n    \n    # Iterate over each string in the input list\n    for string in strings:\n        # Convert the string to lowercase and check if it starts with the lowercase prefix\n        if string.lower().startswith(lower_prefix):\n            # If it does, add the original string to the results list\n            result.append(string)\n    \n    # Return the results list after completing the iteration\n    return result\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Handle empty input list\",\n      \"description\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"subproblem\": \"Iterate over the input list\",\n      \"description\": \"Loop through each string in the input list to check if it starts with the given prefix.\"\n    },\n    {\n      \"subproblem\": \"Case-insensitive comparison\",\n      \"description\": \"Convert both the strings and the prefix to lowercase to ensure case-insensitive comparison.\"\n    },\n    {\n      \"subproblem\": \"Filter strings by prefix\",\n      \"description\": \"Add strings that start with the given prefix to the result list.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize result list\",\n      \"description\": \"Create an empty list to store strings that match the prefix criteria.\"\n    },\n    {\n      \"step\": \"Check for empty input list\",\n      \"description\": \"Return the empty result list immediately if the input list is empty.\"\n    },\n    {\n      \"step\": \"Iterate and compare\",\n      \"description\": \"Loop through each string in the input list, convert both the string and prefix to lowercase, and check if the string starts with the prefix.\"\n    },\n    {\n      \"step\": \"Add matching strings to result\",\n      \"description\": \"If a string starts with the prefix, add it to the result list.\"\n    },\n    {\n      \"step\": \"Return result list\",\n      \"description\": \"Return the list of strings that start with the given prefix.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Check for empty input list\n    if not strings:\n        return result\n    \n    # Iterate and compare\n    for string in strings:\n        # Convert both the string and prefix to lowercase for case-insensitive comparison\n        if string.lower().startswith(prefix.lower()):\n            # Add matching strings to result\n            result.append(string)\n    \n    # Return result list\n    return result\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Handle empty input list\",\n      \"description\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"subproblem\": \"Iterate over the input list\",\n      \"description\": \"Loop through each string in the input list to check if it starts with the given prefix.\"\n    },\n    {\n      \"subproblem\": \"Case-insensitive comparison\",\n      \"description\": \"Convert both the strings and the prefix to lowercase to ensure case-insensitive comparison.\"\n    },\n    {\n      \"subproblem\": \"Filter strings by prefix\",\n      \"description\": \"Add strings that start with the given prefix to the result list.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize result list\",\n      \"description\": \"Create an empty list to store strings that match the prefix criteria.\"\n    },\n    {\n      \"step\": \"Check for empty input list\",\n      \"description\": \"Return the empty result list if the input list is empty.\"\n    },\n    {\n      \"step\": \"Iterate and compare\",\n      \"description\": \"Loop through each string in the input list, convert both the string and prefix to lowercase, and check if the string starts with the prefix.\"\n    },\n    {\n      \"step\": \"Add matching strings to result\",\n      \"description\": \"If a string starts with the prefix, add it to the result list.\"\n    },\n    {\n      \"step\": \"Return result list\",\n      \"description\": \"Return the list of strings that start with the given prefix.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Check for empty input list\n    if not strings:\n        return result\n    \n    # Iterate and compare\n    for string in strings:\n        # Convert both the string and prefix to lowercase\n        if string.lower().startswith(prefix.lower()):\n            # Add matching strings to result\n            result.append(string)\n    \n    # Return result list\n    return result\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Handle empty input list\",\n      \"details\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"description\": \"Normalize case sensitivity\",\n      \"details\": \"Convert both the input strings and the prefix to lowercase to handle case insensitivity.\"\n    },\n    {\n      \"description\": \"Filter strings by prefix\",\n      \"details\": \"Iterate over the list of strings and select only those that start with the given prefix.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Check if the input list is empty\",\n      \"action\": \"If the list is empty, return an empty list immediately.\"\n    },\n    {\n      \"step\": \"Normalize case\",\n      \"action\": \"Convert all strings in the input list and the prefix to lowercase to ensure case insensitivity.\"\n    },\n    {\n      \"step\": \"Filter strings\",\n      \"action\": \"Iterate through the list of strings and collect those that start with the given prefix.\"\n    },\n    {\n      \"step\": \"Return result\",\n      \"action\": \"Return the list of filtered strings.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty\n    if not strings:\n        return []\n    \n    # Normalize case\n    prefix_lower = prefix.lower()\n    strings_lower = [s.lower() for s in strings]\n    \n    # Filter strings\n    filtered_strings = [s for s, s_lower in zip(strings, strings_lower) if s_lower.startswith(prefix_lower)]\n    \n    # Return result\n    return filtered_strings\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Handle empty input list\",\n      \"description\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"subproblem\": \"Iterate over input list\",\n      \"description\": \"Loop through each string in the input list to check if it starts with the given prefix.\"\n    },\n    {\n      \"subproblem\": \"Case-insensitive comparison\",\n      \"description\": \"Convert both the strings and the prefix to lowercase to ensure case-insensitive comparison.\"\n    },\n    {\n      \"subproblem\": \"Filter strings by prefix\",\n      \"description\": \"Add strings that start with the given prefix to the result list.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize result list\",\n      \"description\": \"Create an empty list to store strings that match the prefix criteria.\"\n    },\n    {\n      \"step\": \"Check for empty input list\",\n      \"description\": \"Return the empty result list if the input list is empty.\"\n    },\n    {\n      \"step\": \"Iterate and filter\",\n      \"description\": \"Loop through each string in the input list, convert both the string and prefix to lowercase, and check if the string starts with the prefix. If it does, add it to the result list.\"\n    },\n    {\n      \"step\": \"Return result\",\n      \"description\": \"Return the result list containing all strings that start with the given prefix.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Check for empty input list\n    if not strings:\n        return result\n    \n    # Iterate and filter\n    for string in strings:\n        if string.lower().startswith(prefix.lower()):\n            result.append(string)\n    \n    # Return result\n    return result\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Handle empty input list\",\n      \"description\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"subproblem\": \"Iterate over input list\",\n      \"description\": \"Loop through each string in the input list to check if it starts with the given prefix.\"\n    },\n    {\n      \"subproblem\": \"Case-insensitive comparison\",\n      \"description\": \"Convert both the strings and the prefix to lowercase to ensure case-insensitive comparison.\"\n    },\n    {\n      \"subproblem\": \"Filter strings by prefix\",\n      \"description\": \"Add strings that start with the given prefix to the result list.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Check if the input list is empty\",\n      \"description\": \"Return an empty list if the input list is empty.\"\n    },\n    {\n      \"step\": \"Normalize case\",\n      \"description\": \"Convert all strings in the input list and the prefix to lowercase.\"\n    },\n    {\n      \"step\": \"Filter strings\",\n      \"description\": \"Iterate over the normalized list and add strings that start with the normalized prefix to the result list.\"\n    },\n    {\n      \"step\": \"Return result\",\n      \"description\": \"Return the list of filtered strings.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty\n    if not strings:\n        return []\n    \n    # Normalize case\n    normalized_prefix = prefix.lower()\n    normalized_strings = [s.lower() for s in strings]\n    \n    # Filter strings\n    result = [s for s in strings if s.lower().startswith(normalized_prefix)]\n    \n    # Return result\n    return result\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Input Validation\",\n      \"description\": \"Ensure the input list of strings and the prefix are valid. The list should be iterable and the prefix should be a string.\"\n    },\n    {\n      \"subproblem\": \"Case Insensitivity\",\n      \"description\": \"Convert all strings in the input list and the prefix to lowercase to ensure case insensitivity.\"\n    },\n    {\n      \"subproblem\": \"Filtering\",\n      \"description\": \"Iterate through the list of strings and filter out those that start with the given prefix.\"\n    },\n    {\n      \"subproblem\": \"Output\",\n      \"description\": \"Return the filtered list of strings.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Validate Inputs\",\n      \"description\": \"Check if the input list is iterable and the prefix is a string.\"\n    },\n    {\n      \"step\": \"Normalize Case\",\n      \"description\": \"Convert all strings in the list and the prefix to lowercase.\"\n    },\n    {\n      \"step\": \"Filter Strings\",\n      \"description\": \"Use a list comprehension or a loop to filter strings that start with the prefix.\"\n    },\n    {\n      \"step\": \"Return Result\",\n      \"description\": \"Return the list of filtered strings.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Validate Inputs\n    if not isinstance(strings, list) or not isinstance(prefix, str):\n        raise ValueError(\"Invalid input: 'strings' must be a list and 'prefix' must be a string.\")\n    \n    # Normalize Case\n    prefix_lower = prefix.lower()\n    strings_lower = [s.lower() for s in strings]\n    \n    # Filter Strings\n    filtered_strings = [s for s, s_lower in zip(strings, strings_lower) if s_lower.startswith(prefix_lower)]\n    \n    # Return Result\n    return filtered_strings\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Handle empty input list\",\n      \"description\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"subproblem\": \"Iterate over input list\",\n      \"description\": \"Loop through each string in the input list to check if it starts with the given prefix.\"\n    },\n    {\n      \"subproblem\": \"Check prefix case insensitivity\",\n      \"description\": \"Ensure the comparison between the prefix and the strings is case insensitive.\"\n    },\n    {\n      \"subproblem\": \"Filter strings by prefix\",\n      \"description\": \"Collect strings that start with the given prefix into a new list.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Initialize result list\",\n      \"description\": \"Create an empty list to store strings that match the prefix criteria.\"\n    },\n    {\n      \"step\": \"Handle empty input list\",\n      \"description\": \"Check if the input list is empty and return the empty result list if true.\"\n    },\n    {\n      \"step\": \"Normalize prefix\",\n      \"description\": \"Convert the prefix to lowercase to ensure case insensitivity.\"\n    },\n    {\n      \"step\": \"Iterate and filter\",\n      \"description\": \"Loop through each string in the input list, convert it to lowercase, and check if it starts with the normalized prefix. If it does, add it to the result list.\"\n    },\n    {\n      \"step\": \"Return result\",\n      \"description\": \"Return the result list containing all strings that start with the given prefix.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Initialize result list\n    result = []\n    \n    # Handle empty input list\n    if not strings:\n        return result\n    \n    # Normalize prefix\n    normalized_prefix = prefix.lower()\n    \n    # Iterate and filter\n    for string in strings:\n        if string.lower().startswith(normalized_prefix):\n            result.append(string)\n    \n    # Return result\n    return result\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Handle empty input list\",\n      \"details\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"description\": \"Normalize case sensitivity\",\n      \"details\": \"Convert both the input list of strings and the prefix to lowercase to ensure case-insensitive comparison.\"\n    },\n    {\n      \"description\": \"Filter strings by prefix\",\n      \"details\": \"Iterate through the list of strings and select only those that start with the given prefix.\"\n    },\n    {\n      \"description\": \"Return the filtered list\",\n      \"details\": \"Collect and return the list of strings that match the prefix criteria.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Check if the input list is empty. If so, return an empty list.\",\n    \"Convert all strings in the input list to lowercase.\",\n    \"Convert the prefix to lowercase.\",\n    \"Iterate over the list of strings and check if each string starts with the given prefix.\",\n    \"Collect strings that match the prefix condition into a new list.\",\n    \"Return the new list containing strings that start with the given prefix.\"\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty. If so, return an empty list.\n    if not strings:\n        return []\n    \n    # Convert the prefix to lowercase.\n    prefix = prefix.lower()\n    \n    # Collect strings that match the prefix condition into a new list.\n    filtered_strings = [s for s in strings if s.lower().startswith(prefix)]\n    \n    # Return the new list containing strings that start with the given prefix.\n    return filtered_strings\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Handle empty input list\",\n      \"details\": \"Ensure the function returns an empty list when the input list is empty.\"\n    },\n    {\n      \"description\": \"Normalize case sensitivity\",\n      \"details\": \"Convert both the input list of strings and the prefix to lowercase to ensure case-insensitive comparison.\"\n    },\n    {\n      \"description\": \"Filter strings by prefix\",\n      \"details\": \"Iterate over the list of strings and select only those that start with the given prefix.\"\n    },\n    {\n      \"description\": \"Return the filtered list\",\n      \"details\": \"Compile the selected strings into a new list and return it as the output.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Check if the input list is empty. If so, return an empty list.\",\n    \"Convert all strings in the input list to lowercase.\",\n    \"Convert the prefix to lowercase.\",\n    \"Iterate over the list of strings and check if each string starts with the given prefix.\",\n    \"Collect strings that match the prefix condition into a new list.\",\n    \"Return the new list containing the filtered strings.\"\n  ]\n}\n```", "Round_0": {"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    # Check if the input list is empty. If so, return an empty list.\n    if not strings:\n        return []\n    \n    # Convert the prefix to lowercase.\n    prefix_lower = prefix.lower()\n    \n    # Collect strings that match the prefix condition into a new list.\n    filtered_strings = [\n        string for string in strings if string.lower().startswith(prefix_lower)\n    ]\n    \n    # Return the new list containing the filtered strings.\n    return filtered_strings\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [0.9911, 0.9911, 0.9911, 0.9911, 0.9911, 0.9911, 0.9911, 0.9911, 0.9911, 0.9911], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [111, 111, 111, 111, 111, 111, 111, 111, 111, 111], "passed": false, "pass": false, "pass_num": 10, "round": 304, "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 236}
