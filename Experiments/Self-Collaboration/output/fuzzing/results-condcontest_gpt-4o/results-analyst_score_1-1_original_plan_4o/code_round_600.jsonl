{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp possesses n problems that his students have not viewed yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, meaning no two tasks share the same topic and difficulty simultaneously. There is no instance where two tasks will have both the same topic and difficulty.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "completions": ["import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = comb(n, 3)\n        \n        same_topic_ways = 0\n        for count in topics.values():\n            if count >= 3:\n                same_topic_ways += comb(count, 3)\n        \n        same_difficulty_ways = 0\n        for count in difficulties.values():\n            if count >= 3:\n                same_difficulty_ways += comb(count, 3)\n        \n        invalid_ways = 0\n        for a, b in problems:\n            invalid_ways += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract the invalid combinations where the topic or difficulty is the same\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n, k):\n    if n < k:\n        return 0\n    if k == 3:\n        return n * (n - 1) * (n - 2) // 6\n    if k == 2:\n        return n * (n - 1) // 2\n    return 0\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        pairs = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            pairs[(a_i, b_i)] += 1\n        \n        total_ways = calculate_combinations(n, 3)\n        \n        topic_not_all_different = sum(calculate_combinations(c, 2) for c in topics.values())\n        difficulty_not_all_different = sum(calculate_combinations(d, 2) for d in difficulties.values())\n        both_not_all_different = sum(calculate_combinations(p, 2) for p in pairs.values())\n        \n        valid_ways = total_ways - topic_not_all_different - difficulty_not_all_different + both_not_all_different\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 2:\n                same_topic_ways += comb(count, 2) * (n - count)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 2:\n                same_difficulty_ways += comb(count, 2) * (n - count)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_topic_difficulty_ways = 0\n        for a_i, b_i in problems:\n            same_topic_difficulty_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Using inclusion-exclusion principle\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways + same_topic_difficulty_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing number of test cases and a list of problems for each test case\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Total number of ways to select any three problems\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all topics are different.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems with different topics\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all difficulties are different.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems with different difficulties\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems that do not satisfy either condition (same topic or same difficulty).\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems that do not satisfy either condition\"\n    },\n    {\n      \"description\": \"For each test case, compute the final result by subtracting the number of invalid selections from the total number of selections.\",\n      \"input\": \"Total number of selections, number of invalid selections\",\n      \"output\": \"Number of valid selections\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using combinatorial methods.\",\n    \"For each test case, calculate the number of ways to select three problems with different topics by grouping problems by topic and using combinatorial methods.\",\n    \"For each test case, calculate the number of ways to select three problems with different difficulties by grouping problems by difficulty and using combinatorial methods.\",\n    \"For each test case, calculate the number of invalid selections where neither condition is satisfied.\",\n    \"Subtract", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 90)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that satisfy the conditions for each test case.\",\n      \"steps\": [\n        \"For each test case, initialize a counter to keep track of the number of valid selections.\",\n        \"Iterate over all possible combinations of three problems from the list of n problems.\",\n        \"For each combination, check if the topics of the three problems are all different or if the difficulties are all different.\",\n        \"If either condition is satisfied, increment the counter.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the counter value which represents the number of valid selections.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, iterate over all combinations of three problems and check the conditions.\",\n    \"Count the number of valid combinations that satisfy at least one of the conditions.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that satisfy the conditions for each test case.\",\n      \"steps\": [\n        \"For each test case, generate all possible combinations of three problems from the list of n problems.\",\n        \"Check each combination to see if it satisfies at least one of the conditions: all topics are different or all difficulties are different.\",\n        \"Count the number of valid combinations for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the number of valid combinations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, iterate over all combinations of three problems.\",\n    \"Check if each combination satisfies the conditions of having different topics or different difficulties.\",\n    \"Count and store the number of valid combinations for each test case.\",\n    \"Output the count of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 93)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t from the first line, then for each test case, read the integer n followed by n pairs of integers representing topics and difficulties.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": \"Use combinatorial logic to calculate the number of combinations of three problems from n, which is C(n, 3) = n * (n-1) * (n-2) / 6.\"\n    },\n    {\n      \"description\": \"Calculate the number of invalid combinations where the topics or difficulties are not all different.\",\n      \"details\": \"For each test case, count the occurrences of each topic and difficulty. Use these counts to calculate the number of invalid combinations where topics or difficulties are not all different.\"\n    },\n    {\n      \"description\": \"Subtract the number of invalid combinations from the total combinations to get the valid combinations.\",\n      \"details\": \"Subtract the invalid combinations from the total combinations calculated in the previous steps to get the number of valid combinations.\"\n    },\n    {\n      \"description\": \"Output the number of valid combinations for each test case.\",\n      \"details\": \"Print the result for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of combinations of three problems.\",\n    \"Count the occurrences of each topic and difficulty to identify invalid combinations.\",\n    \"Calculate the number of invalid combinations based on topic and difficulty counts.\",\n    \"Subtract invalid combinations from total combinations to get valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t representing the number of test cases. For each test case, read the integer n representing the number of problems, followed by n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": \"Use combinatorial mathematics to calculate the number of combinations of n problems taken 3 at a time, which is given by nC3 = n! / (3! * (n-3)!).\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems with the same topic.\",\n      \"details\": \"Group problems by topic and count the number of problems in each group. For each group with at least 3 problems, calculate the number of combinations of 3 problems from the group.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems with the same difficulty.\",\n      \"details\": \"Group problems by difficulty and count the number of problems in each group. For each group with at least 3 problems, calculate the number of combinations of 3 problems from the group.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that do not satisfy either condition.\",\n      \"details\": \"Subtract the number of ways to select three problems with the same topic and the number of ways to select three problems with the same difficulty from the total number of ways to select three problems.\"\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": \"For each test case, output the number of ways to select three problems that satisfy at least one of the conditions.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems from n problems.\",\n    \"For each test case, calculate the number of ways to select three problems with the same topic.\",\n    \"For each test case, calculate the number of ways to select three problems with the same difficulty.\",\n    \"For each test case, calculate the number of ways to select three problems that do not satisfy", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = comb(n, 3)\n        \n        same_topic_ways = 0\n        for count in topics.values():\n            if count >= 3:\n                same_topic_ways += comb(count, 3)\n        \n        same_difficulty_ways = 0\n        for count in difficulties.values():\n            if count >= 3:\n                same_difficulty_ways += comb(count, 3)\n        \n        invalid_ways = 0\n        for a, b in problems:\n            invalid_ways += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: solve() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topics[a] += 1\n            difficulties[b] += 1\n        \n        total_ways = comb(n, 3)\n        \n        same_topic_ways = 0\n        for count in topics.values():\n            if count >= 3:\n                same_topic_ways += comb(count, 3)\n        \n        same_difficulty_ways = 0\n        for count in difficulties.values():\n            if count >= 3:\n                same_difficulty_ways += comb(count, 3)\n        \n        invalid_ways = 0\n        for a, b in problems:\n            invalid_ways += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n for the number of problems, followed by n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": \"Use combinatorial mathematics to calculate the number of combinations of n problems taken 3 at a time, which is given by C(n, 3) = n * (n - 1) * (n - 2) / 6.\"\n    },\n    {\n      \"description\": \"Calculate the number of invalid combinations where the topics or difficulties are not all different.\",\n      \"details\": \"Count the occurrences of each topic and each difficulty. For each topic, calculate the number of ways to select three problems with the same topic. Similarly, calculate the number of ways to select three problems with the same difficulty.\"\n    },\n    {\n      \"description\": \"Subtract the invalid combinations from the total combinations to get the valid combinations.\",\n      \"details\": \"Subtract the number of invalid combinations (same topic or same difficulty) from the total number of combinations to get the number of valid combinations.\"\n    },\n    {\n      \"description\": \"Output the number of valid combinations for each test case.\",\n      \"details\": \"For each test case, print the number of valid combinations calculated.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using combinatorial mathematics.\",\n    \"Count the occurrences of each topic and difficulty to determine invalid combinations.\",\n    \"Calculate the number of invalid combinations where topics or difficulties are not all different.\",\n    \"Subtract the invalid combinations from the total combinations to get the valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract the invalid combinations where the topic or difficulty is the same\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, which represent the topic and difficulty of the problem.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems that satisfy the conditions for each test case.\",\n      \"steps\": [\n        \"For each test case, generate all possible combinations of three problems from the list of n problems.\",\n        \"Check each combination to see if it satisfies at least one of the conditions: all topics are different or all difficulties are different.\",\n        \"Count the number of combinations that satisfy the conditions.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, print the number of valid combinations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, iterate over all combinations of three problems.\",\n    \"Check if each combination satisfies the conditions of having different topics or different difficulties.\",\n    \"Count and store the number of valid combinations for each test case.\",\n    \"Output the count for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 93)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integer n, the number of problems.\",\n        \"For each problem, read the integers a_i and b_i, representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from n problems.\",\n      \"steps\": [\n        \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where the topics are not all different.\",\n      \"steps\": [\n        \"Create a dictionary to count the occurrences of each topic.\",\n        \"For each topic with count c, calculate the number of ways to choose 2 problems with the same topic using C(c, 2) = c * (c - 1) / 2.\",\n        \"Sum these values for all topics to get the total number of ways where topics are not all different.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where the difficulties are not all different.\",\n      \"steps\": [\n        \"Create a dictionary to count the occurrences of each difficulty.\",\n        \"For each difficulty with count d, calculate the number of ways to choose 2 problems with the same difficulty using C(d, 2) = d * (d - 1) / 2.\",\n        \"Sum these values for all difficulties to get the total number of ways where difficulties are not all different.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are not all different.\",\n      \"steps\": [\n        \"Create a dictionary to count the occurrences of each (topic, difficulty) pair.\",\n        \"For each pair with count p, calculate the number of ways to choose 2 problems with the same pair using C(p, 2) = p * (p - 1) / 2.\",\n        \"Sum these values for all pairs to get the total number of ways where both topics and difficulties are not", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n, k):\n    if n < k:\n        return 0\n    if k == 3:\n        return n * (n - 1) * (n - 2) // 6\n    if k == 2:\n        return n * (n - 1) // 2\n    return 0\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        pairs = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            pairs[(a_i, b_i)] += 1\n        \n        total_ways = calculate_combinations(n, 3)\n        \n        topic_not_all_different = sum(calculate_combinations(c, 2) for c in topics.values())\n        difficulty_not_all_different = sum(calculate_combinations(d, 2) for d in difficulties.values())\n        both_not_all_different = sum(calculate_combinations(p, 2) for p in pairs.values())\n        \n        valid_ways = total_ways - topic_not_all_different - difficulty_not_all_different + both_not_all_different\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 98)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n, k):\n    if n < k:\n        return 0\n    if k == 3:\n        return n * (n - 1) * (n - 2) // 6\n    if k == 2:\n        return n * (n - 1) // 2\n    return 0\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        pairs = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            pairs[(a_i, b_i)] += 1\n        \n        total_ways = calculate_combinations(n, 3)\n        \n        topic_not_all_different = sum(calculate_combinations(c, 2) for c in topics.values())\n        difficulty_not_all_different = sum(calculate_combinations(d, 2) for d in difficulties.values())\n        both_not_all_different = sum(calculate_combinations(p, 2) for p in pairs.values())\n        \n        valid_ways = total_ways - topic_not_all_different - difficulty_not_all_different + both_not_all_different\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing number of test cases and a list of problems for each test case\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Total number of ways to select any three problems\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different topics.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems with different topics\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have different difficulties.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems with different difficulties\"\n    },\n    {\n      \"description\": \"Combine the results from the previous subproblems to determine the number of valid problem sets for each test case.\",\n      \"input\": \"Results from subproblems 2, 3, and 4\",\n      \"output\": \"Number of valid problem sets for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using combinatorial methods.\",\n    \"For each test case, calculate the number of ways to select three problems with different topics by iterating over the list and using a frequency map to count occurrences of each topic.\",\n    \"For each test case, calculate the number of ways to select three problems with different difficulties by iterating over the list and using a frequency map to count occurrences of each difficulty.\",\n    \"For each test case, use the inclusion-exclusion principle to combine the results from the previous steps to find the number of valid problem sets that satisfy at least one of the conditions.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 2:\n                same_topic_ways += comb(count, 2) * (n - count)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 2:\n                same_difficulty_ways += comb(count, 2) * (n - count)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_topic_difficulty_ways = 0\n        for a_i, b_i in problems:\n            same_topic_difficulty_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Using inclusion-exclusion principle\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways + same_topic_difficulty_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 102)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose any 3 problems\n        total_ways = comb(n, 3)\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 2:\n                same_topic_ways += comb(count, 2) * (n - count)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 2:\n                same_difficulty_ways += comb(count, 2) * (n - count)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_topic_difficulty_ways = 0\n        for a_i, b_i in problems:\n            same_topic_difficulty_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        # Using inclusion-exclusion principle\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways + same_topic_difficulty_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t representing the number of test cases. For each test case, read the integer n representing the number of problems, followed by n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select three problems from n problems.\",\n      \"details\": \"Use combinatorial mathematics to calculate the number of ways to choose 3 problems from n, which is given by the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6.\"\n    },\n    {\n      \"description\": \"Calculate the number of invalid selections where the topics or difficulties are not all different.\",\n      \"details\": \"For each test case, count the occurrences of each topic and each difficulty. Use these counts to calculate the number of invalid selections where the topics or difficulties are not all different.\"\n    },\n    {\n      \"description\": \"Subtract the number of invalid selections from the total number of selections to get the number of valid selections.\",\n      \"details\": \"Subtract the number of invalid selections from the total number of ways to select three problems to get the number of valid selections that meet the requirements.\"\n    },\n    {\n      \"description\": \"Output the number of valid selections for each test case.\",\n      \"details\": \"Print the result for each test case, which is the number of valid selections calculated in the previous step.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select three problems using the combination formula.\",\n    \"For each test case, count the occurrences of each topic and difficulty.\",\n    \"Calculate the number of invalid selections where the topics or difficulties are not all different.\",\n    \"Subtract the number of invalid selections from the total number of selections to get the number of valid selections.\",\n    \"Output the number of valid selections for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef calculate_combinations(n):\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            problems.append((a_i, b_i))\n            topics[a_i] += 1\n            difficulties[b_i] += 1\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing number of test cases and a list of problems for each test case\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given n problems.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Total number of ways to select any three problems\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all topics are different.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems with different topics\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all difficulties are different.\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems with different difficulties\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems that do not satisfy either condition (same topic or same difficulty).\",\n      \"input\": \"List of problems for a test case\",\n      \"output\": \"Number of ways to select three problems that do not satisfy either condition\"\n    },\n    {\n      \"description\": \"For each test case, compute the final result by subtracting the number of invalid selections from the total number of selections.\",\n      \"input\": \"Total number of selections, number of invalid selections\",\n      \"output\": \"Number of valid selections\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using combinatorial methods.\",\n    \"For each test case, calculate the number of ways to select three problems with different topics by grouping problems by topic and using combinatorial methods.\",\n    \"For each test case, calculate the number of ways to select three problems with different difficulties by grouping problems by difficulty and using combinatorial methods.\",\n    \"For each test case, calculate the number of invalid selections where neither condition is satisfied.\",\n    \"Subtract", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 90)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_ways = comb(n, 3)\n        \n        invalid_ways = 0\n        for a_i, b_i in problems:\n            invalid_ways += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n"}}], "scores": [], "pass_results": [false, true, false, false, true, true, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 600, "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp possesses n problems that his students have not viewed yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, meaning no two tasks share the same topic and difficulty simultaneously. There is no instance where two tasks will have both the same topic and difficulty.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "expand_one2two", "save_node": false, "parent_index": 306}
