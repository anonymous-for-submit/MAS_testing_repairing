{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "repair_prompt": ["CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks, and each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Assume that both n and m are always greater than or equal to 5.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current = grid[start_row + x][start_col + y]\n                                \n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    if current == '0':\n                                        operations += 1\n                                else:\n                                    # Inside should be empty\n                                    if current == '1':\n                                        operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Calculate operations needed for current sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                    # Corners can be any type, no operation needed\n                                    continue\n                                elif x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border blocks must be obsidian (1)\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Calculate operations needed for current sub-rectangle\n                        for x in range(start_row, start_row + a):\n                            for y in range(start_col, start_col + b):\n                                if (x == start_row or x == start_row + a - 1) and (y == start_col or y == start_col + b - 1):\n                                    # Corners can be any type, no operation needed\n                                    continue\n                                elif x == start_row or x == start_row + a - 1:\n                                    # Top and bottom borders\n                                    if grid[x][y] == '0':\n                                        operations += 1\n                                elif y == start_col or y == start_col + b - 1:\n                                    # Left and right borders\n                                    if grid[x][y] == '0':\n                                        operations += 1\n                                else:\n                                    # Interior should be empty\n                                    if grid[x][y] == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        \n                        # Top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                operations += 1\n                        \n                        # Inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check if it's a border block\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type, skip\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        \n                        # Check the top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                operations += 1\n                        \n                        # Check the left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                operations += 1\n                        \n                        # Check the inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                operations += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                operations += 1\n                        \n                        # Check inner conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type, skip\n                                        continue\n                                    if (x == 0 or x == a - 1) or (y == 0 or y == b - 1):\n                                        # Should be obsidian\n                                        if grid[start_row + x][start_col + y] == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty\n                                    if grid[start_row + x][start_col + y] == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current = grid[start_row + x][start_col + y]\n                                \n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    if current == '0':\n                                        operations += 1\n                                else:\n                                    # Inside should be empty\n                                    if current == '1':\n                                        operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid representation of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the n \u00d7 m grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the n \u00d7 m grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks as per the portal definition.\",\n        \"Count the number of changes needed to satisfy the portal conditions for each sub-rectangle.\",\n        \"Track the minimum number of operations required across all sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"steps\": [\n        \"For each test case, after evaluating all possible sub-rectangles, output the minimum number of operations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m grid.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and output the minimum number of operations required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current = grid[start_row + x][start_col + y]\n                                \n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    if current == '0':\n                                        operations += 1\n                                else:\n                                    # Inside should be empty\n                                    if current == '1':\n                                        operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"details\": \"Read the input data and store it in a structured format for easy access during processing.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and ensure the dimensions meet the minimum requirements (a \u2265 5, b \u2265 4).\"\n    },\n    {\n      \"description\": \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n      \"details\": \"Check each block in the sub-rectangle against the portal conditions and count the number of changes required.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all possible sub-rectangles for each test case.\",\n      \"details\": \"Compare the operation counts for all sub-rectangles and select the smallest value.\"\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"details\": \"Format the results according to the specified output requirements.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases, dimensions, and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m grid.\",\n    \"For each sub-rectangle, evaluate the number of operations needed to convert it into a portal by checking each block against the portal conditions.\",\n    \"Track the minimum number of operations required to form a portal for each test case.\",\n    \"Output the minimum number of operations for each test case in the specified format.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Calculate operations needed for current sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                    # Corners can be any type, no operation needed\n                                    continue\n                                elif x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border blocks must be obsidian (1)\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m grid that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the n \u00d7 m grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks as specified.\",\n        \"Count the number of changes needed to satisfy the portal conditions.\",\n        \"Track the minimum number of operations required across all sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"steps\": [\n        \"Store the minimum operations for each test case.\",\n        \"Print the result for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and output the minimum number of operations required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type, no operation needed\n                                        continue\n                                    else:\n                                        # Border should be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Track the minimum number of operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read integers n and m, representing the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters (0 or 1), to form the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the n \u00d7 m grid.\",\n        \"For each top-left corner, check if a sub-rectangle of size a \u00d7 b can be formed.\",\n        \"Ensure that a \u2265 5 and b \u2265 4 for each sub-rectangle considered.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, count the number of blocks that need to be changed to satisfy portal conditions.\",\n        \"Ensure the borders (except corners) are obsidian blocks and the interior is empty blocks.\",\n        \"Calculate the total number of changes required for each sub-rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all sub-rectangles for each test case.\",\n      \"steps\": [\n        \"Compare the number of operations required for each sub-rectangle within a test case.\",\n        \"Select the minimum number of operations needed to transform at least one sub-rectangle into a portal.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"Print the minimum number of operations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test cases and grid configurations.\",\n    \"For each test case, iterate over possible sub-rectangles of size a \u00d7 b.\",\n    \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n    \"Determine the minimum number of operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        \n                        # Calculate operations needed for current sub-rectangle\n                        for x in range(start_row, start_row + a):\n                            for y in range(start_col, start_col + b):\n                                if (x == start_row or x == start_row + a - 1) and (y == start_col or y == start_col + b - 1):\n                                    # Corners can be any type, no operation needed\n                                    continue\n                                elif x == start_row or x == start_row + a - 1:\n                                    # Top and bottom borders\n                                    if grid[x][y] == '0':\n                                        operations += 1\n                                elif y == start_col or y == start_col + b - 1:\n                                    # Left and right borders\n                                    if grid[x][y] == '0':\n                                        operations += 1\n                                else:\n                                    # Interior should be empty\n                                    if grid[x][y] == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"For each sub-rectangle, verify the conditions for being a portal and calculate the number of operations needed to transform it.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum number of operations needed for transformation.\",\n      \"details\": \"Track the minimum number of operations across all possible sub-rectangles to find the optimal solution.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input data.\",\n      \"details\": \"Read the number of test cases, dimensions of each rectangle, and the block data for each test case.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a \u00d7 b.\",\n      \"details\": \"For each possible top-left corner, generate sub-rectangles and check if they can be transformed into a portal.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal conditions.\",\n      \"details\": \"Check the border conditions and count the number of operations needed to transform the sub-rectangle into a portal.\"\n    },\n    {\n      \"step\": \"Track the minimum operations needed.\",\n      \"details\": \"Keep a record of the minimum operations required for each test case.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        \n                        # Top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                operations += 1\n                        \n                        # Inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid representation of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b that can be potential portals.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to transform each sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each candidate sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions for the border and inner blocks.\",\n        \"Consider the corners separately as they can be any type.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum number of operations across all candidate sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that can be transformed into a portal.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and store the minimum number of operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check if it's a border block\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and (y == 0 or y == b - 1)) or (x == a - 1 and (y == 0 or y == b - 1)):\n                                        # Corners can be any type, skip\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b that can be potential portals.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure the sub-rectangle fits within the bounds of the grid.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each candidate sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions.\",\n        \"Consider the flexibility of corner blocks which can be any type.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimum number of operations required for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum operations needed across all candidate sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that could be portals.\",\n    \"For each sub-rectangle, calculate the number of operations needed to convert it into a portal.\",\n    \"Track the minimum number of operations needed for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = grid[start_row + x][start_col + y]\n                                \n                                # Check the border conditions\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Border blocks must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"For each sub-rectangle, verify the conditions for being a portal and calculate the number of operations needed to transform it.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum number of operations needed for transformation.\",\n      \"details\": \"Track the minimum number of operations across all possible sub-rectangles to find the optimal solution.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse input data.\",\n      \"details\": \"Read the number of test cases, dimensions of the rectangle, and the block configuration for each test case.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, process the rectangle to find the minimum operations needed.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a \u00d7 b.\",\n      \"details\": \"For each possible top-left corner, generate sub-rectangles and check if they can be transformed into a portal.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal conditions.\",\n      \"details\": \"Check the border conditions and count the number of operations needed to satisfy portal requirements.\"\n    },\n    {\n      \"step\": \"Track the minimum operations for each test case.\",\n      \"details\": \"Store the minimum number of operations needed for each test case and prepare the output.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the minimum number of operations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate operations needed to transform this sub-rectangle into a portal\n                        operations = 0\n                        \n                        # Check the top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                operations += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                operations += 1\n                        \n                        # Check the left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                operations += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                operations += 1\n                        \n                        # Check the inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid representation of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m grid that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the n \u00d7 m grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks as per the portal definition.\",\n        \"Count the number of changes needed to satisfy the portal conditions for each sub-rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required across all possible sub-rectangles for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum number of operations needed to transform any sub-rectangle into a portal.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the grid.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                operations += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                operations += 1\n                        \n                        # Check inner conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    operations += 1\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the integers n and m.\",\n        \"For each test case, read the n lines of m characters representing the grid.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b that can be potential portals.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure the sub-rectangle fits within the bounds of the grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations needed to convert a sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each identified sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of changes needed to satisfy the portal conditions.\",\n        \"Consider the corners separately as they can be any type.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"steps\": [\n        \"For each test case, track the minimum number of operations across all potential portals.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of operations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles that could be portals.\",\n    \"For each sub-rectangle, calculate the number of operations needed to convert it into a portal.\",\n    \"Track the minimum number of operations needed for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type, skip\n                                        continue\n                                    if (x == 0 or x == a - 1) or (y == 0 or y == b - 1):\n                                        # Should be obsidian\n                                        if grid[start_row + x][start_col + y] == '0':\n                                            operations += 1\n                                else:\n                                    # Inside should be empty\n                                    if grid[start_row + x][start_col + y] == '1':\n                                        operations += 1\n                        \n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the grid configuration for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the grid representation of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the n \u00d7 m grid.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b where a \u2265 5 and b \u2265 4.\",\n        \"Ensure that the sub-rectangle fits within the bounds of the n \u00d7 m grid.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of operations required to transform each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks as per the portal definition.\",\n        \"Count the number of changes needed to satisfy the portal conditions for each sub-rectangle.\",\n        \"Track the minimum number of operations required across all sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of operations for each test case.\",\n      \"steps\": [\n        \"For each test case, after evaluating all possible sub-rectangles, output the minimum number of operations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m grid.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track and output the minimum number of operations required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to make this sub-rectangle a portal\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            for y in range(b):\n                                current = grid[start_row + x][start_col + y]\n                                \n                                if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                                    # Border conditions\n                                    if (x == 0 or x == a - 1) and (y == 0 or y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    if current == '0':\n                                        operations += 1\n                                else:\n                                    # Inside should be empty\n                                    if current == '1':\n                                        operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 162, "prompt": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks, and each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. Assume that both n and m are always greater than or equal to 5.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 123}
