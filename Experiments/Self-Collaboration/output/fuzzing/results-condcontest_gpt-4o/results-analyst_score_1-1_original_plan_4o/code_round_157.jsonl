{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["On the great island of Baltia, there live N individuals, numbered from 1 to N. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list for friendships\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = [set(range(1, N + 1)) - friends[i] - {i} for i in range(N + 1)]\n        for a in range(1, N + 1):\n            for b in non_friends[a]:\n                if b <= a:\n                    continue\n                for c in non_friends[a].intersection(non_friends[b]):\n                    if c <= b:\n                        continue\n                    for d in non_friends[a].intersection(non_friends[b], non_friends[c]):\n                        if d <= c:\n                            continue\n                        for e in non_friends[a].intersection(non_friends[b], non_friends[c], non_friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if\nmain()", "completions": ["import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.append((U, V))\n        index += 2\n    \n    # Create an adjacency list for friendships\n    friends = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combo[j] in friends[combo[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all possible combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check for a successful party where all 5 individuals are friends with each other\n    for combo in combinations(range(1, N + 1), 5):\n        if all((combo[i], combo[j]) in friendships for i in range(5) for j in range(i + 1, 5)):\n            print(' '.join(map(str, combo)))\n            return\n    \n    # Check for a successful party where no two individuals are friends with each other\n    for combo in combinations(range(1, N + 1), 5):\n        if all((combo[i], combo[j]) not in friendships for i in range(5) for j in range(i + 1, 5)):\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all possible combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list representation of the graph\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friends[U].add(V)\n        friends[V].add(U)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                # Check if there is a clique of size 5 including this person\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set():\n        # Try to find 5 people with no connections\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friends[person]) < N - 1:\n                non_friends -= friends[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    # Check for either a clique or an independent set of size 5\n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list for friendships\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = [set(range(1, N + 1)) - friends[i] - {i} for i in range(N + 1)]\n        for a in range(1, N + 1):\n            for b in non_friends[a]:\n                if b <= a:\n                    continue\n                for c in non_friends[a].intersection(non_friends[b]):\n                    if c <= b:\n                        continue\n                    for d in non_friends[a].intersection(non_friends[b], non_friends[c]):\n                        if d <= c:\n                            continue\n                        for e in non_friends[a].intersection(non_friends[b], non_friends[c], non_friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendships.\",\n      \"details\": \"Read the first line to get N and M. Then read the next M lines to get pairs of friends.\"\n    },\n    {\n      \"description\": \"Represent the friendships in a suitable data structure.\",\n      \"details\": \"Use an adjacency list or adjacency matrix to represent the friendships between individuals.\"\n    },\n    {\n      \"description\": \"Check for a successful party where all 5 individuals are friends with each other.\",\n      \"details\": \"Find a complete subgraph (clique) of size 5 in the friendship graph.\"\n    },\n    {\n      \"description\": \"Check for a successful party where no two individuals are friends with each other.\",\n      \"details\": \"Find an independent set of size 5 in the friendship graph.\"\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"details\": \"If a successful party is found, output the 5 individuals. Otherwise, output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"Represent the friendships using an adjacency list or matrix.\",\n    \"Implement a function to find a clique of size 5 in the graph.\",\n    \"Implement a function to find an independent set of size 5 in the graph.\",\n    \"Check if either a clique or an independent set of size 5 exists.\",\n    \"Output the 5 individuals if a successful party is possible, otherwise output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list for friendships\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = [set(range(1, N + 1)) - friends[i] - {i} for i in range(N + 1)]\n        for a in range(1, N + 1):\n            for b in non_friends[a]:\n                if b <= a:\n                    continue\n                for c in non_friends[a].intersection(non_friends[b]):\n                    if c <= b:\n                        continue\n                    for d in non_friends[a].intersection(non_friends[b], non_friends[c]):\n                        if d <= c:\n                            continue\n                        for e in non_friends[a].intersection(non_friends[b], non_friends[c], non_friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 67)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list for friendships\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = [set(range(1, N + 1)) - friends[i] - {i} for i in range(N + 1)]\n        for a in range(1, N + 1):\n            for b in non_friends[a]:\n                if b <= a:\n                    continue\n                for c in non_friends[a].intersection(non_friends[b]):\n                    if c <= b:\n                        continue\n                    for d in non_friends[a].intersection(non_friends[b], non_friends[c]):\n                        if d <= c:\n                            continue\n                        for e in non_friends[a].intersection(non_friends[b], non_friends[c], non_friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendships.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendships, such as an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph representation of friendships among individuals.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if they are all friends with each other or if none of them are friends with each other.\",\n      \"output\": \"A boolean indicating whether a given 5-person combination is a successful party.\"\n    },\n    {\n      \"description\": \"Determine if there is at least one successful party combination.\",\n      \"output\": \"A list of 5 individuals if a successful party is possible, or -1 if not.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph representation of the friendships using an adjacency list.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if all individuals are friends with each other or if none are friends with each other using the graph.\",\n    \"If a successful party is found, print the combination of 5 individuals. If no such combination exists, print -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.append((U, V))\n        index += 2\n    \n    # Create an adjacency list for friendships\n    friends = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if combo[j] in friends[combo[i]]:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendships.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendship relationships between individuals.\",\n      \"output\": \"An adjacency list or matrix representing friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all individuals are friends with each other or if no two individuals are friends with each other.\",\n      \"output\": \"A boolean indicating whether the combination is a successful party.\"\n    },\n    {\n      \"description\": \"Determine if there is at least one successful party combination.\",\n      \"output\": \"The indices of a successful party combination or -1 if none exist.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"Represent the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it satisfies the conditions of a successful party (either all friends or no friends).\",\n    \"If a successful party is found, output the indices of the individuals in the party. If no successful party is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all possible combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendships.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get pairs of friends (U_i, V_i).\"\n      ]\n    },\n    {\n      \"description\": \"Represent the friendships in a suitable data structure.\",\n      \"steps\": [\n        \"Use an adjacency list or adjacency matrix to represent the friendships between individuals.\"\n      ]\n    },\n    {\n      \"description\": \"Check for a successful party where all 5 individuals are friends with each other.\",\n      \"steps\": [\n        \"Iterate over all combinations of 5 individuals.\",\n        \"For each combination, check if all pairs within the combination are friends using the data structure.\"\n      ]\n    },\n    {\n      \"description\": \"Check for a successful party where no two individuals are friends with each other.\",\n      \"steps\": [\n        \"Iterate over all combinations of 5 individuals.\",\n        \"For each combination, check if no pairs within the combination are friends using the data structure.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the checks.\",\n      \"steps\": [\n        \"If a successful party is found in either check, print the 5 individuals.\",\n        \"If no successful party is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"Represent the friendships using an adjacency list or matrix.\",\n    \"Iterate over all combinations of 5 individuals to check for a successful party.\",\n    \"Check if all individuals in a combination are friends or if none are friends.\",\n    \"Output the result based on the checks.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check for a successful party where all 5 individuals are friends with each other\n    for combo in combinations(range(1, N + 1), 5):\n        if all((combo[i], combo[j]) in friendships for i in range(5) for j in range(i + 1, 5)):\n            print(' '.join(map(str, combo)))\n            return\n    \n    # Check for a successful party where no two individuals are friends with each other\n    for combo in combinations(range(1, N + 1), 5):\n        if all((combo[i], combo[j]) not in friendships for i in range(5) for j in range(i + 1, 5)):\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendships.\",\n      \"output\": \"A list of friendships and the total number of individuals.\"\n    },\n    {\n      \"description\": \"Represent the friendships in a suitable data structure, such as an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph representation of friendships among individuals.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the total N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each combination of 5 individuals, check if they are all friends with each other or if none of them are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party can be formed with the current combination.\"\n    },\n    {\n      \"description\": \"Determine if any combination of 5 individuals satisfies the successful party condition.\",\n      \"output\": \"The indices of 5 individuals that form a successful party or -1 if no such combination exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Create a graph representation of the friendships using an adjacency list.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if all individuals are friends with each other or if none are friends with each other.\",\n    \"If a successful party is found, output the indices of the 5 individuals. If no successful party is found after checking all combinations, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all possible combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendships.\",\n      \"output\": \"A list of friendships and the total number of individuals.\"\n    },\n    {\n      \"description\": \"Represent the friendships in a suitable data structure, such as an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph representation of the friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the total N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all individuals are friends with each other or if no two individuals are friends with each other.\",\n      \"output\": \"A boolean indicating whether a successful party can be formed with the current combination.\"\n    },\n    {\n      \"description\": \"If a successful party is found, output the combination. If no successful party is found after checking all combinations, output -1.\",\n      \"output\": \"The indices of the 5 individuals forming a successful party or -1 if no such party exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Create a graph representation of the friendships using an adjacency list.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the indices of the 5 individuals. If no successful party is found, print -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendships.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendships, such as an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph representation of friendships among individuals.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the total N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if they are all friends with each other or if none of them are friends with each other.\",\n      \"output\": \"A boolean indicating whether a given 5-person combination is a successful party.\"\n    },\n    {\n      \"description\": \"Determine if there exists at least one successful party from the list of combinations.\",\n      \"output\": \"A list of 5 individuals that form a successful party or -1 if no such party exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Construct a graph representation of the friendships using an adjacency list.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the combination. If no successful party is found after checking all combinations, print -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendships.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendship relationships between individuals.\",\n      \"output\": \"An adjacency list or matrix representing the friendships.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if all individuals are friends with each other or if no two individuals are friends with each other.\",\n      \"output\": \"A boolean indicating whether the combination is a successful party.\"\n    },\n    {\n      \"description\": \"Determine if there is at least one successful party combination.\",\n      \"output\": \"A list of 5 individuals if a successful party is possible, otherwise -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Represent the friendships using an adjacency list or matrix.\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it satisfies the conditions of a successful party (either all are friends or none are friends).\",\n    \"If a successful party is found, output the combination. If no successful party is found after checking all combinations, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 53)"}, "Round_1": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 individuals\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendships.\",\n      \"details\": \"Read the first line to get N and M. Then read the next M lines to get pairs of friends.\"\n    },\n    {\n      \"description\": \"Represent the friendships in a suitable data structure.\",\n      \"details\": \"Use an adjacency list or adjacency matrix to represent the friendships between individuals.\"\n    },\n    {\n      \"description\": \"Check for a successful party where all 5 individuals are friends with each other.\",\n      \"details\": \"Find a complete subgraph (clique) of size 5 in the friendship graph.\"\n    },\n    {\n      \"description\": \"Check for a successful party where no two individuals are friends with each other.\",\n      \"details\": \"Find an independent set of size 5 in the friendship graph.\"\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"details\": \"If a successful party is found, output the 5 individuals. Otherwise, output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"Represent the friendships using an adjacency list or matrix.\",\n    \"Implement a function to find a clique of size 5 in the graph.\",\n    \"Implement a function to find an independent set of size 5 in the graph.\",\n    \"Check for either a clique or an independent set of size 5.\",\n    \"Output the 5 individuals if a successful party is possible, otherwise output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list representation of the graph\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friends[U].add(V)\n        friends[V].add(U)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                # Check if there is a clique of size 5 including this person\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set():\n        # Try to find 5 people with no connections\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friends[person]) < N - 1:\n                non_friends -= friends[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    # Check for either a clique or an independent set of size 5\n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), the number of friendships (M), and the list of friendships.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Create a data structure to represent the friendships, such as an adjacency list or adjacency matrix.\",\n      \"output\": \"A graph representation of friendships among individuals.\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 individuals from the N individuals.\",\n      \"output\": \"A list of all possible 5-person combinations.\"\n    },\n    {\n      \"description\": \"For each 5-person combination, check if they are all friends with each other or if none of them are friends with each other.\",\n      \"output\": \"A boolean indicating whether a given 5-person combination is a successful party.\"\n    },\n    {\n      \"description\": \"Determine if there is at least one successful party among all combinations.\",\n      \"output\": \"The indices of a successful party or -1 if no successful party exists.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input to get N, M, and the list of friendships.\",\n    \"Represent the friendships using an appropriate data structure (e.g., adjacency list).\",\n    \"Generate all possible combinations of 5 individuals from the N individuals.\",\n    \"For each combination, check if it forms a successful party by verifying the friendship conditions.\",\n    \"If a successful party is found, print the indices of the individuals in the party. If no successful party is found, print -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Check all combinations of 5 people\n    for combo in combinations(range(1, N + 1), 5):\n        all_friends = True\n        no_friends = True\n        \n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of individuals (N), number of friendships (M), and the list of friendships.\",\n      \"details\": \"Read the first line to get N and M. Then read the next M lines to get pairs of friends.\"\n    },\n    {\n      \"description\": \"Represent the friendships in a suitable data structure.\",\n      \"details\": \"Use an adjacency list or adjacency matrix to represent the friendships between individuals.\"\n    },\n    {\n      \"description\": \"Check for a successful party where all 5 individuals are friends with each other.\",\n      \"details\": \"Find a complete subgraph (clique) of size 5 in the friendship graph.\"\n    },\n    {\n      \"description\": \"Check for a successful party where no two individuals are friends with each other.\",\n      \"details\": \"Find an independent set of size 5 in the friendship graph.\"\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"details\": \"If a successful party is found, output the 5 individuals. Otherwise, output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"Represent the friendships using an adjacency list or matrix.\",\n    \"Implement a function to find a clique of size 5 in the graph.\",\n    \"Implement a function to find an independent set of size 5 in the graph.\",\n    \"Check if either a clique or an independent set of size 5 exists.\",\n    \"Output the 5 individuals if a successful party is possible, otherwise output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list for friendships\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = [set(range(1, N + 1)) - friends[i] - {i} for i in range(N + 1)]\n        for a in range(1, N + 1):\n            for b in non_friends[a]:\n                if b <= a:\n                    continue\n                for c in non_friends[a].intersection(non_friends[b]):\n                    if c <= b:\n                        continue\n                    for d in non_friends[a].intersection(non_friends[b], non_friends[c]):\n                        if d <= c:\n                            continue\n                        for e in non_friends[a].intersection(non_friends[b], non_friends[c], non_friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 67)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    from collections import defaultdict\n    \n    # Adjacency list for friendships\n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Function to find a clique of size 5\n    def find_clique_of_size_5():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                if b <= a:\n                    continue\n                for c in friends[a].intersection(friends[b]):\n                    if c <= b:\n                        continue\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        if d <= c:\n                            continue\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = [set(range(1, N + 1)) - friends[i] - {i} for i in range(N + 1)]\n        for a in range(1, N + 1):\n            for b in non_friends[a]:\n                if b <= a:\n                    continue\n                for c in non_friends[a].intersection(non_friends[b]):\n                    if c <= b:\n                        continue\n                    for d in non_friends[a].intersection(non_friends[b], non_friends[c]):\n                        if d <= c:\n                            continue\n                        for e in non_friends[a].intersection(non_friends[b], non_friends[c], non_friends[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Check for an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if"}}], "scores": [], "pass_results": [false, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 157, "prompt": "On the great island of Baltia, there live N individuals, numbered from 1 to N. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "condense_two2one", "save_node": true, "parent_index": 69}
