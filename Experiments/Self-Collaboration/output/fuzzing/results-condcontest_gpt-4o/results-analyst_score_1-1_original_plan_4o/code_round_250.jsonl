{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        pair_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            if (a, b) not in pair_count:\n                pair_count[(a, b)] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            pair_count[(a, b)] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Subtract invalid ways where all topics are the same\n        invalid_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Subtract invalid ways where all difficulties are the same\n        invalid_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Add back over-subtracted ways where both topics and difficulties are the same\n        over_subtracted_ways = 0\n        for count in pair_count.values():\n            if count >= 3:\n                over_subtracted_ways += count * (count - 1) * (count - 2) // 6\n        \n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways + over_subtracted_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i in topic_count:\n                topic_count[a_i] += 1\n            else:\n                topic_count[a_i] = 1\n            \n            if b_i in difficulty_count:\n                difficulty_count[b_i] += 1\n            else:\n                difficulty_count[b_i] = 1\n        \n        # Total ways to choose 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract combinations where all three have the same topic\n            if topic_count[a_i] >= 2:\n                invalid_combinations += (topic_count[a_i] - 1) * (n - topic_count[a_i])\n            \n            # Subtract combinations where all three have the same difficulty\n            if difficulty_count[b_i] >= 2:\n                invalid_combinations += (difficulty_count[b_i] - 1) * (n - difficulty_count[b_i])\n        \n        # Each invalid combination is counted twice, so divide by 2\n        invalid_combinations //= 2\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "import sys\nfrom collections import defaultdict\n\ndef combination_3(x):\n    if x < 3:\n        return 0\n    return x * (x - 1) * (x - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            problems.append((a_i, b_i))\n        \n        total_combinations = combination_3(n)\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n\nmain()", "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_same_topic = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_same_topic += comb(count, 3)\n        \n        invalid_same_difficulty = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_same_difficulty += comb(count, 3)\n        \n        invalid_same_topic_and_difficulty = 0\n        for a_i, b_i in problems:\n            if topic_count[a_i] > 1 and difficulty_count[b_i] > 1:\n                invalid_same_topic_and_difficulty += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_same_topic - invalid_same_difficulty + invalid_same_topic_and_difficulty\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Invalid combinations where all topics are the same\n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_combinations += count * (count - 1) * (count - 2) // 6\n        \n        # Invalid combinations where all difficulties are the same\n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_combinations += count * (count - 1) * (count - 2) // 6\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid sets\n        invalid_ways = 0\n        \n        for a, b in problems:\n            # Ways to choose 2 problems with the same topic and 1 with a different topic\n            invalid_ways += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        # Valid ways are total ways minus invalid ways\n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = {}\n        difficulties = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            \n            problems.append((a, b))\n            \n            if a not in topics:\n                topics[a] = 0\n            if b not in difficulties:\n                difficulties[b] = 0\n            \n            topics[a] += 1\n            difficulties[b] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a, b in problems:\n            # Subtract invalid combinations where all three have the same topic or difficulty\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def calculate_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = {}\n        difficulty_count = {}\n        pair_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            if (a, b) not in pair_count:\n                pair_count[(a, b)] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            pair_count[(a, b)] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 2:\n                same_topic_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 2:\n                same_difficulty_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_pair_ways = 0\n        for count in pair_count.values():\n            if count >= 2:\n                same_pair_ways += count * (count - 1) // 2\n        \n        # Valid ways\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways + same_pair_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n# This function will read from standard input and output the results\ncalculate_ways()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        pair_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            if (a, b) not in pair_count:\n                pair_count[(a, b)] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            pair_count[(a, b)] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Subtract invalid ways where all topics are the same\n        invalid_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Subtract invalid ways where all difficulties are the same\n        invalid_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Add back over-subtracted ways where both topics and difficulties are the same\n        over_subtracted_ways = 0\n        for count in pair_count.values():\n            if count >= 3:\n                over_subtracted_ways += count * (count - 1) * (count - 2) // 6\n        \n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways + over_subtracted_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the given n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"For each unique topic, count the number of problems with that topic. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same topic.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"For each unique difficulty, count the number of problems with that difficulty. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are not different.\",\n      \"details\": \"For each pair of topic and difficulty, count the number of problems with that specific pair. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same topic and difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid ways to select three problems that meet at least one of the conditions.\",\n      \"details\": \"Subtract the invalid combinations (where all topics or all difficulties are the same) from the total combinations. Add back the over-subtracted cases where both topics and difficulties are the same.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"For each test case, calculate the number of invalid combinations where all topics are the same", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        pair_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            if (a, b) not in pair_count:\n                pair_count[(a, b)] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            pair_count[(a, b)] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Subtract invalid ways where all topics are the same\n        invalid_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Subtract invalid ways where all difficulties are the same\n        invalid_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Add back over-subtracted ways where both topics and difficulties are the same\n        over_subtracted_ways = 0\n        for count in pair_count.values():\n            if count >= 3:\n                over_subtracted_ways += count * (count - 1) * (count - 2) // 6\n        \n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways + over_subtracted_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"For each topic, count the number of problems with that topic. Use these counts to calculate the number of invalid combinations where all three problems have the same topic.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"For each difficulty, count the number of problems with that difficulty. Use these counts to calculate the number of invalid combinations where all three problems have the same difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations for each test case.\",\n      \"details\": \"Subtract the invalid combinations (same topic and same difficulty) from the total combinations to get the number of valid combinations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using the combination formula.\",\n    \"Count the number of problems for each topic and calculate the number of invalid combinations where all three problems have the same topic.\",\n    \"Count the number of problems for each difficulty and calculate the number of invalid combinations where all three problems have the same difficulty.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid combinations for each test case.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i in topic_count:\n                topic_count[a_i] += 1\n            else:\n                topic_count[a_i] = 1\n            \n            if b_i in difficulty_count:\n                difficulty_count[b_i] += 1\n            else:\n                difficulty_count[b_i] = 1\n        \n        # Total ways to choose 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a_i, b_i in problems:\n            # Subtract combinations where all three have the same topic\n            if topic_count[a_i] >= 2:\n                invalid_combinations += (topic_count[a_i] - 1) * (n - topic_count[a_i])\n            \n            # Subtract combinations where all three have the same difficulty\n            if difficulty_count[b_i] >= 2:\n                invalid_combinations += (difficulty_count[b_i] - 1) * (n - difficulty_count[b_i])\n        \n        # Each invalid combination is counted twice, so divide by 2\n        invalid_combinations //= 2\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains a list of problems with their respective topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same topic.\",\n      \"output\": \"The number of combinations where all three problems have the same topic.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all have the same difficulty.\",\n      \"output\": \"The number of combinations where all three problems have the same difficulty.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that they do not satisfy either condition (all topics different or all difficulties different).\",\n      \"output\": \"The number of invalid combinations that do not satisfy either condition.\"\n    },\n    {\n      \"description\": \"For each test case, subtract the invalid combinations from the total combinations to get the valid combinations.\",\n      \"output\": \"The number of valid combinations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"For each test case, calculate the number of invalid combinations where all three problems have the same topic.\",\n    \"For each test case, calculate the number of invalid combinations where all three problems have the same difficulty.\",\n    \"For each test case, calculate the number of invalid combinations that do not satisfy either condition.\",\n    \"Subtract the invalid combinations from the total combinations to get the valid combinations for each test case.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 91)"}, "Round_1": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"For each topic, count the number of problems with that topic. Use the combination formula C(count, 3) to calculate the number of ways to choose 3 problems with the same topic.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"For each difficulty, count the number of problems with that difficulty. Use the combination formula C(count, 3) to calculate the number of ways to choose 3 problems with the same difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid ways to select three problems that meet at least one of the conditions.\",\n      \"details\": \"Subtract the number of invalid selections (where all topics or all difficulties are the same) from the total number of selections.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"For each test case, calculate the number of ways to select three problems with the same topic.\",\n    \"For each test case, calculate the number of ways to select three problems with the same difficulty.\",\n    \"For each test case, subtract the invalid selections from the total selections to get the number of valid ways.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\n\ndef combination_3(x):\n    if x < 3:\n        return 0\n    return x * (x - 1) * (x - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            problems.append((a_i, b_i))\n        \n        total_combinations = combination_3(n)\n        \n        invalid_topic_combinations = sum(combination_3(count) for count in topics.values())\n        invalid_difficulty_combinations = sum(combination_3(count) for count in difficulties.values())\n        \n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 108)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict\n\ndef combination_3(x):\n    if x < 3:\n        return 0\n    return x * (x - 1) * (x - 2) // 6\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = defaultdict(int)\n        difficulties = defaultdict(int)\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            topics[a_i] += 1\n            difficulties[b_i] += 1\n            problems.append((a_i, b_i))\n        \n        total_combinations = combination_3(n)\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topics[a_i] - 1) * (difficulties[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nsolve()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which represents the number of problems.\",\n        \"For each problem, read two integers a_i and b_i, representing the topic and difficulty.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the number of ways to select three problems that satisfy the conditions.\",\n      \"details\": [\n        \"For each test case, generate all possible combinations of three problems from the list of n problems.\",\n        \"Check each combination to see if it satisfies at least one of the conditions: all topics are different or all difficulties are different.\",\n        \"Count the number of valid combinations.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"details\": [\n        \"For each test case, print the number of valid combinations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store the results for each test case.\",\n    \"For each test case, perform the following steps:\",\n    \"Parse the input to extract the number of problems and their respective topics and difficulties.\",\n    \"Generate all possible combinations of three problems.\",\n    \"For each combination, check if it satisfies the conditions of different topics or different difficulties.\",\n    \"Count the number of valid combinations and store the result.\",\n    \"After processing all test cases, output the results.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains a list of problems with their respective topics and difficulties.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the total number of ways to select any three problems from the given problems.\",\n      \"output\": \"The total number of combinations of three problems from n problems.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all three have the same topic.\",\n      \"output\": \"The number of combinations of three problems with the same topic for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all three have the same difficulty.\",\n      \"output\": \"The number of combinations of three problems with the same difficulty for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the number of ways to select three problems such that all three have the same topic and difficulty.\",\n      \"output\": \"The number of combinations of three problems with the same topic and difficulty for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, use the inclusion-exclusion principle to calculate the number of valid combinations that satisfy at least one of the conditions (different topics or different difficulties).\",\n      \"output\": \"The number of valid combinations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"Iterate over each test case and for each test case, perform the following steps:\",\n    \"Calculate the total number of ways to select any three problems from the given problems.\",\n    \"Count the occurrences of each topic and each difficulty among the problems.\",\n    \"Calculate the number of invalid combinations where all three problems have the same topic.\",\n    \"Calculate the number of invalid combinations where all three problems have the same difficulty.\",\n    \"Calculate the number of invalid combinations where all three problems have the same topic and difficulty.\",\n    \"Use the inclusion-exclusion principle to determine the number of valid combinations that satisfy at least one of the conditions.\",\n    \"Store the result for each test case and print the results after processing all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import defaultdict\n    from math import comb\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        total_combinations = comb(n, 3)\n        \n        invalid_same_topic = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_same_topic += comb(count, 3)\n        \n        invalid_same_difficulty = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_same_difficulty += comb(count, 3)\n        \n        invalid_same_topic_and_difficulty = 0\n        for a_i, b_i in problems:\n            if topic_count[a_i] > 1 and difficulty_count[b_i] > 1:\n                invalid_same_topic_and_difficulty += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        valid_combinations = total_combinations - invalid_same_topic - invalid_same_difficulty + invalid_same_topic_and_difficulty\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the given n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"For each topic, count the number of problems with that topic. Use these counts to calculate the number of invalid combinations where all three problems have the same topic.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"For each difficulty, count the number of problems with that difficulty. Use these counts to calculate the number of invalid combinations where all three problems have the same difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations for each test case.\",\n      \"details\": \"Subtract the invalid combinations (same topic and same difficulty) from the total combinations to get the number of valid combinations for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"For each test case, calculate the number of invalid combinations where all topics are the same.\",\n    \"For each test case, calculate the number of invalid combinations where all difficulties are the same.\",\n    \"Subtract the invalid combinations from the total combinations to get the number of valid combinations for each test case.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Invalid combinations where all topics are the same\n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_combinations += count * (count - 1) * (count - 2) // 6\n        \n        # Invalid combinations where all difficulties are the same\n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_combinations += count * (count - 1) * (count - 2) // 6\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the given n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where at least two have the same topic.\",\n      \"details\": \"Use a dictionary to count the occurrences of each topic. For each topic with count c, calculate the number of ways to choose 2 problems with the same topic and one with a different topic.\"\n    },\n    {\n      \"description\": \"Count the number of ways to select three problems where at least two have the same difficulty.\",\n      \"details\": \"Use a dictionary to count the occurrences of each difficulty. For each difficulty with count c, calculate the number of ways to choose 2 problems with the same difficulty and one with a different difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid problem sets that satisfy at least one of the conditions.\",\n      \"details\": \"Subtract the invalid sets (those that do not satisfy either condition) from the total sets calculated in subproblem 2.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using the combination formula.\",\n    \"Count the number of ways to select three problems where at least two have the same topic using a dictionary to track topic frequencies.\",\n    \"Count the number of ways to select three problems where at least two have the same difficulty using a dictionary to track difficulty frequencies.\",\n    \"Calculate the number of valid problem sets by subtracting the invalid sets from the total sets.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid sets\n        invalid_ways = 0\n        \n        for a, b in problems:\n            # Ways to choose 2 problems with the same topic and 1 with a different topic\n            invalid_ways += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        # Valid ways are total ways minus invalid ways\n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"For each topic, count the number of problems with that topic. Use these counts to calculate the number of invalid combinations where all three problems have the same topic.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"For each difficulty, count the number of problems with that difficulty. Use these counts to calculate the number of invalid combinations where all three problems have the same difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid combinations of three problems.\",\n      \"details\": \"Subtract the invalid combinations (where all topics or all difficulties are the same) from the total combinations to get the number of valid combinations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each problem for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems using the combination formula.\",\n    \"For each test case, count the number of problems for each topic and calculate the number of invalid combinations where all three problems have the same topic.\",\n    \"For each test case, count the number of problems for each difficulty and calculate the number of invalid combinations where all three problems have the same difficulty.\",\n    \"For each test case, subtract the invalid combinations from the total combinations to get the number of valid combinations.\",\n    \"Output the number of valid combinations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topics = {}\n        difficulties = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            \n            problems.append((a, b))\n            \n            if a not in topics:\n                topics[a] = 0\n            if b not in difficulties:\n                difficulties[b] = 0\n            \n            topics[a] += 1\n            difficulties[b] += 1\n        \n        # Total ways to choose 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        # Calculate invalid combinations\n        invalid_combinations = 0\n        \n        for a, b in problems:\n            # Subtract invalid combinations where all three have the same topic or difficulty\n            invalid_combinations += (topics[a] - 1) * (difficulties[b] - 1)\n        \n        # Valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the given n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"For each topic, count the number of problems with that topic. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same topic and sum these values for all topics.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"For each difficulty, count the number of problems with that difficulty. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same difficulty and sum these values for all difficulties.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are not different.\",\n      \"details\": \"For each pair of topic and difficulty, count the number of problems with that specific pair. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same topic and difficulty and sum these values for all pairs.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid ways to select three problems that satisfy at least one of the conditions.\",\n      \"details\": \"Subtract the number of invalid selections (where both topics and difficulties are not different) from the total number of selections. Add back the cases where only topics or only difficulties are not different.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems", "Round_0": {"code": "def calculate_ways(t, test_cases):\n    from collections import defaultdict\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        pair_count = defaultdict(int)\n        \n        for _ in range(n):\n            a, b = int(data[index]), int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            pair_count[(a, b)] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                same_topic_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                same_difficulty_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_pair_ways = 0\n        for count in pair_count.values():\n            if count >= 3:\n                same_pair_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Valid ways\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways + same_pair_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n# Example usage:\n# calculate_ways(2, [\n#     [(2, 4), (3, 4), (2, 1), (1, 3)],\n#     [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]\n# ])\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 118)"}, "Round_1": {"code": "def calculate_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = {}\n        difficulty_count = {}\n        pair_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            if (a, b) not in pair_count:\n                pair_count[(a, b)] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            pair_count[(a, b)] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Ways to choose 3 problems with the same topic\n        same_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 2:\n                same_topic_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Ways to choose 3 problems with the same difficulty\n        same_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 2:\n                same_difficulty_ways += count * (count - 1) // 2 * (n - count)\n        \n        # Ways to choose 3 problems with the same topic and difficulty\n        same_pair_ways = 0\n        for count in pair_count.values():\n            if count >= 2:\n                same_pair_ways += count * (count - 1) // 2\n        \n        # Valid ways\n        valid_ways = total_ways - same_topic_ways - same_difficulty_ways + same_pair_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\n# This function will read from standard input and output the results\ncalculate_ways()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n and then read n pairs of integers representing the topic and difficulty of each problem.\"\n    },\n    {\n      \"description\": \"Calculate the total number of ways to select any three problems from the given n problems.\",\n      \"details\": \"Use the combination formula C(n, 3) = n * (n - 1) * (n - 2) / 6 to calculate the total number of ways to choose 3 problems from n.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all topics are not different.\",\n      \"details\": \"For each unique topic, count the number of problems with that topic. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same topic.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where all difficulties are not different.\",\n      \"details\": \"For each unique difficulty, count the number of problems with that difficulty. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of ways to select three problems where both topics and difficulties are not different.\",\n      \"details\": \"For each pair of topic and difficulty, count the number of problems with that specific pair. Use the combination formula C(count, 3) to find the number of ways to select 3 problems with the same topic and difficulty.\"\n    },\n    {\n      \"description\": \"Calculate the number of valid ways to select three problems that meet at least one of the conditions.\",\n      \"details\": \"Subtract the invalid combinations (where all topics or all difficulties are the same) from the total combinations. Add back the over-subtracted cases where both topics and difficulties are the same.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the list of problems for each test case.\",\n    \"For each test case, calculate the total number of ways to select any three problems.\",\n    \"For each test case, calculate the number of invalid combinations where all topics are the same", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        topic_count = {}\n        difficulty_count = {}\n        pair_count = {}\n        \n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            if (a, b) not in pair_count:\n                pair_count[(a, b)] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            pair_count[(a, b)] += 1\n        \n        # Total ways to choose 3 problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Subtract invalid ways where all topics are the same\n        invalid_topic_ways = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Subtract invalid ways where all difficulties are the same\n        invalid_difficulty_ways = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_ways += count * (count - 1) * (count - 2) // 6\n        \n        # Add back over-subtracted ways where both topics and difficulties are the same\n        over_subtracted_ways = 0\n        for count in pair_count.values():\n            if count >= 3:\n                over_subtracted_ways += count * (count - 1) * (count - 2) // 6\n        \n        valid_ways = total_ways - invalid_topic_ways - invalid_difficulty_ways + over_subtracted_ways\n        results.append(valid_ways)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, false, true, false, false, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 250, "prompt": "Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): * the topics of all three selected problems are different; * the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 111}
