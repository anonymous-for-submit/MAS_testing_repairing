{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "repair_prompt": ["Casimir is curious to determine if the checkered field pattern can be recreated using ticks of size at least k, ensuring no cells contradict the constraints of the tick size.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    # Check diagonals for the current size\n                    if (i - size >= 0 and j - size >= 0 and field[i - size][j - size] == '*' and\n                        i - size >= 0 and j + size < m and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Validate the field to ensure all '*' are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def can_recreate_field(n, m, k, field):\n    # Create a copy of the field to mark used cells\n    used = [[False] * m for _ in range(n)]\n\n    # Check if a tick of size s can be centered at (i, j)\n    def can_place_tick(i, j, s):\n        for d in range(1, s + 1):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark the cells used by a tick of size s centered at (i, j)\n    def mark_tick(i, j, s):\n        for d in range(s + 1):\n            used[i - d][j - d] = True\n            used[i - d][j + d] = True\n\n    # Iterate over the field from bottom to top\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*' and not used[i][j]:\n                # Find the maximum size of the tick that can be placed here\n                size = 0\n                while can_place_tick(i, j, size + 1):\n                    size += 1\n                # If the size is at least k, mark the tick\n                if size >= k:\n                    mark_tick(i, j, size)\n                else:\n                    return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_recreate_field(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be formed at (i, j)\n    def is_valid_tick(i, j, size):\n        if i + size >= n or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i + d][j - d] != '*' or field[i + d][j + d] != '*':\n                return False\n        return True\n\n    # Mark all valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                size = k\n                while is_valid_tick(i, j, size):\n                    for d in range(size + 1):\n                        marked[i + d][j - d] = True\n                        marked[i + d][j + d] = True\n                    size += 1\n\n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            # Check if the cell contains an asterisk\n            if field[i][j] == '*':\n                # Check if it can be the center of a tick of size at least k\n                valid_tick = True\n                for x in range(1, k + 1):\n                    if i - x < 0 or j - x < 0 or j + x >= m:\n                        valid_tick = False\n                        break\n                    if field[i - x][j - x] != '*' or field[i - x][j + x] != '*':\n                        valid_tick = False\n                        break\n                # If valid, mark the cells as part of a tick\n                if valid_tick:\n                    marked[i][j] = True\n                    for x in range(1, k + 1):\n                        marked[i - x][j - x] = True\n                        marked[i - x][j + x] = True\n\n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered cells\n    covered = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size k can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Iterate over each cell in the field\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick can be centered at (i, j)\n                size = 0\n                while can_place_tick(i, j, size + 1):\n                    size += 1\n                if size >= k:\n                    # Mark cells covered by the tick\n                    for d in range(size + 1):\n                        covered[i - d][j - d] = True\n                        covered[i - d][j + d] = True\n\n    # Check if all '*' cells are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered cells\n    covered = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size k can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Iterate over each cell to place ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Try to place the largest possible tick\n                size = 0\n                while can_place_tick(i, j, size):\n                    size += 1\n                size -= 1  # Largest valid size\n                if size >= k:\n                    # Mark cells covered by the tick\n                    for d in range(size + 1):\n                        covered[i - d][j - d] = True\n                        covered[i - d][j + d] = True\n\n    # Check if all '*' are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark visited asterisks\n    visited = [[False] * m for _ in range(n)]\n    \n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this asterisk can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    if (i - size - 1 >= 0 and j - size - 1 >= 0 and j + size + 1 < m and\n                        field[i - size - 1][j - size - 1] == '*' and field[i - size - 1][j + size + 1] == '*'):\n                        size += 1\n                    else:\n                        break\n                \n                # If the tick size is at least k, mark the asterisks as visited\n                if size >= k:\n                    for x in range(size):\n                        visited[i - x - 1][j - x - 1] = True\n                        visited[i - x - 1][j + x + 1] = True\n    \n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not visited[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        \n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be formed at (i, j)\n    def is_valid_tick(i, j, size):\n        for d in range(size):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Try to form the largest possible tick at (i, j)\n                size = 0\n                while is_valid_tick(i, j, size + 1):\n                    size += 1\n\n                # If the tick size is at least k, mark the cells\n                if size >= k:\n                    for d in range(size):\n                        marked[i - d][j - d] = True\n                        marked[i - d][j + d] = True\n\n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size k can be centered at (i, j)\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and j + size < m and\n                        field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Check if all '*' cells are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_draw_tick(field, n, m, k, x, y):\n    # Check if a tick of size k can be drawn with center at (x, y)\n    for size in range(1, k + 1):\n        if x - size < 0 or x + size >= n or y - size < 0 or y + size >= m:\n            return False\n        if field[x - size][y - size] != '*' or field[x - size][y + size] != '*' or \\\n           field[x + size][y - size] != '*' or field[x + size][y + size] != '*':\n            return False\n    return True\n\ndef process_test_case(n, m, k, field):\n    # Create a copy of the field to mark visited cells\n    visited = [[False] * m for _ in range(n)]\n    \n    # Iterate over each cell in the field\n    for x in range(n):\n        for y in range(m):\n            if field[x][y] == '*' and not visited[x][y]:\n                # Check if this cell can be the center of a tick\n                if can_draw_tick(field, n, m, k, x, y):\n                    # Mark all cells of the tick as visited\n                    for size in range(k):\n                        visited[x - size][y - size] = True\n                        visited[x - size][y + size] = True\n                        visited[x + size][y - size] = True\n                        visited[x + size][y + size] = True\n                else:\n                    return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[i] for i in range(index, index + n)]\n        index += n\n        \n        if process_test_case(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    # Check diagonals for the current size\n                    if (i - size >= 0 and j - size >= 0 and field[i - size][j - size] == '*' and\n                        i - size >= 0 and j + size < m and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Validate the field to ensure all '*' are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k, which represent the dimensions of the field and the minimum tick size.\",\n        \"Read the next n lines, each containing m characters, to represent the field.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"For each '*' cell, check if it can be the center of a tick of size at least k.\",\n        \"Ensure that for a tick of size s, the cells in the s diagonals from the center are also '*' and within bounds.\",\n        \"Mark cells that are part of a valid tick to avoid rechecking.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the entire field to ensure all '*' are part of valid ticks.\",\n      \"steps\": [\n        \"After attempting to form ticks, iterate over the field again.\",\n        \"Check if there are any '*' cells that are not part of any valid tick.\",\n        \"If such cells exist, the answer for that test case is NO; otherwise, it is YES.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the field can be recreated with the given constraints, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over the field to identify potential tick centers.\",\n    \"For each potential tick center, verify if a tick of size at least k can be formed.\",\n    \"Mark cells that are part of valid ticks to avoid redundant checks.\",\n    \"After processing, validate the field to ensure all '*' are part of valid ticks.\",\n    \"Output 'YES' or 'NO' for each test case based on the validation results.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    # Check diagonals for the current size\n                    if (i - size >= 0 and j - size >= 0 and field[i - size][j - size] == '*' and\n                        i - size >= 0 and j + size < m and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Validate the field to ensure all '*' are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the field dimensions, minimum tick size, and the field pattern.\",\n      \"output\": \"A structured representation of the input data, such as a list of dictionaries, where each dictionary contains the details of a test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the field can be recreated using ticks of at least the given size k. A tick of size s is defined as a pattern where a center cell has s '*' in each of the four diagonal directions.\",\n      \"output\": \"A boolean value indicating whether the field can be recreated using ticks of at least size k.\"\n    },\n    {\n      \"description\": \"Generate the output for each test case based on the boolean result from the previous step. The output should be 'YES' if the field can be recreated and 'NO' otherwise.\",\n      \"output\": \"A list of strings, each being 'YES' or 'NO', corresponding to each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"Iterate over each test case and for each test case, perform the following steps:\",\n    \"  a. Initialize a boolean flag to true, indicating the field can be recreated.\",\n    \"  b. For each cell in the field that contains '*', check if it can be the center of a tick of size at least k.\",\n    \"  c. If a cell cannot be part of a valid tick, set the boolean flag to false and break out of the loop.\",\n    \"  d. If all '*' cells can be part of valid ticks, keep the flag as true.\",\n    \"Store the result ('YES' or 'NO') for each test case based on the boolean flag.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def can_recreate_field(n, m, k, field):\n    # Create a copy of the field to mark used cells\n    used = [[False] * m for _ in range(n)]\n\n    # Check if a tick of size s can be centered at (i, j)\n    def can_place_tick(i, j, s):\n        for d in range(1, s + 1):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark the cells used by a tick of size s centered at (i, j)\n    def mark_tick(i, j, s):\n        for d in range(s + 1):\n            used[i - d][j - d] = True\n            used[i - d][j + d] = True\n\n    # Iterate over the field from bottom to top\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*' and not used[i][j]:\n                # Find the maximum size of the tick that can be placed here\n                size = 0\n                while can_place_tick(i, j, size + 1):\n                    size += 1\n                # If the size is at least k, mark the tick\n                if size >= k:\n                    mark_tick(i, j, size)\n                else:\n                    return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_recreate_field(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 120)"}, "Round_1": {"code": "def can_recreate_field(n, m, k, field):\n    # Create a copy of the field to mark used cells\n    used = [[False] * m for _ in range(n)]\n\n    # Check if a tick of size s can be centered at (i, j)\n    def can_place_tick(i, j, s):\n        for d in range(1, s + 1):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark the cells used by a tick of size s centered at (i, j)\n    def mark_tick(i, j, s):\n        for d in range(s + 1):\n            used[i - d][j - d] = True\n            used[i - d][j + d] = True\n\n    # Iterate over the field from bottom to top\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*' and not used[i][j]:\n                # Find the maximum size of the tick that can be placed here\n                size = 0\n                while can_place_tick(i, j, size + 1):\n                    size += 1\n                # If the size is at least k, mark the tick\n                if size >= k:\n                    mark_tick(i, j, size)\n                else:\n                    return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_recreate_field(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to obtain the field pattern, storing each line as a list of characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell contains an asterisk ('*').\",\n        \"If it does, attempt to form a tick centered at this cell with size at least k.\",\n        \"Verify that the tick does not contradict the constraints of the tick size by ensuring all required cells are asterisks.\",\n        \"Mark cells that are part of a valid tick to avoid rechecking them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if all asterisks can be part of valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over the field to check if it can be recreated using ticks of size at least k.\",\n    \"For each cell containing an asterisk, attempt to form a tick and verify its validity.\",\n    \"Mark cells that are part of valid ticks to avoid redundant checks.\",\n    \"Output 'YES' if all asterisks can be part of valid ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be formed at (i, j)\n    def is_valid_tick(i, j, size):\n        if i + size >= n or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i + d][j - d] != '*' or field[i + d][j + d] != '*':\n                return False\n        return True\n\n    # Mark all valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                size = k\n                while is_valid_tick(i, j, size):\n                    for d in range(size + 1):\n                        marked[i + d][j - d] = True\n                        marked[i + d][j + d] = True\n                    size += 1\n\n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to obtain the field pattern, storing each line as a list of characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell contains an asterisk ('*').\",\n        \"If it does, verify if it can be the center of a tick of size at least k.\",\n        \"A tick of size k centered at (i, j) requires asterisks at positions (i-x, j-x) and (i-x, j+x) for all x from 1 to k.\",\n        \"Ensure that all required positions are within bounds and contain asterisks.\",\n        \"Mark cells that are part of valid ticks to avoid double-checking.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"If all asterisks in the field can be part of valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over the field to check if all asterisks can be part of valid ticks of size at least k.\",\n    \"Output 'YES' if the field can be recreated using ticks of the required size, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            # Check if the cell contains an asterisk\n            if field[i][j] == '*':\n                # Check if it can be the center of a tick of size at least k\n                valid_tick = True\n                for x in range(1, k + 1):\n                    if i - x < 0 or j - x < 0 or j + x >= m:\n                        valid_tick = False\n                        break\n                    if field[i - x][j - x] != '*' or field[i - x][j + x] != '*':\n                        valid_tick = False\n                        break\n                # If valid, mark the cells as part of a tick\n                if valid_tick:\n                    marked[i][j] = True\n                    for x in range(1, k + 1):\n                        marked[i - x][j - x] = True\n                        marked[i - x][j + x] = True\n\n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field and the minimum tick size.\",\n      \"output\": \"A list of test cases, where each test case contains the field dimensions, minimum tick size, and the field pattern.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the field can be recreated using ticks of at least the given size.\",\n      \"output\": \"A boolean value indicating whether the field can be recreated for each test case.\"\n    },\n    {\n      \"description\": \"Check if a tick of a given size can be centered at a specific cell in the field.\",\n      \"output\": \"A boolean value indicating whether a tick can be centered at the specified cell.\"\n    },\n    {\n      \"description\": \"Iterate over each cell in the field to check if it can be part of a valid tick configuration.\",\n      \"output\": \"A boolean value indicating whether the entire field can be covered by valid ticks.\"\n    },\n    {\n      \"description\": \"Output the result for each test case as 'YES' or 'NO' based on whether the field can be recreated.\",\n      \"output\": \"A list of strings, each being 'YES' or 'NO' for the corresponding test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a boolean matrix to track which cells are covered by ticks.\",\n    \"Define a function to check if a tick of size k can be centered at a given cell (i, j).\",\n    \"Iterate over each cell in the field. For each cell containing '*', check if it can be the center of a tick of size at least k.\",\n    \"If a valid tick is found, mark the cells covered by the tick in the boolean matrix.\",\n    \"After processing all cells, check if all '*' cells in the field are covered by ticks.\",\n    \"Store 'YES' if the field can be recreated, otherwise store 'NO'.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered cells\n    covered = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size k can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        if i - size < 0 or i + size >= n or j - size < 0 or j + size >= m:\n            return False\n        for d in range(1, size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*' or field[i + d][j - d] != '*' or field[i + d][j + d] != '*':\n                return False\n        return True\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick can be centered at (i, j)\n                size = k\n                while can_place_tick(i, j, size):\n                    # Mark cells covered by the tick\n                    for d in range(size + 1):\n                        covered[i - d][j - d] = True\n                        covered[i - d][j + d] = True\n                        covered[i + d][j - d] = True\n                        covered[i + d][j + d] = True\n                    size += 1\n\n    # Check if all '*' cells are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 110)"}, "Round_1": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered cells\n    covered = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size k can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Iterate over each cell in the field\n    for i in range(n - 1, -1, -1):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick can be centered at (i, j)\n                size = 0\n                while can_place_tick(i, j, size + 1):\n                    size += 1\n                if size >= k:\n                    # Mark cells covered by the tick\n                    for d in range(size + 1):\n                        covered[i - d][j - d] = True\n                        covered[i - d][j + d] = True\n\n    # Check if all '*' cells are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the dimensions of the field and the minimum tick size.\",\n      \"output\": \"A list of test cases, where each test case contains the field dimensions, minimum tick size, and the field pattern.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the field can be recreated using ticks of at least the given size.\",\n      \"output\": \"A boolean value indicating whether the field can be recreated for each test case.\"\n    },\n    {\n      \"description\": \"Check if a tick of a given size can be centered at a specific cell in the field.\",\n      \"output\": \"A boolean value indicating whether a tick can be centered at the specified cell.\"\n    },\n    {\n      \"description\": \"Iterate over each cell in the field to check if it can be part of a valid tick configuration.\",\n      \"output\": \"A boolean value indicating whether the entire field can be covered by valid ticks.\"\n    },\n    {\n      \"description\": \"Output the result for each test case as 'YES' or 'NO' based on whether the field can be recreated.\",\n      \"output\": \"A list of strings, each being 'YES' or 'NO' for the corresponding test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a boolean matrix to track which cells are covered by ticks.\",\n    \"Define a function to check if a tick of size k can be centered at a given cell (i, j) in the field.\",\n    \"Iterate over each cell in the field. For each cell containing '*', check if it can be the center of a tick of size at least k.\",\n    \"If a valid tick is found, mark the cells covered by the tick in the boolean matrix.\",\n    \"After processing all cells, check if all '*' cells in the field are covered by ticks in the boolean matrix.\",\n    \"If all '*' cells are covered, append 'YES' to the results list; otherwise, append 'NO'.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered cells\n    covered = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size k can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Iterate over each cell to place ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Try to place the largest possible tick\n                size = 0\n                while can_place_tick(i, j, size):\n                    size += 1\n                size -= 1  # Largest valid size\n                if size >= k:\n                    # Mark cells covered by the tick\n                    for d in range(size + 1):\n                        covered[i - d][j - d] = True\n                        covered[i - d][j + d] = True\n\n    # Check if all '*' are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to obtain the field pattern, storing each line as a list of characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell contains an asterisk ('*').\",\n        \"If it does, verify if it can be the center of a tick of size at least k.\",\n        \"A tick of size k centered at (i, j) requires asterisks at positions (i-x, j-x) and (i-x, j+x) for all x in range(1, k+1).\",\n        \"Ensure all required positions are within bounds and contain asterisks.\",\n        \"If any asterisk cannot be part of a valid tick, mark the test case as 'NO'.\",\n        \"If all asterisks can be part of valid ticks, mark the test case as 'YES'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a flag to 'YES'.\",\n    \"Iterate over each cell in the field to check for asterisks.\",\n    \"For each asterisk, attempt to form a tick of size at least k.\",\n    \"If any asterisk cannot form a valid tick, set the flag to 'NO' and break the loop.\",\n    \"After checking all cells, store the result ('YES' or 'NO') for the test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a copy of the field to mark visited asterisks\n    visited = [[False] * m for _ in range(n)]\n    \n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this asterisk can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    if (i - size - 1 >= 0 and j - size - 1 >= 0 and j + size + 1 < m and\n                        field[i - size - 1][j - size - 1] == '*' and field[i - size - 1][j + size + 1] == '*'):\n                        size += 1\n                    else:\n                        break\n                \n                # If the tick size is at least k, mark the asterisks as visited\n                if size >= k:\n                    for x in range(size):\n                        visited[i - x - 1][j - x - 1] = True\n                        visited[i - x - 1][j + x + 1] = True\n    \n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not visited[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        \n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to obtain the field pattern, storing each line as a list of characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if the cell contains an asterisk ('*').\",\n        \"If it does, attempt to form a tick centered at this cell with size at least k.\",\n        \"Verify that the tick does not contradict the constraints of the tick size by ensuring all required cells are asterisks.\",\n        \"Mark cells that are part of a valid tick to avoid rechecking them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if all asterisks can be part of valid ticks of size at least k, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over the field to check if it can be recreated using ticks of size at least k.\",\n    \"For each cell containing an asterisk, attempt to form a tick and verify its validity.\",\n    \"Mark cells that are part of valid ticks to avoid redundant checks.\",\n    \"Output 'YES' if all asterisks can be part of valid ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be formed at (i, j)\n    def is_valid_tick(i, j, size):\n        for d in range(size):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Try to form the largest possible tick at (i, j)\n                size = 0\n                while is_valid_tick(i, j, size + 1):\n                    size += 1\n\n                # If the tick size is at least k, mark the cells\n                if size >= k:\n                    for d in range(size):\n                        marked[i - d][j - d] = True\n                        marked[i - d][j + d] = True\n\n    # Check if all asterisks are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to obtain the field pattern, storing each line as a list of characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if a tick of size k can be centered at each '*' cell by verifying the presence of '*' in the required positions.\",\n        \"Ensure that the tick does not extend beyond the boundaries of the field.\",\n        \"Mark cells that are part of a valid tick to avoid rechecking them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if all '*' cells can be part of a valid tick, output 'YES'.\",\n        \"If any '*' cell cannot be part of a valid tick, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over the field to check if ticks of size at least k can be formed.\",\n    \"For each '*' cell, verify if it can be the center of a tick of size k.\",\n    \"Mark cells that are part of a valid tick to avoid redundant checks.\",\n    \"Output 'YES' if all '*' cells can be part of valid ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size k can be centered at (i, j)\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and j + size < m and\n                        field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Check if all '*' cells are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the field dimensions, minimum tick size, and the field pattern.\",\n      \"output\": \"A structured representation of the input data, such as a list of dictionaries, where each dictionary contains the details of a test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the field can be recreated using ticks of at least the specified size.\",\n      \"output\": \"A boolean value indicating whether the field can be recreated (true) or not (false) for each test case.\"\n    },\n    {\n      \"description\": \"Implement a function to check if a tick of a given size can be drawn at a specific position in the field.\",\n      \"output\": \"A boolean value indicating whether a tick can be drawn at the specified position.\"\n    },\n    {\n      \"description\": \"Iterate over each cell in the field to check if it can be the center of a valid tick of at least the specified size.\",\n      \"output\": \"A list of boolean values for each test case, indicating if the field can be recreated.\"\n    },\n    {\n      \"description\": \"Format the output to match the required format, printing 'YES' or 'NO' for each test case based on the results.\",\n      \"output\": \"A string output for each test case, either 'YES' or 'NO'.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, initialize a boolean flag to true, indicating the field can be recreated.\",\n    \"Iterate over each cell in the field. If the cell contains '*', check if it can be the center of a valid tick of at least the specified size using the tick-checking function.\",\n    \"If any '*' cannot be part of a valid tick, set the flag to false for that test case.\",\n    \"After processing all cells, store the result ('YES' or 'NO') based on the flag for each test case.\",\n    \"Output the results for all test cases in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def can_draw_tick(field, n, m, k, x, y):\n    # Check if a tick of size k can be drawn with center at (x, y)\n    for size in range(1, k + 1):\n        if x - size < 0 or x + size >= n or y - size < 0 or y + size >= m:\n            return False\n        if field[x - size][y - size] != '*' or field[x - size][y + size] != '*' or \\\n           field[x + size][y - size] != '*' or field[x + size][y + size] != '*':\n            return False\n    return True\n\ndef process_test_case(n, m, k, field):\n    # Create a copy of the field to mark visited cells\n    visited = [[False] * m for _ in range(n)]\n    \n    # Iterate over each cell in the field\n    for x in range(n):\n        for y in range(m):\n            if field[x][y] == '*' and not visited[x][y]:\n                # Check if this cell can be the center of a tick\n                if can_draw_tick(field, n, m, k, x, y):\n                    # Mark all cells of the tick as visited\n                    for size in range(k):\n                        visited[x - size][y - size] = True\n                        visited[x - size][y + size] = True\n                        visited[x + size][y - size] = True\n                        visited[x + size][y + size] = True\n                else:\n                    return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[i] for i in range(index, index + n)]\n        index += n\n        \n        if process_test_case(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k, which represent the dimensions of the field and the minimum tick size.\",\n        \"Read the next n lines, each containing m characters, to represent the field.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"For each '*' cell, check if it can be the center of a tick of size at least k.\",\n        \"Ensure that for a tick of size s, the cells in the s diagonals from the center are also '*' and within bounds.\",\n        \"Mark cells that are part of a valid tick to avoid rechecking.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the entire field to ensure all '*' are part of valid ticks.\",\n      \"steps\": [\n        \"After attempting to form ticks, iterate over the field again.\",\n        \"Check if there are any '*' cells that are not part of any valid tick.\",\n        \"If such cells exist, the answer for that test case is NO; otherwise, it is YES.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print 'YES' if the field can be recreated with the given constraints, otherwise print 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over the field to identify potential tick centers.\",\n    \"For each potential tick center, verify if a tick of size at least k can be formed.\",\n    \"Mark cells that are part of valid ticks to avoid redundant checks.\",\n    \"After processing, validate the field to ensure all '*' are part of valid ticks.\",\n    \"Output 'YES' or 'NO' for each test case based on the validation results.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a matrix to mark cells that are part of valid ticks\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    # Check diagonals for the current size\n                    if (i - size >= 0 and j - size >= 0 and field[i - size][j - size] == '*' and\n                        i - size >= 0 and j + size < m and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Validate the field to ensure all '*' are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, true, true, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 549, "prompt": "Casimir is curious to determine if the checkered field pattern can be recreated using ticks of size at least k, ensuring no cells contradict the constraints of the tick size.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 294}
