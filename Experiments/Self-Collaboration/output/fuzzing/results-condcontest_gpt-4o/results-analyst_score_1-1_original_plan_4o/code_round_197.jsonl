{"name": "1620_B. Triangles on a Rectangle", "description": "A rectangle with its opposite corners in (0, 0) and (w, h) and sides parallel to the axes is drawn on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner. Also, there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\n\n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).", "tags": ["geometry", "greedy", "math"], "difficulty": 8, "id": 1620, "sample_io": [{"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}], "test_list": [{"input": "1\n99 99\n2 1 2\n2 3 4\n2 5 6\n2 7 8\n", "output": ["99\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["25\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["25\n70\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["36\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n147\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n78\n77\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n77\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n70\n"]}, {"input": "1\n99 164\n2 1 2\n2 3 4\n2 5 6\n2 7 8\n", "output": ["164\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n49\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 -1 3 7\n2 2 4\n", "output": ["25\n42\n88\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["20\n70\n44\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n16 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["36\n42\n112\n"]}, {"input": "3\n6 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 4\n", "output": ["25\n42\n210\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n49\n66\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 7\n2 2 4\n", "output": ["25\n42\n66\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 0\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["25\n91\n42\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n91\n77\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n18 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n126\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 0 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n63\n35\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n72\n"]}, {"input": "3\n5 8\n2 1 4\n3 1 3 4\n3 1 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n70\n"]}, {"input": "1\n198 164\n2 1 2\n2 3 4\n2 5 6\n2 7 8\n", "output": ["198\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 0 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n63\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 8\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 1\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n48\n35\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 3 5 6\n25 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n75\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 8 5\n10 7\n2 3 9\n2 1 11\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n70\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 1 10\n3 0 3 7\n2 2 4\n", "output": ["30\n42\n77\n"]}, {"input": "3\n6 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 1\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n42\n33\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 7\n2 1 10\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n117\n77\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 7 5 6\n22 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n49\n132\n"]}, {"input": "3\n9 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 7\n2 2 4\n", "output": ["45\n42\n66\n"]}, {"input": "3\n9 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 0 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 7\n2 2 4\n", "output": ["45\n63\n66\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 11\n26 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n182\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 6 4\n2 2 4\n", "output": ["32\n49\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 1\n3 4 5 5\n17 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n51\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 8 5\n10 7\n2 3 9\n2 1 11\n3 1 3 4\n3 8 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 7\n", "output": ["25\n70\n55\n"]}, {"input": "3\n4 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 7\n2 1 10\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 4 4\n", "output": ["24\n117\n77\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 6 4\n2 2 4\n", "output": ["25\n49\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 1\n3 4 5 5\n20 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n60\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 1 5 6\n11 5\n3 1 2 8\n3 2 1 10\n3 0 3 7\n2 2 4\n", "output": ["30\n50\n77\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 2\n3 7 5 6\n21 5\n3 1 6 4\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["25\n56\n210\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 5 5\n20 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n84\n60\n"]}, {"input": "3\n2 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 9\n2 1 9\n3 1 3 2\n3 7 5 6\n21 5\n3 1 6 4\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["24\n56\n210\n"]}, {"input": "1\n99 99\n2 1 2\n2 0 4\n2 5 6\n2 7 8\n", "output": ["396\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 7\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["40\n42\n77\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n20 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n60\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 16\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["75\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 9\n2 1 13\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n156\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["24\n42\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 9\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n54\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 16\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n60\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 6\n", "output": ["32\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 2\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n49\n33\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 1 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 -1 3 7\n2 2 4\n", "output": ["25\n56\n88\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 11\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 2\n", "output": ["50\n42\n77\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 2\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 2 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["24\n42\n77\n"]}, {"input": "3\n5 24\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 4\n", "output": ["48\n42\n210\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["25\n49\n66\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 7\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 7\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n33\n"]}, {"input": "3\n5 8\n2 1 5\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 0\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["32\n91\n42\n"]}, {"input": "3\n5 8\n2 1 4\n3 1 3 4\n3 0 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["30\n42\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n2 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["24\n70\n44\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n18 7\n2 5 9\n2 1 7\n3 1 3 4\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n54\n35\n"]}, {"input": "3\n6 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n21 1\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n42\n63\n"]}, {"input": "3\n9 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 5 8\n2 2 4\n", "output": ["45\n42\n77\n"]}, {"input": "3\n10 8\n2 1 4\n3 1 3 4\n3 1 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 2 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["50\n42\n70\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 0\n10 7\n2 0 9\n2 0 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 3\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["25\n63\n33\n"]}, {"input": "3\n5 12\n2 2 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 16\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n84\n77\n"]}, {"input": "3\n5 8\n2 1 7\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 1\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["48\n42\n35\n"]}, {"input": "3\n5 9\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 9\n2 1 7\n3 1 3 4\n3 3 5 6\n25 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["27\n42\n75\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 2\n3 7 5 6\n9 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["25\n42\n90\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 10\n26 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n60\n182\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 9\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 4 4\n2 4 4\n", "output": ["40\n49\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 8\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 8 3\n20 5\n3 1 12 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["35\n84\n60\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 16\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["20\n42\n75\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 6\n3 1 4 6\n2 4 5\n0 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["32\n42\n77\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 12\n2 1 4\n", "output": ["36\n42\n121\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 12\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n72\n35\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 0 4\n", "output": ["20\n70\n77\n"]}, {"input": "3\n5 8\n2 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n78\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 10\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["25\n70\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 8\n2 4 2\n10 7\n2 0 4\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["35\n42\n35\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 15\n2 2 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n84\n72\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n2 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 -1 3 4\n2 2 4\n", "output": ["24\n70\n55\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 4 9\n2 2 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n35\n77\n"]}, {"input": "3\n5 12\n2 2 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 4 16\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["45\n84\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 5\n2 8 5\n10 7\n2 3 9\n2 1 11\n3 1 3 4\n3 8 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 4 4\n2 2 4\n", "output": ["20\n70\n35\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 0\n1 7\n2 3 9\n2 1 14\n3 1 3 5\n3 4 5 11\n16 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n91\n112\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 10\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 11\n26 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["30\n70\n182\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 2 7\n3 1 3 1\n3 4 5 5\n17 5\n3 1 6 8\n3 4 6 8\n3 1 3 3\n2 2 4\n", "output": ["25\n35\n35\n"]}, {"input": "3\n1 12\n2 1 6\n3 2 4 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n16 8\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 1\n", "output": ["60\n42\n112\n"]}, {"input": "3\n3 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 2\n3 7 5 6\n21 5\n3 1 6 4\n3 3 6 8\n3 0 3 20\n2 2 3\n", "output": ["24\n56\n420\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 0 4 6\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 5 5\n20 5\n3 2 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["30\n84\n60\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 9\n2 4 2\n10 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 0 6 8\n3 3 6 8\n3 2 4 4\n2 4 4\n", "output": ["40\n49\n80\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 16\n2 4 5\n10 7\n2 5 9\n2 1 13\n3 1 3 1\n3 4 8 3\n20 5\n3 1 12 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["75\n84\n60\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 16\n2 4 5\n10 7\n2 3 17\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 10 8\n3 1 3 4\n2 2 4\n", "output": ["75\n98\n35\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 18\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n108\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 3 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 4\n3 4 5 1\n11 5\n3 1 6 2\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n56\n33\n"]}, {"input": "3\n5 17\n2 0 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 15\n2 2 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["68\n84\n72\n"]}, {"input": "3\n9 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 4 9\n2 2 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["45\n35\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 9\n2 8 5\n10 7\n2 3 3\n2 1 11\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 1 4\n2 2 4\n", "output": ["40\n70\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 0 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 6 5 6\n11 6\n3 1 6 8\n3 3 6 8\n3 2 2 2\n2 2 4\n", "output": ["32\n42\n42\n"]}, {"input": "3\n5 8\n2 1 1\n3 1 3 4\n3 1 4 6\n2 4 0\n10 7\n2 0 9\n2 0 7\n3 1 3 4\n3 2 5 6\n11 5\n3 1 6 8\n3 3 7 8\n3 1 3 4\n2 2 7\n", "output": ["25\n63\n55\n"]}, {"input": "1\n53 164\n2 1 2\n2 0 4\n2 5 6\n2 9 8\n", "output": ["656\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 2 4 6\n2 4 5\n1 8\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 3 5\n3 0 3 3\n2 2 4\n", "output": ["24\n48\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 0 6\n2 4 5\n18 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 12\n2 1 4\n", "output": ["36\n54\n121\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 18\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 2 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n108\n30\n"]}, {"input": "3\n5 8\n2 1 2\n3 3 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 4\n3 4 5 1\n13 5\n3 1 6 2\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n56\n39\n"]}, {"input": "3\n5 17\n2 0 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 28\n2 2 7\n3 1 3 4\n3 7 5 6\n12 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["68\n175\n72\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 9\n2 8 5\n10 7\n2 3 3\n2 1 15\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 1 4\n2 2 4\n", "output": ["40\n98\n35\n"]}, {"input": "3\n5 8\n2 0 2\n3 0 3 4\n3 1 4 3\n2 4 7\n10 7\n2 3 4\n2 1 7\n3 1 0 4\n3 1 5 6\n11 5\n3 1 6 8\n3 3 2 8\n3 0 3 3\n2 2 5\n", "output": ["32\n50\n35\n"]}, {"input": "3\n1 12\n2 1 6\n3 2 4 4\n3 1 4 7\n2 4 5\n10 7\n2 3 1\n2 1 7\n3 1 3 4\n3 7 5 6\n16 8\n3 1 6 8\n3 3 11 8\n3 0 3 13\n2 2 1\n", "output": ["60\n42\n208\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n19 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 6 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 4 7\n2 4 4\n", "output": ["25\n76\n70\n"]}, {"input": "3\n5 8\n2 1 4\n3 0 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 2 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 14\n3 4 6 1\n3 0 3 3\n2 2 4\n", "output": ["32\n42\n65\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 0\n3 1 4 6\n2 4 1\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n8 4\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 0 4\n", "output": ["25\n42\n32\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 0 6\n2 4 5\n18 7\n2 3 15\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 12\n2 1 4\n", "output": ["36\n84\n121\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 7\n3 4 5 6\n11 5\n3 1 6 0\n3 3 10 8\n3 2 5 4\n2 2 6\n", "output": ["32\n60\n44\n"]}, {"input": "3\n10 8\n2 1 2\n3 3 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 9\n3 1 3 4\n3 4 5 1\n13 5\n3 1 6 2\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["50\n56\n39\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 0 10\n3 0 3 8\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 5\n3 1 3 7\n2 2 4\n", "output": ["25\n80\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 11\n2 8 5\n10 7\n2 3 3\n2 1 15\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 1 4\n2 2 4\n", "output": ["50\n98\n35\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n19 7\n2 3 10\n2 1 7\n3 -1 3 4\n3 4 6 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 4 7\n2 4 4\n", "output": ["25\n95\n70\n"]}, {"input": "3\n5 1\n2 0 4\n3 1 3 4\n3 1 4 9\n2 4 2\n20 7\n2 3 10\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 0 6 8\n3 3 6 8\n3 2 4 4\n2 4 1\n", "output": ["40\n80\n80\n"]}, {"input": "1\n53 202\n2 1 2\n2 0 4\n2 3 6\n2 9 8\n", "output": ["808\n"]}, {"input": "3\n5 4\n2 1 4\n3 0 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 2 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 14\n3 4 6 1\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n65\n"]}, {"input": "3\n5 13\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n4 18\n2 3 9\n2 1 7\n3 2 3 4\n3 4 5 6\n11 5\n3 2 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["39\n108\n30\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 1 4\n3 7 5 6\n16 6\n3 2 6 0\n3 3 11 8\n3 0 3 6\n2 2 1\n", "output": ["36\n42\n96\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 10\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 8\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n147\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 0\n3 4 5 6\n14 5\n3 1 6 8\n3 4 6 5\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n77\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 17\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 4\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 7 8\n3 3 11 8\n3 1 3 7\n2 2 0\n", "output": ["51\n42\n66\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 6 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n70\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 0\n", "output": ["25\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 2\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 1\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 3\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 3\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 2 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 3 5 6\n14 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n42\n"]}, {"input": "3\n5 8\n2 1 1\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 8 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 1 10\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 13\n2 3 7\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n78\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 0 4\n3 4 5 6\n11 5\n3 1 6 12\n3 3 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 6\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 7\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 2 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n2 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n147\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 1 6 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 8 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 3\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 0 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n70\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 0 6 8\n3 0 3 4\n2 2 0\n", "output": ["25\n42\n44\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 5\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 7\n2 2 2\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 3 4\n3 2 4 6\n2 4 5\n10 7\n2 3 13\n2 1 7\n2 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 4\n2 2 4\n", "output": ["20\n70\n44\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 4 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 6 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 12\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 3\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["25\n42\n77\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 5 9\n2 1 7\n3 1 3 4\n3 4 5 5\n11 5\n3 1 6 8\n3 4 6 8\n3 0 3 3\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 7\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n16 5\n3 1 6 8\n3 3 11 8\n3 0 3 7\n2 2 4\n", "output": ["36\n42\n112\n"]}, {"input": "3\n5 12\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n21 5\n3 1 6 8\n3 3 6 8\n3 0 3 10\n2 2 3\n", "output": ["25\n42\n210\n"]}, {"input": "3\n5 8\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 5\n12 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 6\n3 2 3 4\n2 2 4\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 8\n2 0 2\n3 2 3 4\n3 1 4 6\n2 4 7\n10 7\n2 3 9\n2 1 7\n3 1 0 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 0 3 3\n2 2 5\n", "output": ["25\n42\n35\n"]}, {"input": "3\n5 12\n2 1 4\n3 2 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 7 5 6\n11 5\n3 0 6 8\n3 3 11 8\n3 1 6 7\n2 2 4\n", "output": ["36\n42\n66\n"]}, {"input": "3\n5 8\n2 1 2\n3 2 0 4\n3 1 8 10\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 12\n3 4 6 8\n3 1 3 4\n2 2 4\n", "output": ["45\n42\n55\n"]}, {"input": "3\n5 8\n3 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 14\n3 1 3 5\n3 4 5 11\n11 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n91\n77\n"]}, {"input": "3\n5 8\n2 0 4\n3 2 3 4\n3 0 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 6 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n42\n35\n"]}, {"input": "3\n5 8\n3 1 0\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 3\n2 1 7\n3 1 3 4\n3 4 5 11\n18 5\n3 1 6 8\n3 3 6 8\n3 0 5 7\n2 2 4\n", "output": ["25\n70\n126\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 0 2\n10 7\n2 0 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 2 3 4\n2 2 4\n", "output": ["32\n63\n35\n"]}, {"input": "3\n5 8\n2 0 4\n3 1 3 4\n3 1 4 6\n2 4 2\n10 7\n2 3 9\n2 1 7\n3 0 3 4\n3 4 5 6\n11 10\n3 1 6 8\n3 3 6 8\n3 2 6 4\n2 2 4\n", "output": ["32\n42\n70\n"]}], "task_id": "codecontest/148", "repair_prompt": ["A rectangle with its opposite corners in (0, 0) and (w, h) and sides parallel to the axes is drawn on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner, and there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom side (y = 0)\n        if k1 >= 2:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        \n        # Top side (y = h)\n        if k2 >= 2:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left side (x = 0)\n        if k3 >= 2:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        \n        # Right side (x = w)\n        if k4 >= 2:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum distances on each side\n        max_x_bottom = x_bottom[-1] - x_bottom[0]\n        max_x_top = x_top[-1] - x_top[0]\n        max_y_left = y_left[-1] - y_left[0]\n        max_y_right = y_right[-1] - y_right[0]\n        \n        # Calculate maximum doubled area\n        max_area = max(max_x_bottom * h, max_x_top * h, max_y_left * w, max_y_right * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Horizontal sides\n        k1 = int(data[index])\n        x1 = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        x2 = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Vertical sides\n        k3 = int(data[index])\n        y1 = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        y2 = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum distances on each side\n        max_horizontal_0 = x1[-1] - x1[0]\n        max_horizontal_h = x2[-1] - x2[0]\n        max_vertical_0 = y1[-1] - y1[0]\n        max_vertical_w = y2[-1] - y2[0]\n        \n        # Calculate maximum doubled area\n        max_area = max(max_horizontal_0 * h, max_horizontal_h * h, max_vertical_0 * w, max_vertical_w * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Check bottom and top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Check left and right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (horizontal_bottom[-1] - horizontal_bottom[0]) * h,\n            (horizontal_top[-1] - horizontal_top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (vertical_left[-1] - vertical_left[0]) * w,\n            (vertical_right[-1] - vertical_right[0]) * w\n        )\n        \n        # The maximum doubled area for this test case\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nt = int(data[index])\nindex += 1\n\ntest_cases = []\nfor _ in range(t):\n    w = int(data[index])\n    h = int(data[index + 1])\n    index += 2\n    \n    k1 = int(data[index])\n    horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n    index += 1 + k1\n    \n    k2 = int(data[index])\n    horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n    index += 1 + k2\n    \n    k3 = int(data[index])\n    vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n    index += 1 + k3\n    \n    k4 = int(data[index])\n    vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n    index += 1 + k4\n    \n    test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n\nresults = max_doubled_area(t, test_cases)\nfor result in results:\n    print(result)\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Read points on the top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Read points on the left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Read points on the right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_doubled_area = 0\n        \n        # Check horizontal sides\n        if len(x_bottom) >= 2:\n            max_doubled_area = max(max_doubled_area, (x_bottom[-1] - x_bottom[0]) * h)\n        if len(x_top) >= 2:\n            max_doubled_area = max(max_doubled_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Check vertical sides\n        if len(y_left) >= 2:\n            max_doubled_area = max(max_doubled_area, (y_left[-1] - y_left[0]) * w)\n        if len(y_right) >= 2:\n            max_doubled_area = max(max_doubled_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_doubled_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom and Top sides\n        if k1 >= 2:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        if k2 >= 2:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        if k3 >= 2:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        if k4 >= 2:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, bottom, top, left, right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (bottom[-1] - bottom[0]) * h,\n            (top[-1] - top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (left[-1] - left[0]) * w,\n            (right[-1] - right[0]) * w\n        )\n        \n        # Determine the maximum doubled area\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k_bottom = int(data[index])\n        bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        k_top = int(data[index])\n        top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        k_left = int(data[index])\n        left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        k_right = int(data[index])\n        right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        test_cases.append((w, h, bottom, top, left, right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom side (y = 0)\n        if k1 >= 2:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        \n        # Top side (y = h)\n        if k2 >= 2:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left side (x = 0)\n        if k3 >= 2:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        \n        # Right side (x = w)\n        if k4 >= 2:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side that are farthest apart for each side of the rectangle.\",\n      \"output\": \"The maximum distance between two points on each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, iterate over each side of the rectangle to find the two points that are farthest apart.\",\n    \"Calculate the maximum possible area of a triangle by considering combinations of two points from the same side and one point from an adjacent side.\",\n    \"For each combination, compute the area of the triangle and keep track of the maximum area found.\",\n    \"Output the doubled maximum area for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom side (y = 0)\n        if k1 >= 2:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        \n        # Top side (y = h)\n        if k2 >= 2:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left side (x = 0)\n        if k3 >= 2:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        \n        # Right side (x = w)\n        if k4 >= 2:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side that are farthest apart for each side of the rectangle.\",\n      \"output\": \"The maximum distance between two points on each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, iterate over each side of the rectangle and find the two points that are farthest apart.\",\n    \"Calculate the maximum possible area of a triangle by considering combinations of two points from the same side and one point from an adjacent side.\",\n    \"For each test case, compute the doubled area of the triangle with the maximum area.\",\n    \"Output the doubled maximum area for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum distances on each side\n        max_x_bottom = x_bottom[-1] - x_bottom[0]\n        max_x_top = x_top[-1] - x_top[0]\n        max_y_left = y_left[-1] - y_left[0]\n        max_y_right = y_right[-1] - y_right[0]\n        \n        # Calculate maximum doubled area\n        max_area = max(max_x_bottom * h, max_x_top * h, max_y_left * w, max_y_right * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 131)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum distances on each side\n        max_x_bottom = x_bottom[-1] - x_bottom[0]\n        max_x_top = x_top[-1] - x_top[0]\n        max_y_left = y_left[-1] - y_left[0]\n        max_y_right = y_right[-1] - y_right[0]\n        \n        # Calculate maximum doubled area\n        max_area = max(max_x_bottom * h, max_x_top * h, max_y_left * w, max_y_right * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side that are farthest apart for each side of the rectangle.\",\n      \"output\": \"The maximum distance between two points on each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum area of such a triangle for each test case.\"\n    },\n    {\n      \"description\": \"Double the calculated maximum area for each test case as the final result.\",\n      \"output\": \"The doubled maximum area for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, iterate over each side of the rectangle to find the two points that are farthest apart.\",\n    \"Calculate the maximum possible area of a triangle by considering combinations of two points from the same side and one point from an adjacent side.\",\n    \"Double the calculated maximum area to get the final result for each test case.\",\n    \"Output the doubled maximum area for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Horizontal sides\n        k1 = int(data[index])\n        x1 = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        k2 = int(data[index])\n        x2 = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Vertical sides\n        k3 = int(data[index])\n        y1 = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        k4 = int(data[index])\n        y2 = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum distances on each side\n        max_horizontal_0 = x1[-1] - x1[0]\n        max_horizontal_h = x2[-1] - x2[0]\n        max_vertical_0 = y1[-1] - y1[0]\n        max_vertical_w = y2[-1] - y2[0]\n        \n        # Calculate maximum doubled area\n        max_area = max(max_horizontal_0 * h, max_horizontal_h * h, max_vertical_0 * w, max_vertical_w * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions w and h.\",\n        \"Read the number of points and their coordinates for the bottom side (y=0).\",\n        \"Read the number of points and their coordinates for the top side (y=h).\",\n        \"Read the number of points and their coordinates for the left side (x=0).\",\n        \"Read the number of points and their coordinates for the right side (x=w).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible doubled area of a triangle for each test case.\",\n      \"steps\": [\n        \"For each test case, identify the two points on the same side that are farthest apart.\",\n        \"Calculate the potential maximum area using these two points and a point from the opposite side.\",\n        \"Repeat the above step for each pair of sides (bottom-top, left-right).\",\n        \"Determine the maximum area from all calculated areas.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum doubled area calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize the program to read input data.\",\n    \"Iterate over each test case to process the rectangle and lattice points.\",\n    \"For each test case, compute the maximum doubled area of a triangle using the identified points.\",\n    \"Store the result for each test case.\",\n    \"Output the stored results.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Check bottom and top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Check left and right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 128)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Check bottom and top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Check left and right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions w and h.\",\n        \"Read the number of points and their coordinates for the bottom side (y=0).\",\n        \"Read the number of points and their coordinates for the top side (y=h).\",\n        \"Read the number of points and their coordinates for the left side (x=0).\",\n        \"Read the number of points and their coordinates for the right side (x=w).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible doubled area of a triangle for each test case.\",\n      \"steps\": [\n        \"For each test case, identify the two points on the same side that are farthest apart.\",\n        \"Calculate the potential maximum area using these two points and a point from the opposite side.\",\n        \"Repeat the above step for each pair of sides (bottom-top, left-right).\",\n        \"Determine the maximum area among all possible triangles for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the doubled maximum area for each test case.\",\n      \"steps\": [\n        \"For each test case, print the calculated doubled maximum area.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data for each test case.\",\n    \"For each test case, calculate the maximum possible doubled area of a triangle using the given points.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 136)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions w and h.\",\n        \"Read the number of points and their coordinates for each of the four sides of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify the pairs of points on each side and calculate potential triangle areas.\",\n      \"steps\": [\n        \"For each side, identify pairs of points that can form a base of a triangle.\",\n        \"For each pair, calculate the potential area of the triangle using a point from another side.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum doubled area of a triangle for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate through all possible pairs of points on each side.\",\n        \"Calculate the area of the triangle formed by these pairs and a point from another side.\",\n        \"Keep track of the maximum doubled area found.\"\n      ]\n    },\n    {\n      \"description\": \"Output the maximum doubled area for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum doubled area calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data for each test case.\",\n    \"For each test case, iterate through pairs of points on each side to form potential triangles.\",\n    \"Calculate the area of each triangle and track the maximum doubled area.\",\n    \"Output the maximum doubled area for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (horizontal_bottom[-1] - horizontal_bottom[0]) * h,\n            (horizontal_top[-1] - horizontal_top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (vertical_left[-1] - vertical_left[0]) * w,\n            (vertical_right[-1] - vertical_right[0]) * w\n        )\n        \n        # The maximum doubled area for this test case\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nt = int(data[index])\nindex += 1\n\ntest_cases = []\nfor _ in range(t):\n    w = int(data[index])\n    h = int(data[index + 1])\n    index += 2\n    \n    k1 = int(data[index])\n    horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n    index += 1 + k1\n    \n    k2 = int(data[index])\n    horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n    index += 1 + k2\n    \n    k3 = int(data[index])\n    vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n    index += 1 + k3\n    \n    k4 = int(data[index])\n    vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n    index += 1 + k4\n    \n    test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n\nresults = max_doubled_area(t, test_cases)\nfor result in results:\n    print(result)\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 94)"}, "Round_1": {"code": "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (horizontal_bottom[-1] - horizontal_bottom[0]) * h,\n            (horizontal_top[-1] - horizontal_top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (vertical_left[-1] - vertical_left[0]) * w,\n            (vertical_right[-1] - vertical_right[0]) * w\n        )\n        \n        # The maximum doubled area for this test case\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nt = int(data[index])\nindex += 1\n\ntest_cases = []\nfor _ in range(t):\n    w = int(data[index])\n    h = int(data[index + 1])\n    index += 2\n    \n    k1 = int(data[index])\n    horizontal_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n    index += 1 + k1\n    \n    k2 = int(data[index])\n    horizontal_top = list(map(int, data[index + 1:index + 1 + k2]))\n    index += 1 + k2\n    \n    k3 = int(data[index])\n    vertical_left = list(map(int, data[index + 1:index + 1 + k3]))\n    index += 1 + k3\n    \n    k4 = int(data[index])\n    vertical_right = list(map(int, data[index + 1:index + 1 + k4]))\n    index += 1 + k4\n    \n    test_cases.append((w, h, horizontal_bottom, horizontal_top, vertical_left, vertical_right))\n\nresults = max_doubled_area(t, test_cases)\nfor result in results:\n    print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions w and h of the rectangle.\",\n        \"Read the number of points and their coordinates for the bottom side (y=0).\",\n        \"Read the number of points and their coordinates for the top side (y=h).\",\n        \"Read the number of points and their coordinates for the left side (x=0).\",\n        \"Read the number of points and their coordinates for the right side (x=w).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible doubled area of a triangle for each test case.\",\n      \"steps\": [\n        \"For each test case, identify the two points on the same side that are farthest apart.\",\n        \"Calculate the potential maximum area using these two points and a point from the opposite side.\",\n        \"Repeat the above step for each pair of sides (bottom-top, left-right).\",\n        \"Determine the maximum area from all calculated areas.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, print the maximum doubled area calculated.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize the program to read input data.\",\n    \"Iterate over each test case to process the rectangle and lattice points.\",\n    \"For each test case, compute the maximum doubled area of a triangle using the identified points.\",\n    \"Store the result for each test case.\",\n    \"Output the stored results.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_area = 0\n        \n        # Bottom and Top sides\n        max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions w and h of the rectangle.\",\n        \"Read the number of points and their coordinates for each of the four sides of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify the pairs of points on each side that can form the base of the triangle.\",\n      \"steps\": [\n        \"For each side, identify all possible pairs of points that can form the base of the triangle.\",\n        \"Ensure that the pairs are valid (i.e., they are not corners).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the area of triangles formed by each pair of points on the same side and a point on a different side.\",\n      \"steps\": [\n        \"For each pair of points on the same side, iterate over points on the other sides to form triangles.\",\n        \"Calculate the area of each triangle using the formula: area = 0.5 * base * height.\",\n        \"Double the area to meet the requirement of outputting the doubled area.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum doubled area for each test case.\",\n      \"steps\": [\n        \"Track the maximum doubled area encountered for each test case.\",\n        \"Compare the areas of all possible triangles and update the maximum as needed.\"\n      ]\n    },\n    {\n      \"description\": \"Output the maximum doubled area for each test case.\",\n      \"steps\": [\n        \"Print the maximum doubled area for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data for each test case.\",\n    \"For each test case, identify valid pairs of points on the same side.\",\n    \"Calculate the doubled area of triangles formed by these pairs and points on other sides.\",\n    \"Track and determine the maximum doubled area for each test case.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Read points on the top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Read points on the left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Read points on the right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_doubled_area = 0\n        \n        # Check horizontal sides\n        if len(x_bottom) >= 2:\n            max_doubled_area = max(max_doubled_area, (x_bottom[-1] - x_bottom[0]) * h)\n        if len(x_top) >= 2:\n            max_doubled_area = max(max_doubled_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Check vertical sides\n        if len(y_left) >= 2:\n            max_doubled_area = max(max_doubled_area, (y_left[-1] - y_left[0]) * w)\n        if len(y_right) >= 2:\n            max_doubled_area = max(max_doubled_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_doubled_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 143)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k_bottom = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        # Read points on the top side (y = h)\n        k_top = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        # Read points on the left side (x = 0)\n        k_left = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        # Read points on the right side (x = w)\n        k_right = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        # Calculate maximum doubled area\n        max_doubled_area = 0\n        \n        # Check horizontal sides\n        if len(x_bottom) >= 2:\n            max_doubled_area = max(max_doubled_area, (x_bottom[-1] - x_bottom[0]) * h)\n        if len(x_top) >= 2:\n            max_doubled_area = max(max_doubled_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Check vertical sides\n        if len(y_left) >= 2:\n            max_doubled_area = max(max_doubled_area, (y_left[-1] - y_left[0]) * w)\n        if len(y_right) >= 2:\n            max_doubled_area = max(max_doubled_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_doubled_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions of the rectangle (w, h).\",\n        \"Read the number of points and their coordinates for each of the four sides of the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify the pairs of points on each side and calculate potential triangle areas.\",\n      \"steps\": [\n        \"For each side, identify pairs of points that can form a base of a triangle.\",\n        \"For each pair, calculate the area of the triangle formed with a point from another side.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum area of a triangle for each test case.\",\n      \"steps\": [\n        \"Compare the areas calculated for all possible triangles in a test case.\",\n        \"Select the maximum area and double it.\"\n      ]\n    },\n    {\n      \"description\": \"Output the doubled maximum area for each test case.\",\n      \"steps\": [\n        \"Print the doubled maximum area for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Initialize a list to store the results for each test case.\",\n    \"Iterate over each test case to process the input and calculate the maximum triangle area.\",\n    \"For each test case, parse the input to extract rectangle dimensions and lattice points.\",\n    \"For each side of the rectangle, identify pairs of points and calculate potential triangle areas with points from other sides.\",\n    \"Determine the maximum area of a triangle for the current test case and double it.\",\n    \"Store the result in the list.\",\n    \"After processing all test cases, output the results.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom and Top sides\n        if k1 >= 2:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        if k2 >= 2:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left and Right sides\n        if k3 >= 2:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        if k4 >= 2:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points for each side.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the dimensions w and h.\",\n        \"Read the number of points and their coordinates for the bottom side (y=0).\",\n        \"Read the number of points and their coordinates for the top side (y=h).\",\n        \"Read the number of points and their coordinates for the left side (x=0).\",\n        \"Read the number of points and their coordinates for the right side (x=w).\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum possible doubled area of a triangle for each test case.\",\n      \"steps\": [\n        \"For each test case, identify the two points on the same side that are farthest apart.\",\n        \"Calculate the potential maximum area using these two points and a point from the opposite side.\",\n        \"Repeat the above step for each pair of opposite sides (horizontal and vertical).\",\n        \"Determine the maximum doubled area from all calculated possibilities.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"Print the doubled maximum area for each test case.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract relevant information for each test case.\",\n    \"For each test case, compute the maximum possible doubled area of a triangle by evaluating pairs of points on the same side and a point from the opposite side.\",\n    \"Output the computed doubled maximum area for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, bottom, top, left, right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (bottom[-1] - bottom[0]) * h,\n            (top[-1] - top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (left[-1] - left[0]) * w,\n            (right[-1] - right[0]) * w\n        )\n        \n        # Determine the maximum doubled area\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k_bottom = int(data[index])\n        bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        k_top = int(data[index])\n        top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        k_left = int(data[index])\n        left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        k_right = int(data[index])\n        right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        test_cases.append((w, h, bottom, top, left, right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 98)"}, "Round_1": {"code": "def max_doubled_area(t, test_cases):\n    results = []\n    for case in test_cases:\n        w, h, bottom, top, left, right = case\n        \n        # Calculate maximum doubled area for horizontal sides\n        max_horizontal_area = max(\n            (bottom[-1] - bottom[0]) * h,\n            (top[-1] - top[0]) * h\n        )\n        \n        # Calculate maximum doubled area for vertical sides\n        max_vertical_area = max(\n            (left[-1] - left[0]) * w,\n            (right[-1] - right[0]) * w\n        )\n        \n        # Determine the maximum doubled area\n        max_area = max(max_horizontal_area, max_vertical_area)\n        results.append(max_area)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        k_bottom = int(data[index])\n        bottom = list(map(int, data[index + 1:index + 1 + k_bottom]))\n        index += 1 + k_bottom\n        \n        k_top = int(data[index])\n        top = list(map(int, data[index + 1:index + 1 + k_top]))\n        index += 1 + k_top\n        \n        k_left = int(data[index])\n        left = list(map(int, data[index + 1:index + 1 + k_left]))\n        index += 1 + k_left\n        \n        k_right = int(data[index])\n        right = list(map(int, data[index + 1:index + 1 + k_right]))\n        index += 1 + k_right\n        \n        test_cases.append((w, h, bottom, top, left, right))\n    \n    results = max_doubled_area(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of the rectangle, and the list of lattice points on each side for each test case.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, identify the two points on the same side that are farthest apart for each side of the rectangle.\",\n      \"output\": \"The maximum distance between two points on each side of the rectangle.\"\n    },\n    {\n      \"description\": \"Calculate the maximum possible area of a triangle formed by choosing two points from the same side and one point from an adjacent side.\",\n      \"output\": \"The maximum doubled area of the triangle for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, iterate over each side of the rectangle to find the two points that are farthest apart.\",\n    \"Calculate the maximum possible area of a triangle by considering combinations of two points from the same side and one point from an adjacent side.\",\n    \"For each combination, compute the area of the triangle and keep track of the maximum area found.\",\n    \"Output the doubled maximum area for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        w = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        \n        # Read points on the bottom side (y = 0)\n        k1 = int(data[index])\n        x_bottom = list(map(int, data[index + 1:index + 1 + k1]))\n        index += 1 + k1\n        \n        # Read points on the top side (y = h)\n        k2 = int(data[index])\n        x_top = list(map(int, data[index + 1:index + 1 + k2]))\n        index += 1 + k2\n        \n        # Read points on the left side (x = 0)\n        k3 = int(data[index])\n        y_left = list(map(int, data[index + 1:index + 1 + k3]))\n        index += 1 + k3\n        \n        # Read points on the right side (x = w)\n        k4 = int(data[index])\n        y_right = list(map(int, data[index + 1:index + 1 + k4]))\n        index += 1 + k4\n        \n        # Calculate maximum doubled area for each side\n        max_area = 0\n        \n        # Bottom side (y = 0)\n        if k1 >= 2:\n            max_area = max(max_area, (x_bottom[-1] - x_bottom[0]) * h)\n        \n        # Top side (y = h)\n        if k2 >= 2:\n            max_area = max(max_area, (x_top[-1] - x_top[0]) * h)\n        \n        # Left side (x = 0)\n        if k3 >= 2:\n            max_area = max(max_area, (y_left[-1] - y_left[0]) * w)\n        \n        # Right side (x = w)\n        if k4 >= 2:\n            max_area = max(max_area, (y_right[-1] - y_right[0]) * w)\n        \n        results.append(max_area)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 197, "prompt": "A rectangle with its opposite corners in (0, 0) and (w, h) and sides parallel to the axes is drawn on a plane.\n\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner, and there are at least two points on every side of a rectangle.\n\nYour task is to choose three points in such a way that: \n\n  * exactly two of them belong to the same side of a rectangle; \n  * the area of a triangle formed by them is maximum possible. \n\nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers w and h (3 \u2264 w, h \u2264 10^6) \u2014 the coordinates of the corner of a rectangle.\n\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers x_1 < x_2 < ... < x_k (0 < x_i < w) \u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\n\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2 \u2264 k \u2264 2 \u22c5 10^5) \u2014 the number of points. Then, k integers y_1 < y_2 < ... < y_k (0 < y_i < h) \u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\n\nThe total number of points on all sides in all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase print a single integer \u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\n\nExample\n\nInput\n\n\n3\n5 8\n2 1 2\n3 2 3 4\n3 1 4 6\n2 4 5\n10 7\n2 3 9\n2 1 7\n3 1 3 4\n3 4 5 6\n11 5\n3 1 6 8\n3 3 6 8\n3 1 3 4\n2 2 4\n\n\nOutput\n\n\n25\n42\n35\n\nNote\n\nThe points in the first testcase of the example: \n\n  * (1, 0), (2, 0); \n  * (2, 8), (3, 8), (4, 8); \n  * (0, 1), (0, 4), (0, 6); \n  * (5, 4), (5, 5). \n\n\n\nThe largest triangle is formed by points (0, 1), (0, 6) and (5, 4) \u2014 its area is 25/2. Thus, the doubled area is 25. Two points that are on the same side are: (0, 1) and (0, 6).", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 83}
