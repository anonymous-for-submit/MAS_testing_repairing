{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is. They also have strict rules on when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You should consider edge cases, such as when N is less than 5 or when there are no friendships at all.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    from itertools import combinations\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    # Create adjacency list for friendships\n    friends = {i: set() for i in range(1, N + 1)}\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a clique of size 5\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            # Check all combinations of 4 friends\n            for combo in combinations(friends[person], 4):\n                if all(friends[friend].issuperset(combo) for friend in combo):\n                    print(person, *combo)\n                    return\n    \n    # Check for an independent set of size 5\n    all_people = set(range(1, N + 1))\n    for combo in combinations(all_people, 5):\n        if all(combo[j] not in friends[combo[i]] for i in range(5) for j in range(i + 1, 5)):\n            print(*combo)\n            return\n    \n    # If no valid party found\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.append((U, V))\n        index += 2\n    \n    if M == 0:\n        if N >= 5:\n            print(1, 2, 3, 4, 5)\n        else:\n            print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique():\n        for node in graph:\n            neighbors = graph[node]\n            if len(neighbors) >= 4:\n                for a in neighbors:\n                    for b in neighbors:\n                        if a != b and b in graph[a]:\n                            for c in neighbors:\n                                if c != a and c != b and c in graph[a] and c in graph[b]:\n                                    for d in neighbors:\n                                        if d != a and d != b and d != c and d in graph[a] and d in graph[b] and d in graph[c]:\n                                            return [node, a, b, c, d]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set():\n        all_people = set(range(1, N + 1))\n        for node in graph:\n            non_neighbors = all_people - graph[node] - {node}\n            if len(non_neighbors) >= 4:\n                non_neighbors = list(non_neighbors)\n                return [node] + non_neighbors[:4]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(*clique)\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(*independent_set)\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    if M == 0:\n        if N >= 5:\n            print(1, 2, 3, 4, 5)\n        else:\n            print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(graph[u]) >= 4:\n                neighbors = list(graph[u])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [u, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(graph[u]) < N - 1:\n                non_friends -= graph[u]\n                non_friends.discard(u)\n                if len(non_friends) >= 4:\n                    return [u] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    clique = find_cl\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    if M == 0:\n        # If there are no friendships, we can pick any 5 people\n        print(1, 2, 3, 4, 5)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of 5 nodes\n    def find_clique():\n        for node in graph:\n            if len(graph[node]) >= 4:\n                # Check if this node and its neighbors form a clique\n                neighbors = list(graph[node])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        if neighbors[j] not in graph[neighbors[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    return [node] + neighbors[:4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for node in graph:\n            if len(graph[node]) < N - 1:\n                non_friends -= graph[node]\n                non_friends.remove(node)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends.add(node)\n                non_friends |= graph[node]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(*clique)\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(*independent_set)\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friendships[a]:\n                if b <= a:\n                    continue\n                for c in friendships[a].intersection(friendships[b]):\n                    if c <= b:\n                        continue\n                    for d in friendships[a].intersection(friendships[b], friendships[c]):\n                        if d <= c:\n                            continue\n                        for e in friendships[a].intersection(friendships[b], friendships[c], friendships[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            if person in non_friends:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends.add(person)\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    people = range(1, N + 1)\n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    friendships = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        index += 2\n        friendships[U].add(V)\n        friendships[V].add(U)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                candidates = list(friendships[person])\n                for i in range(len(candidates)):\n                    for j in range(i + 1, len(candidates)):\n                        for k in range(j + 1, len(candidates)):\n                            for l in range(k + 1, len(candidates)):\n                                clique = [person, candidates[i], candidates[j], candidates[k], candidates[l]]\n                                if all(friendships[clique[x]].issuperset(clique) for x in range(5)):\n                                    return clique\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                for c in friends[a].intersection(friends[b]):\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if a in non_friends:\n                non_friends -= friends[a]\n                non_friends.discard(a)\n                if len(non_friends) >= 4:\n                    return [a] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique\n    clique = find_clique()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set\n    independent_set = find_independent_set()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friendships[a]:\n                if b <= a:\n                    continue\n                for c in friendships[a].intersection(friendships[b]):\n                    if c <= b:\n                        continue\n                    for d in friendships[a].intersection(friendships[b], friendships[c]):\n                        if d <= c:\n                            continue\n                        for e in friendships[a].intersection(friendships[b], friendships[c], friendships[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            if person in non_friends:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends.add(person)\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friendships[a]:\n                for c in friendships[a].intersection(friendships[b]):\n                    for d in friendships[a].intersection(friendships[b], friendships[c]):\n                        for e in friendships[a].intersection(friendships[b], friendships[c], friendships[d]):\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes (no edges between them)\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            if person in non_friends:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n        if len(non_friends) >= 5:\n            return list(non_friends)[:5]\n        return None\n    \n    # Check for clique\n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Check for independent set\n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    from itertools import combinations\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    # Create adjacency list for friendships\n    friends = {i: set() for i in range(1, N + 1)}\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a clique of size 5\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            # Check all combinations of 4 friends\n            for combo in combinations(friends[person], 4):\n                if all(friends[friend].issuperset(combo) for friend in combo):\n                    print(person, *combo)\n                    return\n    \n    # Check for an independent set of size 5\n    all_people = set(range(1, N + 1))\n    for combo in combinations(all_people, 5):\n        if all(combo[j] not in friends[combo[i]] for i in range(5) for j in range(i + 1, 5)):\n            print(*combo)\n            return\n    \n    # If no valid party found\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"input\": \"Raw input data\",\n      \"output\": \"Integers N, M and a list of tuples representing friendships\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with 5 people given the constraints.\",\n      \"input\": \"N, M, and the list of friendships\",\n      \"output\": \"Boolean indicating if a party is possible\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where all are friends or none are friends.\",\n      \"input\": \"List of friendships\",\n      \"output\": \"List of 5 integers representing the people at the party or -1 if not possible\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"If N is less than 5, immediately return -1 as it's impossible to have a party.\",\n    \"Create a graph representation of the friendships using an adjacency list.\",\n    \"Check for a clique of size 5 (all friends) by iterating over each person and their friends.\",\n    \"If a clique of size 5 is found, return the list of those 5 people.\",\n    \"If no clique is found, check for an independent set of size 5 (no friends) by iterating over combinations of people.\",\n    \"If an independent set of size 5 is found, return the list of those 5 people.\",\n    \"If neither a clique nor an independent set is found, return -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    from itertools import combinations\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    # Create adjacency list for friendships\n    friends = {i: set() for i in range(1, N + 1)}\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a clique of size 5\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            # Check all combinations of 4 friends\n            for combo in combinations(friends[person], 4):\n                if all(friends[friend].issuperset(combo) for friend in combo):\n                    print(person, *combo)\n                    return\n    \n    # Check for an independent set of size 5\n    all_people = set(range(1, N + 1))\n    for combo in combinations(all_people, 5):\n        if all(combo[j] not in friends[combo[i]] for i in range(5) for j in range(i + 1, 5)):\n            print(*combo)\n            return\n    \n    # If no valid party found\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"input\": \"Raw input data\",\n      \"output\": \"N, M, and a list of tuples representing friendships\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with 5 people given the constraints.\",\n      \"input\": \"N\",\n      \"output\": \"Boolean indicating if a party is possible\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where all are friends with each other.\",\n      \"input\": \"List of friendships\",\n      \"output\": \"List of 5 people or an indication that such a group doesn't exist\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where no two are friends with each other.\",\n      \"input\": \"List of friendships\",\n      \"output\": \"List of 5 people or an indication that such a group doesn't exist\"\n    },\n    {\n      \"description\": \"Determine the output based on the results of the previous subproblems.\",\n      \"input\": \"Results from subproblems 3 and 4\",\n      \"output\": \"5 numbers indicating the people to invite or -1 if no successful party is possible\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"If N is less than 5, immediately output -1 as a party is not possible.\",\n    \"If M is 0, check if N is at least 5 and output any 5 people, otherwise output -1.\",\n    \"Construct a graph representation of the friendships.\",\n    \"Search for a clique of size 5 in the graph (all 5 people are friends with each other).\",\n    \"If a clique is found, output the 5 people.\",\n    \"If no clique is found, search for an independent set of size 5 (no two people are friends with each other).\",\n    \"If an independent set is found, output the 5 people.\",\n    \"If neither a clique nor an independent set is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.append((U, V))\n        index += 2\n    \n    if M == 0:\n        if N >= 5:\n            print(1, 2, 3, 4, 5)\n        else:\n            print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Function to find a clique of size 5\n    def find_clique():\n        for node in graph:\n            neighbors = graph[node]\n            if len(neighbors) >= 4:\n                for a in neighbors:\n                    for b in neighbors:\n                        if a != b and b in graph[a]:\n                            for c in neighbors:\n                                if c != a and c != b and c in graph[a] and c in graph[b]:\n                                    for d in neighbors:\n                                        if d != a and d != b and d != c and d in graph[a] and d in graph[b] and d in graph[c]:\n                                            return [node, a, b, c, d]\n        return None\n    \n    # Function to find an independent set of size 5\n    def find_independent_set():\n        all_people = set(range(1, N + 1))\n        for node in graph:\n            non_neighbors = all_people - graph[node] - {node}\n            if len(non_neighbors) >= 4:\n                non_neighbors = list(non_neighbors)\n                return [node] + non_neighbors[:4]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(*clique)\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(*independent_set)\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with exactly 5 people.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to have a party.\",\n        \"If M == 0, check if N >= 5 to return any 5 people, else return -1.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if there exists a group of 5 people where all are friends or none are friends.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists for friendships.\",\n        \"Check for a complete subgraph (clique) of size 5 where all nodes are connected.\",\n        \"Check for an independent set of size 5 where no nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the 5 people.\",\n        \"If no configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Check if a party with 5 people is possible based on N.\",\n    \"Construct a graph using the friendship pairs.\",\n    \"Search for a clique of size 5 in the graph.\",\n    \"Search for an independent set of size 5 in the graph.\",\n    \"Output the result based on the search findings.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    if M == 0:\n        if N >= 5:\n            print(1, 2, 3, 4, 5)\n        else:\n            print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(graph[u]) >= 4:\n                neighbors = list(graph[u])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [u, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(graph[u]) < N - 1:\n                non_friends -= graph[u]\n                non_friends.discard(u)\n                if len(non_friends) >= 4:\n                    return [u] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    clique = find_cl", "report": "The compilation output of the preceding code is: name 'find_cl' is not defined"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    if M == 0:\n        if N >= 5:\n            print(1, 2, 3, 4, 5)\n        else:\n            print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for u in range(1, N + 1):\n            if len(graph[u]) >= 4:\n                neighbors = list(graph[u])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [u, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for u in range(1, N + 1):\n            if len(graph[u]) < N - 1:\n                non_friends -= graph[u]\n                non_friends.discard(u)\n                if len(non_friends) >= 4:\n                    return [u] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    clique = find_cl"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all friends or no friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"If M == 0, check if N >= 5 and return any 5 people as they are all non-friends.\"\n      ]\n    },\n    {\n      \"description\": \"Identify a group of 5 people who are either all friends or all non-friends.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists for friendships.\",\n        \"Check for a complete subgraph of 5 nodes (clique) where all nodes are friends.\",\n        \"Check for an independent set of 5 nodes where no nodes are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Handle edge cases where N < 5 or M == 0.\",\n    \"Construct a graph using adjacency lists to represent friendships.\",\n    \"Search for a clique of 5 nodes or an independent set of 5 nodes.\",\n    \"Output the result based on the search findings.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = []\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships.append((u, v))\n        index += 2\n    \n    if M == 0:\n        # If there are no friendships, we can pick any 5 people\n        print(1, 2, 3, 4, 5)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of 5 nodes\n    def find_clique():\n        for node in graph:\n            if len(graph[node]) >= 4:\n                # Check if this node and its neighbors form a clique\n                neighbors = list(graph[node])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        if neighbors[j] not in graph[neighbors[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    return [node] + neighbors[:4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for node in graph:\n            if len(graph[node]) < N - 1:\n                non_friends -= graph[node]\n                non_friends.remove(node)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends.add(node)\n                non_friends |= graph[node]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(*clique)\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(*independent_set)\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all friends or no friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"Create a graph representation of friendships using adjacency lists.\",\n        \"Check for a complete subgraph of 5 nodes (clique) where all nodes are friends.\",\n        \"Check for an independent set of 5 nodes where no nodes are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the checks.\",\n      \"steps\": [\n        \"If a complete subgraph of 5 nodes is found, output the node numbers.\",\n        \"If an independent set of 5 nodes is found, output the node numbers.\",\n        \"If neither is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Check if N is less than 5; if so, output -1.\",\n    \"Construct a graph using adjacency lists to represent friendships.\",\n    \"Search for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Search for an independent set of 5 nodes in the graph.\",\n    \"Output the node numbers if a successful party configuration is found; otherwise, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friendships[a]:\n                if b <= a:\n                    continue\n                for c in friendships[a].intersection(friendships[b]):\n                    if c <= b:\n                        continue\n                    for d in friendships[a].intersection(friendships[b], friendships[c]):\n                        if d <= c:\n                            continue\n                        for e in friendships[a].intersection(friendships[b], friendships[c], friendships[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            if person in non_friends:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends.add(person)\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"input\": \"Raw input data\",\n      \"output\": \"Integers N, M and a list of tuples representing friendships\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with exactly 5 people.\",\n      \"input\": \"Integer N\",\n      \"output\": \"Boolean indicating if a party is possible\"\n    },\n    {\n      \"description\": \"Identify all possible combinations of 5 people from the list of N people.\",\n      \"input\": \"Integer N\",\n      \"output\": \"List of all possible combinations of 5 people\"\n    },\n    {\n      \"description\": \"For each combination of 5 people, check if they are all friends with each other or if no two of them are friends.\",\n      \"input\": \"List of combinations of 5 people, list of friendships\",\n      \"output\": \"List of successful party combinations\"\n    },\n    {\n      \"description\": \"Determine if there is at least one successful party combination and output the result.\",\n      \"input\": \"List of successful party combinations\",\n      \"output\": \"5 numbers indicating a successful party or -1 if none exist\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendships.\",\n    \"Check if N is less than 5. If so, print -1 and exit.\",\n    \"Generate all possible combinations of 5 people from the list of N people.\",\n    \"For each combination, check if all 5 people are friends with each other or if no two are friends.\",\n    \"If a successful party combination is found, print the combination and exit.\",\n    \"If no successful party combination is found after checking all possibilities, print -1.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    people = range(1, N + 1)\n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 80)"}, "Round_1": {"code": "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    # Generate all combinations of 5 people\n    people = range(1, N + 1)\n    for combo in combinations(people, 5):\n        all_friends = True\n        no_friends = True\n        \n        # Check if all are friends or none are friends\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if (combo[i], combo[j]) in friendships:\n                    no_friends = False\n                else:\n                    all_friends = False\n        \n        if all_friends or no_friends:\n            print(' '.join(map(str, combo)))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all friends or no friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"Create a graph representation of friendships using adjacency lists or sets.\",\n        \"Check for a complete subgraph of 5 nodes (clique) where all nodes are friends.\",\n        \"Check for an independent set of 5 nodes where no nodes are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the checks.\",\n      \"steps\": [\n        \"If a complete subgraph of 5 nodes is found, output the node numbers.\",\n        \"If an independent set of 5 nodes is found, output the node numbers.\",\n        \"If neither is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Check if N is less than 5; if so, output -1.\",\n    \"Construct a graph representation of friendships.\",\n    \"Search for a complete subgraph of 5 nodes (clique).\",\n    \"Search for an independent set of 5 nodes.\",\n    \"Output the node numbers if a successful party configuration is found, otherwise output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    friendships = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        index += 2\n        friendships[U].add(V)\n        friendships[V].add(U)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                candidates = list(friendships[person])\n                for i in range(len(candidates)):\n                    for j in range(i + 1, len(candidates)):\n                        for k in range(j + 1, len(candidates)):\n                            for l in range(k + 1, len(candidates)):\n                                clique = [person, candidates[i], candidates[j], candidates[k], candidates[l]]\n                                if all(friendships[clique[x]].issuperset(clique) for x in range(5)):\n                                    return clique\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"details\": \"Read the first line to get N and M. Then read the next M lines to get the pairs of friends.\"\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all attendees being friends.\",\n      \"details\": \"Identify if there exists a complete subgraph of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Check if a successful party is possible with no attendees being friends.\",\n      \"details\": \"Identify if there exists an independent set of 5 nodes in the graph.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where N < 5 or M = 0, where a successful party is impossible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendship pairs.\",\n    \"If N < 5, immediately output -1 as a successful party is impossible.\",\n    \"Construct a graph representation using adjacency lists or matrices based on the friendship pairs.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph. If found, output the nodes.\",\n    \"Check for an independent set of 5 nodes in the graph. If found, output the nodes.\",\n    \"If neither a clique nor an independent set of 5 nodes is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friends[a]:\n                for c in friends[a].intersection(friends[b]):\n                    for d in friends[a].intersection(friends[b], friends[c]):\n                        for e in friends[a].intersection(friends[b], friends[c], friends[d]):\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for a in range(1, N + 1):\n            if a in non_friends:\n                non_friends -= friends[a]\n                non_friends.discard(a)\n                if len(non_friends) >= 4:\n                    return [a] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique\n    clique = find_clique()\n    if clique:\n        print(\" \".join(map(str, clique)))\n        return\n    \n    # Try to find an independent set\n    independent_set = find_independent_set()\n    if independent_set:\n        print(\" \".join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all friends or no friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"Create a graph representation of friendships using adjacency lists.\",\n        \"Check for a complete subgraph of 5 nodes (clique) where all nodes are friends.\",\n        \"Check for an independent set of 5 nodes where no nodes are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the checks.\",\n      \"steps\": [\n        \"If a complete subgraph of 5 nodes is found, output the node numbers.\",\n        \"If an independent set of 5 nodes is found, output the node numbers.\",\n        \"If neither is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Check if N is less than 5; if so, output -1.\",\n    \"Construct a graph using adjacency lists to represent friendships.\",\n    \"Search for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Search for an independent set of 5 nodes in the graph.\",\n    \"Output the node numbers if a successful party configuration is found, otherwise output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friendships[a]:\n                if b <= a:\n                    continue\n                for c in friendships[a].intersection(friendships[b]):\n                    if c <= b:\n                        continue\n                    for d in friendships[a].intersection(friendships[b], friendships[c]):\n                        if d <= c:\n                            continue\n                        for e in friendships[a].intersection(friendships[b], friendships[c], friendships[d]):\n                            if e <= d:\n                                continue\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            if person in non_friends:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends.add(person)\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"details\": \"Read the first line to get N and M. Then read the next M lines to get the pairs of friends.\"\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all attendees being friends.\",\n      \"details\": \"Identify if there exists a complete subgraph of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Check if a successful party is possible with no attendees being friends.\",\n      \"details\": \"Identify if there exists a set of 5 nodes with no edges between them in the friendship graph.\"\n    },\n    {\n      \"description\": \"Handle edge cases.\",\n      \"details\": \"Consider cases where N < 5 or M = 0, and return -1 immediately.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendship pairs.\",\n    \"If N < 5, print -1 and exit as it's impossible to have a party.\",\n    \"If M = 0, check if N >= 5 and print any 5 numbers from 1 to N as they are all non-friends.\",\n    \"Construct a graph representation using adjacency lists or matrices based on the friendship pairs.\",\n    \"Check for a complete subgraph of 5 nodes (clique) in the graph. If found, print the nodes and exit.\",\n    \"Check for an independent set of 5 nodes (no edges between them) in the graph. If found, print the nodes and exit.\",\n    \"If neither condition is met, print -1 indicating a successful party is not possible.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for a in range(1, N + 1):\n            for b in friendships[a]:\n                for c in friendships[a].intersection(friendships[b]):\n                    for d in friendships[a].intersection(friendships[b], friendships[c]):\n                        for e in friendships[a].intersection(friendships[b], friendships[c], friendships[d]):\n                            return [a, b, c, d, e]\n        return None\n    \n    # Check for an independent set of 5 nodes (no edges between them)\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(non_friends) < 5:\n                break\n            if person in non_friends:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n        if len(non_friends) >= 5:\n            return list(non_friends)[:5]\n        return None\n    \n    # Check for clique\n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Check for independent set\n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"input\": \"Raw input data\",\n      \"output\": \"Integers N, M and a list of tuples representing friendships\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with 5 people given the constraints.\",\n      \"input\": \"N, M, and the list of friendships\",\n      \"output\": \"Boolean indicating if a party is possible\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where all are friends or none are friends.\",\n      \"input\": \"List of friendships\",\n      \"output\": \"List of 5 integers representing the people at the party or -1 if not possible\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"If N is less than 5, immediately return -1 as it's impossible to have a party.\",\n    \"Create a graph representation of the friendships using an adjacency list.\",\n    \"Check for a clique of size 5 (all friends) by iterating over each person and their friends.\",\n    \"If a clique of size 5 is found, return the list of those 5 people.\",\n    \"If no clique is found, check for an independent set of size 5 (no friends) by iterating over combinations of people.\",\n    \"If an independent set of size 5 is found, return the list of those 5 people.\",\n    \"If neither a clique nor an independent set is found, return -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    from itertools import combinations\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    # Create adjacency list for friendships\n    friends = {i: set() for i in range(1, N + 1)}\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a clique of size 5\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            # Check all combinations of 4 friends\n            for combo in combinations(friends[person], 4):\n                if all(friends[friend].issuperset(combo) for friend in combo):\n                    print(person, *combo)\n                    return\n    \n    # Check for an independent set of size 5\n    all_people = set(range(1, N + 1))\n    for combo in combinations(all_people, 5):\n        if all(combo[j] not in friends[combo[i]] for i in range(5) for j in range(i + 1, 5)):\n            print(*combo)\n            return\n    \n    # If no valid party found\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 241, "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is. They also have strict rules on when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You should consider edge cases, such as when N is less than 5 or when there are no friendships at all.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 181}
