{"name": "1579_B. Shifting Sort", "description": "The new generation external memory contains an array of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "tags": ["implementation", "sortings"], "difficulty": 8, "id": 1579, "sample_io": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}], "test_list": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["0\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 2 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 2 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 3 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 1 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 8 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n4 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 0 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 0\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n0 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 1 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n1 28 -1 4 5\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 2 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 5 0\n4\n0 6 1 3\n5\n2 5 1 7 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 4 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n4 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 5\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 7 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 2\n3\n0 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n0 4 0\n4\n0 9 0 3\n5\n1 6 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 1 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 4 3\n", "output": ["0\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n0 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["0\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n1 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 -1\n4\n-1 6 1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 1 -1 3\n5\n0 5 0 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 2 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n0\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 6 3\n", "output": ["0\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 2\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 1\n3\n-2 2 0\n4\n3 8 1 6\n5\n2 5 1 6 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 0 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 5 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 5 4\n2 4 2\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 2 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 2 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 1 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 2 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 8 2 4 1\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 2\n4\n2 18 -1 3\n5\n0 -1 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n2\n1 2 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 8 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 0 3\n5\n2 5 1 4 6\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 -1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n2 1 3\n4\n1 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n1 2 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 2 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 0 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 2 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 3 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 2\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 1\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n0 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 -1\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 4 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 11 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 7 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 6\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 12 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 14 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 6 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}], "task_id": "codecontest/14", "repair_prompt": ["The new generation external memory comprises an array of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you substitute the segment a[l \u2026 r] with its cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the specified array a using not more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, array))\n        index += 2\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    actions = []\n    \n    if is_sorted(array):\n        return actions\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            for j in range(i + 1, n):\n                if array[j] == sorted_array[i]:\n                    l, r = i, j\n                    d = 1\n                    array = cyclic_shift(array, l, r, d)\n                    actions.append((l + 1, r + 1, d))\n                    break\n    \n    return actions\n\ndef format_output(test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = sort_with_cyclic_shifts(n, array)\n        results.append(f\"{len(actions)}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    return \"\\n\".join(results)\n\ndef main():\n    test_cases = parse_input()\n    output = format_output(test_cases)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d on the segment arr[l...r]\n    segment = arr[l-1:r]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l-1:r] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return 0, actions\n    \n    # Strategy to sort the array using cyclic shifts\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            # Find the correct position of arr[i] in the sorted array\n            correct_pos = sorted_arr.index(arr[i], i)\n            if correct_pos > i:\n                # Perform a cyclic shift to move arr[i] to its correct position\n                cyclic_shift(arr, i+1, correct_pos+1, correct_pos-i)\n                actions.append((i+1, correct_pos+1, correct_pos-i))\n    \n    return len(actions), actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        k, actions = sort_with_cyclic_shifts(n, arr)\n        results.append(f\"{k}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        actions = []\n        \n        # If the array is already sorted, no actions are needed\n        if a == sorted(a):\n            results.append((0, []))\n            continue\n        \n        # Strategy: Use cyclic shifts to sort the array\n        # This is a simple strategy that may not be optimal but works within the constraints\n        for i in range(n):\n            min_index = i\n            for j in range(i + 1, n):\n                if a[j] < a[min_index]:\n                    min_index = j\n            \n            if min_index != i:\n                # Perform a cyclic shift to bring the minimum element to the front\n                l = i + 1\n                r = min_index + 1\n                d = min_index - i\n                a[i:r] = a[i+d:r] + a[i:i+d]\n                actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # Simple strategy: bubble sort-like approach using cyclic shifts\n        for i in range(n):\n            for j in range(n - 1):\n                if a[j] > a[j + 1]:\n                    # Perform a cyclic shift on the segment [j+1, j+2]\n                    l = j + 1\n                    r = j + 2\n                    d = 1\n                    a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, array))\n        index += 2\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    operations = []\n    \n    if is_sorted(array):\n        return operations\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            # Find the correct position of array[i] in sorted_array\n            correct_pos = sorted_array.index(array[i], i)\n            \n            # Perform cyclic shift to move array[i] to its correct position\n            if correct_pos > i:\n                l = i\n                r = correct_pos\n                d = r - l\n                array = cyclic_shift(array, l, r, d)\n                operations.append((l + 1, r + 1, d))\n    \n    return operations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, array in test_cases:\n        operations = sort_with_cyclic_shifts(n, array)\n        results.append((len(operations), operations))\n    \n    for k, ops in results:\n        print(k)\n        for op in ops:\n            print(*op)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l:r+1] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return 0, actions\n    \n    # Simple strategy: bubble sort-like approach using cyclic shifts\n    for i in range(n):\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[j-1]:\n                # Perform a cyclic shift to swap arr[j] and arr[j-1]\n                cyclic_shift(arr, j-1, j, 1)\n                actions.append((j, j+1, 1))\n    \n    return len(actions), actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        k, actions = sort_with_cyclic_shifts(n, arr)\n        results.append((k, actions))\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    operations = []\n    \n    if is_sorted(array):\n        return operations\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            for j in range(i + 1, n):\n                if array[j] == sorted_array[i]:\n                    l, r = i, j\n                    d = 1\n                    array = cyclic_shift(array, l, r, d)\n                    operations.append((l + 1, r + 1, d))\n                    break\n    \n    return operations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, array in test_cases:\n        operations = sort_with_cyclic_shifts(n, array)\n        results.append((len(operations), operations))\n    \n    for k, operations in results:\n        print(k)\n        for l, r, d in operations:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the correct position of a[i] in the sorted array\n                correct_pos = sorted_a.index(a[i], i)\n                \n                # Perform a cyclic shift to move a[i] to its correct position\n                if correct_pos > i:\n                    l = i + 1\n                    r = correct_pos + 1\n                    d = correct_pos - i\n                    a[i:r] = a[i+d:r] + a[i:i+d]\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d positions on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l:r+1] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return actions  # Already sorted, no actions needed\n    \n    # Simple strategy: bubble sort-like approach using cyclic shifts\n    for i in range(n):\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[j-1]:\n                # Perform a cyclic shift to swap arr[j] and arr[j-1]\n                cyclic_shift(arr, j-1, j, 1)\n                actions.append((j, j+1, 1))\n    \n    return actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        actions = sort_with_cyclic_shifts(n, arr)\n        results.append((len(actions), actions))\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        sorted_a = sorted(a)\n        actions = []\n        \n        if a == sorted_a:\n            results.append((0, actions))\n            continue\n        \n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the segment that needs to be shifted\n                l = i + 1\n                r = a.index(sorted_a[i], l - 1) + 1\n                d = r - l\n                \n                # Perform the cyclic shift\n                segment = a[l-1:r]\n                shifted_segment = segment[d:] + segment[:d]\n                a[l-1:r] = shifted_segment\n                \n                actions.append((l, r, d))\n                \n                if a == sorted_a:\n                    break\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, array))\n        index += 2\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    actions = []\n    \n    if is_sorted(array):\n        return actions\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            for j in range(i + 1, n):\n                if array[j] == sorted_array[i]:\n                    l, r = i, j\n                    d = 1\n                    array = cyclic_shift(array, l, r, d)\n                    actions.append((l + 1, r + 1, d))\n                    break\n    \n    return actions\n\ndef format_output(test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = sort_with_cyclic_shifts(n, array)\n        results.append(f\"{len(actions)}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    return \"\\n\".join(results)\n\ndef main():\n    test_cases = parse_input()\n    output = format_output(test_cases)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"output\": \"A list of test cases, where each test case contains the length of the array and the array elements.\"\n    },\n    {\n      \"description\": \"Implement a function to determine if an array is already sorted.\",\n      \"output\": \"A boolean value indicating whether the array is sorted.\"\n    },\n    {\n      \"description\": \"Develop a function to perform a cyclic shift on a segment of the array. This function should take the array, indices l and r, and offset d as input and return the modified array.\",\n      \"output\": \"The array after performing the cyclic shift on the specified segment.\"\n    },\n    {\n      \"description\": \"Create a strategy to sort the array using cyclic shifts. This involves determining the segments to shift and the offsets required to sort the array in no more than n shifts.\",\n      \"output\": \"A list of actions (l, r, d) that describe the cyclic shifts needed to sort the array.\"\n    },\n    {\n      \"description\": \"Format the output for each test case, including the number of actions and the details of each action.\",\n      \"output\": \"Formatted output for each test case, ready to be printed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a list of test cases.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 and an empty sequence of actions.\",\n    \"If the array is not sorted, apply the sorting strategy to determine the necessary cyclic shifts.\",\n    \"Use the cyclic shift function to perform the shifts and track the actions taken.\",\n    \"Format the results for each test case, including the number of actions and the details of each action.\",\n    \"Print the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, array))\n        index += 2\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    actions = []\n    \n    if is_sorted(array):\n        return actions\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            for j in range(i + 1, n):\n                if array[j] == sorted_array[i]:\n                    l, r = i, j\n                    d = 1\n                    array = cyclic_shift(array, l, r, d)\n                    actions.append((l + 1, r + 1, d))\n                    break\n    \n    return actions\n\ndef format_output(test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = sort_with_cyclic_shifts(n, array)\n        results.append(f\"{len(actions)}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    return \"\\n\".join(results)\n\ndef main():\n    test_cases = parse_input()\n    output = format_output(test_cases)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n for the length of the array and then read the array a of n integers.\"\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"details\": \"For each test case, check if the array a is already sorted in non-decreasing order.\"\n    },\n    {\n      \"description\": \"Implement a method to perform a cyclic shift on a segment of the array.\",\n      \"details\": \"Create a function that takes parameters l, r, and d, and performs a cyclic shift to the left by d on the segment a[l...r].\"\n    },\n    {\n      \"description\": \"Develop a strategy to sort the array using cyclic shifts.\",\n      \"details\": \"Design an algorithm that uses at most n cyclic shifts to sort the array. This could involve identifying unsorted segments and applying cyclic shifts to move elements into their correct positions.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the number of cyclic shifts k used, followed by k lines detailing the parameters l, r, and d for each shift.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the integer n and the array a of n integers.\",\n    \"  b. Check if the array a is already sorted. If yes, output k = 0.\",\n    \"  c. If not sorted, apply the cyclic shift strategy to sort the array.\",\n    \"  d. For each shift performed, record the parameters l, r, and d.\",\n    \"  e. Output the number of shifts k and the details of each shift.\",\n    \"Ensure the total number of shifts does not exceed n for any test case.\"\n  ]\n}\n```", "Round_0": {"code": "def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d on the segment arr[l...r]\n    segment = arr[l-1:r]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l-1:r] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return 0, actions\n    \n    # Strategy to sort the array using cyclic shifts\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            # Find the correct position of arr[i] in the sorted array\n            correct_pos = sorted_arr.index(arr[i])\n            if correct_pos > i:\n                # Perform a cyclic shift to move arr[i] to its correct position\n                cyclic_shift(arr, i+1, correct_pos+1, correct_pos-i)\n                actions.append((i+1, correct_pos+1, correct_pos-i))\n    \n    return len(actions), actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        k, actions = sort_with_cyclic_shifts(n, arr)\n        results.append(f\"{k}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: sort_with_cyclic_shifts() missing 2 required positional arguments: 'n' and 'arr'"}, "Round_1": {"code": "def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d on the segment arr[l...r]\n    segment = arr[l-1:r]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l-1:r] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return 0, actions\n    \n    # Strategy to sort the array using cyclic shifts\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            # Find the correct position of arr[i] in the sorted array\n            correct_pos = sorted_arr.index(arr[i], i)\n            if correct_pos > i:\n                # Perform a cyclic shift to move arr[i] to its correct position\n                cyclic_shift(arr, i+1, correct_pos+1, correct_pos-i)\n                actions.append((i+1, correct_pos+1, correct_pos-i))\n    \n    return len(actions), actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        k, actions = sort_with_cyclic_shifts(n, arr)\n        results.append(f\"{k}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"details\": \"Read the integer t from the first line, then for each test case, read the integer n and the array of integers a.\"\n    },\n    {\n      \"description\": \"Implement a function to perform cyclic shifts on a segment of an array.\",\n      \"details\": \"Given indices l, r, and offset d, shift the segment a[l...r] to the left by d positions.\"\n    },\n    {\n      \"description\": \"Determine the sequence of cyclic shifts needed to sort the array.\",\n      \"details\": \"Develop a strategy to sort the array using cyclic shifts, ensuring the number of shifts does not exceed n.\"\n    },\n    {\n      \"description\": \"Format the output according to the specified requirements.\",\n      \"details\": \"For each test case, output the number of shifts k followed by k lines describing each shift in the format 'l r d'.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, check if the array is already sorted. If sorted, output k = 0.\",\n    \"If the array is not sorted, apply a sorting strategy using cyclic shifts:\",\n    \"  - Identify segments that can be shifted to move elements into their correct positions.\",\n    \"  - Perform cyclic shifts on these segments, keeping track of the number of shifts.\",\n    \"  - Ensure the number of shifts does not exceed n.\",\n    \"Output the number of shifts and the details of each shift for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        actions = []\n        \n        # If the array is already sorted, no actions are needed\n        if a == sorted(a):\n            results.append((0, []))\n            continue\n        \n        # Strategy: Use cyclic shifts to sort the array\n        # This is a simple strategy that may not be optimal but works within the constraints\n        for i in range(n):\n            min_index = i\n            for j in range(i + 1, n):\n                if a[j] < a[min_index]:\n                    min_index = j\n            \n            if min_index != i:\n                # Perform a cyclic shift to bring the minimum element to the front\n                l = i + 1\n                r = min_index + 1\n                d = min_index - i\n                a[i:r] = a[i+d:r] + a[i:i+d]\n                actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read the integer n for the length of the array and then read the array a of n integers.\"\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"details\": \"For each test case, check if the array a is already sorted in non-decreasing order.\"\n    },\n    {\n      \"description\": \"Implement a method to perform a cyclic shift on a segment of the array.\",\n      \"details\": \"Given indices l, r, and offset d, perform a cyclic shift to the left by d on the segment a[l...r].\"\n    },\n    {\n      \"description\": \"Develop a strategy to sort the array using cyclic shifts.\",\n      \"details\": \"Design a sequence of cyclic shifts that sorts the array a in non-decreasing order. Ensure the number of shifts does not exceed n.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"For each test case, output the number of shifts k and the details of each shift in the format 'l r d'. If the array is already sorted, output k = 0.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases t.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Read the integer n and the array a of n integers.\",\n    \"  b. Check if the array a is already sorted. If yes, output k = 0.\",\n    \"  c. If not sorted, determine a sequence of cyclic shifts to sort the array.\",\n    \"  d. Implement the cyclic shift function to modify the array as needed.\",\n    \"  e. Output the number of shifts k and the details of each shift.\",\n    \"Ensure the total number of shifts for each test case does not exceed n.\"\n  ]\n}\n```", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # Simple strategy: bubble sort-like approach using cyclic shifts\n        for i in range(n):\n            for j in range(n - 1):\n                if a[j] > a[j + 1]:\n                    # Perform a cyclic shift on the segment [j+1, j+2]\n                    l = j + 1\n                    r = j + 2\n                    d = 1\n                    a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"output\": \"A list of test cases, where each test case contains the length of the array and the array elements.\"\n    },\n    {\n      \"description\": \"Implement a function to determine if an array is already sorted.\",\n      \"output\": \"A boolean value indicating whether the array is sorted.\"\n    },\n    {\n      \"description\": \"Develop a function to perform a cyclic shift on a segment of the array given the indices l, r, and offset d.\",\n      \"output\": \"The array with the specified segment cyclically shifted.\"\n    },\n    {\n      \"description\": \"Create a strategy to sort the array using cyclic shifts, ensuring that the number of shifts does not exceed the length of the array.\",\n      \"output\": \"A sequence of operations (l, r, d) that sorts the array.\"\n    },\n    {\n      \"description\": \"Format the output to display the number of operations and the details of each operation for each test case.\",\n      \"output\": \"Formatted output for each test case, showing the number of operations and the operations themselves.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format containing the number of test cases and the details of each test case.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 operations.\",\n    \"If the array is not sorted, apply a sorting strategy using cyclic shifts. This involves identifying segments of the array that can be shifted to move elements into their correct positions.\",\n    \"Use the cyclic shift function to perform the necessary shifts on the array, keeping track of each operation.\",\n    \"Ensure that the number of operations does not exceed the length of the array.\",\n    \"Output the number of operations and the details of each operation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, array))\n        index += 2\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    operations = []\n    \n    if is_sorted(array):\n        return operations\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            # Find the correct position of array[i] in sorted_array\n            correct_pos = sorted_array.index(array[i])\n            \n            # Perform cyclic shift to move array[i] to its correct position\n            if correct_pos > i:\n                l = i\n                r = correct_pos\n                d = r - l\n                array = cyclic_shift(array, l, r, d)\n                operations.append((l + 1, r + 1, d))\n    \n    return operations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, array in test_cases:\n        operations = sort_with_cyclic_shifts(n, array)\n        results.append((len(operations), operations))\n    \n    for k, ops in results:\n        print(k)\n        for op in ops:\n            print(*op)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: sort_with_cyclic_shifts() missing 2 required positional arguments: 'n' and 'array'"}, "Round_1": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, array))\n        index += 2\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    operations = []\n    \n    if is_sorted(array):\n        return operations\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            # Find the correct position of array[i] in sorted_array\n            correct_pos = sorted_array.index(array[i], i)\n            \n            # Perform cyclic shift to move array[i] to its correct position\n            if correct_pos > i:\n                l = i\n                r = correct_pos\n                d = r - l\n                array = cyclic_shift(array, l, r, d)\n                operations.append((l + 1, r + 1, d))\n    \n    return operations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, array in test_cases:\n        operations = sort_with_cyclic_shifts(n, array)\n        results.append((len(operations), operations))\n    \n    for k, ops in results:\n        print(k)\n        for op in ops:\n            print(*op)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integer n and the array of integers a.\"\n      ]\n    },\n    {\n      \"description\": \"Implement a function to perform cyclic shifts on a segment of an array.\",\n      \"steps\": [\n        \"Define a function that takes an array, indices l and r, and offset d.\",\n        \"Perform a cyclic shift to the left on the segment a[l...r] by offset d.\"\n      ]\n    },\n    {\n      \"description\": \"Develop a strategy to sort the array using cyclic shifts.\",\n      \"steps\": [\n        \"Identify segments within the array that can be cyclically shifted to move elements into their correct positions.\",\n        \"Ensure that the number of shifts does not exceed n.\"\n      ]\n    },\n    {\n      \"description\": \"Generate the output format as specified.\",\n      \"steps\": [\n        \"For each test case, determine the number of shifts k required to sort the array.\",\n        \"Output k followed by the details of each shift in the format 'l r d'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, check if the array is already sorted. If sorted, output k = 0.\",\n    \"If not sorted, apply the cyclic shift function to sort the array using a strategy that requires at most n shifts.\",\n    \"Track the shifts performed and store them in the required output format.\",\n    \"Output the results for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l:r+1] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return 0, actions\n    \n    # Simple strategy: bubble sort-like approach using cyclic shifts\n    for i in range(n):\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[j-1]:\n                # Perform a cyclic shift to swap arr[j] and arr[j-1]\n                cyclic_shift(arr, j-1, j, 1)\n                actions.append((j, j+1, 1))\n    \n    return len(actions), actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        k, actions = sort_with_cyclic_shifts(n, arr)\n        results.append((k, actions))\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 100)"}, "Round_1": {"code": "def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l:r+1] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return 0, actions\n    \n    # Simple strategy: bubble sort-like approach using cyclic shifts\n    for i in range(n):\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[j-1]:\n                # Perform a cyclic shift to swap arr[j] and arr[j-1]\n                cyclic_shift(arr, j-1, j, 1)\n                actions.append((j, j+1, 1))\n    \n    return len(actions), actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        k, actions = sort_with_cyclic_shifts(n, arr)\n        results.append((k, actions))\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"output\": \"A list of test cases, where each test case contains the length of the array and the array elements.\"\n    },\n    {\n      \"description\": \"Implement a function to check if an array is already sorted.\",\n      \"output\": \"A boolean value indicating whether the array is sorted.\"\n    },\n    {\n      \"description\": \"Develop a function to perform a cyclic shift on a segment of the array given the indices l, r, and offset d.\",\n      \"output\": \"The array with the specified segment cyclically shifted.\"\n    },\n    {\n      \"description\": \"Create a strategy to sort the array using cyclic shifts, ensuring that the number of shifts does not exceed the length of the array.\",\n      \"output\": \"A list of operations (l, r, d) that sorts the array.\"\n    },\n    {\n      \"description\": \"Format the output to display the number of operations and the details of each operation for each test case.\",\n      \"output\": \"Formatted output for each test case, showing the number of operations and the operations themselves.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to determine the number of test cases and extract the details for each test case.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 operations.\",\n    \"If the array is not sorted, apply a sorting strategy using cyclic shifts. Use the cyclic shift function to perform necessary operations.\",\n    \"Ensure that the number of operations does not exceed the length of the array.\",\n    \"Store the operations for each test case.\",\n    \"Output the results for all test cases, including the number of operations and the details of each operation.\"\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    operations = []\n    \n    if is_sorted(array):\n        return operations\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            for j in range(i + 1, n):\n                if array[j] == sorted_array[i]:\n                    l, r = i, j\n                    d = 1\n                    array = cyclic_shift(array, l, r, d)\n                    operations.append((l + 1, r + 1, d))\n                    break\n    \n    return operations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, array in test_cases:\n        operations = sort_with_cyclic_shifts(n, array)\n        results.append((len(operations), operations))\n    \n    for k, operations in results:\n        print(k)\n        for l, r, d in operations:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: sort_with_cyclic_shifts() missing 2 required positional arguments: 'n' and 'array'"}, "Round_1": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, array))\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    operations = []\n    \n    if is_sorted(array):\n        return operations\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            for j in range(i + 1, n):\n                if array[j] == sorted_array[i]:\n                    l, r = i, j\n                    d = 1\n                    array = cyclic_shift(array, l, r, d)\n                    operations.append((l + 1, r + 1, d))\n                    break\n    \n    return operations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, array in test_cases:\n        operations = sort_with_cyclic_shifts(n, array)\n        results.append((len(operations), operations))\n    \n    for k, operations in results:\n        print(k)\n        for l, r, d in operations:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which is the length of the array.\",\n        \"Read the array of integers a of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"steps\": [\n        \"Compare the array a with its sorted version.\",\n        \"If the array is already sorted, set k = 0 and prepare an empty sequence of cyclic shifts.\"\n      ]\n    },\n    {\n      \"description\": \"Sort the array using cyclic shifts if it is not already sorted.\",\n      \"steps\": [\n        \"Identify segments of the array that need to be shifted to achieve a sorted order.\",\n        \"For each segment, determine the appropriate indices l and r and the offset d for the cyclic shift.\",\n        \"Perform the cyclic shift and update the array.\",\n        \"Repeat the process until the array is sorted or the number of shifts reaches n.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integer k, which is the number of cyclic shifts performed.\",\n        \"For each shift, output the indices l, r, and the offset d.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, check if the array is already sorted.\",\n    \"If the array is sorted, output k = 0 and an empty sequence of shifts.\",\n    \"If the array is not sorted, perform cyclic shifts to sort the array.\",\n    \"Ensure that the number of shifts does not exceed n.\",\n    \"Output the number of shifts and the details of each shift for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the correct position of a[i] in the sorted array\n                correct_pos = sorted_a.index(a[i], i)\n                \n                # Perform a cyclic shift to move a[i] to its correct position\n                if correct_pos > i:\n                    l = i + 1\n                    r = correct_pos + 1\n                    d = correct_pos - i\n                    a[i:r] = a[i+d:r] + a[i:i+d]\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: 1 is not in list"}, "Round_1": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, a = case\n        sorted_a = sorted(a)\n        \n        if a == sorted_a:\n            results.append((0, []))\n            continue\n        \n        actions = []\n        \n        # A simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the correct position of a[i] in the sorted array\n                correct_pos = sorted_a.index(a[i], i)\n                \n                # Perform a cyclic shift to move a[i] to its correct position\n                if correct_pos > i:\n                    l = i + 1\n                    r = correct_pos + 1\n                    d = correct_pos - i\n                    a[i:r] = a[i+d:r] + a[i:i+d]\n                    actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the arrays for each test case.\",\n      \"details\": \"Read the integer t from the first line, then for each test case, read the integer n and the array of integers a.\"\n    },\n    {\n      \"description\": \"Implement a function to perform cyclic shifts on a segment of an array.\",\n      \"details\": \"Given indices l, r, and offset d, shift the segment a[l...r] to the left by d positions.\"\n    },\n    {\n      \"description\": \"Determine the sequence of cyclic shifts needed to sort the array.\",\n      \"details\": \"Develop a strategy to sort the array using cyclic shifts, ensuring the number of shifts does not exceed n.\"\n    },\n    {\n      \"description\": \"Format the output according to the specified requirements.\",\n      \"details\": \"For each test case, output the number of shifts k followed by k lines describing each shift in the format 'l r d'.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and the arrays for each test case.\",\n    \"For each test case, check if the array is already sorted. If sorted, output k = 0.\",\n    \"If the array is not sorted, apply a sorting strategy using cyclic shifts:\",\n    \"  - Identify segments that can be shifted to move elements into their correct positions.\",\n    \"  - Perform cyclic shifts on these segments, keeping track of the number of shifts.\",\n    \"Ensure the number of shifts does not exceed n for each test case.\",\n    \"Output the number of shifts and the details of each shift for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def cyclic_shift(arr, l, r, d):\n    # Perform cyclic shift to the left by d positions on the segment arr[l:r+1]\n    segment = arr[l:r+1]\n    d = d % len(segment)  # Ensure d is within the bounds of the segment length\n    shifted_segment = segment[d:] + segment[:d]\n    arr[l:r+1] = shifted_segment\n\ndef sort_with_cyclic_shifts(n, arr):\n    actions = []\n    sorted_arr = sorted(arr)\n    \n    if arr == sorted_arr:\n        return actions  # Already sorted, no actions needed\n    \n    # Simple strategy: bubble sort-like approach using cyclic shifts\n    for i in range(n):\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[j-1]:\n                # Perform a cyclic shift to swap arr[j] and arr[j-1]\n                cyclic_shift(arr, j-1, j, 1)\n                actions.append((j, j+1, 1))\n    \n    return actions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        actions = sort_with_cyclic_shifts(n, arr)\n        results.append((len(actions), actions))\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integer n, which is the length of the array.\",\n        \"Read the array of integers a of length n.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the array is already sorted.\",\n      \"steps\": [\n        \"Compare the array a with its sorted version.\",\n        \"If the array is already sorted, set k = 0 and prepare an empty sequence of cyclic shifts.\"\n      ]\n    },\n    {\n      \"description\": \"Sort the array using cyclic shifts if it is not already sorted.\",\n      \"steps\": [\n        \"Identify segments of the array that need to be shifted to achieve a sorted order.\",\n        \"For each segment, determine the appropriate indices l and r and the offset d for the cyclic shift.\",\n        \"Perform the cyclic shift and update the array.\",\n        \"Repeat the process until the array is sorted or the number of shifts reaches n.\"\n      ]\n    },\n    {\n      \"description\": \"Format and output the results for each test case.\",\n      \"steps\": [\n        \"For each test case, output the integer k, which is the number of cyclic shifts performed.\",\n        \"For each shift, output the indices l, r, and the offset d.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each test case.\",\n    \"For each test case, check if the array is already sorted.\",\n    \"If the array is sorted, output k = 0 and an empty sequence of shifts.\",\n    \"If the array is not sorted, perform cyclic shifts to sort the array.\",\n    \"Ensure the number of shifts does not exceed n.\",\n    \"Output the number of shifts and the details of each shift for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def cyclic_shift_sort(t, test_cases):\n    results = []\n    \n    for n, a in test_cases:\n        sorted_a = sorted(a)\n        actions = []\n        \n        if a == sorted_a:\n            results.append((0, actions))\n            continue\n        \n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the segment that needs to be shifted\n                l = i + 1\n                r = a.index(sorted_a[i], l - 1) + 1\n                d = r - l\n                \n                # Perform the cyclic shift\n                segment = a[l-1:r]\n                shifted_segment = segment[d:] + segment[:d]\n                a[l-1:r] = shifted_segment\n                \n                actions.append((l, r, d))\n                \n                if a == sorted_a:\n                    break\n        \n        results.append((len(actions), actions))\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = cyclic_shift_sort(t, test_cases)\n    \n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details of each test case, including the length of the array and the array elements.\",\n      \"output\": \"A list of test cases, where each test case contains the length of the array and the array elements.\"\n    },\n    {\n      \"description\": \"Implement a function to determine if an array is already sorted.\",\n      \"output\": \"A boolean value indicating whether the array is sorted.\"\n    },\n    {\n      \"description\": \"Develop a function to perform a cyclic shift on a segment of the array. This function should take the array, indices l and r, and offset d as input and return the modified array.\",\n      \"output\": \"The array after performing the cyclic shift on the specified segment.\"\n    },\n    {\n      \"description\": \"Create a strategy to sort the array using cyclic shifts. This involves determining the segments to shift and the offsets required to sort the array in no more than n shifts.\",\n      \"output\": \"A list of actions (l, r, d) that describe the cyclic shifts needed to sort the array.\"\n    },\n    {\n      \"description\": \"Format the output for each test case, including the number of actions and the details of each action.\",\n      \"output\": \"Formatted output for each test case, ready to be printed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a list of test cases.\",\n    \"For each test case, check if the array is already sorted. If it is, output 0 and an empty sequence of actions.\",\n    \"If the array is not sorted, apply the sorting strategy to determine the necessary cyclic shifts.\",\n    \"Use the cyclic shift function to perform the shifts and track the actions taken.\",\n    \"Format the results for each test case, including the number of actions and the details of each action.\",\n    \"Print the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1].split()))\n        test_cases.append((n, array))\n        index += 2\n    \n    return test_cases\n\ndef is_sorted(array):\n    return all(array[i] <= array[i + 1] for i in range(len(array) - 1))\n\ndef cyclic_shift(array, l, r, d):\n    segment = array[l:r+1]\n    d = d % len(segment)\n    shifted_segment = segment[d:] + segment[:d]\n    return array[:l] + shifted_segment + array[r+1:]\n\ndef sort_with_cyclic_shifts(n, array):\n    actions = []\n    \n    if is_sorted(array):\n        return actions\n    \n    sorted_array = sorted(array)\n    \n    for i in range(n):\n        if array[i] != sorted_array[i]:\n            for j in range(i + 1, n):\n                if array[j] == sorted_array[i]:\n                    l, r = i, j\n                    d = 1\n                    array = cyclic_shift(array, l, r, d)\n                    actions.append((l + 1, r + 1, d))\n                    break\n    \n    return actions\n\ndef format_output(test_cases):\n    results = []\n    \n    for n, array in test_cases:\n        actions = sort_with_cyclic_shifts(n, array)\n        results.append(f\"{len(actions)}\")\n        for action in actions:\n            results.append(f\"{action[0]} {action[1]} {action[2]}\")\n    \n    return \"\\n\".join(results)\n\ndef main():\n    test_cases = parse_input()\n    output = format_output(test_cases)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 137, "prompt": "The new generation external memory comprises an array of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you substitute the segment a[l \u2026 r] with its cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the specified array a using not more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "mutate_method": "rephrase_one", "save_node": true, "parent_index": 58}
