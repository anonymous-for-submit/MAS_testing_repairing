{"name": "1580_C. Train Maintenance", "description": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "tags": ["brute force", "data structures", "implementation"], "difficulty": 9, "id": 1580, "sample_io": [{"input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "test_list": [{"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "3 4\n10 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "3 4\n23 15\n14 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n2 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n5\n4\n3\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n2\n3\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 2\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n"]}, {"input": "20 7\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n4 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n3 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n"]}, {"input": "3 2\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n2 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n3\n4\n4\n4\n4\n5\n5\n4\n3\n4\n6\n8\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 2\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 6\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n6\n5\n6\n7\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n1 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n14 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n4\n3\n4\n7\n8\n"]}, {"input": "3 4\n16 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n10 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n10 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 1\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n13 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n467159628 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 0\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n13 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n369260158 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 16\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n23 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n2 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000101 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 7\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n16 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n5 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10001011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1166046831 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n26 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1425917046 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 11\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 1\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 8\n12 25\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1011185365 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n12 15\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 1\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n9 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 18\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n22 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 0\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 173113793\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n3 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 21\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n9 6\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 38795044\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n4 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10010011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 4\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n4 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 29\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 13\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n3 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n10 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n5 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "3 4\n16 21\n10 17\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n4 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n3 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 0\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n0 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 2\n1 1\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 4\n1 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n2 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n0 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "5 2\n1 2\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 13\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n529113291 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 7\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n292159474 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n16 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 0\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 -1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n0 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "task_id": "codecontest/22", "repair_prompt": ["Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n types of trains, and Nitori's department will only have at maximum one train of every type at any time. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the status of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    \n    # Result array to store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = 0  # Start from day 0 of its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count_in_maintenance = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                cycle_length = x_i + y_i\n                current_day_in_cycle = train_status[i]\n                \n                # Check if the train is in maintenance\n                if x_i <= current_day_in_cycle < cycle_length:\n                    count_in_maintenance += 1\n                \n                # Update the cycle day for the next day\n                train_status[i] = (train_status[i] + 1) % cycle_length\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    \n    # Result array to store the number of trains in maintenance each day\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its periods\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        count_in_maintenance = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read maintenance cycles\n    cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        cycles.append((x_i, y_i))\n    \n    # Read operations\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize train status\n    train_status = [None] * n  # None means no train, otherwise it stores the day it was added\n    maintenance_count = [0] * m\n    \n    # Process each day\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_status[k] = day\n        elif op == 2:  # Remove train\n            train_status[k] = None\n        \n        # Calculate maintenance trains\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                added_day = train_status[i]\n                x_i, y_i = cycles[i]\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Check if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % total_cycle\n                    if cycle_position >= x_i:\n                        count += 1\n        \n        maintenance_count[day] = count\n    \n    # Output results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means no train of this type is added\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            if train_status[k] is not None:\n                add_day, x_i, y_i = train_status[k]\n                # Calculate the cycle position on the day it is removed\n                total_cycle = x_i + y_i\n                days_since_add = day - add_day\n                cycle_position = days_since_add % total_cycle\n                \n                # If it was in maintenance, decrement the maintenance count\n                if cycle_position >= x_i:\n                    maintenance_count -= 1\n                \n                train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for the current day\n        current_maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                add_day, x_i, y_i = status\n                total_cycle = x_i + y_i\n                days_since_add = day - add_day\n                cycle_position = days_since_add % total_cycle\n                \n                if cycle_position >= x_i:\n                    current_maintenance_count += 1\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train: None if not present, otherwise (start_day, current_state)\n    # current_state: 0 for working, 1 for maintenance\n    train_states = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = (day, 0)  # Start working\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                start_day, current_state = train_states[i]\n                x_i, y_i = work_maintenance_periods[i]\n                \n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                \n                # Calculate the current cycle position\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                \n                # Determine if the train is in maintenance\n                if cycle_position >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_state = [None] * n  # None means not present, otherwise store the start day\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = day\n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate maintenance trains\n        count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                start_day = train_state[i]\n                x_i, y_i = work_maintenance_periods[i]\n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                # Calculate the current cycle position\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse the first line to get n and m\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Parse the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize a data structure to keep track of the current status of each train type\n    train_status = [None] * n  # None means no train of this type is added\n    \n    # Prepare to store the output\n    output = []\n    \n    # Iterate over each of the m days\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                cycle_position = days_since_added % cycle_length\n                if cycle_position >= x_i:  # In maintenance phase\n                    maintenance_count += 1\n        \n        # Store the result for this day\n        output.append(str(maintenance_count))\n    \n    # Print the output for each day\n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means not present, otherwise it stores the day it was added\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                days_since_added = day - train_status[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # If the train is in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    active_trains = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_cycles[k]\n            active_trains[k] = (day, x_i, y_i)\n        elif op == 2:  # Remove train\n            if k in active_trains:\n                del active_trains[k]\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for start_day, x_i, y_i in active_trains.values():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i:\n                # Check if the train is in maintenance\n                if (days_since_start - x_i) % cycle_length < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the status of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    \n    # Result array to store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = 0  # Start from day 0 of its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count_in_maintenance = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                cycle_length = x_i + y_i\n                current_day_in_cycle = train_status[i]\n                \n                # Check if the train is in maintenance\n                if x_i <= current_day_in_cycle < cycle_length:\n                    count_in_maintenance += 1\n                \n                # Update the cycle day for the next day\n                train_status[i] = (train_status[i] + 1) % cycle_length\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train type (e.g., whether it is added and its current cycle day).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"For each train that is added, calculate its current cycle day and determine if it is in maintenance.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all train types to count how many are in maintenance based on their current cycle day.\",\n        \"Store the count of trains in maintenance for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each day.\",\n      \"steps\": [\n        \"Print the number of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train statuses and maintenance cycles.\",\n    \"Iterate over each day, updating train statuses based on operations.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the maintenance count for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the status of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    \n    # Result array to store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = 0  # Start from day 0 of its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count_in_maintenance = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                cycle_length = x_i + y_i\n                current_day_in_cycle = train_status[i]\n                \n                # Check if the train is in maintenance\n                if x_i <= current_day_in_cycle < cycle_length:\n                    count_in_maintenance += 1\n                \n                # Update the cycle day for the next day\n                train_status[i] = (train_status[i] + 1) % cycle_length\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train type (e.g., whether it is added and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"For each train that is added, calculate its maintenance schedule based on its work and maintenance periods.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all train types to check if they are in the maintenance period.\",\n        \"Count the number of trains in maintenance and store the result for that day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"Iterate over the stored results and print the number of trains in maintenance for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train types, their work and maintenance periods, and daily operations.\",\n    \"Initialize data structures to track the status of each train type and their maintenance schedules.\",\n    \"Simulate the daily operations, updating the status of trains and calculating their maintenance periods.\",\n    \"For each day, determine how many trains are in maintenance and store the result.\",\n    \"Output the results for each day, showing the number of trains in maintenance.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    \n    # Result array to store the number of trains in maintenance each day\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its periods\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        count_in_maintenance = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 106)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    \n    # Result array to store the number of trains in maintenance each day\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its periods\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        count_in_maintenance = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        count_in_maintenance += 1\n        \n        maintenance_count[day] = count_in_maintenance\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types, number of days, train operation details, and train maintenance cycles.\",\n      \"steps\": [\n        \"Read the first line to get integers n (number of train types) and m (number of days).\",\n        \"Read the next n lines to get the maintenance cycle for each train type, consisting of x_i (working days) and y_i (maintenance days).\",\n        \"Read the next m lines to get the operations for each day, consisting of op (operation type) and k (train model).\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the daily operations to track train status and calculate the number of trains in maintenance.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (whether it is added or removed).\",\n        \"For each day, update the status of the train model based on the operation (add or remove).\",\n        \"Calculate the number of trains in maintenance by checking the status and maintenance cycle of each train model.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train status, determine the number of trains in maintenance.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary information about train types, maintenance cycles, and daily operations.\",\n    \"Initialize data structures to track the status of each train model.\",\n    \"Iterate over each day, updating train statuses and calculating the number of trains in maintenance.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    # Read maintenance cycles\n    cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        cycles.append((x_i, y_i))\n    \n    # Read operations\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize train status\n    train_status = [None] * n  # None means no train, otherwise it stores the day it was added\n    maintenance_count = [0] * m\n    \n    # Process each day\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_status[k] = day\n        elif op == 2:  # Remove train\n            train_status[k] = None\n        \n        # Calculate maintenance trains\n        count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                added_day = train_status[i]\n                x_i, y_i = cycles[i]\n                total_cycle = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Check if the train is in maintenance\n                if days_since_added >= x_i:\n                    cycle_position = days_since_added % total_cycle\n                    if cycle_position >= x_i:\n                        count += 1\n        \n        maintenance_count[day] = count\n    \n    # Output results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train type (e.g., whether it is added and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train statuses, determine how many trains are in the maintenance phase.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data including train types, work and maintenance periods, and daily operations.\",\n    \"Initialize a data structure to manage the state of each train type, including whether it is currently added and its cycle position.\",\n    \"Iterate over each day, updating the state of the trains based on the operation (add or remove) and the current day.\",\n    \"For each day, calculate the number of trains in maintenance by checking their cycle positions.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means no train of this type is added\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            if train_status[k] is not None:\n                add_day, x_i, y_i = train_status[k]\n                # Calculate the cycle position on the day it is removed\n                total_cycle = x_i + y_i\n                days_since_add = day - add_day\n                cycle_position = days_since_add % total_cycle\n                \n                # If it was in maintenance, decrement the maintenance count\n                if cycle_position >= x_i:\n                    maintenance_count -= 1\n                \n                train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for the current day\n        current_maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                add_day, x_i, y_i = status\n                total_cycle = x_i + y_i\n                days_since_add = day - add_day\n                cycle_position = days_since_add % total_cycle\n                \n                if cycle_position >= x_i:\n                    current_maintenance_count += 1\n        \n        results.append(current_maintenance_count)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train types, their work and maintenance periods, and daily operations.\"\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days, keeping track of their work and maintenance cycles.\",\n      \"output\": \"A data structure that maintains the state of each train type (whether it is working or in maintenance) for each day.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train types, number of days, work and maintenance periods for each train type, and the operations for each day.\",\n    \"Initialize a data structure to keep track of the state of each train type (working or in maintenance) and the day they were added.\",\n    \"Iterate over each day and perform the following steps:\",\n    \"  - If a train is added, record its start day and initialize its cycle (working or maintenance).\",\n    \"  - If a train is removed, update the state to reflect its removal.\",\n    \"  - For each train currently in the department, update its state based on its work and maintenance cycle.\",\n    \"  - Count the number of trains in maintenance and store the result for the current day.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State of each train: None if not present, otherwise (start_day, current_state)\n    # current_state: 0 for working, 1 for maintenance\n    train_states = [None] * n\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = (day, 0)  # Start working\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for i in range(n):\n            if train_states[i] is not None:\n                start_day, current_state = train_states[i]\n                x_i, y_i = work_maintenance_periods[i]\n                \n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                \n                # Calculate the current cycle position\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                \n                # Determine if the train is in maintenance\n                if cycle_position >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train types, their work and maintenance periods, and daily operations.\"\n    },\n    {\n      \"description\": \"Track the state of each train type, specifically whether it is currently added or removed, and if added, track its current cycle (working or maintenance).\",\n      \"output\": \"A data structure that maintains the current state of each train type.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and calculate the number of trains in maintenance.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, the work and maintenance periods for each train type, and the daily operations.\",\n    \"Initialize a data structure to track the state of each train type, including whether it is added or removed and its current cycle status.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, update its state to indicate it is in the working cycle and track the start day.\",\n    \"  - If a train is removed, update its state to indicate it is no longer present.\",\n    \"  - For each train currently added, determine if it is in the maintenance cycle based on the current day and its cycle periods.\",\n    \"  - Count the number of trains in maintenance and store the result for the current day.\",\n    \"Output the list of maintenance counts for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    train_state = [None] * n  # None means not present, otherwise store the start day\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            train_state[k] = day\n        elif op == 2:  # Remove train\n            train_state[k] = None\n        \n        # Calculate maintenance trains\n        count = 0\n        for i in range(n):\n            if train_state[i] is not None:\n                start_day = train_state[i]\n                x_i, y_i = work_maintenance_periods[i]\n                # Calculate the number of days since the train was added\n                days_since_added = day - start_day\n                # Calculate the current cycle position\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train type (e.g., whether it is added and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train statuses, determine how many trains are in the maintenance phase.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data including train types, work and maintenance periods, and daily operations.\",\n    \"Initialize a data structure to manage the state of each train type, including whether it is currently added and its cycle position.\",\n    \"Iterate over each day, updating the state of the trains based on the operation (add or remove) and the current day.\",\n    \"For each day, calculate the number of trains in maintenance by checking their cycle positions.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    maintenance_count = 0\n    \n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                if days_since_added >= x_i:\n                    # Check if it's in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train type (whether it is added and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train statuses, determine how many trains are in the maintenance phase.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract all necessary data including train types, work and maintenance periods, and daily operations.\",\n    \"Initialize a data structure to track the status of each train type, including whether it is currently added and its position in the work-maintenance cycle.\",\n    \"Iterate over each day, updating the status of trains based on the operation (add or remove) and their cycle positions.\",\n    \"For each day, calculate the number of trains currently in maintenance and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Parse the first line to get n and m\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    # Parse the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type\n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Initialize a data structure to keep track of the current status of each train type\n    train_status = [None] * n  # None means no train of this type is added\n    \n    # Prepare to store the output\n    output = []\n    \n    # Iterate over each of the m days\n    for day in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        index += 2\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = train_cycles[k]\n            train_status[k] = (day, x_i, y_i)  # Store the day it was added and its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance for this day\n        maintenance_count = 0\n        for status in train_status:\n            if status is not None:\n                added_day, x_i, y_i = status\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                cycle_position = days_since_added % cycle_length\n                if cycle_position >= x_i:  # In maintenance phase\n                    maintenance_count += 1\n        \n        # Store the result for this day\n        output.append(str(maintenance_count))\n    \n    # Print the output for each day\n    sys.stdout.write(\"\\n\".join(output) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train type (e.g., whether it is added and its current cycle position).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current cycle position.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train statuses, determine how many trains are in the maintenance phase.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data about train types, their work and maintenance cycles, and daily operations.\",\n    \"Initialize data structures to track the status of each train type, including whether it is currently added and its position in the work-maintenance cycle.\",\n    \"Iterate over each day, updating the status of trains based on the operations (add or remove) and their cycle positions.\",\n    \"For each day, calculate and store the number of trains currently in maintenance.\",\n    \"Output the stored results for each day, representing the number of trains in maintenance.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means not present, otherwise it stores the day it was added\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                days_since_added = day - train_status[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # If the train is in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 105)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # Initialize the state of each train type\n    train_status = [None] * n  # None means not present, otherwise it stores the day it was added\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                days_since_added = day - train_status[i]\n                cycle_length = x_i + y_i\n                if days_since_added >= x_i:\n                    # If the train is in the maintenance period\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the working and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get x_i and y_i for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over m days, keeping track of their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current state of trains (added or removed) and their maintenance cycles.\",\n        \"For each day, perform the operation specified (add or remove a train) and update the state of trains accordingly.\",\n        \"Calculate the number of trains in maintenance for each day based on their current state.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after performing the operation, determine how many trains are in maintenance.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary information about train types and daily operations.\",\n    \"Initialize data structures to track train states and maintenance cycles.\",\n    \"Iterate over each day, updating train states based on operations and calculating maintenance status.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    active_trains = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_cycles[k]\n            active_trains[k] = (day, x_i, y_i)\n        elif op == 2:  # Remove train\n            if k in active_trains:\n                del active_trains[k]\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for start_day, x_i, y_i in active_trains.values():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i:\n                # Check if the train is in maintenance\n                if (days_since_start - x_i) % cycle_length < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 102)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        train_cycles.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking\n    active_trains = {}\n    maintenance_count = [0] * m\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train\n            x_i, y_i = train_cycles[k]\n            active_trains[k] = (day, x_i, y_i)\n        elif op == 2:  # Remove train\n            if k in active_trains:\n                del active_trains[k]\n        \n        # Calculate maintenance count for the current day\n        count = 0\n        for start_day, x_i, y_i in active_trains.values():\n            cycle_length = x_i + y_i\n            days_since_start = day - start_day\n            if days_since_start >= x_i:\n                # Check if the train is in maintenance\n                if (days_since_start - x_i) % cycle_length < y_i:\n                    count += 1\n        \n        maintenance_count[day] = count\n    \n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train types (n), number of days (m), the work and maintenance periods for each train type, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train type.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate the addition and removal of trains over the m days and track their maintenance status.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train type (e.g., whether it is added and its current cycle day).\",\n        \"For each day, perform the operation specified (add or remove a train) and update the status of the trains accordingly.\",\n        \"For each train that is added, calculate its current cycle day and determine if it is in maintenance.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, iterate over all train types to count how many are in maintenance based on their current cycle day.\",\n        \"Store the count of trains in maintenance for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each day.\",\n      \"steps\": [\n        \"Print the number of trains in maintenance for each of the m days.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track train statuses and maintenance cycles.\",\n    \"Iterate over each day, updating train statuses based on operations.\",\n    \"Calculate and store the number of trains in maintenance for each day.\",\n    \"Output the maintenance count for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize the status of each train type\n    train_status = [None] * n  # None means no train of this type is present\n    \n    # Result array to store the number of trains in maintenance each day\n    maintenance_count = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = 0  # Start from day 0 of its cycle\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Count trains in maintenance\n        count_in_maintenance = 0\n        for i in range(n):\n            if train_status[i] is not None:\n                x_i, y_i = work_maintenance[i]\n                cycle_length = x_i + y_i\n                current_day_in_cycle = train_status[i]\n                \n                # Check if the train is in maintenance\n                if x_i <= current_day_in_cycle < cycle_length:\n                    count_in_maintenance += 1\n                \n                # Update the cycle day for the next day\n                train_status[i] = (train_status[i] + 1) % cycle_length\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the results\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 88, "prompt": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n types of trains, and Nitori's department will only have at maximum one train of every type at any time. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "examples": "\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 11}
