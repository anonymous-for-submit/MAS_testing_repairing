{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "repair_prompt": ["CQXYM encountered a rectangle A with dimensions n by m. Inside are n rows and m columns consisting of blocks. Each block in the rectangle may be an obsidian block or empty. CQXYM has the ability to transform an obsidian block into an empty one or vice versa in just one operation.\n\nA rectangle M that is a \u00d7 b in size is considered a portal only if it meets certain requirements:\n\n  * a must be at least 5, and b must be at least 4.\n  * Every block M_{x,1} and M_{x,b} must be an obsidian block for all 1 < x < a.\n  * Every block M_{1,x} and M_{a,x} must be an obsidian block for all 1 < x < b.\n  * Every block M_{x,y} must be empty for all 1<x<a,1<y<b.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nKeep in mind that there must be a rows and b columns, as opposed to b rows and a columns.\n\nNote that corners can be any type.\n\nCQXYM is curious about the fewest number of steps needed to convert at least one sub-rectangle into a portal.\nThe rectangle A can have various configurations of blocks. Consider edge cases where n or m is less than required dimensions for forming a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner conditions\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        rectangle = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, rectangle))\n    \n    return test_cases\n\ndef count_transformations(n, m, rectangle):\n    min_transformations = float('inf')\n    \n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    transformations = 0\n                    \n                    # Check the top and bottom borders\n                    for x in range(1, b - 1):\n                        if rectangle[i][j + x] != '1':\n                            transformations += 1\n                        if rectangle[i + a - 1][j + x] != '1':\n                            transformations += 1\n                    \n                    # Check the left and right borders\n                    for y in range(1, a - 1):\n                        if rectangle[i + y][j] != '1':\n                            transformations += 1\n                        if rectangle[i + y][j + b - 1] != '1':\n                            transformations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if rectangle[i + x][j + y] != '0':\n                                transformations += 1\n                    \n                    min_transformations = min(min_transformations, transformations)\n    \n    return min_transformations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, rectangle in test_cases:\n        result = count_transformations(n, m, rectangle)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(n, m, grid):\n    # Initialize the minimum operations to a large number\n    min_operations = float('inf')\n    \n    # Iterate over all possible top-left corners of sub-rectangles\n    for start_row in range(n - 4):  # Ensure at least 5 rows\n        for start_col in range(m - 3):  # Ensure at least 4 columns\n            # Iterate over all possible sizes of sub-rectangles\n            for a in range(5, n - start_row + 1):\n                for b in range(4, m - start_col + 1):\n                    # Calculate the number of operations needed for this sub-rectangle\n                    operations = 0\n                    \n                    # Check the top and bottom borders\n                    for x in range(b):\n                        if grid[start_row][start_col + x] == '0':\n                            operations += 1\n                        if grid[start_row + a - 1][start_col + x] == '0':\n                            operations += 1\n                    \n                    # Check the left and right borders\n                    for y in range(a):\n                        if grid[start_row + y][start_col] == '0':\n                            operations += 1\n                        if grid[start_row + y][start_col + b - 1] == '0':\n                            operations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[start_row + x][start_col + y] == '1':\n                                operations += 1\n                    \n                    # Update the minimum operations\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_steps_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4 + 1):\n            for j in range(m - 3 + 1):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        steps = 0\n                        # Top and bottom borders\n                        for x in range(j + 1, j + b - 1):\n                            if grid[i][x] == '0':\n                                steps += 1\n                            if grid[i + a - 1][x] == '0':\n                                steps += 1\n                        # Left and right borders\n                        for y in range(i + 1, i + a - 1):\n                            if grid[y][j] == '0':\n                                steps += 1\n                            if grid[y][j + b - 1] == '0':\n                                steps += 1\n                        # Inner area\n                        for y in range(i + 1, i + a - 1):\n                            for x in range(j + 1, j + b - 1):\n                                if grid[y][x] == '1':\n                                    steps += 1\n                        # Update minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_steps_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate transformations needed for sub-rectangle starting at (i, j) with size a x b\n                        steps = 0\n                        \n                        # Check top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                steps += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                steps += 1\n                        \n                        # Check left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                steps += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                steps += 1\n                        \n                        # Check inner blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    steps += 1\n                        \n                        # Update minimum steps for this test case\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                x, y = start_row + i, start_col + j\n                                if (i == 0 or i == a - 1) and (j == 0 or j == b - 1):\n                                    # Corners can be any type\n                                    continue\n                                elif i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Borders must be obsidian\n                                    if grid[x][y] == '0':\n                                        operations += 1\n                                else:\n                                    # Inside must be empty\n                                    if grid[x][y] == '1':\n                                        operations += 1\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if (i == 0 or i == a - 1 or j == 0 or j == b - 1):\n                                    # Border conditions\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_operations_to_portal(n, m, grid):\n    min_operations = float('inf')\n    \n    # Iterate over all possible top-left corners of sub-rectangles\n    for top in range(n):\n        for left in range(m):\n            # Iterate over all possible sizes of sub-rectangles\n            for a in range(5, n - top + 1):\n                for b in range(4, m - left + 1):\n                    # Calculate the number of operations needed to transform this sub-rectangle into a portal\n                    operations = 0\n                    \n                    # Check the top and bottom borders\n                    for x in range(left + 1, left + b - 1):\n                        if grid[top][x] == '0':  # Top border\n                            operations += 1\n                        if grid[top + a - 1][x] == '0':  # Bottom border\n                            operations += 1\n                    \n                    # Check the left and right borders\n                    for y in range(top + 1, top + a - 1):\n                        if grid[y][left] == '0':  # Left border\n                            operations += 1\n                        if grid[y][left + b - 1] == '0':  # Right border\n                            operations += 1\n                    \n                    # Check the inner area\n                    for y in range(top + 1, top + a - 1):\n                        for x in range(left + 1, left + b - 1):\n                            if grid[y][x] == '1':  # Inner area should be empty\n                                operations += 1\n                    \n                    # Update the minimum operations found\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    return test_cases\n\ndef calculate_transformations(n, m, grid):\n    min_transformations = float('inf')\n    \n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    transformations = 0\n                    \n                    # Check the top and bottom rows\n                    for x in range(1, b - 1):\n                        if grid[i][j + x] != '1':\n                            transformations += 1\n                        if grid[i + a - 1][j + x] != '1':\n                            transformations += 1\n                    \n                    # Check the left and right columns\n                    for y in range(1, a - 1):\n                        if grid[i + y][j] != '1':\n                            transformations += 1\n                        if grid[i + y][j + b - 1] != '1':\n                            transformations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[i + x][j + y] != '0':\n                                transformations += 1\n                    \n                    min_transformations = min(min_transformations, transformations)\n    \n    return min_transformations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, grid in test_cases:\n        if n < 5 or m < 4:\n            results.append(0)\n        else:\n            result = calculate_transformations(n, m, grid)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):  # Ensure at least 5 rows\n            for start_col in range(m - 3):  # Ensure at least 4 columns\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Border conditions\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\nmain()", "def min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner conditions\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the dimensions n and m, followed by n lines of m characters representing the grid.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the given grid dimensions.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal of size at least 5x4.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"details\": \"For each candidate sub-rectangle, calculate the number of operations needed to transform it into a portal by checking the conditions for the border and inner blocks.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"details\": \"For each test case, keep track of the minimum number of operations needed to transform any sub-rectangle into a portal.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"Print the minimum number of operations for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations needed for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner conditions\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the configuration of blocks for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains the dimensions (n, m) and a 2D list representing the rectangle configuration.\"\n    },\n    {\n      \"description\": \"For each test case, identify all possible sub-rectangles of size at least 5x4 within the given rectangle.\",\n      \"output\": \"A list of potential sub-rectangles for each test case, defined by their top-left and bottom-right coordinates.\"\n    },\n    {\n      \"description\": \"For each potential sub-rectangle, calculate the number of transformations needed to convert it into a portal according to the given requirements.\",\n      \"output\": \"A transformation count for each potential sub-rectangle.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of transformations required to convert at least one sub-rectangle into a portal for each test case.\",\n      \"output\": \"The minimum transformation count for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format containing all test cases.\",\n    \"Iterate over each test case to process the rectangle configuration.\",\n    \"For each rectangle, generate all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, evaluate the number of transformations needed to meet the portal requirements.\",\n    \"Track the minimum number of transformations needed for each test case.\",\n    \"Output the minimum transformation count for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        rectangle = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, rectangle))\n    \n    return test_cases\n\ndef count_transformations(n, m, rectangle):\n    min_transformations = float('inf')\n    \n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    transformations = 0\n                    \n                    # Check the top and bottom borders\n                    for x in range(1, b - 1):\n                        if rectangle[i][j + x] != '1':\n                            transformations += 1\n                        if rectangle[i + a - 1][j + x] != '1':\n                            transformations += 1\n                    \n                    # Check the left and right borders\n                    for y in range(1, a - 1):\n                        if rectangle[i + y][j] != '1':\n                            transformations += 1\n                        if rectangle[i + y][j + b - 1] != '1':\n                            transformations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if rectangle[i + x][j + y] != '0':\n                                transformations += 1\n                    \n                    min_transformations = min(min_transformations, transformations)\n    \n    return min_transformations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, rectangle in test_cases:\n        result = count_transformations(n, m, rectangle)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n      \"details\": \"Read the number of test cases, and for each test case, read the dimensions n and m, followed by the n lines of m characters representing the grid.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the given grid.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal of size at least 5x4.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"details\": \"For each candidate sub-rectangle, calculate the number of operations needed to transform it into a portal by checking and modifying the border and inner blocks as per the portal requirements.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"details\": \"For each test case, keep track of the minimum number of operations needed to form at least one valid portal and store this result.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to get the number of test cases and the grid configurations for each test case.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required to form a portal for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(n, m, grid):\n    # Initialize the minimum operations to a large number\n    min_operations = float('inf')\n    \n    # Iterate over all possible top-left corners of sub-rectangles\n    for start_row in range(n):\n        for start_col in range(m):\n            # Iterate over all possible sizes of sub-rectangles\n            for a in range(5, n - start_row + 1):\n                for b in range(4, m - start_col + 1):\n                    # Calculate the number of operations needed for this sub-rectangle\n                    operations = 0\n                    \n                    # Check the top and bottom borders\n                    for x in range(b):\n                        if grid[start_row][start_col + x] == '0':\n                            operations += 1\n                        if grid[start_row + a - 1][start_col + x] == '0':\n                            operations += 1\n                    \n                    # Check the left and right borders\n                    for y in range(a):\n                        if grid[start_row + y][start_col] == '0':\n                            operations += 1\n                        if grid[start_row + y][start_col + b - 1] == '0':\n                            operations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[start_row + x][start_col + y] == '1':\n                                operations += 1\n                    \n                    # Update the minimum operations\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def min_operations_to_portal(n, m, grid):\n    # Initialize the minimum operations to a large number\n    min_operations = float('inf')\n    \n    # Iterate over all possible top-left corners of sub-rectangles\n    for start_row in range(n - 4):  # Ensure at least 5 rows\n        for start_col in range(m - 3):  # Ensure at least 4 columns\n            # Iterate over all possible sizes of sub-rectangles\n            for a in range(5, n - start_row + 1):\n                for b in range(4, m - start_col + 1):\n                    # Calculate the number of operations needed for this sub-rectangle\n                    operations = 0\n                    \n                    # Check the top and bottom borders\n                    for x in range(b):\n                        if grid[start_row][start_col + x] == '0':\n                            operations += 1\n                        if grid[start_row + a - 1][start_col + x] == '0':\n                            operations += 1\n                    \n                    # Check the left and right borders\n                    for y in range(a):\n                        if grid[start_row + y][start_col] == '0':\n                            operations += 1\n                        if grid[start_row + y][start_col + b - 1] == '0':\n                            operations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[start_row + x][start_col + y] == '1':\n                                operations += 1\n                    \n                    # Update the minimum operations\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Validate Input\",\n      \"description\": \"Ensure that the input format is correct and meets the constraints specified in the requirement. This includes checking the number of test cases, dimensions of the rectangle, and the characters used to represent blocks.\"\n    },\n    {\n      \"subproblem\": \"Identify Potential Portal Areas\",\n      \"description\": \"For each test case, identify all possible sub-rectangles within the given rectangle A that meet the minimum size requirements for a portal (at least 5 rows and 4 columns).\"\n    },\n    {\n      \"subproblem\": \"Calculate Transformation Steps\",\n      \"description\": \"For each identified sub-rectangle, calculate the number of transformations needed to convert it into a portal. This involves checking each block against the portal requirements and counting the necessary changes.\"\n    },\n    {\n      \"subproblem\": \"Determine Minimum Steps\",\n      \"description\": \"For each test case, determine the minimum number of transformation steps required to convert at least one sub-rectangle into a portal.\"\n    },\n    {\n      \"subproblem\": \"Output Results\",\n      \"description\": \"Output the minimum number of steps for each test case in the specified format.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read Input\",\n      \"description\": \"Read the number of test cases and the dimensions and block configurations for each test case.\"\n    },\n    {\n      \"step\": \"Validate Input\",\n      \"description\": \"Check that the input meets the specified constraints and format.\"\n    },\n    {\n      \"step\": \"Iterate Over Test Cases\",\n      \"description\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Identify Sub-rectangles\",\n      \"description\": \"Find all sub-rectangles within the given rectangle that meet the minimum size requirements for a portal.\"\n    },\n    {\n      \"step\": \"Calculate Transformations\",\n      \"description\": \"For each sub-rectangle, calculate the number of transformations needed to meet the portal requirements.\"\n    },\n    {\n      \"step\": \"Find Minimum Transformations\",\n      \"description\": \"Determine the minimum number of transformations required for any sub-rectangle to become a portal.\"\n    },\n    {\n      \"step\": \"Output Result\",\n      \"description\": \"Output the minimum number of transformations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_steps_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4 + 1):\n            for j in range(m - 3 + 1):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        steps = 0\n                        # Top and bottom borders\n                        for x in range(j + 1, j + b - 1):\n                            if grid[i][x] == '0':\n                                steps += 1\n                            if grid[i + a - 1][x] == '0':\n                                steps += 1\n                        # Left and right borders\n                        for y in range(i + 1, i + a - 1):\n                            if grid[y][j] == '0':\n                                steps += 1\n                            if grid[y][j + b - 1] == '0':\n                                steps += 1\n                        # Inner area\n                        for y in range(i + 1, i + a - 1):\n                            for x in range(j + 1, j + b - 1):\n                                if grid[y][x] == '1':\n                                    steps += 1\n                        # Update minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_steps_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the configuration of blocks for each test case.\",\n      \"output\": \"A list of test cases, where each test case contains the dimensions (n, m) and a 2D list representing the rectangle configuration.\"\n    },\n    {\n      \"description\": \"For each test case, identify all possible sub-rectangles of size at least 5x4 within the given rectangle.\",\n      \"output\": \"A list of potential sub-rectangles for each test case, defined by their top-left and bottom-right coordinates.\"\n    },\n    {\n      \"description\": \"For each potential sub-rectangle, calculate the number of transformations needed to convert it into a portal according to the given requirements.\",\n      \"output\": \"A transformation count for each potential sub-rectangle.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of transformations required to convert at least one sub-rectangle into a portal for each test case.\",\n      \"output\": \"The minimum transformation count for each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, check the border and inner blocks to calculate the number of transformations needed to meet the portal requirements.\",\n    \"Track the minimum number of transformations needed for each test case.\",\n    \"Output the minimum transformation count for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate transformations needed for sub-rectangle starting at (i, j) with size a x b\n                        steps = 0\n                        \n                        # Check top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':  # Top border\n                                steps += 1\n                            if grid[i + a - 1][j + x] != '1':  # Bottom border\n                                steps += 1\n                        \n                        # Check left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':  # Left border\n                                steps += 1\n                            if grid[i + y][j + b - 1] != '1':  # Right border\n                                steps += 1\n                        \n                        # Check inner blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    steps += 1\n                        \n                        # Update minimum steps for this test case\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by n lines of m characters representing the grid.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the grid.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check dimensions to ensure they are at least 5x4.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"details\": \"For each sub-rectangle, verify the portal conditions and calculate the number of transformations needed to meet these conditions.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of transformations needed for each test case.\",\n      \"details\": \"For each test case, track the minimum number of transformations required to convert any sub-rectangle into a portal.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"Print the minimum number of transformations for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, check if it can be transformed into a portal and calculate the number of transformations required.\",\n    \"Track the minimum number of transformations needed for each test case.\",\n    \"Output the minimum number of transformations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                x, y = start_row + i, start_col + j\n                                if (i == 0 or i == a - 1) and (j == 0 or j == b - 1):\n                                    # Corners can be any type\n                                    continue\n                                elif i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Borders must be obsidian\n                                    if grid[x][y] == '0':\n                                        operations += 1\n                                else:\n                                    # Inside must be empty\n                                    if grid[x][y] == '1':\n                                        operations += 1\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configurations.\",\n      \"details\": \"Read the input data to get the number of test cases. For each test case, read the dimensions n and m, followed by n lines of m characters representing the block configuration.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the given rectangle.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal of size at least 5x4.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"details\": \"For each identified sub-rectangle, verify if it meets the portal requirements and calculate the number of transformations needed to convert it into a portal.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of transformations needed for each test case.\",\n      \"details\": \"For each test case, find the sub-rectangle that requires the fewest transformations to become a portal and record this number.\"\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"details\": \"Print the minimum number of transformations needed for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the block configurations for each test case.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, check if it can be transformed into a portal and calculate the number of transformations required.\",\n    \"Track the minimum number of transformations needed for each test case.\",\n    \"Output the minimum number of transformations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if (i == 0 or i == a - 1 or j == 0 or j == b - 1):\n                                    # Border conditions\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: expected an indented block (<string>, line 128)"}, "Round_1": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if (i == 0 or i == a - 1 or j == 0 or j == b - 1):\n                                    # Border conditions\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the dimensions n and m, followed by n lines of m characters representing the grid.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the grid.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal of size at least 5x4.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"details\": \"For each candidate sub-rectangle, calculate the number of operations needed to transform it into a portal by checking the conditions for obsidian and empty blocks.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"details\": \"For each test case, find the sub-rectangle that requires the fewest operations to become a portal and record this number.\"\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"details\": \"Print the minimum number of operations for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations required for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(n, m, grid):\n    min_operations = float('inf')\n    \n    # Iterate over all possible top-left corners of sub-rectangles\n    for top in range(n):\n        for left in range(m):\n            # Iterate over all possible sizes of sub-rectangles\n            for a in range(5, n - top + 1):\n                for b in range(4, m - left + 1):\n                    # Calculate the number of operations needed to transform this sub-rectangle into a portal\n                    operations = 0\n                    \n                    # Check the top and bottom borders\n                    for x in range(left + 1, left + b - 1):\n                        if grid[top][x] == '0':  # Top border\n                            operations += 1\n                        if grid[top + a - 1][x] == '0':  # Bottom border\n                            operations += 1\n                    \n                    # Check the left and right borders\n                    for y in range(top + 1, top + a - 1):\n                        if grid[y][left] == '0':  # Left border\n                            operations += 1\n                        if grid[y][left + b - 1] == '0':  # Right border\n                            operations += 1\n                    \n                    # Check the inner area\n                    for y in range(top + 1, top + a - 1):\n                        for x in range(left + 1, left + b - 1):\n                            if grid[y][x] == '1':  # Inner area should be empty\n                                operations += 1\n                    \n                    # Update the minimum operations found\n                    min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Input Parsing\",\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configuration for each test case.\"\n    },\n    {\n      \"subproblem\": \"Portal Validation\",\n      \"description\": \"Implement a function to check if a given sub-rectangle meets the portal requirements.\"\n    },\n    {\n      \"subproblem\": \"Transformation Calculation\",\n      \"description\": \"Calculate the minimum number of transformations needed to convert a sub-rectangle into a portal.\"\n    },\n    {\n      \"subproblem\": \"Edge Case Handling\",\n      \"description\": \"Handle cases where the dimensions of the rectangle are less than the required dimensions for forming a portal.\"\n    },\n    {\n      \"subproblem\": \"Output Generation\",\n      \"description\": \"Generate the output for each test case, which is the minimum number of transformations needed.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse Input\",\n      \"description\": \"Read the input data and store the number of test cases, dimensions, and block configurations.\"\n    },\n    {\n      \"step\": \"Iterate Over Test Cases\",\n      \"description\": \"For each test case, iterate over all possible sub-rectangles that meet the minimum size requirements.\"\n    },\n    {\n      \"step\": \"Check Portal Validity\",\n      \"description\": \"For each sub-rectangle, check if it can be transformed into a portal by verifying the block requirements.\"\n    },\n    {\n      \"step\": \"Calculate Transformations\",\n      \"description\": \"For valid sub-rectangles, calculate the number of transformations needed to convert it into a portal.\"\n    },\n    {\n      \"step\": \"Determine Minimum Transformations\",\n      \"description\": \"Track the minimum number of transformations needed across all sub-rectangles for each test case.\"\n    },\n    {\n      \"step\": \"Handle Edge Cases\",\n      \"description\": \"Ensure that test cases with dimensions smaller than required are handled appropriately.\"\n    },\n    {\n      \"step\": \"Output Results\",\n      \"description\": \"Output the minimum number of transformations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    return test_cases\n\ndef calculate_transformations(n, m, grid):\n    min_transformations = float('inf')\n    \n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    transformations = 0\n                    \n                    # Check the top and bottom rows\n                    for x in range(1, b - 1):\n                        if grid[i][j + x] != '1':\n                            transformations += 1\n                        if grid[i + a - 1][j + x] != '1':\n                            transformations += 1\n                    \n                    # Check the left and right columns\n                    for y in range(1, a - 1):\n                        if grid[i + y][j] != '1':\n                            transformations += 1\n                        if grid[i + y][j + b - 1] != '1':\n                            transformations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[i + x][j + y] != '0':\n                                transformations += 1\n                    \n                    min_transformations = min(min_transformations, transformations)\n    \n    return min_transformations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, grid in test_cases:\n        if n < 5 or m < 4:\n            results.append(0)\n        else:\n            result = calculate_transformations(n, m, grid)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 120)"}, "Round_1": {"code": "def parse_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    return test_cases\n\ndef calculate_transformations(n, m, grid):\n    min_transformations = float('inf')\n    \n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for i in range(n - a + 1):\n                for j in range(m - b + 1):\n                    transformations = 0\n                    \n                    # Check the top and bottom rows\n                    for x in range(1, b - 1):\n                        if grid[i][j + x] != '1':\n                            transformations += 1\n                        if grid[i + a - 1][j + x] != '1':\n                            transformations += 1\n                    \n                    # Check the left and right columns\n                    for y in range(1, a - 1):\n                        if grid[i + y][j] != '1':\n                            transformations += 1\n                        if grid[i + y][j + b - 1] != '1':\n                            transformations += 1\n                    \n                    # Check the inner area\n                    for x in range(1, a - 1):\n                        for y in range(1, b - 1):\n                            if grid[i + x][j + y] != '0':\n                                transformations += 1\n                    \n                    min_transformations = min(min_transformations, transformations)\n    \n    return min_transformations\n\ndef main():\n    test_cases = parse_input()\n    results = []\n    \n    for n, m, grid in test_cases:\n        if n < 5 or m < 4:\n            results.append(0)\n        else:\n            result = calculate_transformations(n, m, grid)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n      \"details\": \"Read the integer t for the number of test cases. For each test case, read integers n and m, followed by n lines of m characters representing the grid.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the grid.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check dimensions to ensure they are at least 5x4.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"details\": \"For each sub-rectangle, verify the portal conditions and calculate the number of transformations needed to meet these conditions.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of transformations needed for each test case.\",\n      \"details\": \"For each test case, track the minimum number of transformations required to convert any sub-rectangle into a portal.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"Print the minimum number of transformations for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data to extract the number of test cases and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, check if it can be transformed into a portal and calculate the number of transformations needed.\",\n    \"Track the minimum number of transformations required for each test case.\",\n    \"Output the minimum number of transformations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Border conditions\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):  # Ensure at least 5 rows\n            for start_col in range(m - 3):  # Ensure at least 4 columns\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                                    # Border conditions\n                                    if (i == 0 and j == 0) or (i == 0 and j == b - 1) or (i == a - 1 and j == 0) or (i == a - 1 and j == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if current_block == '0':\n                                            operations += 1\n                                else:\n                                    # Inside must be empty (0)\n                                    if current_block == '1':\n                                        operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n      \"details\": \"Read the number of test cases t. For each test case, read the dimensions n and m, followed by n lines of m characters representing the grid.\"\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the given grid dimensions.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal of size at least 5x4.\"\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"details\": \"For each candidate sub-rectangle, calculate the number of operations needed to transform it into a portal by checking the conditions for the border and inner blocks.\"\n    },\n    {\n      \"description\": \"Determine the minimum number of operations required for each test case.\",\n      \"details\": \"For each test case, keep track of the minimum number of operations needed to transform any sub-rectangle into a portal.\"\n    },\n    {\n      \"description\": \"Output the results for each test case.\",\n      \"details\": \"Print the minimum number of operations for each test case on a new line.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\",\n    \"Track the minimum number of operations needed for each test case.\",\n    \"Output the minimum number of operations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_operations_to_portal(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, grid = case\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Iterate over all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(i + 1, i + a - 1):\n                            if grid[x][j] != '1':\n                                operations += 1\n                            if grid[x][j + b - 1] != '1':\n                                operations += 1\n                        \n                        for y in range(j + 1, j + b - 1):\n                            if grid[i][y] != '1':\n                                operations += 1\n                            if grid[i + a - 1][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner conditions\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_operations_to_portal(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 200, "prompt": "CQXYM encountered a rectangle A with dimensions n by m. Inside are n rows and m columns consisting of blocks. Each block in the rectangle may be an obsidian block or empty. CQXYM has the ability to transform an obsidian block into an empty one or vice versa in just one operation.\n\nA rectangle M that is a \u00d7 b in size is considered a portal only if it meets certain requirements:\n\n  * a must be at least 5, and b must be at least 4.\n  * Every block M_{x,1} and M_{x,b} must be an obsidian block for all 1 < x < a.\n  * Every block M_{1,x} and M_{a,x} must be an obsidian block for all 1 < x < b.\n  * Every block M_{x,y} must be empty for all 1<x<a,1<y<b.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nKeep in mind that there must be a rows and b columns, as opposed to b rows and a columns.\n\nNote that corners can be any type.\n\nCQXYM is curious about the fewest number of steps needed to convert at least one sub-rectangle into a portal.\nThe rectangle A can have various configurations of blocks. Consider edge cases where n or m is less than required dimensions for forming a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 89}
