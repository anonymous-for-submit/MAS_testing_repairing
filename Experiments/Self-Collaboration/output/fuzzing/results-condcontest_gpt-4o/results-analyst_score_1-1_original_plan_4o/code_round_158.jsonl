{"name": "1586_H. Omkar and Tours", "description": "Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.\n\nEvery city has an enjoyment value e. Each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled. (In other words, they pay max t over all the roads on which they traveled.) If a vehicle traverses no roads, they pay 0 toll.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. (Keep in mind that a tour group with v vehicles can travel only on roads with capacity \u2265 v.) Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "tags": ["data structures", "dsu", "sortings", "trees"], "difficulty": 14, "id": 1586, "sample_io": [{"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 8\n2 8\n2 3\n2 1\n1 0\n"]}], "test_list": [{"input": "2 6\n1 2\n1 2 2 1\n1 1\n2 1\n3 1\n1 2\n2 2\n3 2\n", "output": ["2 1\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 3\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n3 0\n"]}, {"input": "8 64\n1 1 1 1 1 1 1 1\n6 1 31 60\n1 3 3 8\n1 2 4 27\n4 1 41 27\n7 1 6 39\n1 5 28 46\n1 8 8 55\n55 6\n24 1\n28 1\n46 4\n15 6\n52 4\n58 4\n19 1\n55 8\n59 8\n18 2\n18 7\n26 1\n41 3\n48 4\n41 7\n46 6\n42 8\n44 4\n56 4\n13 1\n46 6\n1 2\n34 5\n47 6\n18 5\n35 8\n26 6\n57 7\n35 2\n27 3\n26 2\n39 2\n11 5\n23 1\n1 2\n54 3\n47 5\n48 2\n13 8\n40 6\n7 6\n38 2\n35 5\n6 6\n19 3\n10 6\n64 1\n2 3\n31 2\n1 6\n59 7\n47 3\n38 7\n18 4\n6 6\n27 7\n13 5\n63 8\n10 8\n11 4\n30 6\n2 2\n34 5\n", "output": ["1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 9\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 5\n1 2 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 1\n1 2\n2 2\n3 2\n", "output": ["2 0\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 2\n1 2 4 9\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 13\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 13\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n2 1\n1 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n5 1\n5 1\n"]}, {"input": "2 2\n4 0\n1 2 4 3\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 0 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n3 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 0 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n6 1\n6 1\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 1 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n3 1\n3 1\n4 1\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 2 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n10 1\n7 2\n", "output": ["7 0\n1 0\n"]}, {"input": "5 5\n1 0 9 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n9 1\n9 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 4\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n5 1\n"]}, {"input": "2 2\n8 1\n1 2 4 3\n10 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["9 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 4\n10 1\n4 2\n", "output": ["7 0\n7 4\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n6 1\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 2 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n2 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 2\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "2 2\n11 3\n1 2 4 9\n10 1\n5 2\n", "output": ["11 0\n3 0\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n3 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "2 1\n4 0\n1 2 4 9\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 3\n2 2 3 3 0\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n0 0\n3 2\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 2\n5 1\n"]}, {"input": "5 5\n1 2 6 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n8 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 6\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 7\n3 0\n5 3\n"]}, {"input": "5 2\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n"]}, {"input": "2 2\n5 2\n1 2 4 9\n10 1\n5 2\n", "output": ["5 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 13\n1 3 2 8\n2 4 3 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 13\n3 0\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 7\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 1 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n3 1\n3 1\n4 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n4 1 0 5 6\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["6 11\n6 0\n5 4\n"]}, {"input": "2 2\n8 2\n1 2 4 4\n10 1\n5 2\n", "output": ["8 0\n2 0\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 2\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 2\n4 1\n6 2\n"]}, {"input": "5 2\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 0 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 2\n", "output": ["3 1\n3 0\n4 7\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 2\n4 5\n4 2\n", "output": ["4 7\n3 0\n4 7\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 2 1\n2 5 1 1\n4 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 0\n2 1\n3 2\n5 1\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 4\n1 3 1 6\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 6\n3 0\n5 3\n"]}, {"input": "2 2\n8 2\n1 2 8 4\n10 1\n5 2\n", "output": ["8 0\n8 4\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 1 2\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 1\n6 2\n"]}, {"input": "5 2\n9 2 0 5 2\n1 2 4 7\n1 3 1 3\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 3\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 9\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 9\n3 0\n3 2\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n2 0\n5 1\n"]}, {"input": "2 1\n8 2\n1 2 8 4\n10 1\n5 2\n", "output": ["8 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n1 3\n7 5\n6 3\n", "output": ["3 9\n3 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 2\n"]}, {"input": "5 3\n4 4 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n4 0\n5 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n3 0\n0 0\n"]}, {"input": "5 3\n10 0 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["10 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 3\n4 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 3\n"]}, {"input": "5 3\n4 9 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["9 11\n4 0\n5 1\n"]}, {"input": "5 3\n4 9 0 5 4\n1 2 4 14\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["9 14\n4 0\n5 1\n"]}, {"input": "2 2\n7 3\n1 2 4 9\n10 2\n5 2\n", "output": ["3 0\n3 0\n"]}, {"input": "8 64\n1 1 1 1 1 1 1 1\n6 1 31 60\n1 3 3 8\n1 2 4 27\n4 1 41 27\n7 1 6 39\n1 5 28 46\n1 8 8 55\n55 6\n24 1\n28 1\n46 4\n15 6\n52 4\n58 4\n19 1\n55 8\n59 8\n18 2\n18 7\n26 1\n41 3\n48 4\n41 7\n46 6\n42 8\n44 4\n56 4\n13 1\n46 6\n1 2\n34 5\n47 6\n18 5\n35 8\n26 6\n57 7\n35 2\n27 3\n26 2\n39 2\n11 5\n23 1\n1 2\n54 3\n47 5\n48 2\n13 8\n40 6\n7 6\n38 2\n35 5\n6 6\n19 3\n10 6\n64 1\n2 3\n41 2\n1 6\n59 7\n47 3\n38 7\n18 4\n6 6\n27 7\n13 5\n63 8\n10 8\n11 4\n30 6\n2 2\n34 5\n", "output": ["1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n1 0\n1 0\n1 0\n1 0\n1 60\n1 0\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 60\n1 0\n1 0\n1 0\n1 60\n1 60\n1 0\n1 60\n1 0\n1 0\n1 60\n1 60\n1 60\n1 0\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 2 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 8\n2 8\n2 3\n2 1\n1 0\n"]}, {"input": "5 5\n2 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 0 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["0 0\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 5\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n5 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 9\n10 2\n5 2\n", "output": ["2 0\n2 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 0\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 14\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 14\n3 0\n5 3\n"]}, {"input": "5 3\n7 4 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["7 11\n2 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n13 2\n", "output": ["5 11\n2 0\n2 0\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 2\n1 2\n2 2\n2 2\n", "output": ["2 0\n2 1\n2 0\n2 0\n2 0\n2 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 1\n1 4\n7 5\n8 2\n", "output": ["5 0\n3 0\n5 4\n"]}, {"input": "5 3\n4 1 0 5 4\n1 2 4 7\n1 3 1 11\n2 4 8 4\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n4 0\n5 4\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 4\n", "output": ["5 11\n2 0\n5 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 2\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n5 2\n"]}, {"input": "2 2\n8 1\n1 2 4 3\n10 2\n2 2\n", "output": ["1 0\n8 3\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 1\n", "output": ["4 8\n3 0\n4 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n5 1\n2 4\n2 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n4 1\n"]}, {"input": "5 5\n1 1 5 2 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n2 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 5 1\n2 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 0\n6 1\n"]}, {"input": "2 2\n9 3\n1 2 4 9\n10 1\n5 2\n", "output": ["9 0\n3 0\n"]}, {"input": "2 2\n5 4\n1 2 4 9\n10 1\n5 2\n", "output": ["5 0\n4 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n3 4 15 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 3\n3 0\n2 0\n"]}, {"input": "5 3\n2 2 0 5 1\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 8\n1 0\n5 4\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n4 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n1 1\n6 1\n"]}, {"input": "5 5\n1 2 3 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 2\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 0\n5 1\n"]}, {"input": "5 3\n2 2 0 3 5\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n5 0\n2 7\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 9\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n1 5\n6 2\n", "output": ["3 9\n3 2\n3 2\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 6\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 6\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 3\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 3\n4 2 0 5 3\n1 2 4 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n10 1\n7 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 1 0 5 3\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 3\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 6\n1 2\n1 2 2 1\n1 2\n2 1\n3 1\n1 2\n2 2\n2 2\n", "output": ["2 0\n2 1\n1 0\n2 0\n2 0\n2 0\n"]}, {"input": "2 2\n7 2\n1 2 4 5\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "2 2\n8 0\n1 2 4 3\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 2\n1 2 4 4\n10 1\n5 2\n", "output": ["7 0\n2 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n8 1\n1 2 4 0\n10 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n5 3\n"]}, {"input": "2 2\n8 1\n1 2 4 0\n9 2\n5 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n6 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 3\n4 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n4 5\n4 2\n", "output": ["4 8\n3 0\n4 7\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n8 1\n3 1\n2 2\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n10 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n2 3 1 1\n1 4 2 0\n3 5 1 1\n10 1\n8 1\n5 2\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 2 3 1 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 15 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 3\n"]}, {"input": "5 3\n4 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n4 5 2 2\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 2\n7 1\n1 2 4 5\n10 1\n5 2\n", "output": ["7 0\n1 0\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 2 1\n4 1\n5 1\n6 1\n8 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n12 1\n7 2\n", "output": ["7 0\n1 0\n"]}, {"input": "2 2\n8 0\n1 2 4 4\n10 2\n5 2\n", "output": ["0 0\n0 0\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 7\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 8\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n14 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 1\n1 3\n7 5\n6 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 3\n9 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 4 3\n4 5 2 1\n1 3\n7 5\n6 2\n", "output": ["9 11\n2 0\n2 0\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n5 1\n5 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "5 5\n1 1 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n10 1\n5 1\n5 1\n2 4\n1 1\n", "output": ["1 0\n1 0\n1 0\n4 0\n6 1\n"]}, {"input": "2 1\n4 0\n1 2 4 13\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 5\n1 2 6 -1 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n8 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n6 1\n6 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 12 3\n2 5 1 1\n1 3\n7 5\n8 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 5\n1 2 3 4 0\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 2\n", "output": ["2 1\n2 1\n3 1\n4 1\n4 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 7\n1 3 1 5\n2 4 8 2\n2 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 7\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 4 1\n4 1\n5 1\n6 1\n8 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n1 0\n1 0\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n2 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n2 2 0 5 3\n1 2 1 11\n1 3 1 8\n2 4 8 4\n2 5 1 0\n1 3\n7 5\n8 2\n", "output": ["5 11\n3 0\n5 4\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 4 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 4 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 6 7\n1 3 1 8\n2 4 8 2\n3 5 1 0\n1 3\n7 5\n6 3\n", "output": ["3 8\n3 0\n0 0\n"]}, {"input": "5 5\n1 2 5 4 6\n1 2 4 1\n1 3 1 1\n1 4 2 1\n3 5 1 1\n9 1\n8 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n2 1\n4 1\n6 1\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n3 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n2 1\n5 1\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n5 2\n", "output": ["4 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 2\n1 4 1 1\n2 5 1 1\n4 1\n4 2\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 0\n2 1\n3 2\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 0 8\n1 4 2 2\n2 5 0 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n2 7\n"]}, {"input": "5 3\n5 4 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n2 2\n", "output": ["4 0\n"]}, {"input": "5 3\n5 0 0 5 2\n1 2 6 6\n1 3 1 11\n2 4 8 3\n4 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n10 1\n2 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 4 12\n1 3 1 5\n2 4 8 2\n4 5 1 1\n1 3\n3 5\n6 2\n", "output": ["3 12\n3 0\n3 2\n"]}, {"input": "5 3\n4 5 0 5 4\n1 2 4 7\n1 3 1 11\n1 4 8 1\n2 5 1 1\n1 3\n14 5\n8 1\n", "output": ["5 11\n4 0\n5 1\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n16 1\n2 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 6 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n3 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "2 1\n4 -1\n1 2 4 13\n16 1\n0 3\n", "output": ["4 0\n"]}, {"input": "5 3\n2 0 0 6 2\n1 2 6 7\n1 3 1 9\n2 4 8 2\n1 5 1 0\n2 3\n7 5\n6 3\n", "output": ["0 0\n2 0\n0 0\n"]}, {"input": "5 3\n2 2 3 3 3\n1 4 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n5 1\n5 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 3\n2 2 3 3 3\n1 2 4 4\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "2 2\n4 0\n1 2 4 6\n10 1\n5 2\n", "output": ["4 0\n0 0\n"]}, {"input": "5 5\n1 2 3 3 5\n1 2 4 1\n1 3 2 1\n2 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n5 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 1 8\n2 4 8 2\n2 5 1 2\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 5\n1 2 3 0 5\n1 2 4 1\n1 3 2 1\n1 4 3 1\n2 5 0 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 1\n2 1\n2 1\n3 1\n3 1\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 7 7\n1 3 1 8\n2 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["3 8\n3 0\n3 3\n"]}, {"input": "5 3\n5 2 0 5 2\n1 2 4 7\n1 3 1 11\n2 4 8 3\n2 5 2 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n5 3\n"]}, {"input": "5 5\n1 0 2 2 2\n1 2 2 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n", "output": ["2 5\n2 3\n2 3\n2 1\n1 0\n"]}, {"input": "2 2\n7 0\n1 2 4 9\n5 1\n7 2\n", "output": ["7 0\n0 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 0 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 3\n2 0 0 3 3\n1 2 3 7\n1 3 1 8\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["3 8\n3 0\n3 2\n"]}, {"input": "5 3\n2 2 0 3 3\n1 2 4 7\n1 3 0 11\n2 4 8 2\n2 5 1 1\n1 3\n7 5\n6 2\n", "output": ["0 0\n3 0\n3 2\n"]}, {"input": "5 5\n1 0 6 0 5\n1 2 4 0\n1 3 2 1\n1 4 2 1\n2 5 1 1\n4 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n6 1\n6 1\n"]}, {"input": "2 2\n7 1\n1 2 4 9\n10 2\n7 2\n", "output": ["1 0\n1 0\n"]}, {"input": "5 5\n1 2 5 4 5\n1 2 4 1\n1 3 1 1\n1 4 2 1\n2 5 1 1\n5 2\n4 1\n3 1\n2 1\n1 1\n", "output": ["2 0\n2 1\n2 1\n4 1\n5 1\n"]}, {"input": "5 5\n1 0 9 0 5\n1 2 4 1\n1 3 2 1\n1 4 2 1\n2 5 1 1\n6 1\n4 1\n3 1\n2 1\n1 1\n", "output": ["1 0\n1 0\n1 0\n9 1\n9 1\n"]}, {"input": "5 3\n4 4 0 5 2\n1 2 6 7\n1 3 1 11\n1 4 8 3\n2 5 1 1\n1 3\n7 5\n8 2\n", "output": ["5 11\n2 0\n4 0\n"]}], "task_id": "codecontest/43", "repair_prompt": ["Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other, guaranteeing that you can reach any city from any other city through the road network.\n\nEvery city has an enjoyment value e; each road has a capacity c, and the capacity denotes the maximum number of vehicles that can be on it. Additionally, it has an associated toll t; however, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled, meaning they pay max t over all the roads on which they traveled. If a vehicle traverses no roads, they pay 0 toll.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x, bearing in mind that a tour group with v vehicles can travel only on roads with capacity \u2265 v. Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y. (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle, ensuring he can reimburse the group regardless of which city they choose. Omkar is looking forward to seeing the smiles on the faces of the tourists as they enjoy all that Omkarland has to offer!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        queries.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, queries\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start, vehicle_count):\n    max_enjoyment = enjoyment_values[start]\n    max_toll = 0\n    visited = [False] * len(enjoyment_values)\n    queue = deque([(start, 0)])\n    visited[start] = True\n    \n    while queue:\n        current, current_toll = queue.popleft()\n        max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n        max_toll = max(max_toll, current_toll)\n        \n        for neighbor, capacity, toll in graph[current]:\n            if not visited[neighbor] and capacity >= vehicle_count:\n                visited[neighbor] = True\n                queue.append((neighbor, max(current_toll, toll)))\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, queries = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count)\n        results\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        # BFS to find reachable cities and max toll\n        queue = deque([(start, 0)])\n        visited = set([start])\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    visited.add(neighbor)\n                    new_max_toll = max(current_max_toll, toll)\n                    queue.append((neighbor, new_max_toll))\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, new_max_toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities\n        queue = deque([(start, 0)])\n        visited = set()\n        reachable_cities = []\n        \n        while queue:\n            city, max_t = queue.popleft()\n            if city in visited:\n                continue\n            visited.add(city)\n            reachable_cities.append((enjoyment_values[city], max_t))\n            \n            for neighbor, capacity, toll in graph[city]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(max_t, toll)))\n        \n        # Find the maximum enjoyment and corresponding max toll\n        for enjoyment, toll in reachable_cities:\n            if enjoyment > max_enjoyment:\n                max_enjoyment = enjoyment\n                max_toll = toll\n            elif enjoyment == max_enjoyment:\n                max_toll = max(max_toll, toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities and calculate max enjoyment and toll\n        queue = deque([(start, 0)])\n        visited = set()\n        local_max_enjoyment = enjoyment_values[start]\n        local_max_toll = 0\n        \n        while queue:\n            current, current_toll = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            \n            # Update local max enjoyment\n            local_max_enjoyment = max(local_max_enjoyment, enjoyment_values[current])\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        # Calculate the max toll for the cities with max enjoyment\n        for city in visited:\n            if enjoyment_values[city] == local_max_enjoyment:\n                # BFS/DFS to find the max toll to this city\n                queue = deque([(start, 0)])\n                visited_toll = set()\n                \n                while queue:\n                    current, current_toll = queue.popleft()\n                    if current in visited_toll:\n                        continue\n                    visited_toll.add(current)\n                    \n                    if current == city:\n                        local_max_toll = max(local_max_toll, current_toll)\nmain()", "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities and max enjoyment\n        queue = deque([(start, 0)])\n        visited = set()\n        local_max_enjoyment = enjoyment_values[start]\n        \n        while queue:\n            current, current_toll = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            \n            local_max_enjoyment = max(local_max_enjoyment, enjoyment_values[current])\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        # Find all cities with max enjoyment value\n        max_enjoyment_cities = [city for city in visited if enjoyment_values[city] == local_max_enjoyment]\n        \n        # Find the max toll for the shortest path to any of these cities\n        for city in max_enjoyment_cities:\n            # BFS to find the shortest path toll\n            queue = deque([(start, 0)])\n            visited = set()\n            \n            while queue:\n                current, current_toll = queue.popleft()\n                if current in visited:\n                    continue\n                visited.add(current)\n                \n                if current == city:\n                    max_toll = max(max_toll, current_toll\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, roads, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road details including connected cities, capacity, and toll.\",\n        \"Read the next q lines to get the tour group details including number of vehicles and starting city.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with capacity and toll attributes.\"\n      ]\n    },\n    {\n      \"description\": \"Determine reachable cities for each tour group based on road capacity constraints.\",\n      \"steps\": [\n        \"For each tour group, perform a graph traversal (e.g., BFS or DFS) starting from the given city.\",\n        \"Only traverse roads with capacity greater than or equal to the number of vehicles in the tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum enjoyment value for reachable cities.\",\n      \"steps\": [\n        \"For each tour group, find the city with the highest enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, determine the shortest path to each reachable city using a suitable algorithm (e.g., Dijkstra's).\",\n        \"Calculate the maximum toll encountered on the shortest path to the city with the highest enjoyment value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group information.\",\n    \"Construct a graph representation using adjacency lists.\",\n    \"For each tour group, perform a graph traversal to identify reachable cities based on road capacity.\",\n    \"Determine the maximum enjoyment value among reachable cities for each tour group.\",\n    \"Calculate the maximum toll for the shortest path to the city with", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Filter Roads by Capacity\",\n      \"description\": \"For each query, filter the roads in the graph to only include those with a capacity greater than or equal to the number of vehicles in the tour group.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"For each query, perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities using the filtered roads.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each query, among the reachable cities, determine the city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each query, calculate the maximum toll that would be paid on the shortest path to any city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each query, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each tour group query, filter the roads to only include those with sufficient capacity for the number of vehicles in the group.\",\n    \"Perform a graph traversal from the starting city to find all reachable cities using the filtered roads.\",\n    \"Identify the city with the maximum enjoyment value among the reachable cities.\",\n    \"Calculate the maximum toll that would be paid on the shortest path to any city with the maximum enjoyment value.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```", "Round_0": {"code": "def parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    roads = []\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        roads.append((a, b, c, t))\n        index += 4\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        queries.append((v, x))\n        index += 2\n    \n    return n, q, enjoyment_values, roads, queries\n\ndef build_graph(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef bfs_max_enjoyment_and_toll(graph, enjoyment_values, start, vehicle_count):\n    max_enjoyment = enjoyment_values[start]\n    max_toll = 0\n    visited = [False] * len(enjoyment_values)\n    queue = deque([(start, 0)])\n    visited[start] = True\n    \n    while queue:\n        current, current_toll = queue.popleft()\n        max_enjoyment = max(max_enjoyment, enjoyment_values[current])\n        max_toll = max(max_toll, current_toll)\n        \n        for neighbor, capacity, toll in graph[current]:\n            if not visited[neighbor] and capacity >= vehicle_count:\n                visited[neighbor] = True\n                queue.append((neighbor, max(current_toll, toll)))\n    \n    return max_enjoyment, max_toll\n\ndef main():\n    n, q, enjoyment_values, roads, queries = parse_input()\n    graph = build_graph(n, roads)\n    \n    results = []\n    for vehicle_count, start_city in queries:\n        max_enjoyment, max_toll = bfs_max_enjoyment_and_toll(graph, enjoyment_values, start_city, vehicle_count)\n        results", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Filter Roads by Capacity\",\n      \"description\": \"For each query, filter the roads in the graph to only include those with a capacity greater than or equal to the number of vehicles in the tour group.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"For each query, perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities using the filtered roads.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each query, among the reachable cities, determine the city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each query, calculate the maximum toll that would be incurred on the shortest path to any city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each query, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each tour group query, filter the roads to only include those with sufficient capacity for the number of vehicles in the group.\",\n    \"Perform a graph traversal from the starting city to find all reachable cities using the filtered roads.\",\n    \"Identify the city with the maximum enjoyment value among the reachable cities.\",\n    \"Calculate the maximum toll incurred on the shortest path to any city with the maximum enjoyment value.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 152)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections with their capacities and tolls.\",\n        \"Read the next q lines to get the tour group details (number of vehicles and starting city).\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacity and toll.\",\n        \"Ensure the graph is a tree since there are n cities and n-1 roads.\"\n      ]\n    },\n    {\n      \"description\": \"Determine reachable cities for each tour group based on road capacity constraints.\",\n      \"steps\": [\n        \"For each tour group, perform a traversal (e.g., BFS or DFS) starting from the given city.\",\n        \"Only traverse roads with capacity greater than or equal to the number of vehicles in the tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum enjoyment value for reachable cities.\",\n      \"steps\": [\n        \"For each tour group, find the city with the highest enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, determine the shortest path to each reachable city using BFS or DFS.\",\n        \"Calculate the maximum toll encountered on the shortest path to the city with the highest enjoyment value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Construct the graph representation of cities and roads.\",\n    \"For each tour group, determine the set of reachable cities based on road capacity.\",\n    \"For each tour group, find the city with the maximum enjoyment value among reachable cities.\",\n    \"For each tour group, calculate the maximum toll for the shortest path to the city with maximum enjoyment value.\",\n    \"Output the maximum enjoyment value and the maximum toll for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 149)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            current_enjoyment = enjoyment_values[current]\n            \n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_max_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"name\": \"Parse Input\",\n      \"description\": \"Read and parse the input data to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\"\n    },\n    {\n      \"name\": \"Build Graph\",\n      \"description\": \"Construct a graph representation of the cities and roads using adjacency lists, where each node represents a city and each edge represents a road with its capacity and toll.\"\n    },\n    {\n      \"name\": \"Filter Roads by Capacity\",\n      \"description\": \"For each query, filter the roads in the graph to only include those with a capacity greater than or equal to the number of vehicles in the tour group.\"\n    },\n    {\n      \"name\": \"Find Reachable Cities\",\n      \"description\": \"For each query, perform a graph traversal (e.g., BFS or DFS) from the starting city to find all reachable cities using the filtered roads.\"\n    },\n    {\n      \"name\": \"Determine Maximum Enjoyment\",\n      \"description\": \"For each query, among the reachable cities, determine the city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Calculate Maximum Toll\",\n      \"description\": \"For each query, calculate the maximum toll that would be paid on the shortest path to any city with the maximum enjoyment value.\"\n    },\n    {\n      \"name\": \"Output Results\",\n      \"description\": \"For each query, output the maximum enjoyment value and the maximum toll per vehicle.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent the cities and roads.\",\n    \"For each tour group query, filter the roads to only include those with sufficient capacity for the number of vehicles in the group.\",\n    \"Perform a graph traversal from the starting city to find all reachable cities using the filtered roads.\",\n    \"Identify the city with the maximum enjoyment value among the reachable cities.\",\n    \"Calculate the maximum toll that would be paid on the shortest path to any city with the maximum enjoyment value.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each query.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        # BFS to find reachable cities and max toll\n        queue = deque([(start, 0)])\n        visited = set([start])\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    visited.add(neighbor)\n                    new_max_toll = max(current_max_toll, toll)\n                    queue.append((neighbor, new_max_toll))\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, new_max_toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 146)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        # BFS to find reachable cities and max toll\n        queue = deque([(start, 0)])\n        visited = set([start])\n        max_enjoyment = enjoyment_values[start]\n        max_toll = 0\n        \n        while queue:\n            current, current_max_toll = queue.popleft()\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    visited.add(neighbor)\n                    new_max_toll = max(current_max_toll, toll)\n                    queue.append((neighbor, new_max_toll))\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, new_max_toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, roads with capacities and tolls, and tour group details.\",\n      \"output\": \"Structured data for cities, roads, and tour groups.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads, where nodes represent cities and edges represent roads with their respective capacities and tolls.\",\n      \"output\": \"Graph data structure with nodes and edges.\"\n    },\n    {\n      \"description\": \"For each tour group, determine the set of cities that are reachable from the starting city, considering the road capacity constraints.\",\n      \"output\": \"List of reachable cities for each tour group.\"\n    },\n    {\n      \"description\": \"For each reachable city, calculate the maximum enjoyment value that can be achieved.\",\n      \"output\": \"Maximum enjoyment value for each tour group.\"\n    },\n    {\n      \"description\": \"For each tour group, determine the maximum toll that would be incurred on the shortest path to any city with the maximum enjoyment value.\",\n      \"output\": \"Maximum toll for each tour group.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of groups, enjoyment values, roads, and tour group details.\",\n    \"Construct a graph using adjacency lists or adjacency matrices to represent the cities and roads.\",\n    \"Implement a graph traversal algorithm (e.g., BFS or DFS) to find all cities reachable from the starting city for each tour group, considering the capacity constraints.\",\n    \"For each tour group, iterate over the reachable cities to find the city with the maximum enjoyment value.\",\n    \"For each city with the maximum enjoyment value, calculate the maximum toll on the shortest path from the starting city using a modified Dijkstra's algorithm or similar approach.\",\n    \"Output the maximum enjoyment value and the maximum toll for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nimport heapq\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities\n        queue = deque([(start, 0)])\n        visited = set()\n        reachable_cities = []\n        \n        while queue:\n            city, max_t = queue.popleft()\n            if city in visited:\n                continue\n            visited.add(city)\n            reachable_cities.append((enjoyment_values[city], max_t))\n            \n            for neighbor, capacity, toll in graph[city]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(max_t, toll)))\n        \n        # Find the maximum enjoyment and corresponding max toll\n        for enjoyment, toll in reachable_cities:\n            if enjoyment > max_enjoyment:\n                max_enjoyment = enjoyment\n                max_toll = toll\n            elif enjoyment == max_enjoyment:\n                max_toll = max(max_toll, toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 158)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities\n        queue = deque([(start, 0)])\n        visited = set()\n        reachable_cities = []\n        \n        while queue:\n            city, max_t = queue.popleft()\n            if city in visited:\n                continue\n            visited.add(city)\n            reachable_cities.append((enjoyment_values[city], max_t))\n            \n            for neighbor, capacity, toll in graph[city]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(max_t, toll)))\n        \n        # Find the maximum enjoyment and corresponding max toll\n        for enjoyment, toll in reachable_cities:\n            if enjoyment > max_enjoyment:\n                max_enjoyment = enjoyment\n                max_toll = toll\n            elif enjoyment == max_enjoyment:\n                max_toll = max(max_toll, toll)\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, roads, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road details including connected cities, capacity, and toll.\",\n        \"Read the next q lines to get the tour group details including number of vehicles and starting city.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with capacity and toll attributes.\"\n      ]\n    },\n    {\n      \"description\": \"Determine reachable cities for each tour group based on road capacity constraints.\",\n      \"steps\": [\n        \"For each tour group, perform a graph traversal (e.g., BFS or DFS) starting from the given city.\",\n        \"Only traverse roads with capacity greater than or equal to the number of vehicles in the tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum enjoyment value for reachable cities.\",\n      \"steps\": [\n        \"For each tour group, find the city with the highest enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, determine the shortest path to each reachable city using a suitable algorithm (e.g., Dijkstra's).\",\n        \"Calculate the maximum toll encountered on the shortest path to the city with the highest enjoyment value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group information.\",\n    \"Construct a graph representation using adjacency lists.\",\n    \"For each tour group, perform a graph traversal to identify reachable cities based on road capacity.\",\n    \"Determine the maximum enjoyment value among reachable cities for each tour group.\",\n    \"Calculate the maximum toll for the shortest path to the city with", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 147)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_max_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of queries, enjoyment values for each city, road connections with capacities and tolls, and the tour group details.\",\n      \"output\": \"Structured data containing cities, roads, and tour groups.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of Omkarland using the cities and roads data. Each city is a node, and each road is an edge with attributes for capacity and toll.\",\n      \"output\": \"Graph data structure representing the cities and roads.\"\n    },\n    {\n      \"description\": \"For each tour group, determine the set of cities that are reachable from the starting city, considering the road capacity constraints.\",\n      \"output\": \"List of reachable cities for each tour group.\"\n    },\n    {\n      \"description\": \"For each tour group, find the city with the maximum enjoyment value among the reachable cities.\",\n      \"output\": \"Maximum enjoyment value for each tour group.\"\n    },\n    {\n      \"description\": \"For each tour group, calculate the maximum toll that would be incurred on the shortest path to any of the cities with the maximum enjoyment value.\",\n      \"output\": \"Maximum toll per vehicle for each tour group.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of queries, enjoyment values, road connections, and tour group details.\",\n    \"Construct a graph using the parsed data, where nodes represent cities and edges represent roads with capacity and toll attributes.\",\n    \"For each tour group, perform a graph traversal (e.g., BFS or DFS) starting from the given city, considering only roads with sufficient capacity to determine reachable cities.\",\n    \"Identify the city with the highest enjoyment value among the reachable cities for each tour group.\",\n    \"For each city with the maximum enjoyment value, calculate the maximum toll on the shortest path from the starting city to that city.\",\n    \"Output the maximum enjoyment value and the maximum toll per vehicle for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities and calculate max enjoyment and toll\n        queue = deque([(start, 0)])\n        visited = set()\n        local_max_enjoyment = enjoyment_values[start]\n        local_max_toll = 0\n        \n        while queue:\n            current, current_toll = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            \n            # Update local max enjoyment\n            local_max_enjoyment = max(local_max_enjoyment, enjoyment_values[current])\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        # Calculate the max toll for the cities with max enjoyment\n        for city in visited:\n            if enjoyment_values[city] == local_max_enjoyment:\n                # BFS/DFS to find the max toll to this city\n                queue = deque([(start, 0)])\n                visited_toll = set()\n                \n                while queue:\n                    current, current_toll = queue.popleft()\n                    if current in visited_toll:\n                        continue\n                    visited_toll.add(current)\n                    \n                    if current == city:\n                        local_max_toll = max(local_max_toll, current", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 71)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities and calculate max enjoyment and toll\n        queue = deque([(start, 0)])\n        visited = set()\n        local_max_enjoyment = enjoyment_values[start]\n        local_max_toll = 0\n        \n        while queue:\n            current, current_toll = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            \n            # Update local max enjoyment\n            local_max_enjoyment = max(local_max_enjoyment, enjoyment_values[current])\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        # Calculate the max toll for the cities with max enjoyment\n        for city in visited:\n            if enjoyment_values[city] == local_max_enjoyment:\n                # BFS/DFS to find the max toll to this city\n                queue = deque([(start, 0)])\n                visited_toll = set()\n                \n                while queue:\n                    current, current_toll = queue.popleft()\n                    if current in visited_toll:\n                        continue\n                    visited_toll.add(current)\n                    \n                    if current == city:\n                        local_max_toll = max(local_max_toll, current_toll)"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, road connections, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road connections, capacities, and tolls.\",\n        \"Read the next q lines to get the tour group details (number of vehicles and starting city).\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with associated capacities and tolls.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the maximum enjoyment value reachable for each tour group.\",\n      \"steps\": [\n        \"For each tour group, perform a graph traversal (e.g., BFS or DFS) starting from the given city.\",\n        \"Only traverse roads with capacity greater than or equal to the number of vehicles in the tour group.\",\n        \"Track the maximum enjoyment value encountered during the traversal.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, find the shortest path to each city with the maximum enjoyment value using a graph traversal.\",\n        \"Track the maximum toll encountered on the shortest path.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group details.\",\n    \"Construct a graph using adjacency lists to represent cities and roads.\",\n    \"For each tour group, perform a graph traversal to find reachable cities and determine the maximum enjoyment value.\",\n    \"For each reachable city with maximum enjoyment, calculate the maximum toll on the shortest path.\",\n    \"Output the maximum enjoyment value and toll per vehicle for each tour group.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities and max enjoyment\n        queue = deque([(start, 0)])\n        visited = set()\n        local_max_enjoyment = enjoyment_values[start]\n        local_max_toll = 0\n        \n        while queue:\n            current, current_toll = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            \n            local_max_enjoyment = max(local_max_enjoyment, enjoyment_values[current])\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        # Find all cities with max enjoyment value\n        max_enjoyment_cities = [city for city in visited if enjoyment_values[city] == local_max_enjoyment]\n        \n        # Find the max toll for the shortest path to any of these cities\n        for city in max_enjoyment_cities:\n            # BFS to find the shortest path toll\n            queue = deque([(start, 0)])\n            visited = set()\n            \n            while queue:\n                current, current_toll = queue.popleft()\n                if current in visited:\n                    continue\n                visited.add(current)\n                \n                if current == city:", "report": "The compilation output of the preceding code is: expected an indented block (<string>, line 71)"}, "Round_1": {"code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start in queries:\n        max_enjoyment = -1\n        max_toll = 0\n        \n        # BFS to find reachable cities and max enjoyment\n        queue = deque([(start, 0)])\n        visited = set()\n        local_max_enjoyment = enjoyment_values[start]\n        \n        while queue:\n            current, current_toll = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            \n            local_max_enjoyment = max(local_max_enjoyment, enjoyment_values[current])\n            \n            for neighbor, capacity, toll in graph[current]:\n                if neighbor not in visited and capacity >= v:\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        # Find all cities with max enjoyment value\n        max_enjoyment_cities = [city for city in visited if enjoyment_values[city] == local_max_enjoyment]\n        \n        # Find the max toll for the shortest path to any of these cities\n        for city in max_enjoyment_cities:\n            # BFS to find the shortest path toll\n            queue = deque([(start, 0)])\n            visited = set()\n            \n            while queue:\n                current, current_toll = queue.popleft()\n                if current in visited:\n                    continue\n                visited.add(current)\n                \n                if current == city:\n                    max_toll = max(max_toll, current_toll"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, roads, and tour group queries.\",\n      \"output\": \"Structured data containing cities, roads, and tour group queries.\"\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads, where nodes represent cities and edges represent roads with their respective capacities and tolls.\",\n      \"output\": \"Graph data structure representing the cities and roads.\"\n    },\n    {\n      \"description\": \"For each tour group query, determine the set of cities that can be reached from the starting city given the vehicle capacity constraint.\",\n      \"output\": \"Reachable cities for each tour group query.\"\n    },\n    {\n      \"description\": \"For each reachable city, calculate the maximum enjoyment value and the maximum toll on the shortest path from the starting city.\",\n      \"output\": \"Maximum enjoyment value and maximum toll for each tour group query.\"\n    },\n    {\n      \"description\": \"Output the results for each tour group query, including the highest enjoyment value and the maximum toll per vehicle.\",\n      \"output\": \"Formatted output for each query.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of cities, number of groups, enjoyment values, roads, and tour group queries.\",\n    \"Construct a graph using adjacency lists or another suitable data structure to represent the cities and roads.\",\n    \"Implement a function to perform a breadth-first search (BFS) or depth-first search (DFS) from the starting city for each tour group query, considering only roads with sufficient capacity.\",\n    \"For each reachable city, track the maximum enjoyment value and the maximum toll encountered on the path from the starting city.\",\n    \"For each tour group query, determine the city with the highest enjoyment value and calculate the maximum toll on the shortest path to that city.\",\n    \"Output the highest enjoyment value and the maximum toll per vehicle for each tour group query.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 144)"}, "Round_1": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    graph = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    queries = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        queries.append((v, x))\n    \n    results = []\n    \n    for v, start_city in queries:\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        \n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        \n        while queue:\n            current_city, current_max_toll = queue.popleft()\n            visited[current_city] = True\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    max_enjoyment = max(max_enjoyment, enjoyment_values[neighbor])\n                    max_toll = max(max_toll, toll)\n                    queue.append((neighbor, max(max_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of cities, number of groups, enjoyment values, roads, and tour group details.\",\n      \"steps\": [\n        \"Read the first line to get n (number of cities) and q (number of groups).\",\n        \"Read the second line to get the enjoyment values for each city.\",\n        \"Read the next n-1 lines to get the road details including connected cities, capacity, and toll.\",\n        \"Read the next q lines to get the tour group details including number of vehicles and starting city.\"\n      ]\n    },\n    {\n      \"description\": \"Construct a graph representation of the cities and roads.\",\n      \"steps\": [\n        \"Use an adjacency list to represent the graph where each city is a node and roads are edges with capacity and toll attributes.\"\n      ]\n    },\n    {\n      \"description\": \"Determine reachable cities for each tour group based on road capacity constraints.\",\n      \"steps\": [\n        \"For each tour group, perform a graph traversal (e.g., BFS or DFS) starting from the given city.\",\n        \"Only traverse roads with capacity greater than or equal to the number of vehicles in the tour group.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum enjoyment value for reachable cities.\",\n      \"steps\": [\n        \"For each tour group, find the city with the highest enjoyment value among the reachable cities.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the maximum toll for the shortest path to the city with maximum enjoyment value.\",\n      \"steps\": [\n        \"For each tour group, determine the shortest path to each reachable city using a suitable algorithm (e.g., Dijkstra's).\",\n        \"Calculate the maximum toll encountered on the shortest path to the city with the highest enjoyment value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for each tour group.\",\n      \"steps\": [\n        \"For each tour group, output the maximum enjoyment value and the maximum toll per vehicle.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract cities, roads, and tour group information.\",\n    \"Construct a graph representation using adjacency lists.\",\n    \"For each tour group, perform a graph traversal to identify reachable cities based on road capacity.\",\n    \"Determine the maximum enjoyment value among reachable cities for each tour group.\",\n    \"Calculate the maximum toll for the shortest path to the city with", "Round_0": {"code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read number of cities and number of groups\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    # Read enjoyment values\n    enjoyment_values = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Read roads\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        c = int(data[index + 2])\n        t = int(data[index + 3])\n        index += 4\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    # Read tour groups\n    tour_groups = []\n    for _ in range(q):\n        v = int(data[index])\n        x = int(data[index + 1]) - 1\n        index += 2\n        tour_groups.append((v, x))\n    \n    # Process each tour group\n    results = []\n    for v, start_city in tour_groups:\n        # BFS to find reachable cities\n        max_enjoyment = enjoyment_values[start_city]\n        max_toll = 0\n        visited = [False] * n\n        queue = deque([(start_city, 0)])\n        visited[start_city] = True\n        \n        while queue:\n            current_city, current_toll = queue.popleft()\n            max_enjoyment = max(max_enjoyment, enjoyment_values[current_city])\n            max_toll = max(max_toll, current_toll)\n            \n            for neighbor, capacity, toll in graph[current_city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        results.append((max_enjoyment, max_toll))\n    \n    # Output results\n    for enjoyment, toll in results:\n        print(enjoyment, toll)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, false, false, true, false, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 158, "prompt": "Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other, guaranteeing that you can reach any city from any other city through the road network.\n\nEvery city has an enjoyment value e; each road has a capacity c, and the capacity denotes the maximum number of vehicles that can be on it. Additionally, it has an associated toll t; however, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled, meaning they pay max t over all the roads on which they traveled. If a vehicle traverses no roads, they pay 0 toll.\n\nOmkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x, bearing in mind that a tour group with v vehicles can travel only on roads with capacity \u2265 v. Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y. (This trip from x to y will always be on the shortest path from x to y.)\n\nIn the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle, ensuring he can reimburse the group regardless of which city they choose. Omkar is looking forward to seeing the smiles on the faces of the tourists as they enjoy all that Omkarland has to offer!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 q \u2264 2 \u22c5 10^5), representing the number of cities and the number of groups, respectively.\n\nThe next line contains n integers e_1, e_2, \u2026, e_n (1 \u2264 e_i \u2264 10^9), where e_i represents the enjoyment value for city i.\n\nThe next n-1 lines each contain four integers a, b, c, and t (1 \u2264 a,b \u2264 n, 1 \u2264 c \u2264 10^9, 1 \u2264 t \u2264 10^9), representing an road between city a and city b with capacity c and toll t.\n\nThe next q lines each contain two integers v and x (1 \u2264 v \u2264 10^9, 1 \u2264 x \u2264 n), representing the number of vehicles in the tour group and the starting city, respectively.\n\nOutput\n\nOutput q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.\n\nExamples\n\nInput\n\n\n5 3\n2 2 3 3 3\n1 2 4 7\n1 3 2 8\n2 4 8 2\n2 5 1 1\n1 3\n9 5\n6 2\n\n\nOutput\n\n\n3 8\n3 0\n3 2\n\n\nInput\n\n\n5 5\n1 2 3 4 5\n1 2 4 1\n1 3 3 1\n1 4 2 1\n2 5 1 1\n5 1\n4 1\n3 1\n2 1\n1 1\n\n\nOutput\n\n\n1 0\n2 1\n3 1\n4 1\n5 1\n\n\nInput\n\n\n5 5\n1 2 2 2 2\n1 2 5 8\n1 3 6 3\n1 4 4 5\n1 5 7 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\nOutput\n\n\n2 8\n2 8\n2 3\n2 1\n1 0\n\nNote\n\nA map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.\n\n<image>\n\nFor the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\nFor the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.\n\nFor the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.\n\nA map of the second sample is shown below:\n\n<image>\n\nFor the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\nFor the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.\n\nFor the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.\n\nFor the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.\n\nFor the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 122}
