{"name": "1582_A. Luntik and Concerts", "description": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "tags": ["math"], "difficulty": 7, "id": 1582, "sample_io": [{"input": "4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}], "test_list": [{"input": "4\n1 1 1\n2 1 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 5\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 1 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 4\n2 2 2\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n4 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 8\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 7\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 5\n1 2 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n2 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 3 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 1 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n3 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 4 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 3\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 0\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 1\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 5\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 1 1\n4 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 2 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 5 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 6\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 6\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 3\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 3\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n2 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 2\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 0\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 4 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 6\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 3 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n4 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n4 2 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 0\n5 2 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n12 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n4 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 0 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 4 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 10\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n2 4 5\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n11 4 9\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n9 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 6\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 1 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n1 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n3 1 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 4 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 0\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 4 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 1\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n2 3 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n4 1 2\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 7 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n6 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 0\n4 3 2\n3 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n3 4 5\n1 1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n2 2 0\n0 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 8\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 13\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 1\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 1\n0 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 6 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n4 3 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 2 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 5 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 10\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 2 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 1 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n3 2 1\n1 4 0\n1 1 0\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 3\n2 2 1\n3 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 4\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 8 5\n2 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n2 1 1\n3 3 1\n6 4 3\n1 1 3\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 2\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}], "task_id": "codecontest/28", "repair_prompt": ["Luntik has decided to try singing. He has a one-minute songs, b two-minute songs, and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Some insight into the optimal distribution strategy would be a great help.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is the sum of all songs, we need to find the closest possible sum to total_duration // 2.\n        \n        # Initialize a set to keep track of possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "completions": ["def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The strategy is to check if the total duration is even or odd\n        # If even, the minimal difference is 0, if odd, the minimal difference is 1\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The strategy is to check if the total duration is even or odd\n        # If even, the minimal difference is 0, if odd, the minimal difference is 1\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Initialize a set to track possible durations\n        possible_durations = {0}\n        \n        # Process one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Process two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Process three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the closest possible duration to target_duration\n        closest_duration = 0\n        for duration in possible_durations:\n            if duration <= target_duration:\n                closest_duration = max(closest_duration, duration)\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is small, we can use a simple approach to find the minimal difference.\n        # We will try to balance the songs between two concerts.\n        \n        # Calculate the minimal possible difference\n        # The difference can be calculated as the remainder when total_duration is divided by 2\n        minimal_diff = total_duration % 2\n        results.append(minimal_diff)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Use a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        \n        # Add two-minute songs\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        \n        # Add three-minute songs\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to the target duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target_duration))\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = [(int(data[i]), int(data[i+1]), int(data[i+2])) for i in range(1, len(data), 3)]\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split the total_duration into two parts with minimal difference\n        # This is a variation of the partition problem\n        # We can use a greedy approach to approximate the solution\n        half_duration = total_duration // 2\n        # Try to fill one concert to be as close to half_duration as possible\n        # Start with the largest songs (3-minute) to fill the concert\n        concert1_duration = 0\n        # Add 3-minute songs\n        three_minute_songs = min(c, half_duration // 3)\n        concert1_duration += three_minute_songs * 3\n        half_duration -= three_minute_songs * 3\n        # Add 2-minute songs\n        two_minute_songs = min(b, half_duration // 2)\n        concert1_duration += two_minute_songs * 2\n        half_duration -= two_minute_songs * 2\n        # Add 1-minute songs\n        one_minute_songs = min(a, half_duration)\n        concert1_duration += one_minute_songs * 1\n        half_duration -= one_minute_songs * 1\n        \n        concert2_duration = total_duration - concert1_duration\n        difference = abs(concert1_duration - concert2_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n\n        # Use a set to track possible sums\n        possible_sums = {0}\n\n        # Add 1-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                if s + 1 <= half_duration:\n                    new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n\n        # Add 2-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                if s + 2 <= half_duration:\n                    new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n\n        # Add 3-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                if s + 3 <= half_duration:\n                    new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n\n        # Find the closest sum to half_duration\n        closest_sum = max(possible_sums)\n        minimal_diff = total_duration - 2 * closest_sum\n        results.append(minimal_diff)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Initialize DP array\n        dp = [False] * (target_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest possible duration to target_duration\n        for i in range(target_duration, -1, -1):\n            if dp[i]:\n                concert1_duration = i\n                break\n        \n        concert2_duration = total_duration - concert1_duration\n        minimal_diff = abs(concert1_duration - concert2_duration)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split the total_duration into two parts with minimal difference\n        # We can use a greedy approach to try to balance the two concerts\n        half_duration = total_duration // 2\n        \n        # Initialize possible sums for the first concert\n        possible_sums = {0}\n        \n        # Try to add songs to the first concert to get as close as possible to half_duration\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the difference between the two concerts\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()", "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is the sum of all songs, we need to find the closest possible sum to total_duration // 2.\n        \n        # Initialize a set to keep track of possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs by summing up the products of the number of songs and their respective durations.\",\n    \"For each test case, use a strategy to distribute the songs into two concerts such that the absolute difference in their durations is minimized. This can be approached as a variation of the partition problem, where the goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference in minutes between the concerts' durations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is the sum of all songs, we need to find the closest possible sum to total_duration // 2.\n        \n        # Initialize a set to keep track of possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is the sum of all songs, we need to find the closest possible sum to total_duration // 2.\n        \n        # Initialize a set to keep track of possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a strategy to distribute the songs into two concerts such that the absolute difference in their durations is minimized. This can be approached as a variation of the partition problem, where the goal is to split the songs into two groups with minimal difference in total duration.\",\n    \"Output the minimal possible difference in minutes between the concerts' durations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The strategy is to check if the total duration is even or odd\n        # If even, the minimal difference is 0, if odd, the minimal difference is 1\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the counts of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the song counts for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a strategy to distribute the songs into two groups such that the absolute difference in their total durations is minimized. This can be approached as a variation of the partition problem.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The strategy is to check if the total duration is even or odd\n        # If even, the minimal difference is 0, if odd, the minimal difference is 1\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"steps\": [\n        \"Multiply the number of one-minute songs by 1.\",\n        \"Multiply the number of two-minute songs by 2.\",\n        \"Multiply the number of three-minute songs by 3.\",\n        \"Sum the results to get the total duration of all songs.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"steps\": [\n        \"Divide the total duration by 2 to get the target duration for each concert.\",\n        \"Consider both floor and ceiling values of the division to account for integer division.\"\n      ]\n    },\n    {\n      \"description\": \"Distribute songs to minimize the difference between concert durations.\",\n      \"steps\": [\n        \"Use a greedy or dynamic programming approach to distribute songs.\",\n        \"Try to match the target duration as closely as possible for each concert.\",\n        \"Calculate the absolute difference between the two concert durations.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the number of one-minute, two-minute, and three-minute songs.\",\n    \"Calculate the total duration of all songs.\",\n    \"Determine the target duration for each concert.\",\n    \"Distribute songs between the two concerts to minimize the difference in durations.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Initialize a DP array to track possible durations\n        dp = [False] * (target_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target_duration, 0, -1):\n                if j >= 1 and dp[j - 1]:\n                    dp[j] = True\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target_duration, 1, -1):\n                if j >= 2 and dp[j - 2]:\n                    dp[j] = True\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target_duration, 2, -1):\n                if j >= 3 and dp[j - 3]:\n                    dp[j] = True\n        \n        # Find the closest possible duration to target_duration\n        closest_duration = 0\n        for i in range(target_duration, -1, -1):\n            if dp[i]:\n                closest_duration = i\n                break\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Initialize a set to track possible durations\n        possible_durations = {0}\n        \n        # Process one-minute songs\n        for _ in range(a):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 1)\n            possible_durations.update(new_durations)\n        \n        # Process two-minute songs\n        for _ in range(b):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 2)\n            possible_durations.update(new_durations)\n        \n        # Process three-minute songs\n        for _ in range(c):\n            new_durations = set()\n            for duration in possible_durations:\n                new_durations.add(duration + 3)\n            possible_durations.update(new_durations)\n        \n        # Find the closest possible duration to target_duration\n        closest_duration = 0\n        for duration in possible_durations:\n            if duration <= target_duration:\n                closest_duration = max(closest_duration, duration)\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs by summing up the products of the number of songs and their respective durations.\",\n    \"For each test case, use a strategy to distribute the songs into two concerts such that the absolute difference in their durations is minimized. This can be approached as a variation of the partition problem, where the goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference in minutes between the concerts' durations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is small, we can use a simple approach to find the minimal difference.\n        # We will try to balance the songs between two concerts.\n        \n        # Calculate the minimal possible difference\n        # The difference can be calculated as the remainder when total_duration is divided by 2\n        minimal_diff = total_duration % 2\n        results.append(minimal_diff)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"steps\": [\n        \"Multiply the number of one-minute songs by 1.\",\n        \"Multiply the number of two-minute songs by 2.\",\n        \"Multiply the number of three-minute songs by 3.\",\n        \"Sum the results to get the total duration.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"steps\": [\n        \"Divide the total duration by 2 to get the target duration for each concert.\"\n      ]\n    },\n    {\n      \"description\": \"Distribute songs to minimize the difference between concert durations.\",\n      \"steps\": [\n        \"Use a greedy or dynamic programming approach to distribute songs.\",\n        \"Ensure the sum of durations in each concert is as close as possible to the target duration.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference.\",\n      \"steps\": [\n        \"Calculate the absolute difference between the durations of the two concerts.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, read the number of one-minute, two-minute, and three-minute songs.\",\n    \"Calculate the total duration of all songs.\",\n    \"Determine the target duration for each concert.\",\n    \"Distribute songs between the two concerts to minimize the difference in durations.\",\n    \"Calculate and output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Dynamic programming approach to find the closest sum to target_duration\n        possible_sums = {0}\n        \n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        closest_sum = min(possible_sums, key=lambda x: abs(x - target_duration))\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = [(int(data[i]), int(data[i+1]), int(data[i+2])) for i in range(1, len(data), 3)]\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Use a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        \n        # Add two-minute songs\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        \n        # Add three-minute songs\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to the target duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - target_duration))\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = [(int(data[i]), int(data[i+1]), int(data[i+2])) for i in range(1, len(data), 3)]\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs by summing up the durations: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a strategy to distribute the songs into two concerts such that the absolute difference in their durations is minimized. This can be approached as a variation of the partition problem.\",\n    \"Output the minimal possible difference in minutes between the concerts durations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split the total_duration into two parts with minimal difference\n        # This is a variation of the partition problem\n        # We can use a greedy approach to approximate the solution\n        half_duration = total_duration // 2\n        # Try to fill one concert to be as close to half_duration as possible\n        # Start with the largest songs (3-minute) to fill the concert\n        concert1_duration = 0\n        # Add 3-minute songs\n        three_minute_songs = min(c, half_duration // 3)\n        concert1_duration += three_minute_songs * 3\n        half_duration -= three_minute_songs * 3\n        # Add 2-minute songs\n        two_minute_songs = min(b, half_duration // 2)\n        concert1_duration += two_minute_songs * 2\n        half_duration -= two_minute_songs * 2\n        # Add 1-minute songs\n        one_minute_songs = min(a, half_duration)\n        concert1_duration += one_minute_songs * 1\n        half_duration -= one_minute_songs * 1\n        \n        concert2_duration = total_duration - concert1_duration\n        difference = abs(concert1_duration - concert2_duration)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs by summing up the products of the number of songs and their respective durations.\",\n    \"For each test case, use a strategy to distribute the songs into two concerts such that the absolute difference in their durations is minimized. This can be approached as a variation of the partition problem, where the goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference in minutes between the concerts' durations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # We need to find the closest we can get to half of the total duration\n        half_duration = total_duration // 2\n\n        # Dynamic programming approach to solve the partition problem\n        # dp[i] will be True if a sum of i can be formed with the given songs\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n\n        # Try to form sums using 1-minute songs\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n\n        # Try to form sums using 2-minute songs\n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n\n        # Try to form sums using 3-minute songs\n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n\n        # Find the largest sum we can form that is <= half_duration\n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                closest_sum = i\n                break\n\n        # The minimal difference is the difference between twice the closest sum and the total duration\n        minimal_diff = total_duration - 2 * closest_sum\n        results.append(minimal_diff)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n\n        # Use a set to track possible sums\n        possible_sums = {0}\n\n        # Add 1-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                if s + 1 <= half_duration:\n                    new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n\n        # Add 2-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                if s + 2 <= half_duration:\n                    new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n\n        # Add 3-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                if s + 3 <= half_duration:\n                    new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n\n        # Find the closest sum to half_duration\n        closest_sum = max(possible_sums)\n        minimal_diff = total_duration - 2 * closest_sum\n        results.append(minimal_diff)\n\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Calculate the total duration of all songs.\",\n      \"details\": \"Sum the durations of all one-minute, two-minute, and three-minute songs.\"\n    },\n    {\n      \"description\": \"Determine the target duration for each concert.\",\n      \"details\": \"Divide the total duration by 2 to find the target duration for each concert.\"\n    },\n    {\n      \"description\": \"Distribute songs to minimize the difference in concert durations.\",\n      \"details\": \"Use a strategy to distribute songs such that the absolute difference between the two concert durations is minimized.\"\n    },\n    {\n      \"description\": \"Calculate the minimal possible difference.\",\n      \"details\": \"Compute the absolute difference between the durations of the two concerts.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Read input data.\",\n      \"details\": \"Parse the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Calculate total duration of songs.\",\n      \"details\": \"Sum the durations of all songs (a * 1 + b * 2 + c * 3).\"\n    },\n    {\n      \"step\": \"Determine target duration for each concert.\",\n      \"details\": \"Divide the total duration by 2 to find the target duration for each concert.\"\n    },\n    {\n      \"step\": \"Distribute songs to minimize difference.\",\n      \"details\": \"Implement a strategy to distribute songs between two concerts to minimize the absolute difference in durations.\"\n    },\n    {\n      \"step\": \"Calculate and store the minimal possible difference.\",\n      \"details\": \"Compute the absolute difference between the two concert durations and store the result.\"\n    },\n    {\n      \"step\": \"Output results.\",\n      \"details\": \"Print the minimal possible difference for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Initialize DP array\n        dp = [False] * (target_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest possible duration to target_duration\n        for i in range(target_duration, -1, -1):\n            if dp[i]:\n                concert1_duration = i\n                break\n        \n        concert2_duration = total_duration - concert1_duration\n        minimal_diff = abs(concert1_duration - concert2_duration)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        target_duration = total_duration // 2\n        \n        # Initialize DP array\n        dp = [False] * (target_duration + 1)\n        dp[0] = True\n        \n        # Process one-minute songs\n        for _ in range(a):\n            for j in range(target_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        # Process two-minute songs\n        for _ in range(b):\n            for j in range(target_duration, 0, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        # Process three-minute songs\n        for _ in range(c):\n            for j in range(target_duration, 0, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the closest possible duration to target_duration\n        for i in range(target_duration, -1, -1):\n            if dp[i]:\n                concert1_duration = i\n                break\n        \n        concert2_duration = total_duration - concert1_duration\n        minimal_diff = abs(concert1_duration - concert2_duration)\n        results.append(minimal_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) for each test case.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of each type of song for each test case.\",\n    \"For each test case, calculate the total duration of all songs using the formula: total_duration = a * 1 + b * 2 + c * 3.\",\n    \"For each test case, use a strategy to distribute the songs into two concerts such that the absolute difference in their durations is minimized. This can involve iterating over possible distributions and calculating the resulting differences.\",\n    \"Output the minimal possible difference for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split the total_duration into two parts with minimal difference\n        # We can use a greedy approach to try to balance the two concerts\n        half_duration = total_duration // 2\n        \n        # Initialize possible sums for the first concert\n        possible_sums = {0}\n        \n        # Try to add songs to the first concert to get as close as possible to half_duration\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the difference between the two concerts\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to split the total_duration into two parts with minimal difference\n        # We can use a greedy approach to try to balance the two concerts\n        half_duration = total_duration // 2\n        \n        # Initialize possible sums for the first concert\n        possible_sums = {0}\n        \n        # Try to add songs to the first concert to get as close as possible to half_duration\n        for _ in range(a):\n            possible_sums = {x + 1 for x in possible_sums} | possible_sums\n        for _ in range(b):\n            possible_sums = {x + 2 for x in possible_sums} | possible_sums\n        for _ in range(c):\n            possible_sums = {x + 3 for x in possible_sums} | possible_sums\n        \n        # Find the closest sum to half_duration\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the difference between the two concerts\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n      \"input\": \"A single integer t followed by t lines, each containing three integers a, b, c.\",\n      \"output\": \"A list of tuples, each containing three integers (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\"\n    },\n    {\n      \"description\": \"Calculate the total duration of all songs for each test case.\",\n      \"input\": \"A tuple (a, b, c) representing the number of one-minute, two-minute, and three-minute songs.\",\n      \"output\": \"An integer representing the total duration of all songs.\"\n    },\n    {\n      \"description\": \"Determine the minimal possible difference in durations between two concerts for each test case.\",\n      \"input\": \"The total duration of all songs and the number of each type of song (a, b, c).\",\n      \"output\": \"An integer representing the minimal possible difference in minutes between the concerts' durations.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases and the number of one-minute, two-minute, and three-minute songs for each test case.\",\n    \"For each test case, calculate the total duration of all songs by summing up the products of the number of songs and their respective durations.\",\n    \"For each test case, use a strategy to distribute the songs into two concerts such that the absolute difference in their durations is minimized. This can be approached as a variation of the partition problem, where the goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\",\n    \"Output the minimal possible difference in minutes between the concerts' durations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is the sum of all songs, we need to find the closest possible sum to total_duration // 2.\n        \n        # Initialize a set to keep track of possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: timed out"}, "Round_1": {"code": "def minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The goal is to find a subset of songs that makes the sum of durations as close as possible to half of the total duration.\n        # Since the total duration is the sum of all songs, we need to find the closest possible sum to total_duration // 2.\n        \n        # Initialize a set to keep track of possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 1)\n            possible_sums.update(new_sums)\n        \n        # Add two-minute songs\n        for _ in range(b):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 2)\n            possible_sums.update(new_sums)\n        \n        # Add three-minute songs\n        for _ in range(c):\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s + 3)\n            possible_sums.update(new_sums)\n        \n        # Find the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal possible difference\n        difference = abs(total_duration - 2 * closest_sum)\n        results.append(difference)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        test_cases.append((a, b, c))\n        index += 3\n    \n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 344, "prompt": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs, and c three-minute songs and wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Some insight into the optimal distribution strategy would be a great help.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 241}
