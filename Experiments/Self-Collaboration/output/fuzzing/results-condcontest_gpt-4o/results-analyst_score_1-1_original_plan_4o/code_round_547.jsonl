{"name": "1580_C. Train Maintenance", "description": "Kawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "tags": ["brute force", "data structures", "implementation"], "difficulty": 9, "id": 1580, "sample_io": [{"input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "test_list": [{"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "3 4\n10 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "3 4\n23 15\n14 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n2 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n5\n4\n3\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n2\n3\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 2\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n"]}, {"input": "20 7\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n4 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n3 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n"]}, {"input": "3 2\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n2 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n1 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n2\n2\n2\n1\n3\n4\n4\n4\n4\n5\n5\n4\n3\n4\n6\n8\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 2\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 6\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n6\n5\n6\n7\n7\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n1 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n14 9\n14 19\n7 19\n2 9\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n4\n3\n4\n7\n8\n"]}, {"input": "3 4\n16 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n10 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n10 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 1\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 0\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n13 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n467159628 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 0\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n21 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n13 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n369260158 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 16\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n26 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n23 15\n14 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n17 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n2 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000101 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 7\n15 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 4\n16 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n9 15\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 5\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n5 15\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 8\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10001011 100000000\n998244353 1\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1166046831 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n26 15\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1425917046 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 11\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "20 20\n1 4\n864803385 801909796\n17 4\n12 1\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n15 15\n7 3\n19 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 1\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 8\n12 25\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1011185365 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000001\n733475792 0\n2 2\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n2 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n16 15\n12 15\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000011 000000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 1\n9 15\n12 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n9 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n10 18\n12 10\n2 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n733475792 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n22 15\n12 10\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 169535970\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n657453515 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n1258790837 0\n3 0\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n657453515 173113793\n3 10\n16 6\n2 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 6\n450441171 733598623\n2 9\n3 10\n433415385 169535970\n3 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n16 21\n10 17\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 4\n9 6\n12 9\n1 1\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n0\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 241782432\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 38795044\n7 8\n17 12\n2 8\n15 9\n14 19\n7 19\n2 13\n15 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n3\n4\n5\n7\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n2 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 18\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n4 1\n10000011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 1\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10010011 100000000\n1258790837 0\n3 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n1 2\n10000011 100000000\n998244353 0\n2 4\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000001 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "5 4\n3 1\n10000011 100000000\n211018821 0\n4 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n3 1\n10000011 101000000\n211018821 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "20 20\n1 4\n864803385 772221280\n17 4\n12 3\n8 2\n15 4\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n15 9\n14 19\n7 19\n2 9\n4 29\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n3\n3\n4\n4\n3\n2\n4\n6\n7\n"]}, {"input": "3 4\n14 15\n12 13\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 1\n10000001 100000000\n998244353 1\n3 1\n1 3\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 0\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "3 4\n14 15\n10 9\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 1\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n9 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 2\n10000001 100000000\n1258790837 0\n5 1\n1 4\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n8 2\n15 1\n6 17\n16 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n5\n4\n3\n5\n7\n8\n"]}, {"input": "5 2\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "3 4\n16 21\n10 17\n2 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n0\n1\n0\n"]}, {"input": "5 4\n1 1\n00000001 000010000\n1683854825 0\n3 1\n2 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n0\n"]}, {"input": "5 4\n1 1\n11000001 100000000\n998244353 -1\n4 1\n1 10\n1 5\n2 5\n1 5\n1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n5 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "5 1\n1 0\n10000001 100000000\n1632524008 1\n2 1\n1 2\n1 5\n3 5\n1 5\n1 1\n", "output": ["0\n"]}, {"input": "3 4\n16 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 1\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "5 1\n1 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 2\n1 2\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 2\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "5 4\n1 0\n10000001 000010000\n998244353 0\n3 1\n1 2\n1 5\n2 5\n1 5\n1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n0 0\n430995384 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 2\n1 1\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 9\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 4\n1 12\n12 22\n1 2\n1 3\n1 1\n2 1\n2 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n1908812372 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "5 1\n2 1\n10000101 100000000\n1632524008 1\n2 0\n1 2\n1 5\n2 5\n1 5\n2 1\n", "output": ["0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n1 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n0 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n188952235 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n2 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n8\n"]}, {"input": "5 2\n1 2\n10000000 100010000\n998244353 1\n2 1\n1 1\n1 5\n2 5\n1 4\n1 1\n", "output": ["0\n0\n"]}, {"input": "10 7\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n9 11\n430995384 733598623\n1 13\n2 10\n657453515 169535970\n3 10\n8 6\n10 6\n7 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 8\n", "output": ["0\n0\n0\n0\n0\n0\n1\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 1\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 6\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 7\n3 10\n9 6\n529113291 733598623\n2 9\n5 10\n433415385 169535970\n3 10\n8 6\n3 4\n3 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 1\n2 9\n1 1\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "3 1\n9 15\n12 9\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 7\n3 10\n-1 0\n140846265 733598623\n2 9\n5 13\n433415385 217146891\n3 10\n8 6\n3 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 169535970\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "20 20\n1 4\n864803385 423778809\n12 4\n12 3\n15 2\n15 1\n6 17\n13 11\n292159474 273519822\n7 8\n17 12\n2 7\n5 9\n14 19\n7 19\n3 9\n49 15\n7 3\n15 7\n7 17\n1 11\n1 8\n1 1\n1 20\n1 9\n1 18\n1 13\n1 12\n1 6\n1 4\n1 19\n1 7\n1 14\n1 10\n1 5\n1 2\n1 15\n1 16\n1 17\n1 3\n", "output": ["0\n0\n0\n1\n1\n1\n1\n0\n1\n2\n3\n4\n4\n5\n6\n5\n4\n5\n7\n7\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n1 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 2\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n2 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 5\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n12 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "3 1\n9 15\n16 11\n4 4\n1 3\n0 1\n0 2\n2 3\n", "output": ["0\n"]}, {"input": "10 10\n3 10\n17 0\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "10 10\n3 10\n17 -1\n752625088 733598623\n2 9\n5 10\n890580799 237879025\n3 10\n16 6\n10 9\n9 6\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n1 2\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}, {"input": "10 10\n3 10\n9 6\n430995384 733598623\n2 9\n5 10\n433415385 169535970\n0 10\n8 6\n10 6\n7 8\n1 1\n2 1\n1 8\n2 8\n1 9\n1 4\n2 9\n1 3\n1 5\n1 6\n", "output": ["0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n"]}, {"input": "5 4\n2 1\n10000001 100000000\n998244353 0\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "output": ["0\n0\n0\n1\n"]}], "task_id": "codecontest/22", "repair_prompt": ["Kawasiro Nitori is excellent in engineering. Because of her expertise, she has been appointed to help maintain trains and is tasked with ensuring the smooth operation and maintenance of the trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. Initially, there are no trains, and at each of the following m days, one train will be added or removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance. Ensure that your solution is efficient enough to handle large values of n and m.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train models' work and maintenance periods\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Read operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store number of trains in maintenance each day\n    maintenance_count = []\n    \n    # Simulate each day's operations\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = day  # Store the day it was added\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                added_day = train_states[model]\n                x_i, y_i = train_cycles[model]\n                # Calculate the cycle position\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the result\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_period, maintenance_period, remaining_work_days)\n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:  # It was in maintenance\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means not present, otherwise it stores the day it was added\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for model in range(n):\n            if train_status[model] is not None:\n                added_day = train_status[model]\n                x_i, y_i = train_cycles[model]\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train model work and maintenance periods\n    train_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    # Read operations\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    result = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (x_i, y_i, x_i, 'working')  # (work_period, maintenance_period, remaining_days, state)\n        elif op == 2:  # Remove train\n            if train_states[k][3] == 'maintenance':\n                maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_days, state = train_states[i]\n                remaining_days -= 1\n                \n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_days, state)\n        \n        result.append(maintenance_count)\n    \n    # Print the result for each day\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, 'working', x_i)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                state, remaining_days = train_states[k][2], train_states[k][3]\n                if state == 'maintenance':\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, state, remaining_days = train_states[i]\n                remaining_days -= 1\n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                train_states[i] = (x_i, y_i, state, remaining_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, 0)  # (work_days, maintenance_days, current_day)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, y_i, current_day = train_states[k]\n                if current_day >= x_i:  # If it was in maintenance\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, current_day = train_states[i]\n                if current_day < x_i + y_i - 1:\n                    current_day += 1\n                else:\n                    current_day = 0\n                \n                if current_day == x_i:  # Just entered maintenance\n                    maintenance_count += 1\n                elif current_day == 0 and current_day != x_i:  # Just left maintenance\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, current_day)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train models' work and maintenance periods\n    train_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    # Read operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize state tracking\n    train_states = [None] * n  # None means no train of this model is added\n    maintenance_count = 0\n    result = []\n    \n    # Simulate each day's operations\n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                if remaining_work_days > 0:\n                    train_states[i] = (x_i, y_i, remaining_work_days - 1)\n                else:\n                    train_states[i] = (x_i, y_i, x_i - 1)\n                    if remaining_work_days == 0:\n                        maintenance_count += 1\n                    elif remaining_work_days == -1:\n                        maintenance_count -= 1\n        \n        # Record the number of trains in maintenance\n        result.append(maintenance_count)\n    \n    # Output the result\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, x_i, 'working')  # (x_i, y_i, remaining_days, state)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, _, remaining_days, state = train_states[k]\n                if state == 'maintenance':\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_days, state = train_states[i]\n                remaining_days -= 1\n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                train_states[i] = (x_i, y_i, remaining_days, state)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result for each day\n    results = []\n    \n    # Simulate each day\n    for op, k in operations:\n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (0, x_i, y_i)  # (current_day_in_cycle, work_period, maintenance_period)\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Count trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                current_day_in_cycle, x_i, y_i = state\n                if current_day_in_cycle >= x_i:  # In maintenance period\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n        \n        # Update the cycle state for the next day\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                total_cycle_length = x_i + y_i\n                train_states[i] = ((current_day_in_cycle + 1) % total_cycle_length, x_i, y_i)\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_period, maintenance_period, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train models' work and maintenance periods\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Read operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store number of trains in maintenance each day\n    maintenance_count = []\n    \n    # Simulate each day's operations\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = day  # Store the day it was added\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                added_day = train_states[model]\n                x_i, y_i = train_cycles[model]\n                # Calculate the cycle position\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the result\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, including whether it is currently added, in work, or in maintenance.\",\n      \"output\": \"A data structure that efficiently updates and queries the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current day.\",\n      \"output\": \"An updated state of the train models for each day, reflecting the addition or removal of trains.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of the trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and the operations for each day.\",\n    \"Initialize a data structure to track the state of each train model, including its work and maintenance cycle.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, update its state to reflect the start of its work cycle.\",\n    \"  - If a train is removed, update its state to reflect its removal.\",\n    \"  - For each train, update its state to determine if it is in maintenance based on its work and maintenance cycle.\",\n    \"Calculate the number of trains in maintenance for the current day and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train models' work and maintenance periods\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Read operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store number of trains in maintenance each day\n    maintenance_count = []\n    \n    # Simulate each day's operations\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = day  # Store the day it was added\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                added_day = train_states[model]\n                x_i, y_i = train_cycles[model]\n                # Calculate the cycle position\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the result\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models with their respective work and maintenance periods, and a list of daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, specifically whether it is currently working or in maintenance, and the remaining days in its current state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the passage of time.\",\n      \"output\": \"An updated state of the trains after each day's operations.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance at the end of each day based on the current state of all trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and the list of operations for each day.\",\n    \"Initialize a data structure to keep track of the state of each train model, including whether it is working or in maintenance and the remaining days in its current state.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, set its initial state to working and initialize its work and maintenance cycle.\",\n    \"  - If a train is removed, ensure it is not counted in maintenance and remove it from the tracking data structure.\",\n    \"  - Update the state of all trains to reflect the passage of one day, transitioning trains between working and maintenance as needed.\",\n    \"After processing each day's operations, count the number of trains currently in maintenance and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_period, maintenance_period, remaining_work_days)\n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:  # It was in maintenance\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: expected an indented block (<string>, line 93)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_period, maintenance_period, remaining_work_days)\n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:  # It was in maintenance\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), and the operation details for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the working and maintenance periods (x_i, y_i) for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Track the status of each train model (added or removed) and calculate the maintenance status for each day.\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the current status of each train model (added or removed).\",\n        \"For each day, update the status of the train model based on the operation (add or remove).\",\n        \"Calculate the number of trains in maintenance for each day based on their current status and maintenance cycle.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"For each day, after updating the train status, calculate the number of trains in maintenance.\",\n        \"Print the result for each day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, train model details, and daily operations.\",\n    \"Initialize a data structure to track the status of each train model.\",\n    \"Iterate over each day, updating the status of train models based on the operation.\",\n    \"Calculate the number of trains in maintenance for each day using the maintenance cycle logic.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means not present, otherwise it stores the day it was added\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for model in range(n):\n            if train_status[model] is not None:\n                added_day = train_status[model]\n                x_i, y_i = train_cycles[model]\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 102)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    train_cycles = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # To track the current status of each train model\n    train_status = [None] * n  # None means not present, otherwise it stores the day it was added\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_status[k] = day\n        elif op == 2:  # Remove train of model k\n            train_status[k] = None\n        \n        # Calculate the number of trains in maintenance\n        maintenance_count = 0\n        for model in range(n):\n            if train_status[model] is not None:\n                added_day = train_status[model]\n                x_i, y_i = train_cycles[model]\n                cycle_length = x_i + y_i\n                days_since_added = day - added_day\n                \n                # Determine if the train is in maintenance\n                if days_since_added >= x_i:\n                    if (days_since_added - x_i) % cycle_length < y_i:\n                        maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models with their respective work and maintenance periods, and a list of daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, specifically whether it is currently working or in maintenance, and the remaining days in its current state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the passage of time.\",\n      \"output\": \"An updated state of the trains after each day's operations.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance at the end of each day based on the current state of all trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and the list of operations for each day.\",\n    \"Initialize a data structure to keep track of the state of each train model, including whether it is working or in maintenance and the remaining days in its current state.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, set its initial state to working and initialize its work and maintenance cycle.\",\n    \"  - If a train is removed, ensure it is not counted as in maintenance and remove it from the tracking data structure.\",\n    \"  - Update the state of all trains to reflect the passage of one day, decrementing the remaining days in their current state.\",\n    \"  - Transition trains from working to maintenance or vice versa as their remaining days reach zero.\",\n    \"Calculate the number of trains in maintenance at the end of each day and store the result.\",\n    \"Output the list of maintenance counts for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train model work and maintenance periods\n    train_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    # Read operations\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    result = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (x_i, y_i, x_i, 'working')  # (work_period, maintenance_period, remaining_days, state)\n        elif op == 2:  # Remove train\n            if train_states[k][3] == 'maintenance':\n                maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_days, state = train_states[i]\n                remaining_days -= 1\n                \n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_days, state)\n        \n        result.append(maintenance_count)\n    \n    # Print the result for each day\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 108)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train model work and maintenance periods\n    train_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    # Read operations\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to zero-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    result = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (x_i, y_i, x_i, 'working')  # (work_period, maintenance_period, remaining_days, state)\n        elif op == 2:  # Remove train\n            if train_states[k][3] == 'maintenance':\n                maintenance_count -= 1\n            train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_days, state = train_states[i]\n                remaining_days -= 1\n                \n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_days, state)\n        \n        result.append(maintenance_count)\n    \n    # Print the result for each day\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, specifically whether it is currently in operation or maintenance, and the remaining days in its current state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current state of each train model.\",\n      \"output\": \"An updated state of the train models for each day, reflecting the addition or removal of trains.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all train models.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and the operations for each day.\",\n    \"Initialize a data structure to track the state of each train model, including whether it is in operation or maintenance and the remaining days in its current state.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, set its initial state to 'working' and track the remaining work days.\",\n    \"  - If a train is removed, ensure it is not counted in maintenance and remove it from the tracking structure.\",\n    \"  - Update the state of all trains, decrementing the remaining days in their current state.\",\n    \"  - Transition trains from 'working' to 'maintenance' or vice versa as their remaining days reach zero.\",\n    \"For each day, count the number of trains currently in maintenance and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, 'working', x_i)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                state, remaining_days = train_states[k][2], train_states[k][3]\n                if state == 'maintenance':\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, state, remaining_days = train_states[i]\n                remaining_days -= 1\n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                train_states[i] = (x_i, y_i, state, remaining_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 107)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, 'working', x_i)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                state, remaining_days = train_states[k][2], train_states[k][3]\n                if state == 'maintenance':\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, state, remaining_days = train_states[i]\n                remaining_days -= 1\n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                train_states[i] = (x_i, y_i, state, remaining_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models with their respective work and maintenance periods, and a list of daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, specifically whether it is currently working or in maintenance, and the remaining days in its current state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the passage of time.\",\n      \"output\": \"An updated state of the trains after each day's operations.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance at the end of each day based on the current state of all trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and the list of operations for each day.\",\n    \"Initialize a data structure to keep track of the state of each train model, including whether it is working or in maintenance and the remaining days in its current state.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, set its initial state to working and initialize its work and maintenance cycle.\",\n    \"  - If a train is removed, ensure it is not counted in maintenance and remove it from the tracking data structure.\",\n    \"  - Update the state of all trains to reflect the passage of one day, transitioning trains between working and maintenance as needed.\",\n    \"After processing each day's operations, count the number of trains currently in maintenance and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, 0)  # (work_days, maintenance_days, current_day)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, y_i, current_day = train_states[k]\n                if current_day >= x_i:  # If it was in maintenance\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, current_day = train_states[i]\n                if current_day < x_i + y_i - 1:\n                    current_day += 1\n                else:\n                    current_day = 0\n                \n                if current_day == x_i:  # Just entered maintenance\n                    maintenance_count += 1\n                elif current_day == 0 and current_day != x_i:  # Just left maintenance\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, current_day)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 109)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, 0)  # (work_days, maintenance_days, current_day)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, y_i, current_day = train_states[k]\n                if current_day >= x_i:  # If it was in maintenance\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, current_day = train_states[i]\n                if current_day < x_i + y_i - 1:\n                    current_day += 1\n                else:\n                    current_day = 0\n                \n                if current_day == x_i:  # Just entered maintenance\n                    maintenance_count += 1\n                elif current_day == 0 and current_day != x_i:  # Just left maintenance\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, current_day)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, including whether it is currently added, in work, or in maintenance.\",\n      \"output\": \"A data structure that efficiently updates and queries the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current day.\",\n      \"output\": \"An updated state of the trains for each day, reflecting the addition or removal of trains.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of the trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, the work and maintenance periods for each train model, and the daily operations.\",\n    \"Initialize a data structure to track the state of each train model, including its current cycle (work or maintenance) and the remaining days in that cycle.\",\n    \"Iterate over each day, performing the following steps:\",\n    \"  - If the operation is to add a train, update the data structure to reflect the train's addition and set its initial state to 'work'.\",\n    \"  - If the operation is to remove a train, update the data structure to reflect the train's removal.\",\n    \"  - For each train currently added, update its state based on its current cycle and decrement the remaining days in that cycle.\",\n    \"  - If a train's work cycle ends, transition it to the maintenance cycle, and vice versa.\",\n    \"Calculate the number of trains in maintenance for the current day by counting trains in the maintenance cycle.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train models' work and maintenance periods\n    train_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    # Read operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize state tracking\n    train_states = [None] * n  # None means no train of this model is added\n    maintenance_count = 0\n    result = []\n    \n    # Simulate each day's operations\n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                if remaining_work_days > 0:\n                    train_states[i] = (x_i, y_i, remaining_work_days - 1)\n                else:\n                    train_states[i] = (x_i, y_i, x_i - 1)\n                    if remaining_work_days == 0:\n                        maintenance_count += 1\n                    elif remaining_work_days == -1:\n                        maintenance_count -= 1\n        \n        # Record the number of trains in maintenance\n        result.append(maintenance_count)\n    \n    # Output the result\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 108)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train models' work and maintenance periods\n    train_periods = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_periods.append((x_i, y_i))\n        index += 2\n    \n    # Read operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # Initialize state tracking\n    train_states = [None] * n  # None means no train of this model is added\n    maintenance_count = 0\n    result = []\n    \n    # Simulate each day's operations\n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = train_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_days, maintenance_days, remaining_work_days)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update train states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                if remaining_work_days > 0:\n                    train_states[i] = (x_i, y_i, remaining_work_days - 1)\n                else:\n                    train_states[i] = (x_i, y_i, x_i - 1)\n                    if remaining_work_days == 0:\n                        maintenance_count += 1\n                    elif remaining_work_days == -1:\n                        maintenance_count -= 1\n        \n        # Record the number of trains in maintenance\n        result.append(maintenance_count)\n    \n    # Output the result\n    for count in result:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models with their respective work and maintenance periods, and a list of daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, specifically whether it is currently working or in maintenance, and the remaining days in its current state.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the passage of time.\",\n      \"output\": \"An updated state of the trains after each day's operations.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance at the end of each day based on the current state of all trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and the list of operations for each day.\",\n    \"Initialize a data structure to keep track of the state of each train model, including whether it is working or in maintenance and the remaining days in its current state.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, set its initial state to working and initialize its work and maintenance cycle.\",\n    \"  - If a train is removed, remove it from the tracking data structure.\",\n    \"  - Update the state of all trains to reflect the passage of one day, decrementing the remaining days in their current state.\",\n    \"  - Transition trains from working to maintenance or vice versa as their remaining days reach zero.\",\n    \"Calculate the number of trains in maintenance at the end of each day and store the result.\",\n    \"Output the list of integers representing the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for op, k in operations:\n        if op == 1:  # Add train\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, x_i, 'working')  # (x_i, y_i, remaining_days, state)\n        elif op == 2:  # Remove train\n            if train_states[k] is not None:\n                _, _, remaining_days, state = train_states[k]\n                if state == 'maintenance':\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_days, state = train_states[i]\n                remaining_days -= 1\n                if remaining_days == 0:\n                    if state == 'working':\n                        state = 'maintenance'\n                        remaining_days = y_i\n                        maintenance_count += 1\n                    else:\n                        state = 'working'\n                        remaining_days = x_i\n                        maintenance_count -= 1\n                train_states[i] = (x_i, y_i, remaining_days, state)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"steps\": [\n        \"Read the first line to get n and m.\",\n        \"Read the next n lines to get the work (x_i) and maintenance (y_i) periods for each train model.\",\n        \"Read the next m lines to get the operations (op, k) for each day.\"\n      ]\n    },\n    {\n      \"description\": \"Track the state of each train model to determine if it is currently added and its current cycle state (working or maintenance).\",\n      \"steps\": [\n        \"Initialize a data structure to keep track of the state of each train model (e.g., a dictionary with model index as key).\",\n        \"For each operation, update the state of the train model based on whether it is added or removed.\"\n      ]\n    },\n    {\n      \"description\": \"Simulate each day to determine how many trains are in maintenance.\",\n      \"steps\": [\n        \"For each day, iterate over all train models that are currently added.\",\n        \"Check if each train model is in its maintenance period based on its cycle state and update the count of trains in maintenance.\",\n        \"Update the cycle state of each train model for the next day.\"\n      ]\n    },\n    {\n      \"description\": \"Output the number of trains in maintenance for each day.\",\n      \"steps\": [\n        \"After processing all operations for a day, output the count of trains in maintenance for that day.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract necessary data.\",\n    \"Initialize data structures to track the state of each train model.\",\n    \"Iterate over each day and perform the operations to update train states.\",\n    \"Simulate the cycle of each train model to determine maintenance status.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result for each day\n    results = []\n    \n    # Simulate each day\n    for op, k in operations:\n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (0, x_i, y_i)  # (current_day_in_cycle, work_period, maintenance_period)\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Count trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                current_day_in_cycle, x_i, y_i = state\n                if current_day_in_cycle >= x_i:  # In maintenance period\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n        \n        # Update the cycle state for the next day\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                total_cycle_length = x_i + y_i\n                train_states[i] = ((current_day_in_cycle + 1) % total_cycle_length, x_i, y_i)\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 88)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        work_maintenance_periods.append((x_i, y_i))\n        index += 2\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result for each day\n    results = []\n    \n    # Simulate each day\n    for op, k in operations:\n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (0, x_i, y_i)  # (current_day_in_cycle, work_period, maintenance_period)\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Count trains in maintenance\n        maintenance_count = 0\n        for state in train_states:\n            if state is not None:\n                current_day_in_cycle, x_i, y_i = state\n                if current_day_in_cycle >= x_i:  # In maintenance period\n                    maintenance_count += 1\n        \n        results.append(maintenance_count)\n        \n        # Update the cycle state for the next day\n        for i in range(n):\n            if train_states[i] is not None:\n                current_day_in_cycle, x_i, y_i = train_states[i]\n                total_cycle_length = x_i + y_i\n                train_states[i] = ((current_day_in_cycle + 1) % total_cycle_length, x_i, y_i)\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, specifically whether it is currently working or in maintenance.\",\n      \"output\": \"A data structure that can efficiently update and query the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operations (add or remove) and the current day.\",\n      \"output\": \"An updated state of the trains for each day, reflecting the addition or removal of trains.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of all trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract n, m, the work and maintenance periods for each train model, and the daily operations.\",\n    \"Initialize a data structure to keep track of the state of each train model, including its current cycle (working or maintenance) and the remaining days in that cycle.\",\n    \"Iterate over each day, processing the operations:\",\n    \"  - If a train is added, set its initial state to working and track its cycle.\",\n    \"  - If a train is removed, ensure it is not counted in maintenance and remove it from tracking.\",\n    \"  - Update the state of all trains, decrementing the days in their current cycle and switching cycles if necessary.\",\n    \"For each day, count the number of trains currently in maintenance and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    work_maintenance_periods = []\n    for _ in range(n):\n        x_i = int(data[index])\n        index += 1\n        y_i = int(data[index])\n        index += 1\n        work_maintenance_periods.append((x_i, y_i))\n    \n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        index += 1\n        k = int(data[index]) - 1  # Convert to 0-based index\n        index += 1\n        operations.append((op, k))\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is present\n    maintenance_count = 0\n    results = []\n    \n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            x_i, y_i = work_maintenance_periods[k]\n            train_states[k] = (x_i, y_i, x_i)  # (work_period, maintenance_period, remaining_work_days)\n        \n        elif op == 2:  # Remove train of model k\n            if train_states[k] is not None:\n                _, y_i, remaining_work_days = train_states[k]\n                if remaining_work_days <= 0:\n                    maintenance_count -= 1\n                train_states[k] = None\n        \n        # Update all trains' states\n        for i in range(n):\n            if train_states[i] is not None:\n                x_i, y_i, remaining_work_days = train_states[i]\n                \n                if remaining_work_days > 0:\n                    remaining_work_days -= 1\n                else:\n                    remaining_work_days = -y_i + 1\n                    maintenance_count += 1\n                \n                if remaining_work_days == 0:\n                    maintenance_count -= 1\n                \n                train_states[i] = (x_i, y_i, remaining_work_days)\n        \n        results.append(maintenance_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of train models (n), number of days (m), the work and maintenance periods for each train model, and the operations for each day.\",\n      \"output\": \"A structured representation of the input data, including train models' work and maintenance periods and daily operations.\"\n    },\n    {\n      \"description\": \"Implement a data structure to track the state of each train model, including whether it is currently added, in work, or in maintenance.\",\n      \"output\": \"A data structure that efficiently updates and queries the state of each train model.\"\n    },\n    {\n      \"description\": \"Simulate each day's operations, updating the state of the trains based on the operation (add or remove) and the current day.\",\n      \"output\": \"An updated state of the train models for each day, reflecting the addition or removal of trains.\"\n    },\n    {\n      \"description\": \"Calculate the number of trains in maintenance for each day based on the current state of the trains.\",\n      \"output\": \"A list of integers representing the number of trains in maintenance for each day.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of train models, number of days, work and maintenance periods for each train model, and the operations for each day.\",\n    \"Initialize a data structure to track the state of each train model, including its work and maintenance cycle.\",\n    \"Iterate over each day's operations:\",\n    \"  - If a train is added, update its state to reflect the start of its work cycle.\",\n    \"  - If a train is removed, update its state to reflect its removal.\",\n    \"  - For each train, update its state to determine if it is in maintenance based on its work and maintenance cycle.\",\n    \"Calculate the number of trains in maintenance for the current day and store the result.\",\n    \"Output the number of trains in maintenance for each day.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    # Read train models' work and maintenance periods\n    train_cycles = []\n    index = 2\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        train_cycles.append((x_i, y_i))\n        index += 2\n    \n    # Read operations for each day\n    operations = []\n    for _ in range(m):\n        op = int(data[index])\n        k = int(data[index + 1]) - 1  # Convert to 0-based index\n        operations.append((op, k))\n        index += 2\n    \n    # State tracking for each train model\n    train_states = [None] * n  # None means no train of this model is added\n    \n    # Result list to store number of trains in maintenance each day\n    maintenance_count = []\n    \n    # Simulate each day's operations\n    for day in range(m):\n        op, k = operations[day]\n        \n        if op == 1:  # Add train of model k\n            train_states[k] = day  # Store the day it was added\n        elif op == 2:  # Remove train of model k\n            train_states[k] = None\n        \n        # Calculate number of trains in maintenance\n        count_in_maintenance = 0\n        for model in range(n):\n            if train_states[model] is not None:\n                added_day = train_states[model]\n                x_i, y_i = train_cycles[model]\n                # Calculate the cycle position\n                days_since_added = day - added_day\n                cycle_length = x_i + y_i\n                cycle_position = days_since_added % cycle_length\n                # Check if in maintenance\n                if cycle_position >= x_i:\n                    count_in_maintenance += 1\n        \n        maintenance_count.append(count_in_maintenance)\n    \n    # Output the result\n    for count in maintenance_count:\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, true, false, false, true, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 547, "prompt": "Kawasiro Nitori is excellent in engineering. Because of her expertise, she has been appointed to help maintain trains and is tasked with ensuring the smooth operation and maintenance of the trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. Initially, there are no trains, and at each of the following m days, one train will be added or removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance each day.\n\nOn a day a train is removed, it is not counted as in maintenance. Ensure that your solution is efficient enough to handle large values of n and m.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "examples": "\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 330}
