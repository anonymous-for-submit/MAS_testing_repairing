{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "repair_prompt": ["CQXYM encountered a rectangle A with dimensions n by m. Inside are n rows and m columns consisting of blocks. Each block in the rectangle may be an obsidian block or empty. CQXYM has the ability to transform an obsidian block into an empty one or vice versa in just one operation.\n\nA rectangle M that is a \u00d7 b in size is considered a portal only if it meets certain requirements:\n\n  * a must be at least 5, and b must be at least 4.\n  * Every block M_{x,1} and M_{x,b} must be an obsidian block for all 1 < x < a.\n  * Every block M_{1,x} and M_{a,x} must be an obsidian block for all 1 < x < b.\n  * Every block M_{x,y} must be empty for all 1<x<a,1<y<b.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nKeep in mind that there must be a rows and b columns, as opposed to b rows and a columns.\n\nNote that corners can be any type.\n\nCQXYM is curious about the fewest number of steps needed to convert at least one sub-rectangle into a portal.\nThe rectangle A can have various configurations of blocks.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 5 + 1):\n            for j in range(m - 4 + 1):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check the borders and count transformations\n                        for x in range(i, i + a):\n                            if x == i or x == i + a - 1:\n                                for y in range(j, j + b):\n                                    if (y == j or y == j + b - 1):\n                                        continue  # corners can be any type\n                                    if grid[x][y] == '0':\n                                        steps += 1\n                            else:\n                                if grid[x][j] == '0':\n                                    steps += 1\n                                if grid[x][j + b - 1] == '0':\n                                    steps += 1\n                        \n                        # Check the inner part and count transformations\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] == '1':\n                                    steps += 1\n                        \n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        steps = 0\n                        # Check the borders\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom borders\n                                for y in range(1, b - 1):\n                                    if grid[i + x][j + y] == '0':\n                                        steps += 1\n                            else:\n                                # Left and right borders\n                                if grid[i + x][j] == '0':\n                                    steps += 1\n                                if grid[i + x][j + b - 1] == '0':\n                                    steps += 1\n                        # Check the inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] == '1':\n                                    steps += 1\n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                steps += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                steps += 1\n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                steps += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                steps += 1\n                        \n                        # Check internal empty block conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    steps += 1\n                        \n                        # Update minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                steps += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                steps += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                steps += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                steps += 1\n                        \n                        # Check inner area conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    steps += 1\n                        \n                        # Update minimum steps for this test case\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 5 + 1):\n            for j in range(m - 4 + 1):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check the borders and inner blocks\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    # Border condition\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if grid[i + x][j + y] == '0':\n                                            steps += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if grid[i + x][j + y] == '1':\n                                        steps += 1\n                        \n                        # Track the minimum steps needed\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n):\n            for left in range(m):\n                # Iterate over all possible bottom-right corners ensuring at least 5x4 size\n                for bottom in range(top + 4, n):\n                    for right in range(left + 3, m):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        # Top and bottom borders\n                        for x in range(left + 1, right):\n                            if grid[top][x] == '0':  # Should be obsidian\n                                operations += 1\n                            if grid[bottom][x] == '0':  # Should be obsidian\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(top + 1, bottom):\n                            if grid[y][left] == '0':  # Should be obsidian\n                                operations += 1\n                            if grid[y][right] == '0':  # Should be obsidian\n                                operations += 1\n                        \n                        # Inner area should be empty\n                        for y in range(top + 1, bottom):\n                            for x in range(left + 1, right):\n                                if grid[y][x] == '1':  # Should be empty\n                                    operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n - 4):\n            for left in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - top + 1):\n                    for b in range(4, m - left + 1):\n                        # Calculate the number of transformations needed\n                        steps = 0\n                        # Check the borders\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom borders\n                                for y in range(b):\n                                    if y == 0 or y == b - 1:\n                                        continue  # Corners can be any type\n                                    if grid[top + x][left + y] == '0':\n                                        steps += 1\n                            else:\n                                # Left and right borders\n                                if grid[top + x][left] == '0':\n                                    steps += 1\n                                if grid[top + x][left + b - 1] == '0':\n                                    steps += 1\n                        # Check the inner part\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[top + x][left + y] == '1':\n                                    steps += 1\n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed\n                        steps = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom borders\n                                for y in range(1, b - 1):\n                                    if grid[start_row + x][start_col + y] == '0':\n                                        steps += 1\n                            else:\n                                # Left and right borders\n                                if grid[start_row + x][start_col] == '0':\n                                    steps += 1\n                                if grid[start_row + x][start_col + b - 1] == '0':\n                                    steps += 1\n                        \n                        # Check the inner area conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] == '1':\n                                    steps += 1\n                        \n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n):\n            for left in range(m):\n                # Iterate over all possible bottom-right corners ensuring sub-rectangle is at least 5x4\n                for bottom in range(top + 4, n):\n                    for right in range(left + 3, m):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(top + 1, bottom):\n                            if grid[x][left] != '1':\n                                operations += 1\n                            if grid[x][right] != '1':\n                                operations += 1\n                        for y in range(left + 1, right):\n                            if grid[top][y] != '1':\n                                operations += 1\n                            if grid[bottom][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner area\n                        for x in range(top + 1, bottom):\n                            for y in range(left + 1, right):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n):\n            for left in range(m):\n                # Iterate over all possible bottom-right corners that satisfy the minimum size requirement\n                for bottom in range(top + 4, n):\n                    for right in range(left + 3, m):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        # Top and bottom borders\n                        for x in range(left + 1, right):\n                            if grid[top][x] == '0':  # Top border\n                                operations += 1\n                            if grid[bottom][x] == '0':  # Bottom border\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(top + 1, bottom):\n                            if grid[y][left] == '0':  # Left border\n                                operations += 1\n                            if grid[y][right] == '0':  # Right border\n                                operations += 1\n                        \n                        # Check the inner area for empty blocks\n                        for y in range(top + 1, bottom):\n                            for x in range(left + 1, right):\n                                if grid[y][x] == '1':  # Inner area should be empty\n                                    operations += 1\n                        \n                        # Track the minimum number of transformations required\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 5 + 1):\n            for j in range(m - 4 + 1):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check the borders and count transformations\n                        for x in range(i, i + a):\n                            if x == i or x == i + a - 1:\n                                for y in range(j, j + b):\n                                    if (y == j or y == j + b - 1):\n                                        continue  # corners can be any type\n                                    if grid[x][y] == '0':\n                                        steps += 1\n                            else:\n                                if grid[x][j] == '0':\n                                    steps += 1\n                                if grid[x][j + b - 1] == '0':\n                                    steps += 1\n                        \n                        # Check the inner part and count transformations\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] == '1':\n                                    steps += 1\n                        \n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a by b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"Verify the conditions for a portal: borders must be obsidian, inner blocks must be empty, and corners can be any type.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of transformations needed for each sub-rectangle to become a portal.\",\n      \"details\": \"Count the number of blocks that need to be changed from obsidian to empty or vice versa to satisfy portal conditions.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of transformations across all sub-rectangles.\",\n      \"details\": \"Compare the transformation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input data.\",\n      \"details\": \"Read the number of test cases, dimensions of each rectangle, and the block configurations.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, process the rectangle to find potential portals.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a by b.\",\n      \"details\": \"Use nested loops to iterate over possible positions for the top-left corner of sub-rectangles.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal conditions.\",\n      \"details\": \"Check if the sub-rectangle meets the portal requirements and calculate necessary transformations.\"\n    },\n    {\n      \"step\": \"Track the minimum transformation count for each test case.\",\n      \"details\": \"Store the minimum number of transformations needed to form a portal for each test case.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the minimum transformation count for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 5 + 1):\n            for j in range(m - 4 + 1):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check the borders and count transformations\n                        for x in range(i, i + a):\n                            if x == i or x == i + a - 1:\n                                for y in range(j, j + b):\n                                    if (y == j or y == j + b - 1):\n                                        continue  # corners can be any type\n                                    if grid[x][y] == '0':\n                                        steps += 1\n                            else:\n                                if grid[x][j] == '0':\n                                    steps += 1\n                                if grid[x][j + b - 1] == '0':\n                                    steps += 1\n                        \n                        # Check the inner part and count transformations\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] == '1':\n                                    steps += 1\n                        \n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"decomposition\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a by b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"For each sub-rectangle, verify the conditions for being a portal and calculate the number of transformations needed.\"\n    },\n    {\n      \"subproblem\": \"Calculate the minimum number of transformations needed.\",\n      \"details\": \"Track the minimum number of transformations required across all sub-rectangles to form at least one portal.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input.\",\n      \"details\": \"Read the number of test cases, dimensions of the rectangle, and the block configuration for each test case.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, perform the following steps.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a by b.\",\n      \"details\": \"For each possible top-left corner, generate sub-rectangles and check if they can be transformed into a portal.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal conditions.\",\n      \"details\": \"Check the border conditions and count the number of transformations needed to satisfy the portal requirements.\"\n    },\n    {\n      \"step\": \"Determine the minimum transformations for each test case.\",\n      \"details\": \"Keep track of the minimum transformations needed to convert at least one sub-rectangle into a portal.\"\n    },\n    {\n      \"step\": \"Output the result for each test case.\",\n      \"details\": \"Print the minimum number of transformations for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        steps = 0\n                        # Check the borders\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom borders\n                                for y in range(1, b - 1):\n                                    if grid[i + x][j + y] == '0':\n                                        steps += 1\n                            else:\n                                # Left and right borders\n                                if grid[i + x][j] == '0':\n                                    steps += 1\n                                if grid[i + x][j + b - 1] == '0':\n                                    steps += 1\n                        # Check the inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] == '1':\n                                    steps += 1\n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a by b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle meets the portal requirements.\",\n      \"details\": \"Verify the border conditions and internal empty block conditions for each sub-rectangle.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of transformations needed to convert a sub-rectangle into a portal.\",\n      \"details\": \"Count the number of blocks that need to be changed from empty to obsidian or vice versa.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of transformations across all sub-rectangles.\",\n      \"details\": \"Track the minimum transformation count for all valid sub-rectangles.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input data.\",\n      \"details\": \"Read the number of test cases, dimensions of each rectangle, and the block configurations.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, process the rectangle to find potential portals.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a by b.\",\n      \"details\": \"Use nested loops to iterate over possible top-left corners and dimensions.\"\n    },\n    {\n      \"step\": \"Validate each sub-rectangle against portal requirements.\",\n      \"details\": \"Check border and internal conditions for each sub-rectangle.\"\n    },\n    {\n      \"step\": \"Calculate transformation steps for each valid sub-rectangle.\",\n      \"details\": \"Count necessary changes to meet portal requirements.\"\n    },\n    {\n      \"step\": \"Track the minimum transformation steps needed.\",\n      \"details\": \"Update the minimum count if a sub-rectangle requires fewer changes.\"\n    },\n    {\n      \"step\": \"Output the minimum transformation steps for each test case.\",\n      \"details\": \"Print the result for each test case in the required format.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                steps += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                steps += 1\n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                steps += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                steps += 1\n                        \n                        # Check internal empty block conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    steps += 1\n                        \n                        # Update minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the configuration of blocks for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the rectangle configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a x b within the given rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the bounds of n and m.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b that satisfy a >= 5 and b >= 4.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of transformations needed to convert each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks and count the number of transformations needed.\",\n        \"Check the inner area conditions for empty blocks and count the number of transformations needed.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of transformations required for each test case.\",\n      \"steps\": [\n        \"For each test case, keep track of the minimum number of transformations across all possible sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of transformations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the configuration of each rectangle.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a x b.\",\n    \"For each sub-rectangle, calculate the number of transformations needed to meet the portal requirements.\",\n    \"Track the minimum number of transformations needed for each test case.\",\n    \"Output the minimum number of transformations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n):\n            for j in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x][j] != '1':\n                                steps += 1\n                            if grid[i + x][j + b - 1] != '1':\n                                steps += 1\n                        \n                        for y in range(1, b - 1):\n                            if grid[i][j + y] != '1':\n                                steps += 1\n                            if grid[i + a - 1][j + y] != '1':\n                                steps += 1\n                        \n                        # Check inner area conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    steps += 1\n                        \n                        # Update minimum steps for this test case\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a by b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"Verify the conditions for a portal: borders must be obsidian, inner blocks must be empty, and corners can be any type.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of transformations needed for each sub-rectangle to become a portal.\",\n      \"details\": \"Count the number of blocks that need to be changed from obsidian to empty or vice versa to satisfy portal conditions.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of transformations needed across all sub-rectangles.\",\n      \"details\": \"Compare the transformation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configurations.\",\n      \"details\": \"Read and store the input data for processing.\"\n    },\n    {\n      \"step\": \"Iterate over each test case and process the rectangle A.\",\n      \"details\": \"For each test case, perform the following operations.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a by b within rectangle A.\",\n      \"details\": \"Use nested loops to iterate over possible top-left corners and check sub-rectangle dimensions.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal and calculate the transformation cost.\",\n      \"details\": \"Apply the portal conditions and count necessary transformations.\"\n    },\n    {\n      \"step\": \"Track the minimum transformation cost for each test case.\",\n      \"details\": \"Store the minimum transformation count for each test case.\"\n    },\n    {\n      \"step\": \"Output the minimum transformation cost for each test case.\",\n      \"details\": \"Print the results for all test cases.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 5 + 1):\n            for j in range(m - 4 + 1):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check the borders and inner blocks\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    # Border condition\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if grid[i + x][j + y] == '0':\n                                            steps += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if grid[i + x][j + y] == '1':\n                                        steps += 1\n                        \n                        # Track the minimum steps needed\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 133)"}, "Round_1": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 5 + 1):\n            for j in range(m - 4 + 1):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check the borders and inner blocks\n                        for x in range(a):\n                            for y in range(b):\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    # Border condition\n                                    if (x == 0 and y == 0) or (x == 0 and y == b - 1) or (x == a - 1 and y == 0) or (x == a - 1 and y == b - 1):\n                                        # Corners can be any type\n                                        continue\n                                    else:\n                                        # Borders must be obsidian (1)\n                                        if grid[i + x][j + y] == '0':\n                                            steps += 1\n                                else:\n                                    # Inner blocks must be empty (0)\n                                    if grid[i + x][j + y] == '1':\n                                        steps += 1\n                        \n                        # Track the minimum steps needed\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        \n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the configuration of blocks for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the rectangle configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the given rectangle.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles.\",\n        \"For each top-left corner, iterate over all possible bottom-right corners to ensure the sub-rectangle is at least 5x4.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"steps\": [\n        \"For each identified sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of transformations needed to satisfy the portal conditions.\",\n        \"Track the minimum number of transformations required across all sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of transformations needed for each test case.\",\n      \"steps\": [\n        \"For each test case, after evaluating all sub-rectangles, output the minimum number of transformations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details of each rectangle.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of transformations needed to convert it into a portal.\",\n    \"Track the minimum number of transformations needed for each test case.\",\n    \"Output the result for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n):\n            for left in range(m):\n                # Iterate over all possible bottom-right corners ensuring at least 5x4 size\n                for bottom in range(top + 4, n):\n                    for right in range(left + 3, m):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        # Top and bottom borders\n                        for x in range(left + 1, right):\n                            if grid[top][x] == '0':  # Should be obsidian\n                                operations += 1\n                            if grid[bottom][x] == '0':  # Should be obsidian\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(top + 1, bottom):\n                            if grid[y][left] == '0':  # Should be obsidian\n                                operations += 1\n                            if grid[y][right] == '0':  # Should be obsidian\n                                operations += 1\n                        \n                        # Inner area should be empty\n                        for y in range(top + 1, bottom):\n                            for x in range(left + 1, right):\n                                if grid[y][x] == '1':  # Should be empty\n                                    operations += 1\n                        \n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a by b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"Verify the conditions for a portal: borders must be obsidian, inner blocks must be empty, and corners can be any type.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of transformations needed for each sub-rectangle to become a portal.\",\n      \"details\": \"Count the number of blocks that need to be changed from obsidian to empty or vice versa to satisfy portal conditions.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of transformations needed across all sub-rectangles.\",\n      \"details\": \"Compare the transformation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the block configurations.\",\n      \"details\": \"Read and store the input data for processing.\"\n    },\n    {\n      \"step\": \"Iterate over each test case and process the rectangle A.\",\n      \"details\": \"For each test case, perform the following operations.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a by b within rectangle A.\",\n      \"details\": \"Use nested loops to iterate over possible top-left corners and check sub-rectangle dimensions.\"\n    },\n    {\n      \"step\": \"For each sub-rectangle, check if it can be transformed into a portal and calculate the transformation cost.\",\n      \"details\": \"Apply the portal conditions and count necessary transformations.\"\n    },\n    {\n      \"step\": \"Track the minimum transformation cost for each test case.\",\n      \"details\": \"Store the minimum transformation count for each test case.\"\n    },\n    {\n      \"step\": \"Output the minimum transformation cost for each test case.\",\n      \"details\": \"Print the results for all test cases.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n - 4):\n            for left in range(m - 3):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - top + 1):\n                    for b in range(4, m - left + 1):\n                        # Calculate the number of transformations needed\n                        steps = 0\n                        # Check the borders\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom borders\n                                for y in range(b):\n                                    if y == 0 or y == b - 1:\n                                        continue  # Corners can be any type\n                                    if grid[top + x][left + y] == '0':\n                                        steps += 1\n                            else:\n                                # Left and right borders\n                                if grid[top + x][left] == '0':\n                                    steps += 1\n                                if grid[top + x][left + b - 1] == '0':\n                                    steps += 1\n                        # Check the inner part\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[top + x][left + y] == '1':\n                                    steps += 1\n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the configuration of blocks for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases, t.\",\n        \"For each test case, read the dimensions n and m.\",\n        \"Read the n lines of m characters representing the rectangle configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size a x b within the given rectangle that can potentially be transformed into a portal.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles within the bounds of n and m.\",\n        \"For each top-left corner, iterate over all possible dimensions a and b that satisfy a >= 5 and b >= 4.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the number of transformations needed to convert each identified sub-rectangle into a portal.\",\n      \"steps\": [\n        \"For each sub-rectangle, check the border conditions for obsidian blocks and count the number of transformations needed.\",\n        \"Check the inner area conditions for empty blocks and count the number of transformations needed.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the minimum number of transformations required for each test case.\",\n      \"steps\": [\n        \"For each test case, keep track of the minimum number of transformations across all possible sub-rectangles.\",\n        \"Store the result for each test case.\"\n      ]\n    },\n    {\n      \"description\": \"Output the results for all test cases.\",\n      \"steps\": [\n        \"Print the minimum number of transformations for each test case on a new line.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the configuration of each rectangle.\",\n    \"For each test case, iterate over all possible sub-rectangles of size a x b.\",\n    \"For each sub-rectangle, calculate the number of transformations needed to meet the portal requirements.\",\n    \"Track the minimum number of transformations needed for each test case.\",\n    \"Output the minimum number of transformations for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n):\n            for start_col in range(m):\n                # Iterate over all possible dimensions a and b\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of transformations needed\n                        steps = 0\n                        \n                        # Check the border conditions\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom borders\n                                for y in range(1, b - 1):\n                                    if grid[start_row + x][start_col + y] == '0':\n                                        steps += 1\n                            else:\n                                # Left and right borders\n                                if grid[start_row + x][start_col] == '0':\n                                    steps += 1\n                                if grid[start_row + x][start_col + b - 1] == '0':\n                                    steps += 1\n                        \n                        # Check the inner area conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] == '1':\n                                    steps += 1\n                        \n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, dimensions of each rectangle, and the configuration of blocks for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read integers n and m, the dimensions of the rectangle.\",\n        \"Read the next n lines, each containing m characters, to form the matrix representing the rectangle.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the given rectangle.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles.\",\n        \"For each top-left corner, iterate over all possible bottom-right corners to ensure the sub-rectangle is at least 5x4.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"steps\": [\n        \"For each identified sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of transformations needed to satisfy the portal conditions.\",\n        \"Track the minimum number of transformations required across all sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of transformations for each test case.\",\n      \"steps\": [\n        \"For each test case, after evaluating all sub-rectangles, output the minimum number of transformations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the configuration of each rectangle.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, calculate the number of transformations needed to convert it into a portal.\",\n    \"Track and output the minimum number of transformations required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n):\n            for left in range(m):\n                # Iterate over all possible bottom-right corners ensuring sub-rectangle is at least 5x4\n                for bottom in range(top + 4, n):\n                    for right in range(left + 3, m):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions\n                        for x in range(top + 1, bottom):\n                            if grid[x][left] != '1':\n                                operations += 1\n                            if grid[x][right] != '1':\n                                operations += 1\n                        for y in range(left + 1, right):\n                            if grid[top][y] != '1':\n                                operations += 1\n                            if grid[bottom][y] != '1':\n                                operations += 1\n                        \n                        # Check the inner area\n                        for x in range(top + 1, bottom):\n                            for y in range(left + 1, right):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        \n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the grid configurations for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n and m, which represent the dimensions of the grid.\",\n        \"Read the next n lines, each containing m characters, to form the grid configuration.\"\n      ]\n    },\n    {\n      \"description\": \"Identify all possible sub-rectangles of size at least 5x4 within the grid.\",\n      \"steps\": [\n        \"Iterate over all possible top-left corners of sub-rectangles.\",\n        \"For each top-left corner, iterate over all possible bottom-right corners that satisfy the minimum size requirement.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a sub-rectangle can be transformed into a portal with the minimum number of operations.\",\n      \"steps\": [\n        \"For each identified sub-rectangle, check the border conditions for obsidian blocks.\",\n        \"Count the number of transformations needed to satisfy the portal conditions.\",\n        \"Track the minimum number of transformations required across all sub-rectangles.\"\n      ]\n    },\n    {\n      \"description\": \"Output the minimum number of transformations for each test case.\",\n      \"steps\": [\n        \"For each test case, after evaluating all sub-rectangles, output the minimum number of transformations found.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and grid configurations.\",\n    \"For each test case, iterate over all possible sub-rectangles of size at least 5x4.\",\n    \"For each sub-rectangle, evaluate the number of transformations needed to convert it into a portal.\",\n    \"Track and output the minimum number of transformations required for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for top in range(n):\n            for left in range(m):\n                # Iterate over all possible bottom-right corners that satisfy the minimum size requirement\n                for bottom in range(top + 4, n):\n                    for right in range(left + 3, m):\n                        # Calculate the number of transformations needed for this sub-rectangle\n                        operations = 0\n                        \n                        # Check the border conditions for obsidian blocks\n                        # Top and bottom borders\n                        for x in range(left + 1, right):\n                            if grid[top][x] == '0':  # Top border\n                                operations += 1\n                            if grid[bottom][x] == '0':  # Bottom border\n                                operations += 1\n                        \n                        # Left and right borders\n                        for y in range(top + 1, bottom):\n                            if grid[y][left] == '0':  # Left border\n                                operations += 1\n                            if grid[y][right] == '0':  # Right border\n                                operations += 1\n                        \n                        # Check the inner area for empty blocks\n                        for y in range(top + 1, bottom):\n                            for x in range(left + 1, right):\n                                if grid[y][x] == '1':  # Inner area should be empty\n                                    operations += 1\n                        \n                        # Track the minimum number of transformations required\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"decomposed_subproblems\": [\n    {\n      \"subproblem\": \"Identify all possible sub-rectangles of size a by b within the given rectangle A.\",\n      \"details\": \"Iterate over all possible top-left corners of sub-rectangles and check if they can form a valid portal.\"\n    },\n    {\n      \"subproblem\": \"Check if a sub-rectangle can be transformed into a portal.\",\n      \"details\": \"Verify the conditions for a portal: borders must be obsidian, inner blocks must be empty, and corners can be any type.\"\n    },\n    {\n      \"subproblem\": \"Calculate the number of transformations needed for each sub-rectangle to become a portal.\",\n      \"details\": \"Count the number of blocks that need to be changed from obsidian to empty or vice versa to satisfy portal conditions.\"\n    },\n    {\n      \"subproblem\": \"Determine the minimum number of transformations across all sub-rectangles.\",\n      \"details\": \"Compare the transformation counts for all valid sub-rectangles and select the minimum.\"\n    }\n  ],\n  \"high_level_plan\": [\n    {\n      \"step\": \"Parse the input data.\",\n      \"details\": \"Read the number of test cases, dimensions of each rectangle, and the block configurations.\"\n    },\n    {\n      \"step\": \"Iterate over each test case.\",\n      \"details\": \"For each test case, process the rectangle to find potential portals.\"\n    },\n    {\n      \"step\": \"Generate all possible sub-rectangles of size a by b.\",\n      \"details\": \"Use nested loops to iterate over possible positions for the top-left corner of sub-rectangles.\"\n    },\n    {\n      \"step\": \"Evaluate each sub-rectangle for portal conditions.\",\n      \"details\": \"Check if the sub-rectangle meets the portal requirements and calculate necessary transformations.\"\n    },\n    {\n      \"step\": \"Track the minimum transformation count for each test case.\",\n      \"details\": \"Store the minimum number of transformations needed to form a portal for each test case.\"\n    },\n    {\n      \"step\": \"Output the results.\",\n      \"details\": \"Print the minimum transformation count for each test case.\"\n    }\n  ]\n}\n```", "Round_0": {"code": "def min_transformations_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_steps = float('inf')\n        \n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 5 + 1):\n            for j in range(m - 4 + 1):\n                # Check all possible sizes of sub-rectangles\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        steps = 0\n                        \n                        # Check the borders and count transformations\n                        for x in range(i, i + a):\n                            if x == i or x == i + a - 1:\n                                for y in range(j, j + b):\n                                    if (y == j or y == j + b - 1):\n                                        continue  # corners can be any type\n                                    if grid[x][y] == '0':\n                                        steps += 1\n                            else:\n                                if grid[x][j] == '0':\n                                    steps += 1\n                                if grid[x][j + b - 1] == '0':\n                                    steps += 1\n                        \n                        # Check the inner part and count transformations\n                        for x in range(i + 1, i + a - 1):\n                            for y in range(j + 1, j + b - 1):\n                                if grid[x][y] == '1':\n                                    steps += 1\n                        \n                        # Update the minimum steps\n                        min_steps = min(min_steps, steps)\n        \n        results.append(min_steps)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        grid = [data[i] for i in range(index, index + n)]\n        index += n\n        test_cases.append((n, m, grid))\n    \n    results = min_transformations_to_portal(test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 60, "prompt": "CQXYM encountered a rectangle A with dimensions n by m. Inside are n rows and m columns consisting of blocks. Each block in the rectangle may be an obsidian block or empty. CQXYM has the ability to transform an obsidian block into an empty one or vice versa in just one operation.\n\nA rectangle M that is a \u00d7 b in size is considered a portal only if it meets certain requirements:\n\n  * a must be at least 5, and b must be at least 4.\n  * Every block M_{x,1} and M_{x,b} must be an obsidian block for all 1 < x < a.\n  * Every block M_{1,x} and M_{a,x} must be an obsidian block for all 1 < x < b.\n  * Every block M_{x,y} must be empty for all 1<x<a,1<y<b.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nKeep in mind that there must be a rows and b columns, as opposed to b rows and a columns.\n\nNote that corners can be any type.\n\nCQXYM is curious about the fewest number of steps needed to convert at least one sub-rectangle into a portal.\nThe rectangle A can have various configurations of blocks.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 60}
