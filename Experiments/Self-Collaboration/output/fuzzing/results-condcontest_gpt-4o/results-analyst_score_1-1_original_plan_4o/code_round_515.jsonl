{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "repair_prompt": ["Casimir wants to know if it's possible to recreate the pattern on the checkered field using ticks of size at least k while ensuring no cells contradict the tick size constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        marked = [[False] * m for _ in range(n)]\n        \n        def can_form_tick(x, y, size):\n            for i in range(size):\n                if x - i < 0 or y - i < 0 or y + i >= m:\n                    return False\n                if field[x - i][y - i] != '*' or field[x - i][y + i] != '*':\n                    return False\n            return True\n        \n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    size = 0\n                    while can_form_tick(x, y, size + 1):\n                        size += 1\n                    if size >= k:\n                        for i in range(size):\n                            marked[x - i][y - i] = True\n                            marked[x - i][y + i] = True\n        \n        valid = True\n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        # Create a copy of the field to mark valid tick positions\n        valid_field = [['.' for _ in range(m)] for _ in range(n)]\n        \n        # Check for possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n                    \n                    # If the tick size is at least k, mark the positions as valid\n                    if size > k:\n                        for s in range(size):\n                            valid_field[i - s][j - s] = '*'\n                            valid_field[i - s][j + s] = '*'\n        \n        # Check if all '*' in the original field are valid\n        is_valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and valid_field[i][j] != '*':\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n        \n        results.append(\"YES\" if is_valid else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to track if a cell is part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Check for each cell if it can be the center of a tick of size at least k\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size k can be formed with (i, j) as the center\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and j + size < m and\n                        field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If a tick of size at least k is possible, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Validate the entire field to ensure all '*' cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark all possible ticks\n    for i in range(n):\n        for j in range(m):\n            size = 0\n            while can_place_tick(i, j, size):\n                size += 1\n            # Mark all cells that are part of ticks of size >= k\n            for d in range(k, size):\n                for offset in range(d + 1):\n                    marked[i - offset][j - offset] = True\n                    marked[i - offset][j + offset] = True\n\n    # Check if all '*' in the field are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be centered at (i, j)\n    def is_valid_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark all possible ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                size = k - 1\n                while is_valid_tick(i, j, size):\n                    size += 1\n                # Mark all cells that are part of valid ticks\n                for d in range(size):\n                    marked[i - d][j - d] = True\n                    marked[i - d][j + d] = True\n\n    # Check if all '*' are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Check if a tick of size k can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        for d in range(size):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark cells covered by a tick centered at (i, j) of size size\n    def mark_tick(i, j, size):\n        for d in range(size):\n            covered[i - d][j - d] = True\n            covered[i - d][j + d] = True\n\n    # Iterate over each cell to find possible tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Find the maximum size of the tick that can be placed here\n                size = 0\n                while can_place_tick(i, j, size + 1):\n                    size += 1\n                # If the size is at least k, mark the cells\n                if size >= k:\n                    mark_tick(i, j, size)\n\n    # Check if all '*' cells are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered positions\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each position in the field to check for potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be formed\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and field[i - size][j - size] == '*' and\n                        i - size >= 0 and j + size < m and field[i - size][j + size] == '*' and\n                        i + size < n and j - size >= 0 and field[i + size][j - size] == '*' and\n                        i + size < n and j + size < m and field[i + size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the positions as covered\n                if size > k:\n                    for s in range(size):\n                        covered[i - s][j - s] = True\n                        covered[i - s][j + s] = True\n                        covered[i + s][j - s] = True\n                        covered[i + s][j + s] = True\n\n    # Check if all '*' positions are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to track valid tick cells\n    valid_tick_cells = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and j + size < m and\n                        field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells as valid\n                if size > k:\n                    for s in range(size):\n                        valid_tick_cells[i - s][j - s] = True\n                        valid_tick_cells[i - s][j + s] = True\n\n    # Validate the entire field to ensure all '*' cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not valid_tick_cells[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        # Create a matrix to mark which '*' can be part of a valid tick\n        valid = [[False] * m for _ in range(n)]\n        \n        # Check for possible tick centers\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if i - size < 0 or j - size < 0 or j + size >= m:\n                            break\n                        if field[i - size][j - size] == '*' and field[i - size][j + size] == '*':\n                            size += 1\n                        else:\n                            break\n                    # If a tick of size at least k is possible, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            valid[i - s][j - s] = True\n                            valid[i - s][j + s] = True\n        \n        # Verify if all '*' are part of valid ticks\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not valid[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        # Create a matrix to mark which '*' can be part of a valid tick\n        valid = [[False] * m for _ in range(n)]\n        \n        # Check for possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n                    # If the tick size is at least k, mark the cells as valid\n                    if size > k:\n                        for s in range(size):\n                            valid[i - s][j - s] = True\n                            valid[i - s][j + s] = True\n        \n        # Check if all '*' are part of a valid tick\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not valid[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        marked = [[False] * m for _ in range(n)]\n        \n        def can_form_tick(x, y, size):\n            for i in range(size):\n                if x - i < 0 or y - i < 0 or y + i >= m:\n                    return False\n                if field[x - i][y - i] != '*' or field[x - i][y + i] != '*':\n                    return False\n            return True\n        \n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    size = 0\n                    while can_form_tick(x, y, size + 1):\n                        size += 1\n                    if size >= k:\n                        for i in range(size):\n                            marked[x - i][y - i] = True\n                            marked[x - i][y + i] = True\n        \n        valid = True\n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case including field size, minimum tick size, and field pattern.\",\n      \"steps\": [\n        \"Read the integer t from the first line representing the number of test cases.\",\n        \"For each test case, read the integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field pattern consisting of '.' and '*' characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field pattern can be recreated using ticks of at least size k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if a '*' can be the center of a tick of size at least k.\",\n        \"Verify that the tick does not contradict the tick size constraints by ensuring all required cells are '*'.\",\n        \"Mark cells that are part of a valid tick to avoid rechecking them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the field can be recreated with valid ticks, output 'YES'.\",\n        \"If not, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test case details.\",\n    \"For each test case, analyze the field pattern to determine if it can be recreated using valid ticks.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```", "Round_0": {"code": "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        marked = [[False] * m for _ in range(n)]\n        \n        def can_form_tick(x, y, size):\n            for i in range(size):\n                if x - i < 0 or y - i < 0 or y + i >= m:\n                    return False\n                if field[x - i][y - i] != '*' or field[x - i][y + i] != '*':\n                    return False\n            return True\n        \n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    size = 0\n                    while can_form_tick(x, y, size + 1):\n                        size += 1\n                    if size >= k:\n                        for i in range(size):\n                            marked[x - i][y - i] = True\n                            marked[x - i][y + i] = True\n        \n        valid = True\n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to construct the field matrix of size n x m.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field matrix.\",\n        \"Check if a tick of size k can be centered at each '*' cell by verifying the presence of '*' in the required positions.\",\n        \"Ensure that no '*' cell contradicts the tick size constraints.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the field can be recreated using ticks of size at least k, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the field matrix to determine if it can be recreated using ticks of size at least k.\",\n    \"Output 'YES' or 'NO' for each test case based on the analysis.\"\n  ]\n}\n```", "Round_0": {"code": "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        # Create a copy of the field to mark valid tick positions\n        valid_field = [['.' for _ in range(m)] for _ in range(n)]\n        \n        # Check for possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n                    \n                    # If the tick size is at least k, mark the positions as valid\n                    if size > k:\n                        for s in range(size):\n                            valid_field[i - s][j - s] = '*'\n                            valid_field[i - s][j + s] = '*'\n        \n        # Check if all '*' in the original field are valid\n        is_valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and valid_field[i][j] != '*':\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n        \n        results.append(\"YES\" if is_valid else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 98)"}, "Round_1": {"code": "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        # Create a copy of the field to mark valid tick positions\n        valid_field = [['.' for _ in range(m)] for _ in range(n)]\n        \n        # Check for possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n                    \n                    # If the tick size is at least k, mark the positions as valid\n                    if size > k:\n                        for s in range(size):\n                            valid_field[i - s][j - s] = '*'\n                            valid_field[i - s][j + s] = '*'\n        \n        # Check if all '*' in the original field are valid\n        is_valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and valid_field[i][j] != '*':\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n        \n        results.append(\"YES\" if is_valid else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k, which represent the dimensions of the field and the minimum tick size.\",\n        \"Read the next n lines to capture the field configuration as a list of strings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of at least size k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"For each '*' cell, check if it can be the center of a tick of size at least k.\",\n        \"Ensure that the tick does not extend beyond the field boundaries and that all required cells are '*'.\",\n        \"Mark cells that are part of a valid tick to avoid re-evaluation.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the entire field to ensure all '*' cells are part of valid ticks.\",\n      \"steps\": [\n        \"After attempting to form ticks, iterate over the field again.\",\n        \"Check if there are any '*' cells that are not part of any valid tick.\",\n        \"If such cells exist, the answer for that test case is 'NO'. Otherwise, it's 'YES'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a data structure to track which cells are part of valid ticks.\",\n    \"Iterate over each cell in the field to attempt forming ticks of size at least k.\",\n    \"Mark cells that are part of valid ticks to avoid re-evaluation.\",\n    \"After processing the field, validate that all '*' cells are part of valid ticks.\",\n    \"Output 'YES' if all '*' cells are part of valid ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to track if a cell is part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Check for each cell if it can be the center of a tick of size at least k\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size k can be formed with (i, j) as the center\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and j + size < m and\n                        field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If a tick of size at least k is possible, mark the cells\n                if size > k:\n                    for s in range(size):\n                        marked[i - s][j - s] = True\n                        marked[i - s][j + s] = True\n\n    # Validate the entire field to ensure all '*' cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the field dimensions, minimum tick size, and the field pattern.\",\n      \"output\": \"A structured representation of the input data, such as a list of dictionaries, where each dictionary contains the details of a test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the field can be constructed using ticks of at least the given size k.\",\n      \"output\": \"A boolean value indicating whether the field can be constructed as required for each test case.\"\n    },\n    {\n      \"description\": \"Implement a function to check if a tick of a given size can be centered at a specific cell in the field.\",\n      \"output\": \"A boolean value indicating whether a tick of the specified size can be centered at the given cell.\"\n    },\n    {\n      \"description\": \"Iterate over each cell in the field to identify potential tick centers and verify if the entire field can be covered by valid ticks.\",\n      \"output\": \"A boolean value indicating whether the entire field can be covered by valid ticks for each test case.\"\n    },\n    {\n      \"description\": \"Format the results for each test case as 'YES' or 'NO' based on whether the field can be constructed as required.\",\n      \"output\": \"A list of strings, each being 'YES' or 'NO', corresponding to each test case.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a boolean flag to track if the field can be constructed using valid ticks.\",\n    \"Iterate over each cell in the field to check if it can be the center of a tick of at least size k.\",\n    \"For each potential tick center, verify if the tick can be drawn without contradicting the tick size constraints.\",\n    \"If a valid tick configuration is found for the entire field, set the flag to true for that test case.\",\n    \"After processing all cells, determine the result for each test case based on the flag and store 'YES' or 'NO'.\",\n    \"Output the results for all test cases in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark all possible ticks\n    for i in range(n):\n        for j in range(m):\n            size = 0\n            while can_place_tick(i, j, size):\n                size += 1\n            # Mark all cells that are part of ticks of size >= k\n            for d in range(k, size):\n                for offset in range(d + 1):\n                    marked[i - offset][j - offset] = True\n                    marked[i - offset][j + offset] = True\n\n    # Check if all '*' in the field are marked\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case, including the field dimensions, minimum tick size, and the field pattern.\",\n      \"output\": \"A structured representation of the input data, such as a list of dictionaries, where each dictionary contains the details of a test case.\"\n    },\n    {\n      \"description\": \"For each test case, determine if the field can be recreated using ticks of at least the given size. This involves checking if each '*' can be part of a valid tick.\",\n      \"output\": \"A boolean value for each test case indicating whether the field can be recreated with the given constraints.\"\n    },\n    {\n      \"description\": \"Implement a function to check if a tick of a given size can be centered at a specific cell in the field.\",\n      \"output\": \"A function that returns true if a tick of the required size can be centered at the given cell, false otherwise.\"\n    },\n    {\n      \"description\": \"Iterate over each cell in the field to verify if all '*' can be part of a valid tick configuration.\",\n      \"output\": \"A final decision for each test case, either 'YES' or 'NO', based on whether the field can be recreated with the given constraints.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the input data and parse it into a structured format.\",\n    \"For each test case, initialize a boolean flag to track if the field can be recreated.\",\n    \"Iterate over each cell in the field. If a cell contains '*', check if it can be part of a valid tick using the tick validation function.\",\n    \"If any '*' cannot be part of a valid tick, set the flag to false for that test case.\",\n    \"After checking all cells, append 'YES' to the results if the flag is true, otherwise append 'NO'.\",\n    \"Output the results for all test cases.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be centered at (i, j)\n    def is_valid_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark all possible ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                size = 0\n                while is_valid_tick(i, j, size):\n                    size += 1\n                # Mark all cells that are part of valid ticks\n                for d in range(size):\n                    marked[i - d][j - d] = True\n                    marked[i - d][j + d] = True\n\n    # Check if all '*' are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 92)"}, "Round_1": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Function to check if a tick of size `size` can be centered at (i, j)\n    def is_valid_tick(i, j, size):\n        if i - size < 0 or j - size < 0 or j + size >= m:\n            return False\n        for d in range(size + 1):\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark all possible ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                size = k - 1\n                while is_valid_tick(i, j, size):\n                    size += 1\n                # Mark all cells that are part of valid ticks\n                for d in range(size):\n                    marked[i - d][j - d] = True\n                    marked[i - d][j + d] = True\n\n    # Check if all '*' are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not marked[i][j]:\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        if can_form_ticks(n, m, k, field):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k, which represent the dimensions of the field and the minimum tick size.\",\n        \"Read the next n lines to construct the field as a 2D list of characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"For each '*' cell, check if it can be the center of a tick of size at least k.\",\n        \"Ensure that all '*' cells can be part of a valid tick or are covered by a tick of size at least k.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a tick of a given size can be drawn from a specific center cell.\",\n      \"steps\": [\n        \"For a given center cell, check if the tick can extend k cells in all four diagonal directions without encountering a '.' or going out of bounds.\",\n        \"If a tick can be drawn, mark the cells covered by the tick.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if all '*' cells are covered by valid ticks, output 'YES'.\",\n        \"If any '*' cell cannot be covered by a valid tick, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, iterate over the field to determine if it can be recreated using valid ticks.\",\n    \"For each '*' cell, check if it can be the center of a tick of size at least k.\",\n    \"Ensure all '*' cells are covered by valid ticks.\",\n    \"Output 'YES' if the field can be recreated, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to mark cells that are covered by valid ticks\n    covered = [[False] * m for _ in range(n)]\n\n    # Check if a tick of size k can be centered at (i, j)\n    def can_place_tick(i, j, size):\n        for d in range(size):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                return False\n        return True\n\n    # Mark cells covered by a tick centered at (i, j) of size size\n    def mark_tick(i, j, size):\n        for d in range(size):\n            covered[i - d][j - d] = True\n            covered[i - d][j + d] = True\n\n    # Iterate over each cell to find possible tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Find the maximum size of the tick that can be placed here\n                size = 0\n                while can_place_tick(i, j, size + 1):\n                    size += 1\n                # If the size is at least k, mark the cells\n                if size >= k:\n                    mark_tick(i, j, size)\n\n    # Check if all '*' cells are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, the number of test cases.\",\n        \"For each test case, read the integers n, m, and k.\",\n        \"Read the next n lines to construct the checkered field as a 2D array of characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if a tick of size at least k can be formed at each '*' position in the field.\",\n      \"steps\": [\n        \"For each '*' in the field, check if it can be the center of a tick of size at least k.\",\n        \"A tick of size s at position (i, j) requires '*' at positions (i-s, j-s), (i-s, j+s), (i+s, j-s), and (i+s, j+s).\",\n        \"Ensure that all required positions for a tick of size s are within bounds and contain '*'.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the entire field to ensure all '*' can be part of valid ticks.\",\n      \"steps\": [\n        \"Create a boolean matrix to track which '*' positions are covered by valid ticks.\",\n        \"Iterate over the field and attempt to form ticks, marking covered positions in the boolean matrix.\",\n        \"After processing, check if all '*' positions in the field are marked as covered.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if all '*' positions are covered by valid ticks, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a boolean matrix to track covered positions.\",\n    \"Iterate over each position in the field to check for potential tick centers.\",\n    \"For each potential tick center, verify if a tick of size at least k can be formed.\",\n    \"Mark all positions covered by valid ticks in the boolean matrix.\",\n    \"After processing the field, check if all '*' positions are covered.\",\n    \"Output 'YES' if all '*' are covered, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered positions\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each position in the field to check for potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be formed\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and field[i - size][j - size] == '*' and\n                        i - size >= 0 and j + size < m and field[i - size][j + size] == '*' and\n                        i + size < n and j - size >= 0 and field[i + size][j - size] == '*' and\n                        i + size < n and j + size < m and field[i + size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the positions as covered\n                if size > k:\n                    for s in range(size):\n                        covered[i - s][j - s] = True\n                        covered[i - s][j + s] = True\n                        covered[i + s][j - s] = True\n                        covered[i + s][j + s] = True\n\n    # Check if all '*' positions are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 90)"}, "Round_1": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a boolean matrix to track covered positions\n    covered = [[False] * m for _ in range(n)]\n\n    # Iterate over each position in the field to check for potential tick centers\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if a tick of size at least k can be formed\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and field[i - size][j - size] == '*' and\n                        i - size >= 0 and j + size < m and field[i - size][j + size] == '*' and\n                        i + size < n and j - size >= 0 and field[i + size][j - size] == '*' and\n                        i + size < n and j + size < m and field[i + size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the positions as covered\n                if size > k:\n                    for s in range(size):\n                        covered[i - s][j - s] = True\n                        covered[i - s][j + s] = True\n                        covered[i + s][j - s] = True\n                        covered[i + s][j + s] = True\n\n    # Check if all '*' positions are covered\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not covered[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k, which represent the dimensions of the field and the minimum tick size.\",\n        \"Read the next n lines to capture the field configuration as a list of strings.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of at least size k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"For each '*' cell, check if it can be the center of a tick of size at least k.\",\n        \"Ensure that the tick does not extend beyond the field boundaries and that all required cells are '*'.\",\n        \"Mark cells that are part of a valid tick to avoid re-evaluation.\"\n      ]\n    },\n    {\n      \"description\": \"Validate the entire field to ensure all '*' cells are part of valid ticks.\",\n      \"steps\": [\n        \"After attempting to form ticks, iterate over the field again.\",\n        \"Check if there are any '*' cells that are not part of any valid tick.\",\n        \"If such cells exist, the answer for that test case is 'NO'. Otherwise, it is 'YES'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, initialize a data structure to track which cells are part of valid ticks.\",\n    \"Iterate over each cell in the field to attempt forming ticks of size at least k.\",\n    \"Mark cells that are part of valid ticks to avoid re-evaluation.\",\n    \"After processing the field, validate that all '*' cells are part of valid ticks.\",\n    \"Output 'YES' if all '*' cells are part of valid ticks, otherwise output 'NO'.\"\n  ]\n}\n```", "Round_0": {"code": "def can_form_ticks(n, m, k, field):\n    # Create a 2D list to track valid tick cells\n    valid_tick_cells = [[False] * m for _ in range(n)]\n\n    # Iterate over each cell in the field\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                # Check if this cell can be the center of a tick of size at least k\n                size = 0\n                while True:\n                    if (i - size >= 0 and j - size >= 0 and j + size < m and\n                        field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    else:\n                        break\n\n                # If the tick size is at least k, mark the cells as valid\n                if size > k:\n                    for s in range(size):\n                        valid_tick_cells[i - s][j - s] = True\n                        valid_tick_cells[i - s][j + s] = True\n\n    # Validate the entire field to ensure all '*' cells are part of valid ticks\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and not valid_tick_cells[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        index += 1\n        field = [data[index + i] for i in range(n)]\n        index += n\n\n        result = can_form_ticks(n, m, k, field)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to construct the field matrix for the test case.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field matrix.\",\n        \"Check if a tick of size k can be centered at each '*' cell by verifying the presence of '*' in the required positions.\",\n        \"Ensure that no '*' cell contradicts the tick size constraints.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the field can be recreated using ticks of size at least k, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the field matrix to determine if it can be recreated using ticks of size at least k.\",\n    \"Output 'YES' or 'NO' for each test case based on the analysis.\"\n  ]\n}\n```", "Round_0": {"code": "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        # Create a matrix to mark which '*' can be part of a valid tick\n        valid = [[False] * m for _ in range(n)]\n        \n        # Check for possible tick centers\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if i - size < 0 or j - size < 0 or j + size >= m:\n                            break\n                        if field[i - size][j - size] == '*' and field[i - size][j + size] == '*':\n                            size += 1\n                        else:\n                            break\n                    # If a tick of size at least k is possible, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            valid[i - s][j - s] = True\n                            valid[i - s][j + s] = True\n        \n        # Verify if all '*' are part of valid ticks\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not valid[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case.\",\n      \"steps\": [\n        \"Read the integer t from the first line, which represents the number of test cases.\",\n        \"For each test case, read the integers n, m, and k from the first line of the test case description.\",\n        \"Read the next n lines to construct the field matrix, which consists of m characters per line.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field can be recreated using ticks of size at least k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field matrix.\",\n        \"Check if a tick of size k can be centered at each '*' cell by verifying the presence of '*' in the required positions.\",\n        \"Ensure that no '*' cell contradicts the tick size constraints by being isolated or part of a smaller tick.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the field can be recreated using ticks of size at least k, output 'YES'.\",\n        \"Otherwise, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and the details for each test case.\",\n    \"For each test case, analyze the field matrix to determine if it can be recreated using ticks of size at least k.\",\n    \"Output 'YES' or 'NO' for each test case based on the analysis.\"\n  ]\n}\n```", "Round_0": {"code": "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        # Create a matrix to mark which '*' can be part of a valid tick\n        valid = [[False] * m for _ in range(n)]\n        \n        # Check for possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n                    # If the tick size is at least k, mark the cells as valid\n                    if size > k:\n                        for s in range(size):\n                            valid[i - s][j - s] = True\n                            valid[i - s][j + s] = True\n        \n        # Check if all '*' are part of a valid tick\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not valid[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases and the details for each test case including field size, minimum tick size, and field pattern.\",\n      \"steps\": [\n        \"Read the integer t from the first line representing the number of test cases.\",\n        \"For each test case, read the integers n, m, and k representing the field dimensions and minimum tick size.\",\n        \"Read the next n lines to capture the field pattern consisting of '.' and '*' characters.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if the field pattern can be recreated using ticks of at least size k.\",\n      \"steps\": [\n        \"For each test case, iterate over each cell in the field.\",\n        \"Check if a '*' can be the center of a tick of size at least k.\",\n        \"Verify that the tick does not contradict the tick size constraints by ensuring all required cells are '*'.\",\n        \"Mark cells that are part of a valid tick to avoid rechecking them.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result for each test case.\",\n      \"steps\": [\n        \"For each test case, if the field can be recreated with valid ticks, output 'YES'.\",\n        \"If not, output 'NO'.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract test case details.\",\n    \"For each test case, analyze the field pattern to determine if it can be recreated using valid ticks.\",\n    \"Output the result for each test case based on the analysis.\"\n  ]\n}\n```", "Round_0": {"code": "def can_recreate_pattern(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        marked = [[False] * m for _ in range(n)]\n        \n        def can_form_tick(x, y, size):\n            for i in range(size):\n                if x - i < 0 or y - i < 0 or y + i >= m:\n                    return False\n                if field[x - i][y - i] != '*' or field[x - i][y + i] != '*':\n                    return False\n            return True\n        \n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    size = 0\n                    while can_form_tick(x, y, size + 1):\n                        size += 1\n                    if size >= k:\n                        for i in range(size):\n                            marked[x - i][y - i] = True\n                            marked[x - i][y + i] = True\n        \n        valid = True\n        for x in range(n):\n            for y in range(m):\n                if field[x][y] == '*' and not marked[x][y]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_recreate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [true, false, true, false, true, true, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 515, "prompt": "Casimir wants to know if it's possible to recreate the pattern on the checkered field using ticks of size at least k while ensuring no cells contradict the tick size constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "condense_two2one", "save_node": false, "parent_index": 105}
