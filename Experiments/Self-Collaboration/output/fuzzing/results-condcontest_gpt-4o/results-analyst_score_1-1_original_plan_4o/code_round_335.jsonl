{"name": "1622_E. Math Test", "description": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "tags": ["bitmasks", "brute force", "greedy"], "difficulty": 11, "id": 1622, "sample_io": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n"]}], "test_list": [{"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1 4 2 6 3 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n2 1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n4 1 5 2 3 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 4 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n4 1 2 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000100\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 3 5 1 2 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n001\n110\n4 4\n0 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["2 1 3\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["3 1 2\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n100101\n111101\n", "output": ["3 1 2\n3 4 1 2\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n1 1 2 0\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0011\n0111\n0101\n3 1\n20 3 2\n011110\n000101\n111011\n", "output": ["3 1 2\n1 2 4 3\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 10\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n2 3 4 1\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n5 1 3 4\n100\n100\n101\n100\n4 4\n12 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 4\n010110\n010101\n111111\n", "output": ["1 2 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n000\n4 4\n6 3 0 1\n0001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100100\n111101\n", "output": ["2 1 3\n1 4 3 2\n6 2 3 4 1 5\n"]}, {"input": "3\n4 3\n3 1 3 2\n110\n000\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 0 7\n110110\n000101\n111101\n", "output": ["1 3 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 1\n110\n100\n100\n101\n4 4\n2 2 0 13\n1101\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000001\n111101\n", "output": ["3 1 2\n2 3 4 1\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 3 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n111\n000\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0100\n0100\n3 2\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000001\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0111\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 0 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n1101\n3 1\n34 3 7\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 1\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 2\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n001\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 8\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 1 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n11 1 0 4\n1001\n0010\n0110\n0101\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n110\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 4 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n4 1 0 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n6 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0000\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 1 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n100\n101\n000\n4 4\n11 1 1 11\n1001\n0010\n1110\n0101\n3 1\n34 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n13 1 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 2\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 1 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n1110\n0101\n3 6\n20 3 15\n000110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n2 3 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n110\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n9 1 4 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n101\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n20 3 2\n010110\n000101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n36 3 7\n010100\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 10\n1101\n0010\n0100\n0101\n3 1\n20 3 7\n010010\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n100\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n101\n4 4\n3 1 0 10\n0001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 0 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0001\n3 1\n30 3 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0010\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n0 1 2 0\n110\n100\n101\n100\n4 4\n2 2 0 10\n1001\n0010\n0110\n0101\n3 6\n38 3 6\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n010\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n11 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 2 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n1 1 2 2\n110\n100\n111\n100\n4 4\n6 2 0 10\n1001\n0010\n0111\n0101\n3 1\n20 3 2\n010110\n000101\n111011\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n010\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n8 3 2\n010110\n100101\n110101\n", "output": ["3 1 2\n2 3 4 1\n3 4 1 6 2 5\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0010\n0001\n3 1\n30 0 2\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n111\n100\n101\n000\n4 4\n11 2 0 10\n1001\n0010\n0110\n0100\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 0 2 2\n111\n100\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n2 1\n66 3 2\n010110\n000101\n110110\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 1 2\n101\n100\n000\n100\n4 4\n6 1 0 10\n1001\n0010\n1110\n0100\n3 1\n20 0 7\n010110\n000101\n111111\n", "output": ["3 2 1\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n5 2 4 2\n111\n101\n101\n000\n4 4\n16 1 1 11\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111011\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 0 1 0\n111\n000\n101\n010\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 7\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n011\n100\n101\n101\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1101\n0010\n0100\n0111\n3 6\n38 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 4 1 2\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n100\n000\n4 4\n11 1 0 10\n1001\n0010\n0110\n0001\n3 1\n34 3 1\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 0\n110\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0011\n0110\n0001\n3 6\n38 2 8\n010110\n000101\n111101\n", "output": ["3 1 2\n1 2 4 3\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n10 1 2 2\n110\n110\n101\n100\n4 4\n6 2 0 18\n1001\n0010\n0110\n0101\n3 6\n20 3 0\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n3 1 4 5 2 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n101\n110\n101\n100\n4 4\n6 1 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 7\n011110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 4\n100\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 1\n20 3 2\n010110\n010101\n111111\n", "output": ["1 2 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n100\n100\n100\n4 4\n6 2 1 11\n1001\n0010\n0110\n0101\n3 6\n38 2 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n4 1 2 2\n111\n100\n000\n100\n4 4\n11 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n110\n100\n101\n100\n4 4\n2 2 0 17\n1001\n0110\n0110\n0101\n3 6\n38 3 12\n010110\n000101\n111101\n", "output": ["3 1 2\n2 3 4 1\n3 2 4 5 1 6\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n100\n101\n000\n4 4\n11 1 0 10\n1001\n0110\n0110\n0101\n3 1\n34 3 7\n110110\n000100\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n0 1 2 2\n111\n100\n101\n000\n4 4\n4 1 0 10\n1001\n0010\n0110\n0001\n3 1\n54 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n3 1 2 2\n011\n100\n101\n100\n4 4\n2 1 0 10\n1001\n0010\n0110\n0101\n3 6\n38 2 8\n010110\n000101\n111001\n", "output": ["3 1 2\n3 1 4 2\n4 2 5 3 1 6\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n12 1 0 11\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000101\n110101\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n100\n4 4\n1 0 0 10\n1101\n0010\n0110\n0101\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n2 1 2 2\n111\n000\n101\n000\n4 4\n11 1 0 17\n1001\n0010\n0110\n0101\n3 1\n66 3 2\n010110\n000111\n110111\n", "output": ["2 1 3\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 3 2\n111\n100\n101\n000\n4 4\n6 1 0 10\n1101\n0010\n0010\n0101\n3 2\n20 3 7\n010110\n000101\n111101\n", "output": ["3 1 2\n3 1 4 2\n2 1\n"]}, {"input": "3\n4 3\n5 1 2 2\n101\n100\n001\n100\n4 4\n8 1 0 10\n1001\n0110\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111111\n", "output": ["3 2 1\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 4 2\n101\n101\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 3 7\n010110\n000101\n111111\n", "output": ["2 1 3\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 1 0\n011\n100\n111\n000\n4 4\n20 1 0 10\n1001\n0010\n0110\n0101\n3 1\n34 3 2\n010110\n000101\n110111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n110\n110\n101\n100\n4 4\n6 3 0 10\n1001\n0110\n0110\n0101\n3 6\n13 3 1\n010110\n100101\n111101\n", "output": ["3 1 2\n2 3 4 1\n5 2 3 4 1 6\n"]}, {"input": "3\n4 3\n4 1 1 2\n101\n100\n000\n101\n4 4\n6 1 0 10\n1001\n0010\n0110\n0100\n3 1\n20 6 7\n010110\n000101\n111110\n", "output": ["3 1 2\n1 3 4 2\n1\n"]}, {"input": "3\n4 3\n5 1 2 2\n111\n100\n101\n100\n4 4\n6 1 0 17\n1001\n0010\n0110\n0101\n1 1\n20 3 8\n010110\n010101\n111111\n", "output": ["3 1 2\n2 3 4 1\n1\n"]}], "task_id": "codecontest/158", "repair_prompt": ["Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he earns p_j points (otherwise, he receives 0 points). Moreover, the points for the questions are arranged in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Ensure your solution is efficient and handles edge cases properly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of students who answered each question correctly\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation based on sorted indices\n        permutation = [0] * m\n        for i, idx in enumerate(question_indices):\n            permutation[idx] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "completions": ["import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Generate permutations of points from 1 to m\n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    max_surprise_value = -1\n    best_permutation = None\n    for perm in permutations(range(1, m + 1)):\n        surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most often answered correctly\n        question_correct_count = [0] * m\n        \n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: question_correct_count[x], reverse=True)\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    # Generate the initial permutation of points\n    initial_permutation = list(range(1, m + 1))\n    \n    # Sort the permutation in descending order to maximize surprise value\n    sorted_permutation = sorted(initial_permutation, reverse=True)\n    \n    return sorted_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        \n        results.append(max_surprise_permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign the highest points to the least correctly answered questions\n        permutation = [0] * m\n        for i, index in enumerate(question_indices):\n            permutation[index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of students who answered each question correctly\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation based on sorted indices\n        permutation = [0] * m\n        for i, idx in enumerate(question_indices):\n            permutation[idx] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as a binary string.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points earned by summing the points for correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the earned points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each permutation of points, calculate the surprise value as the sum of absolute differences between expected and earned points for all students.\",\n        \"Identify the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"Generate all possible permutations of points from 1 to m.\",\n    \"For each permutation, calculate the earned points for each student and compute the surprise value.\",\n    \"Select the permutation that maximizes the surprise value for each test case.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        earned_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - earned_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of students who answered each question correctly\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation based on sorted indices\n        permutation = [0] * m\n        for i, idx in enumerate(question_indices):\n            permutation[idx] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the points earned by summing the points of correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the earned points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate permutations of points from 1 to m.\",\n    \"Calculate the actual points earned by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and select the one with the maximum value.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        # Generate permutations of points from 1 to m\n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of test cases, number of students, number of questions, expected points, and students' answers.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points received by summing the points for correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the received points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each permutation of points, calculate the surprise value as the sum of absolute differences between expected and received points for all students.\",\n        \"Identify the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"Iterate over all possible permutations of points from 1 to m.\",\n    \"For each permutation, calculate the received points for each student and compute the surprise value.\",\n    \"Select the permutation that yields the maximum surprise value.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: EOF while scanning triple-quoted string literal (<string>, line 134)"}, "Round_1": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers matrix for each test case.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers matrix for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"Initialize a permutation of points from 1 to m.\",\n        \"For each student, calculate the total points received using the permutation and their answers.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Track the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, initialize a permutation of points from 1 to m.\",\n    \"Calculate the actual points each student received using the permutation.\",\n    \"Iterate over possible permutations to find the one that maximizes the surprise value.\",\n    \"Output the permutation that results in the maximum surprise value for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate the initial permutation of points\n        initial_permutation = list(range(1, m + 1))\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in itertools.permutations(initial_permutation):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points, and students' answers.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers for each student.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student received based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"Initialize a permutation of points from 1 to m.\",\n        \"For each student, calculate the total points received using the permutation and their answers.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each permutation of points, calculate the surprise value using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Track the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"Iterate over all possible permutations of points for the questions.\",\n    \"For each permutation, calculate the actual points received by each student and compute the surprise value.\",\n    \"Select the permutation that results in the maximum surprise value.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, student_answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if student_answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        permutations = itertools.permutations(range(1, m + 1))\n        \n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations:\n            surprise_value = calculate_surprise_value(n, m, expected_points, student_answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 146)"}, "Round_1": {"code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        student_answers = []\n        for _ in range(n):\n            student_answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answers in student_answers:\n            for j in range(m):\n                if answers[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign points in descending order to questions with fewer correct answers\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as when all students expect zero points or when all questions are answered correctly by all students.\",\n      \"output\": \"A robust solution that correctly handles edge cases.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases.\",\n    \"For each test case, perform the following steps:\",\n    \"  a. Parse the number of students (n) and questions (m).\",\n    \"  b. Parse the expected points for each student.\",\n    \"  c. Parse the answers given by each student as a binary string.\",\n    \"  d. Generate all possible permutations of question points from 1 to m.\",\n    \"  e. For each permutation, calculate the actual points for each student and compute the surprise value.\",\n    \"  f. Track the permutation that results in the maximum surprise value.\",\n    \"  g. Output the permutation that maximizes the surprise value.\",\n    \"Ensure the solution is efficient and handles edge cases properly.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    max_surprise_value = -1\n    best_permutation = None\n    for perm in permutations(range(1, m + 1)):\n        surprise_value = calculate_surprise_value(n, m, expected_points, answers, perm)\n        if surprise_value > max_surprise_value:\n            max_surprise_value = surprise_value\n            best_permutation = perm\n    return best_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n, m = int(data[index]), int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        best_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        results.append(\" \".join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with students, questions, expected points, and answers\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points for each student based on a permutation of question points\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"List of expected points and list of actual points for each permutation\",\n      \"output\": \"Permutation of question points that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"input\": \"Permutation of question points for each test case\",\n      \"output\": \"Formatted output for each test case\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, generate all possible permutations of question points.\",\n    \"For each permutation, calculate the actual points each student would get.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Select the permutation that maximizes the surprise value.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 93)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of correct answers for each question\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation of points\n        permutation = [0] * m\n        for i, question_index in enumerate(question_indices):\n            permutation[question_index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"input\": \"Raw input string\",\n      \"output\": \"Structured data containing test cases with students, questions, expected points, and answers\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"input\": \"Structured data for a single test case\",\n      \"output\": \"List of actual points for each student based on a permutation of question points\"\n    },\n    {\n      \"description\": \"Compute the surprise value for a given permutation of question points by calculating the sum of absolute differences between expected and actual points for all students.\",\n      \"input\": \"Expected points and actual points for each student\",\n      \"output\": \"Surprise value for the permutation\"\n    },\n    {\n      \"description\": \"Generate permutations of question points and evaluate the surprise value for each permutation to find the permutation that maximizes the surprise value.\",\n      \"input\": \"Number of questions\",\n      \"output\": \"Permutation of question points that maximizes the surprise value\"\n    },\n    {\n      \"description\": \"Output the permutation of question points for each test case.\",\n      \"input\": \"Permutation of question points for each test case\",\n      \"output\": \"Formatted output for all test cases\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a list of question points as a permutation of numbers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points each student would get.\",\n    \"Compute the surprise value for each permutation by summing the absolute differences between expected and actual points for all students.\",\n    \"Track the permutation that results in the maximum surprise value.\",\n    \"Once all permutations are evaluated, store the permutation with the maximum surprise value for the current test case.\",\n    \"Output the stored permutation for each test case in the required format.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # We need to find a permutation of [1, 2, ..., m] that maximizes the surprise value\n        # A simple greedy approach is to assign the highest points to the questions that are most often answered correctly\n        question_correct_count = [0] * m\n        \n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    question_correct_count[j] += 1\n        \n        # Create a list of (correct_count, question_index) and sort it\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: question_correct_count[x], reverse=True)\n        \n        # Assign the highest points to the most frequently correctly answered questions\n        permutation = [0] * m\n        for i in range(m):\n            permutation[question_indices[i]] = m - i\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, and for each test case, extract the number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"output\": \"A structured representation of the input data for each test case.\"\n    },\n    {\n      \"description\": \"For each test case, calculate the actual points each student would get for a given permutation of question points.\",\n      \"output\": \"A function that computes the actual points for each student based on a given permutation of question points.\"\n    },\n    {\n      \"description\": \"Determine the permutation of question points that maximizes the surprise value, which is the sum of absolute differences between expected and actual points for all students.\",\n      \"output\": \"A permutation of question points that maximizes the surprise value.\"\n    },\n    {\n      \"description\": \"Handle edge cases such as when all students expect zero points or when all questions are answered correctly by all students.\",\n      \"output\": \"A robust solution that correctly handles edge cases.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Read and parse the input data to extract the number of test cases and details for each test case.\",\n    \"For each test case, initialize a permutation of question points as a list of integers from 1 to m.\",\n    \"For each permutation of question points, calculate the actual points each student would receive and compute the surprise value.\",\n    \"Iterate over all possible permutations of question points to find the permutation that maximizes the surprise value.\",\n    \"Output the permutation of question points for each test case that results in the maximum surprise value.\",\n    \"Ensure the solution is efficient and handles edge cases by considering constraints and optimizing the permutation search.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nimport itertools\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef find_max_surprise_permutation(n, m, expected_points, answers):\n    # Generate the initial permutation of points\n    initial_permutation = list(range(1, m + 1))\n    \n    # Sort the permutation in descending order to maximize surprise value\n    sorted_permutation = sorted(initial_permutation, reverse=True)\n    \n    return sorted_permutation\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Find the permutation that maximizes the surprise value\n        max_surprise_permutation = find_max_surprise_permutation(n, m, expected_points, answers)\n        \n        results.append(max_surprise_permutation)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input data to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as binary strings.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the points earned by summing the points of correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the earned points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value for each test case.\",\n      \"steps\": [\n        \"For each test case, iterate over possible permutations of points from 1 to m.\",\n        \"Calculate the surprise value for each permutation using the formula \u2211_{i=1}^{n} |x_i - r_i|.\",\n        \"Select the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"For each test case, generate all permutations of points from 1 to m.\",\n    \"Calculate the actual points earned by each student for each permutation.\",\n    \"Compute the surprise value for each permutation and select the one with the maximum value.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        actual_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - actual_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: unexpected EOF while parsing (<string>, line 98)"}, "Round_1": {"code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # To maximize the surprise value, we need to maximize the difference\n        # between expected and actual points. This can be achieved by assigning\n        # the highest points to the questions that are least answered correctly.\n        \n        # Count how many students answered each question correctly\n        correct_count = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_count[j] += 1\n        \n        # Create a list of question indices sorted by the number of correct answers\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_count[x])\n        \n        # Assign the highest points to the least correctly answered questions\n        permutation = [0] * m\n        for i, index in enumerate(question_indices):\n            permutation[index] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of test cases, number of students, number of questions, expected points for each student, and the answers given by each student.\",\n      \"steps\": [\n        \"Read the number of test cases.\",\n        \"For each test case, read the number of students and questions.\",\n        \"Read the expected points for each student.\",\n        \"Read the answers given by each student as a binary string.\"\n      ]\n    },\n    {\n      \"description\": \"Calculate the actual points each student has earned based on their answers and a given permutation of points.\",\n      \"steps\": [\n        \"For each student, calculate the total points earned by summing the points for correctly answered questions.\",\n        \"Use a permutation of points from 1 to m to calculate the earned points.\"\n      ]\n    },\n    {\n      \"description\": \"Determine the permutation of points that maximizes the surprise value.\",\n      \"steps\": [\n        \"For each permutation of points, calculate the surprise value as the sum of absolute differences between expected and earned points for all students.\",\n        \"Identify the permutation that results in the maximum surprise value.\"\n      ]\n    },\n    {\n      \"description\": \"Output the permutation of points for each test case.\",\n      \"steps\": [\n        \"For each test case, print the permutation of points that maximizes the surprise value.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input data to extract necessary information for each test case.\",\n    \"Generate all possible permutations of points from 1 to m.\",\n    \"For each permutation, calculate the earned points for each student and compute the surprise value.\",\n    \"Select the permutation that maximizes the surprise value for each test case.\",\n    \"Output the selected permutation for each test case.\"\n  ]\n}\n```", "Round_0": {"code": "import sys\nfrom itertools import permutations\n\ndef calculate_surprise_value(n, m, expected_points, answers, permutation):\n    surprise_value = 0\n    for i in range(n):\n        earned_points = sum(permutation[j] for j in range(m) if answers[i][j] == '1')\n        surprise_value += abs(expected_points[i] - earned_points)\n    return surprise_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Generate all permutations of points from 1 to m\n        max_surprise_value = -1\n        best_permutation = None\n        \n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = calculate_surprise_value(n, m, expected_points, answers, permutation)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                best_permutation = permutation\n        \n        results.append(' '.join(map(str, best_permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: calculate_surprise_value() missing 5 required positional arguments: 'n', 'm', 'expected_points', 'answers', and 'permutation'"}, "Round_1": {"code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        expected_points = list(map(int, data[index:index + n]))\n        index += n\n        \n        answers = []\n        for _ in range(n):\n            answers.append(data[index])\n            index += 1\n        \n        # Calculate the number of students who answered each question correctly\n        correct_counts = [0] * m\n        for answer in answers:\n            for j in range(m):\n                if answer[j] == '1':\n                    correct_counts[j] += 1\n        \n        # Pair each question with its correct count and sort by correct count\n        question_indices = list(range(m))\n        question_indices.sort(key=lambda x: correct_counts[x])\n        \n        # Create the permutation based on sorted indices\n        permutation = [0] * m\n        for i, idx in enumerate(question_indices):\n            permutation[idx] = i + 1\n        \n        results.append(' '.join(map(str, permutation)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}], "scores": [], "pass_results": [false, false, true, true, false, true, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 335, "prompt": "Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j-th question correctly, he earns p_j points (otherwise, he receives 0 points). Moreover, the points for the questions are arranged in such a way that the array p is a permutation of numbers from 1 to m.\n\nFor the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to \u2211_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.\n\nYour task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them. Ensure your solution is efficient and handles edge cases properly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains two integers n and m (1 \u2264 n \u2264 10; 1 \u2264 m \u2264 10^4) \u2014 the number of students and the number of questions, respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_n (0 \u2264 x_i \u2264 (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.\n\nThis is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} \u2208 \\{0, 1\\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.\n\nThe sum of m for all test cases does not exceed 10^4.\n\nOutput\n\nFor each test case, print m integers \u2014 a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\n\nExample\n\nInput\n\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\n\nOutput\n\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 ", "mutate_method": "add_1_sentence_at_end", "save_node": false, "parent_index": 115}
