{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is. These rules must be followed precisely, and they cannot be altered. They also have strict rules on when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You should consider edge cases, such as when N is less than 5 or when there are no friendships at all.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find\nmain()", "completions": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of size 5 (clique)\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for a subset of 5 people with no friendships\n    def find_independent_set_of_size_5():\n        non_friends = []\n        for person in range(1, N + 1):\n            if len(friendships[person]) == 0:\n                non_friends.append(person)\n                if len(non_friends) == 5:\n                    return non_friends\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    friendships = []\n    for _ in range(M):\n        U = int(data[index])\n        index += 1\n        V = int(data[index])\n        index += 1\n        friendships.append((U, V))\n    \n    # If N < 5, immediately output -1\n    if N < 5:\n        print(-1)\n        return\n    \n    # Create a graph representation using adjacency list\n    from collections import defaultdict\n    graph = defaultdict(set)\n    \n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(graph[person]) >= 4:\n                friends = list(graph[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in graph[friends[j]] and\n                                    friends[i] in graph[friends[k]] and\n                                    friends[i] in graph[friends[l]] and\n                                    friends[j] in graph[friends[k]] and\n                                    friends[j] in graph[friends[l]] and\n                                    friends[k] in graph[friends[l]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for u, v in friendships:\n            if u in non_friends:\n                non_friends.remove(u)\n            if v in non_friends:\n                non_friends.remove(v)\n        \n        if len(non_friends) >= 5:\n            return list(non_friends)[:5]\n        return None\n    \n    # Determine the output\n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in friendships[friends[j]] and\n                                    friends[i] in friendships[friends[k]] and\n                                    friends[i] in friendships[friends[l]] and\n                                    friends[j] in friendships[friends[k]] and\n                                    friends[j] in friendships[friends[l]] and\n                                    friends[k] in friendships[friends[l]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                # Check if we can form a clique with this person\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friends[person]) < N - 1:\n                non_friends -= friends[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for friendships\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph (clique) of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friends[person]) < N - 1:\n                non_friends -= friends[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Check for independent set of 5 people\n    if M == 0:\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Check for a complete subgraph of 5 people\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            potential_clique = [person] + list(friends[person])\n            if len(potential_clique) >= 5:\n                for i in range(len(potential_clique)):\n                    for j in range(i + 1, len(potential_clique)):\n                        if potential_clique[j] not in friends[potential_clique[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    print(*potential_clique[:5])\n                    return\n    \n    # Check for independent set of 5 people\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(non_friends) < 5:\n            break\n        if person in non_friends:\n            non_friends -= friends[person]\n            non_friends.discard(person)\n            if len(non_friends) >= 4:\n                print(person, *list(non_friends)[:4])\n                return\n            non_friends = set(range(1, N + 1))\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    friendships = []\n    for _ in range(M):\n        U = int(data[index])\n        index += 1\n        V = int(data[index])\n        index += 1\n        friendships.append((U, V))\n    \n    # If N is less than 5, immediately output -1\n    if N < 5:\n        print(-1)\n        return\n    \n    # Create a graph representation using adjacency list\n    from collections import defaultdict\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for node in graph:\n            if len(graph[node]) >= 4:\n                neighbors = list(graph[node])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [node, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        all_people = set(range(1, N + 1))\n        for node in graph:\n            non_neighbors = all_people - graph[node] - {node}\n            if len(non_neighbors) >= 4:\n                non_neighbors = list(non_neighbors)\n                return [node, non_neighbors[0], non_neighbors[1], non_neighbors[2], non_neighbors[3]]\n        return None\n    \n    # Determine the final output\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of 5\n    for person in range(1, N + 1):\n        if len(friendships[person]) >= 4:\n            # Check if this person and 4 of their friends form a clique\n            friends = list(friendships[person])\n            for i in range(len(friends)):\n                for j in range(i + 1, len(friends)):\n                    for k in range(j + 1, len(friends)):\n                        for l in range(k + 1, len(friends)):\n                            f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                            if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                f3 in friendships[f2] and f4 in friendships[f2] and\n                                f4 in friendships[f3]):\n                                print(person, f1, f2, f3, f4)\n                                return\n    \n    # Check for an independent set of 5\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(non_friends) < 5:\n            break\n        if len(friendships[person]) < N - 5:\n            # This person can be part of an independent set\n            potential_set = non_friends - friendships[person] - {person}\n            if len(potential_set) >= 4:\n                result = [person] + list(potential_set)[:4]\n                print(' '.join(map(str, result)))\n                return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    if M == 0:\n        print(1, 2, 3, 4, 5)\n        return\n    \n    if M >= 10:\n        # Attempt to find a complete subgraph of 5 people\n        from collections import defaultdict\n        \n        graph = defaultdict(set)\n        for u, v in friendships:\n            graph[u].add(v)\n            graph[v].add(u)\n        \n        # Check for a clique of size 5\n        for person in range(1, N + 1):\n            if len(graph[person]) >= 4:\n                friends = list(graph[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in graph[friends[j]] and\n                                    friends[i] in graph[friends[k]] and\n                                    friends[i] in graph[friends[l]] and\n                                    friends[j] in graph[friends[k]] and\n                                    friends[j] in graph[friends[l]] and\n                                    friends[k] in graph[friends[l]]):\n                                    print(person, friends[i], friends[j], friends[k], friends[l])\n                                    return\n    \n    # Attempt to find an independent set of 5 people\n    non_friends = set(range(1, N + 1))\n    for u, v in friendships:\n        if u in non_friends:\n            non_friends.remove(u)\n        if v in non_friends:\n            non_friends.remove(v)\n    \n    if len(non_friends) >= 5:\n        print(*list(non_friends)[:5])\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find\nmain()"], "session_history": {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"goal\": \"Create data structures to store the people and their friendships.\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with exactly 5 people.\",\n      \"goal\": \"Ensure N is at least 5.\"\n    },\n    {\n      \"description\": \"Identify if there exists a group of 5 people where all are friends with each other.\",\n      \"goal\": \"Find a complete subgraph of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Identify if there exists a group of 5 people where no two are friends with each other.\",\n      \"goal\": \"Find an independent set of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Determine if a successful party is possible based on the above checks.\",\n      \"goal\": \"Output the 5 people if possible, otherwise output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendship pairs.\",\n    \"Check if N is less than 5. If so, output -1 as a party is not possible.\",\n    \"Construct a graph representation of friendships using adjacency lists or matrices.\",\n    \"Search for a complete subgraph of 5 nodes. If found, output the nodes.\",\n    \"Search for an independent set of 5 nodes. If found, output the nodes.\",\n    \"If neither a complete subgraph nor an independent set is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find", "report": "The compilation output of the preceding code is: main() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find"}}, "session_historys": [{"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all attendees being friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"Create a graph representation using adjacency lists for friendships.\",\n        \"Check for any complete subgraph (clique) of size 5 in the graph.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with no attendees being friends.\",\n      \"steps\": [\n        \"If N >= 5, check if there are at least 5 people with no friendships.\",\n        \"Identify any subset of 5 people who are not connected by any friendship.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the checks.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the list of 5 people.\",\n        \"If no configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Create a graph representation using adjacency lists.\",\n    \"Check for a complete subgraph of size 5 (all friends).\",\n    \"Check for a subset of 5 people with no friendships.\",\n    \"Output the result based on the checks.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of size 5 (clique)\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for a subset of 5 people with no friendships\n    def find_independent_set_of_size_5():\n        non_friends = []\n        for person in range(1, N + 1):\n            if len(friendships[person]) == 0:\n                non_friends.append(person)\n                if len(non_friends) == 5:\n                    return non_friends\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print", "report": "The compilation output of the preceding code is: main() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of size 5 (clique)\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for a subset of 5 people with no friendships\n    def find_independent_set_of_size_5():\n        non_friends = []\n        for person in range(1, N + 1):\n            if len(friendships[person]) == 0:\n                non_friends.append(person)\n                if len(non_friends) == 5:\n                    return non_friends\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    # If neither is found, print"}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with exactly 5 people given the constraints.\",\n      \"output\": \"Boolean indicating if a party is possible.\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where all are friends with each other.\",\n      \"output\": \"List of 5 people if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where no two are friends with each other.\",\n      \"output\": \"List of 5 people if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Determine the output based on the results of the previous subproblems.\",\n      \"output\": \"List of 5 people for a successful party or -1 if no such party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"If N < 5, immediately output -1 as a party is not possible.\",\n    \"Create a graph representation of friendships using an adjacency list.\",\n    \"Check for a clique of size 5 (all friends with each other) using the graph.\",\n    \"Check for an independent set of size 5 (no two are friends) using the graph.\",\n    \"If either a clique or an independent set is found, output the list of 5 people.\",\n    \"If neither is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    friendships = []\n    for _ in range(M):\n        U = int(data[index])\n        index += 1\n        V = int(data[index])\n        index += 1\n        friendships.append((U, V))\n    \n    # If N < 5, immediately output -1\n    if N < 5:\n        print(-1)\n        return\n    \n    # Create a graph representation using adjacency list\n    from collections import defaultdict\n    graph = defaultdict(set)\n    \n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(graph[person]) >= 4:\n                friends = list(graph[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in graph[friends[j]] and\n                                    friends[i] in graph[friends[k]] and\n                                    friends[i] in graph[friends[l]] and\n                                    friends[j] in graph[friends[k]] and\n                                    friends[j] in graph[friends[l]] and\n                                    friends[k] in graph[friends[l]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for u, v in friendships:\n            if u in non_friends:\n                non_friends.remove(u)\n            if v in non_friends:\n                non_friends.remove(v)\n        \n        if len(non_friends) >= 5:\n            return list(non_friends)[:5]\n        return None\n    \n    # Determine the output\n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent", "report": "The compilation output of the preceding code is: name 'find_independent' is not defined"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    friendships = []\n    for _ in range(M):\n        U = int(data[index])\n        index += 1\n        V = int(data[index])\n        index += 1\n        friendships.append((U, V))\n    \n    # If N < 5, immediately output -1\n    if N < 5:\n        print(-1)\n        return\n    \n    # Create a graph representation using adjacency list\n    from collections import defaultdict\n    graph = defaultdict(set)\n    \n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(graph[person]) >= 4:\n                friends = list(graph[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in graph[friends[j]] and\n                                    friends[i] in graph[friends[k]] and\n                                    friends[i] in graph[friends[l]] and\n                                    friends[j] in graph[friends[k]] and\n                                    friends[j] in graph[friends[l]] and\n                                    friends[k] in graph[friends[l]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for u, v in friendships:\n            if u in non_friends:\n                non_friends.remove(u)\n            if v in non_friends:\n                non_friends.remove(v)\n        \n        if len(non_friends) >= 5:\n            return list(non_friends)[:5]\n        return None\n    \n    # Determine the output\n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if it's possible to have a successful party based on the number of people.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to have a party with less than 5 people.\"\n      ]\n    },\n    {\n      \"description\": \"Determine if there exists a group of 5 people where all are friends or none are friends.\",\n      \"steps\": [\n        \"Create a graph representation using adjacency lists for the friendships.\",\n        \"Check for a complete subgraph of 5 nodes (clique) where all nodes are connected.\",\n        \"Check for an independent set of 5 nodes where no nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the 5 people.\",\n        \"If no configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Check if N is less than 5; if so, output -1.\",\n    \"Construct a graph using the friendship pairs.\",\n    \"Search for a complete subgraph of 5 nodes (clique) in the graph.\",\n    \"Search for an independent set of 5 nodes in the graph.\",\n    \"Output the 5 people if a successful party configuration is found, otherwise output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in friendships[friends[j]] and\n                                    friends[i] in friendships[friends[k]] and\n                                    friends[i] in friendships[friends[l]] and\n                                    friends[j] in friendships[friends[k]] and\n                                    friends[j] in friendships[friends[l]] and\n                                    friends[k] in friendships[friends[l]]):\n                                    return [person, friends[i], friends[j], friends[k], friends[l]]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 4:\n                    return [person] + list(non_friends)[:4]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all people being friends or no two people being friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"Create a graph representation of friendships using adjacency lists.\",\n        \"Check for a complete subgraph of 5 nodes (clique) where all nodes are friends.\",\n        \"Check for an independent set of 5 nodes where no nodes are friends.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the checks.\",\n      \"steps\": [\n        \"If a successful party configuration is found, output the 5 people involved.\",\n        \"If no configuration is found, output -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Implement a graph representation using adjacency lists.\",\n    \"Check for a clique of 5 nodes in the graph.\",\n    \"Check for an independent set of 5 nodes in the graph.\",\n    \"Output the result based on the checks.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                # Check if we can form a clique with this person\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friends[person]) < N - 1:\n                non_friends -= friends[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 114)"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for the graph\n    friends = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes (clique)\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                # Check if we can form a clique with this person\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friends[person]) < N - 1:\n                non_friends -= friends[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendships.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with exactly 5 people given the constraints.\",\n      \"output\": \"Boolean indicating if a party is possible.\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where all are friends with each other.\",\n      \"output\": \"A list of 5 people if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where no two are friends with each other.\",\n      \"output\": \"A list of 5 people if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Determine the final output based on the results of the previous subproblems.\",\n      \"output\": \"A list of 5 people for a successful party or -1 if no such party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendships.\",\n    \"If N is less than 5, immediately output -1 as a party is not possible.\",\n    \"Create a graph representation of friendships using adjacency lists.\",\n    \"Check for a complete subgraph (clique) of size 5 in the graph.\",\n    \"If a clique of size 5 is found, output the list of 5 people.\",\n    \"If no clique is found, check for an independent set of size 5.\",\n    \"If an independent set of size 5 is found, output the list of 5 people.\",\n    \"If neither a clique nor an independent set of size 5 is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Create adjacency list for friendships\n    friends = defaultdict(set)\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        friends[u].add(v)\n        friends[v].add(u)\n    \n    # Check for a complete subgraph (clique) of size 5\n    def find_clique():\n        for person in range(1, N + 1):\n            if len(friends[person]) >= 4:\n                potential_clique = [person] + list(friends[person])\n                if len(potential_clique) >= 5:\n                    for i in range(5):\n                        for j in range(i + 1, 5):\n                            if potential_clique[j] not in friends[potential_clique[i]]:\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        return potential_clique[:5]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friends[person]) < N - 1:\n                non_friends -= friends[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n        return None\n    \n    clique = find_clique()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    independent_set = find_independent_set()\n    if independent_set:\n        print(' '.join(map(str, independent_set)))\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all people being friends or no people being friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"If M == 0, check if N >= 5 and return any 5 people as they are all not friends.\",\n        \"If M >= 10, check for a complete subgraph of 5 people (all friends).\"\n      ]\n    },\n    {\n      \"description\": \"Find a group of 5 people where either all are friends or none are friends.\",\n      \"steps\": [\n        \"Use graph traversal techniques to find a complete subgraph of 5 people.\",\n        \"Use graph traversal techniques to find an independent set of 5 people.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Check for immediate impossibility conditions (N < 5 or M == 0).\",\n    \"Use graph traversal to find either a complete subgraph or an independent set of 5 people.\",\n    \"Output the result based on the findings.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    friends = defaultdict(set)\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friends[u].add(v)\n        friends[v].add(u)\n        index += 2\n    \n    # Check for independent set of 5 people\n    if M == 0:\n        print(1, 2, 3, 4, 5)\n        return\n    \n    # Check for a complete subgraph of 5 people\n    for person in range(1, N + 1):\n        if len(friends[person]) >= 4:\n            potential_clique = [person] + list(friends[person])\n            if len(potential_clique) >= 5:\n                for i in range(len(potential_clique)):\n                    for j in range(i + 1, len(potential_clique)):\n                        if potential_clique[j] not in friends[potential_clique[i]]:\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    print(*potential_clique[:5])\n                    return\n    \n    # Check for independent set of 5 people\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(non_friends) < 5:\n            break\n        if person in non_friends:\n            non_friends -= friends[person]\n            non_friends.discard(person)\n            if len(non_friends) >= 4:\n                print(person, *list(non_friends)[:4])\n                return\n            non_friends = set(range(1, N + 1))\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"output\": \"N, M, and a list of tuples representing friendships.\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with exactly 5 people given the constraints.\",\n      \"output\": \"Boolean indicating if a party is possible.\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where all are friends with each other.\",\n      \"output\": \"List of 5 people if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Identify a group of 5 people where no two are friends with each other.\",\n      \"output\": \"List of 5 people if such a group exists, otherwise null.\"\n    },\n    {\n      \"description\": \"Determine the final output based on the results of the previous subproblems.\",\n      \"output\": \"List of 5 people for a successful party or -1 if no such party is possible.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to get N, M, and the list of friendship pairs.\",\n    \"If N is less than 5, immediately output -1 as a party is not possible.\",\n    \"Create a graph representation of the friendships using an adjacency list.\",\n    \"Check for a clique of size 5 (all friends with each other) using the graph.\",\n    \"Check for an independent set of size 5 (no two are friends) using the graph.\",\n    \"If either a clique or an independent set is found, output the list of 5 people.\",\n    \"If neither is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    \n    friendships = []\n    for _ in range(M):\n        U = int(data[index])\n        index += 1\n        V = int(data[index])\n        index += 1\n        friendships.append((U, V))\n    \n    # If N is less than 5, immediately output -1\n    if N < 5:\n        print(-1)\n        return\n    \n    # Create a graph representation using adjacency list\n    from collections import defaultdict\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Check for a clique of size 5\n    def find_clique_of_size_5():\n        for node in graph:\n            if len(graph[node]) >= 4:\n                neighbors = list(graph[node])\n                for i in range(len(neighbors)):\n                    for j in range(i + 1, len(neighbors)):\n                        for k in range(j + 1, len(neighbors)):\n                            for l in range(k + 1, len(neighbors)):\n                                if (neighbors[i] in graph[neighbors[j]] and\n                                    neighbors[i] in graph[neighbors[k]] and\n                                    neighbors[i] in graph[neighbors[l]] and\n                                    neighbors[j] in graph[neighbors[k]] and\n                                    neighbors[j] in graph[neighbors[l]] and\n                                    neighbors[k] in graph[neighbors[l]]):\n                                    return [node, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n        return None\n    \n    # Check for an independent set of size 5\n    def find_independent_set_of_size_5():\n        all_people = set(range(1, N + 1))\n        for node in graph:\n            non_neighbors = all_people - graph[node] - {node}\n            if len(non_neighbors) >= 4:\n                non_neighbors = list(non_neighbors)\n                return [node, non_neighbors[0], non_neighbors[1], non_neighbors[2], non_neighbors[3]]\n        return None\n    \n    # Determine the final output\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if it's possible to have a successful party based on the given conditions.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"If M == 0, check if there are at least 5 people to form a party with no friendships.\"\n      ]\n    },\n    {\n      \"description\": \"Identify a group of 5 people where either all are friends or none are friends.\",\n      \"steps\": [\n        \"Create a graph representation of friendships using adjacency lists.\",\n        \"Search for a complete subgraph of 5 nodes (clique) where all nodes are connected.\",\n        \"Search for an independent set of 5 nodes where no nodes are connected.\"\n      ]\n    },\n    {\n      \"description\": \"Output the result based on the findings.\",\n      \"steps\": [\n        \"If a successful party configuration is found, print the 5 people involved.\",\n        \"If no configuration is found, print -1.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and friendship pairs.\",\n    \"Check for immediate impossibility conditions (N < 5 or M == 0).\",\n    \"Construct a graph representation of friendships.\",\n    \"Search for a clique of 5 nodes or an independent set of 5 nodes.\",\n    \"Output the result based on the search findings.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a clique of 5\n    for person in range(1, N + 1):\n        if len(friendships[person]) >= 4:\n            # Check if this person and 4 of their friends form a clique\n            friends = list(friendships[person])\n            for i in range(len(friends)):\n                for j in range(i + 1, len(friends)):\n                    for k in range(j + 1, len(friends)):\n                        for l in range(k + 1, len(friends)):\n                            f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                            if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                f3 in friendships[f2] and f4 in friendships[f2] and\n                                f4 in friendships[f3]):\n                                print(person, f1, f2, f3, f4)\n                                return\n    \n    # Check for an independent set of 5\n    non_friends = set(range(1, N + 1))\n    for person in range(1, N + 1):\n        if len(non_friends) < 5:\n            break\n        if len(friendships[person]) < N - 5:\n            # This person can be part of an independent set\n            potential_set = non_friends - friendships[person] - {person}\n            if len(potential_set) >= 4:\n                result = [person] + list(potential_set)[:4]\n                print(' '.join(map(str, result)))\n                return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"steps\": [\n        \"Read the first line to get N and M.\",\n        \"Read the next M lines to get the friendship pairs.\"\n      ]\n    },\n    {\n      \"description\": \"Check if a successful party is possible with all people being friends or no one being friends.\",\n      \"steps\": [\n        \"If N < 5, immediately return -1 as it's impossible to form a party.\",\n        \"If M == 0, return any 5 distinct people as no one is friends with anyone.\",\n        \"If M >= 10, check for a complete subgraph of 5 people (all friends).\"\n      ]\n    },\n    {\n      \"description\": \"Find a complete subgraph of 5 people where all are friends.\",\n      \"steps\": [\n        \"Use graph traversal techniques to find a clique of size 5.\",\n        \"If found, return the 5 people.\"\n      ]\n    },\n    {\n      \"description\": \"Find a set of 5 people where no two are friends.\",\n      \"steps\": [\n        \"Use graph traversal techniques to find an independent set of size 5.\",\n        \"If found, return the 5 people.\"\n      ]\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the friendship pairs.\",\n    \"Check if N < 5, return -1 if true.\",\n    \"Check if M == 0, return any 5 distinct people if true.\",\n    \"If M >= 10, attempt to find a complete subgraph of 5 people.\",\n    \"If a complete subgraph is found, return the 5 people.\",\n    \"If not found, attempt to find an independent set of 5 people.\",\n    \"If an independent set is found, return the 5 people.\",\n    \"If neither a complete subgraph nor an independent set is found, return -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    friendships = set()\n    index = 2\n    for _ in range(M):\n        U = int(data[index])\n        V = int(data[index + 1])\n        friendships.add((U, V))\n        friendships.add((V, U))\n        index += 2\n    \n    if M == 0:\n        print(1, 2, 3, 4, 5)\n        return\n    \n    if M >= 10:\n        # Attempt to find a complete subgraph of 5 people\n        from collections import defaultdict\n        \n        graph = defaultdict(set)\n        for u, v in friendships:\n            graph[u].add(v)\n            graph[v].add(u)\n        \n        # Check for a clique of size 5\n        for person in range(1, N + 1):\n            if len(graph[person]) >= 4:\n                friends = list(graph[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                if (friends[i] in graph[friends[j]] and\n                                    friends[i] in graph[friends[k]] and\n                                    friends[i] in graph[friends[l]] and\n                                    friends[j] in graph[friends[k]] and\n                                    friends[j] in graph[friends[l]] and\n                                    friends[k] in graph[friends[l]]):\n                                    print(person, friends[i], friends[j], friends[k], friends[l])\n                                    return\n    \n    # Attempt to find an independent set of 5 people\n    non_friends = set(range(1, N + 1))\n    for u, v in friendships:\n        if u in non_friends:\n            non_friends.remove(u)\n        if v in non_friends:\n            non_friends.remove(v)\n    \n    if len(non_friends) >= 5:\n        print(*list(non_friends)[:5])\n        return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "report": "The compilation output of the preceding code is: Code Test Passed."}}, {"plan": "```json\n{\n  \"subproblems\": [\n    {\n      \"description\": \"Parse the input to extract the number of people (N), number of friendships (M), and the list of friendship pairs.\",\n      \"goal\": \"Create data structures to store the people and their friendships.\"\n    },\n    {\n      \"description\": \"Check if it's possible to have a party with exactly 5 people.\",\n      \"goal\": \"Ensure N is at least 5.\"\n    },\n    {\n      \"description\": \"Identify if there exists a group of 5 people where all are friends with each other.\",\n      \"goal\": \"Find a complete subgraph of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Identify if there exists a group of 5 people where no two are friends with each other.\",\n      \"goal\": \"Find an independent set of 5 nodes in the friendship graph.\"\n    },\n    {\n      \"description\": \"Determine if a successful party is possible based on the above checks.\",\n      \"goal\": \"Output the 5 people if possible, otherwise output -1.\"\n    }\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract N, M, and the list of friendship pairs.\",\n    \"Check if N is less than 5. If so, output -1 as a party is not possible.\",\n    \"Construct a graph representation of friendships using adjacency lists or matrices.\",\n    \"Search for a complete subgraph of 5 nodes. If found, output the nodes.\",\n    \"Search for an independent set of 5 nodes. If found, output the nodes.\",\n    \"If neither a complete subgraph nor an independent set is found, output -1.\"\n  ]\n}\n```", "Round_0": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find", "report": "The compilation output of the preceding code is: main() takes 0 positional arguments but 1 was given"}, "Round_1": {"code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    if N < 5:\n        print(-1)\n        return\n    \n    from collections import defaultdict\n    \n    # Parse friendships\n    friendships = defaultdict(set)\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        friendships[u].add(v)\n        friendships[v].add(u)\n        index += 2\n    \n    # Check for a complete subgraph of 5 nodes\n    def find_clique_of_size_5():\n        for person in range(1, N + 1):\n            if len(friendships[person]) >= 4:\n                friends = list(friendships[person])\n                for i in range(len(friends)):\n                    for j in range(i + 1, len(friends)):\n                        for k in range(j + 1, len(friends)):\n                            for l in range(k + 1, len(friends)):\n                                f1, f2, f3, f4 = friends[i], friends[j], friends[k], friends[l]\n                                if (f2 in friendships[f1] and f3 in friendships[f1] and f4 in friendships[f1] and\n                                    f3 in friendships[f2] and f4 in friendships[f2] and\n                                    f4 in friendships[f3]):\n                                    return [person, f1, f2, f3, f4]\n        return None\n    \n    # Check for an independent set of 5 nodes\n    def find_independent_set_of_size_5():\n        non_friends = set(range(1, N + 1))\n        for person in range(1, N + 1):\n            if len(friendships[person]) < N - 1:\n                non_friends -= friendships[person]\n                non_friends.discard(person)\n                if len(non_friends) >= 5:\n                    return list(non_friends)[:5]\n                non_friends = set(range(1, N + 1))\n        return None\n    \n    # Try to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        print(' '.join(map(str, clique)))\n        return\n    \n    # Try to find an independent set of size 5\n    independent_set = find"}}], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 7, "round": 346, "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is. These rules must be followed precisely, and they cannot be altered. They also have strict rules on when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You should consider edge cases, such as when N is less than 5 or when there are no friendships at all.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "expand_one2two", "save_node": true, "parent_index": 197}
