{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "repair_prompt": ["The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible. The goal is to find a starting cell that maximizes the number of successful moves.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def simulate_robot_movement(n, m, commands):\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def move(x, y, command):\n        if command == 'L':\n            return x, y - 1\n        elif command == 'R':\n            return x, y + 1\n        elif command == 'U':\n            return x - 1, y\n        elif command == 'D':\n            return x + 1, y\n    \n    def count_successful_moves(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            new_x, new_y = move(x, y, command)\n            if is_valid_move(new_x, new_y):\n                successful_moves += 1\n                x, y = new_x, new_y\n            else:\n                break\n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n    \n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = simulate_robot_movement(n, m, commands)\n    print(result[0], result[1])\n\nmain()", "completions": ["def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append((n, m), commands)\n\n# Output\nfind_starting_cell(t, test_cases)\n\nmain()", "def count_successful_moves(n, m, commands):\n    max_successful_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = 0\n            x, y = i, j\n\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                successful_moves += 1\n\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = count_successful_moves(n, m, commands)\n    print(start_cell[0], start_cell[1])\n\nmain()", "def find_starting_cell(t, test_cases):\n    def count_successful_moves(n, m, s):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n\n        def simulate_move(x, y):\n            successful_moves = 0\n            visited = set()\n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                successful_moves += 1\n                dx, dy = directions[s[successful_moves % len(s)]]\n                x, y = x + dx, y + dy\n            return successful_moves\n\n        max_successful_moves = 0\n        max_cell = (1, 1)\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                successful_moves = simulate_move(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    max_cell = (i, j)\n        return max_cell\n\n    results = []\n    for i in range(t):\n        n, m = test_cases[i][0]\n        s = test_cases[i][1]\n        result = count_successful_moves(n, m, s)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input()\n    test_cases.append((n, m), s)\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n\nmain()", "def simulate_robot_movement(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            dx, dy = directions[command]\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y):\n                x, y = new_x, new_y\n                successful_moves += 1\n            else:\n                break\n        return successful_moves, (x, y)\n    \n    max_successful_moves = 0\n    optimal_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            moves, _ = execute_commands(i, j)\n            if moves > max_successful_moves:\n                max_successful_moves = moves\n                optimal_starting_cell = (i, j)\n    \n    return optimal_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    optimal_starting_cell = simulate_robot_movement(n, m, commands)\n    print(optimal_starting_cell[0], optimal_starting_cell[1])\n\nmain()", "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n\nmain()", "def count_successful_moves(n, m, commands):\n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            successful_moves = 0\n\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                successful_moves += 1\n\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n\n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = count_successful_moves(n, m, commands)\n    print(result[0], result[1])\n\nmain()", "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                current_row, current_col = row, col\n                successful_moves = 0\n                \n                for command in commands:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    if current_row < 1 or current_row > n or current_col < 1 or current_col > m:\n                        break\n                    successful_moves += 1\n                \n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(starting_cell[0], starting_cell[1])\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n\nmain()", "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n\nmain()", "def find_optimal_starting_cell(t, test_cases):\n    def count_successful_moves(n, m, commands, start_row, start_col):\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        successful_moves = 0\n        for command in commands:\n            dr, dc = directions[command]\n            new_row, new_col = start_row + dr, start_col + dc\n            if 1 <= new_row <= n and 1 <= new_col <= m:\n                successful_moves += 1\n                start_row, start_col = new_row, new_col\n        return successful_moves\n\n    results = []\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        max_successful_moves = 0\n        optimal_starting_cell = (1, 1)\n\n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                successful_moves = count_successful_moves(n, m, commands, row, col)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    optimal_starting_cell = (row, col)\n\n        results.append(optimal_starting_cell)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_optimal_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n\nmain()", "def simulate_robot_movement(n, m, commands):\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def move(x, y, command):\n        if command == 'L':\n            return x, y - 1\n        elif command == 'R':\n            return x, y + 1\n        elif command == 'U':\n            return x - 1, y\n        elif command == 'D':\n            return x + 1, y\n    \n    def count_successful_moves(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            new_x, new_y = move(x, y, command)\n            if is_valid_move(new_x, new_y):\n                successful_moves += 1\n                x, y = new_x, new_y\n            else:\n                break\n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n    \n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = simulate_robot_movement(n, m, commands)\n    print(result[0], result[1])\n\nmain()"], "session_history": {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Simulate the robot's movement on the board based on the given commands\",\n    \"Track the number of successful moves for each starting cell\",\n    \"Find the starting cell that maximizes the number of successful moves\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases\",\n    \"For each test case:\",\n    \"   Read the board size and sequence of commands\",\n    \"   Initialize a variable to track the maximum number of successful moves\",\n    \"   Initialize variables to store the coordinates of the starting cell with the maximum successful moves\",\n    \"   Iterate through each cell on the board:\",\n    \"       Simulate the robot's movement from the current cell based on the commands\",\n    \"       Track the number of successful moves\",\n    \"       Update the maximum number of successful moves and the coordinates of the starting cell if needed\",\n    \"   Output the coordinates of the starting cell with the maximum successful moves\"\n  ]\n}", "Round_0": {"code": "def simulate_robot_movement(n, m, commands):\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def move(x, y, command):\n        if command == 'L':\n            return x, y - 1\n        elif command == 'R':\n            return x, y + 1\n        elif command == 'U':\n            return x - 1, y\n        elif command == 'D':\n            return x + 1, y\n    \n    def count_successful_moves(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            new_x, new_y = move(x, y, command)\n            if is_valid_move(new_x, new_y):\n                successful_moves += 1\n                x, y = new_x, new_y\n            else:\n                break\n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n    \n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = simulate_robot_movement(n, m, commands)\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 51)"}, "Round_1": {"code": "def simulate_robot_movement(n, m, commands):\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def move(x, y, command):\n        if command == 'L':\n            return x, y - 1\n        elif command == 'R':\n            return x, y + 1\n        elif command == 'U':\n            return x - 1, y\n        elif command == 'D':\n            return x + 1, y\n    \n    def count_successful_moves(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            new_x, new_y = move(x, y, command)\n            if is_valid_move(new_x, new_y):\n                successful_moves += 1\n                x, y = new_x, new_y\n            else:\n                break\n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n    \n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = simulate_robot_movement(n, m, commands)\n    print(result[0], result[1])\n"}}, "session_historys": [{"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the starting cell that maximizes the number of successful moves\",\n    \"Calculate the number of successful moves for each starting cell\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": \"For each test case, iterate through each cell on the board\",\n    \"step_4\": \"For each cell, simulate the robot's movement based on the command sequence and calculate the number of successful moves\",\n    \"step_5\": \"Track the starting cell that maximizes the number of successful moves\",\n    \"step_6\": \"Output the coordinates of the cell that maximizes the number of successful moves\"\n  }\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append((n, m), commands)\n\n# Output\nfind_starting_cell(t, test_cases)\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 55)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append((n, m), commands)\n\n# Output\nfind_starting_cell(t, test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Iterate through each test case and determine the maximum number of successful moves for each starting cell\",\n    \"Output the coordinates of the cell with the maximum number of successful moves for each test case\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input data for each test case\",\n    \"Step 2\": \"Iterate through each test case\",\n    \"Step 3\": {\n      \"Substep 1\": \"Initialize a variable to store the maximum number of successful moves\",\n      \"Substep 2\": \"Iterate through each cell in the board\",\n      \"Substep 3\": \"Simulate the robot's movement from the current cell using the given commands\",\n      \"Substep 4\": \"Count the number of successful moves\",\n      \"Substep 5\": \"Update the maximum number of successful moves if the current cell has more successful moves\",\n      \"Substep 6\": \"Output the coordinates of the cell with the maximum number of successful moves\"\n    }\n  }\n}", "Round_0": {"code": "def count_successful_moves(n, m, commands):\n    max_successful_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = 0\n            x, y = i, j\n\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                successful_moves += 1\n\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = count_successful_moves(n, m, commands)\n    print(start_cell[0], start_cell[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def count_successful_moves(n, m, commands):\n    max_successful_moves = 0\n    start_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = 0\n            x, y = i, j\n\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                successful_moves += 1\n\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                start_cell = (i, j)\n\n    return start_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    start_cell = count_successful_moves(n, m, commands)\n    print(start_cell[0], start_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Iterate through each test case and determine the maximum number of successful moves for each starting cell\",\n    \"Output the coordinates of the cell with the maximum number of successful moves for each test case\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Parse the input data for each test case\",\n    \"Step 2\": \"Iterate through each test case\",\n    \"Step 3\": {\n      \"Substep 1\": \"Initialize a variable to store the maximum number of successful moves\",\n      \"Substep 2\": \"Iterate through each cell in the board\",\n      \"Substep 3\": \"Simulate the robot's movement from the current cell based on the given commands\",\n      \"Substep 4\": \"Count the number of successful moves\",\n      \"Substep 5\": \"Update the maximum number of successful moves if the current cell yields a higher count\",\n      \"Substep 6\": \"Output the coordinates of the cell with the maximum number of successful moves\"\n    }\n  }\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    def count_successful_moves(n, m, s):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n\n        def simulate_move(x, y):\n            successful_moves = 0\n            visited = set()\n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                successful_moves += 1\n                dx, dy = directions[s[successful_moves % len(s)]]\n                x, y = x + dx, y + dy\n            return successful_moves\n\n        max_successful_moves = 0\n        max_cell = (1, 1)\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                successful_moves = simulate_move(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    max_cell = (i, j)\n        return max_cell\n\n    results = []\n    for i in range(t):\n        n, m = test_cases[i][0]\n        s = test_cases[i][1]\n        result = count_successful_moves(n, m, s)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input()\n    test_cases.append((n, m), s)\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 55)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    def count_successful_moves(n, m, s):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n\n        def is_valid_move(x, y):\n            return 0 <= x < n and 0 <= y < m\n\n        def simulate_move(x, y):\n            successful_moves = 0\n            visited = set()\n            while is_valid_move(x, y) and (x, y) not in visited:\n                visited.add((x, y))\n                successful_moves += 1\n                dx, dy = directions[s[successful_moves % len(s)]]\n                x, y = x + dx, y + dy\n            return successful_moves\n\n        max_successful_moves = 0\n        max_cell = (1, 1)\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                successful_moves = simulate_move(i, j)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    max_cell = (i, j)\n        return max_cell\n\n    results = []\n    for i in range(t):\n        n, m = test_cases[i][0]\n        s = test_cases[i][1]\n        result = count_successful_moves(n, m, s)\n        results.append(result)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = input()\n    test_cases.append((n, m), s)\n\n# Output\nresults = find_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the starting cell that maximizes the number of successful moves\",\n    \"Implement a function to simulate the robot's movement based on the given commands\"\n  ],\n  \"high_level_plan\": [\n    \"Parse the input to extract the necessary information for each test case\",\n    \"Create a function to simulate the robot's movement on the board\",\n    \"Iterate through each test case and determine the starting cell that maximizes the number of successful moves\",\n    \"Output the coordinates of the optimal starting cell for each test case\"\n  ]\n}", "Round_0": {"code": "def simulate_robot_movement(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            dx, dy = directions[command]\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y):\n                x, y = new_x, new_y\n                successful_moves += 1\n            else:\n                break\n        return successful_moves, (x, y)\n    \n    max_successful_moves = 0\n    optimal_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            moves, _ = execute_commands(i, j)\n            if moves > max_successful_moves:\n                max_successful_moves = moves\n                optimal_starting_cell = (i, j)\n    \n    return optimal_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    optimal_starting_cell = simulate_robot_movement(n, m, commands)\n    print(optimal_starting_cell[0], optimal_starting_cell[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 44)"}, "Round_1": {"code": "def simulate_robot_movement(n, m, commands):\n    directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n    \n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def execute_commands(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            dx, dy = directions[command]\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y):\n                x, y = new_x, new_y\n                successful_moves += 1\n            else:\n                break\n        return successful_moves, (x, y)\n    \n    max_successful_moves = 0\n    optimal_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            moves, _ = execute_commands(i, j)\n            if moves > max_successful_moves:\n                max_successful_moves = moves\n                optimal_starting_cell = (i, j)\n    \n    return optimal_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    optimal_starting_cell = simulate_robot_movement(n, m, commands)\n    print(optimal_starting_cell[0], optimal_starting_cell[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the starting cell that maximizes the number of successful moves\",\n    \"Calculate the number of successful moves for each starting cell\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": \"For each test case, iterate through each cell on the board\",\n    \"step_4\": \"For each cell, simulate the robot's movement based on the command sequence and calculate the number of successful moves\",\n    \"step_5\": \"Track the starting cell that maximizes the number of successful moves\",\n    \"step_6\": \"Output the coordinates of the cell that maximizes the number of successful moves\"\n  }\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 55)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Iterate through each test case and determine the maximum number of successful moves for each starting cell\",\n    \"Output the coordinates of the cell with the maximum number of successful moves for each test case\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases\",\n    \"For each test case, read the board size and sequence of commands\",\n    \"Iterate through each cell in the board and simulate the robot's movement based on the sequence of commands\",\n    \"Count the number of successful moves for each starting cell\",\n    \"Output the coordinates of the cell with the maximum number of successful moves\"\n  ]\n}", "Round_0": {"code": "def count_successful_moves(n, m, commands):\n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            successful_moves = 0\n\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                successful_moves += 1\n\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n\n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = count_successful_moves(n, m, commands)\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def count_successful_moves(n, m, commands):\n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x, y = i, j\n            successful_moves = 0\n\n            for command in commands:\n                if command == 'L':\n                    y -= 1\n                elif command == 'R':\n                    y += 1\n                elif command == 'U':\n                    x -= 1\n                elif command == 'D':\n                    x += 1\n\n                if x < 1 or x > n or y < 1 or y > m:\n                    break\n                successful_moves += 1\n\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n\n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = count_successful_moves(n, m, commands)\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the starting cell that maximizes the number of successful moves\",\n    \"Implement a function to simulate the robot's movement based on the given commands\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases\",\n    \"For each test case:\",\n    \"   Read the board dimensions and command sequence\",\n    \"   Iterate through each cell in the board to find the starting cell that maximizes successful moves\",\n    \"   Output the coordinates of the starting cell\"\n  ]\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                current_row, current_col = row, col\n                successful_moves = 0\n                \n                for command in commands:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    if current_row < 1 or current_row > n or current_col < 1 or current_col > m:\n                        break\n                    successful_moves += 1\n                \n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(starting_cell[0], starting_cell[1])\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 49)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                current_row, current_col = row, col\n                successful_moves = 0\n                \n                for command in commands:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    if current_row < 1 or current_row > n or current_col < 1 or current_col > m:\n                        break\n                    successful_moves += 1\n                \n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(starting_cell[0], starting_cell[1])\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"Iterate through each test case and determine the starting cell that maximizes the number of successful moves\",\n    \"Calculate the number of successful moves for each starting cell\"\n  ],\n  \"high_level_plan\": {\n    \"step_1\": \"Parse the input to extract the number of test cases, board dimensions, and command sequences\",\n    \"step_2\": \"Iterate through each test case\",\n    \"step_3\": \"For each test case, iterate through each cell on the board\",\n    \"step_4\": \"For each cell, simulate the robot's movement based on the command sequence and calculate the number of successful moves\",\n    \"step_5\": \"Track the starting cell that maximizes the number of successful moves\",\n    \"step_6\": \"Output the coordinates of the cell that maximizes the number of successful moves\"\n  }\n}", "Round_0": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n", "report": "The compilation output of the preceding code is: EOL while scanning string literal (<string>, line 55)"}, "Round_1": {"code": "def find_starting_cell(t, test_cases):\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        \n        max_successful_moves = 0\n        starting_cell = (1, 1)\n        \n        for row in range(1, n+1):\n            for col in range(1, m+1):\n                successful_moves = simulate_robot_movement(n, m, row, col, commands)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    starting_cell = (row, col)\n        \n        print(f\"{starting_cell[0]} {starting_cell[1]}\")\n\ndef simulate_robot_movement(n, m, start_row, start_col, commands):\n    row, col = start_row, start_col\n    successful_moves = 0\n    \n    for command in commands:\n        if command == 'L' and col > 1:\n            col -= 1\n            successful_moves += 1\n        elif command == 'R' and col < m:\n            col += 1\n            successful_moves += 1\n        elif command == 'U' and row > 1:\n            row -= 1\n            successful_moves += 1\n        elif command == 'D' and row < n:\n            row += 1\n            successful_moves += 1\n        else:\n            break\n    \n    return successful_moves\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nfind_starting_cell(t, test_cases)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Simulate the robot's movement on the board based on the given commands\",\n    \"Track the number of successful moves for each starting cell\",\n    \"Find the starting cell that maximizes the number of successful moves\"\n  ],\n  \"high_level_plan\": {\n    \"Step 1\": \"Read the number of test cases\",\n    \"Step 2\": \"For each test case, read the board size and sequence of commands\",\n    \"Step 3\": \"Iterate through all possible starting cells on the board\",\n    \"Step 4\": \"Simulate the robot's movement from each starting cell and count the number of successful moves\",\n    \"Step 5\": \"Find the starting cell with the maximum number of successful moves\",\n    \"Step 6\": \"Output the coordinates of the optimal starting cell for each test case\"\n  }\n}", "Round_0": {"code": "def find_optimal_starting_cell(t, test_cases):\n    def count_successful_moves(n, m, commands, start_row, start_col):\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        successful_moves = 0\n        for command in commands:\n            dr, dc = directions[command]\n            new_row, new_col = start_row + dr, start_col + dc\n            if 1 <= new_row <= n and 1 <= new_col <= m:\n                successful_moves += 1\n                start_row, start_col = new_row, new_col\n        return successful_moves\n\n    results = []\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        max_successful_moves = 0\n        optimal_starting_cell = (1, 1)\n\n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                successful_moves = count_successful_moves(n, m, commands, row, col)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    optimal_starting_cell = (row, col)\n\n        results.append(optimal_starting_cell)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_optimal_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 49)"}, "Round_1": {"code": "def find_optimal_starting_cell(t, test_cases):\n    def count_successful_moves(n, m, commands, start_row, start_col):\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        successful_moves = 0\n        for command in commands:\n            dr, dc = directions[command]\n            new_row, new_col = start_row + dr, start_col + dc\n            if 1 <= new_row <= n and 1 <= new_col <= m:\n                successful_moves += 1\n                start_row, start_col = new_row, new_col\n        return successful_moves\n\n    results = []\n    for i in range(t):\n        n, m = test_cases[i][0]\n        commands = test_cases[i][1]\n        max_successful_moves = 0\n        optimal_starting_cell = (1, 1)\n\n        for row in range(1, n + 1):\n            for col in range(1, m + 1):\n                successful_moves = count_successful_moves(n, m, commands, row, col)\n                if successful_moves > max_successful_moves:\n                    max_successful_moves = successful_moves\n                    optimal_starting_cell = (row, col)\n\n        results.append(optimal_starting_cell)\n\n    return results\n\n# Input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input()\n    test_cases.append(((n, m), commands))\n\n# Output\nresults = find_optimal_starting_cell(t, test_cases)\nfor result in results:\n    print(result[0], result[1])\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input data for each test case\",\n    \"Simulate the robot's movement on the board based on the given commands\",\n    \"Track the number of successful moves for each starting cell\",\n    \"Find the starting cell that maximizes the number of successful moves\"\n  ],\n  \"high_level_plan\": [\n    \"Read the number of test cases\",\n    \"For each test case:\",\n    \"   Read the board size and sequence of commands\",\n    \"   Initialize a variable to track the maximum number of successful moves\",\n    \"   Initialize variables to store the coordinates of the starting cell with the maximum successful moves\",\n    \"   Iterate through each cell on the board:\",\n    \"       Simulate the robot's movement from the current cell based on the commands\",\n    \"       Track the number of successful moves\",\n    \"       Update the maximum number of successful moves and the coordinates of the starting cell if needed\",\n    \"   Output the coordinates of the starting cell with the maximum successful moves\"\n  ]\n}", "Round_0": {"code": "def simulate_robot_movement(n, m, commands):\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def move(x, y, command):\n        if command == 'L':\n            return x, y - 1\n        elif command == 'R':\n            return x, y + 1\n        elif command == 'U':\n            return x - 1, y\n        elif command == 'D':\n            return x + 1, y\n    \n    def count_successful_moves(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            new_x, new_y = move(x, y, command)\n            if is_valid_move(new_x, new_y):\n                successful_moves += 1\n                x, y = new_x, new_y\n            else:\n                break\n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n    \n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = simulate_robot_movement(n, m, commands)\n    print(result[0], result[1])\n", "report": "The compilation output of the preceding code is: invalid syntax (<string>, line 51)"}, "Round_1": {"code": "def simulate_robot_movement(n, m, commands):\n    def is_valid_move(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def move(x, y, command):\n        if command == 'L':\n            return x, y - 1\n        elif command == 'R':\n            return x, y + 1\n        elif command == 'U':\n            return x - 1, y\n        elif command == 'D':\n            return x + 1, y\n    \n    def count_successful_moves(start_x, start_y):\n        x, y = start_x, start_y\n        successful_moves = 0\n        for command in commands:\n            new_x, new_y = move(x, y, command)\n            if is_valid_move(new_x, new_y):\n                successful_moves += 1\n                x, y = new_x, new_y\n            else:\n                break\n        return successful_moves\n    \n    max_successful_moves = 0\n    best_starting_cell = (1, 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            successful_moves = count_successful_moves(i, j)\n            if successful_moves > max_successful_moves:\n                max_successful_moves = successful_moves\n                best_starting_cell = (i, j)\n    \n    return best_starting_cell\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    commands = input().strip()\n    result = simulate_robot_movement(n, m, commands)\n    print(result[0], result[1])\n"}}], "scores": [], "pass_results": [true, true, true, true, false, false, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 11, "prompt": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible. The goal is to find a starting cell that maximizes the number of successful moves.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "add_1_sentence_at_end", "save_node": true, "parent_index": 11}
