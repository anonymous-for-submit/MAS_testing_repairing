{"name": "1607_F. Robot on the Board 2", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nEach cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell \u2014 left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. \n\n  * If the robot moves beyond the edge of the board, it falls and breaks. \n  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). \n\n\n\nRobot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.\n\nDetermine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "tags": ["brute force", "dfs and similar", "dp", "graphs", "implementation"], "difficulty": 12, "id": 1607, "sample_io": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n"]}], "test_list": [{"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nUDUR\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nRUDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRDRR\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 7\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n2 1 7\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 6\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDUD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 1 12\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDLDU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 9\n1 2 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nUUDR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n3 1 5\n4 3 10\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 9\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDULD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nURLL\n\n4 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nDRUU\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n2 1 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nDRRR\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 4\n3 2 5\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n3 1 4\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nDRRR\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n1 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nDDLU\nDUDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n2 2 4\n4 3 10\n1 1 3"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nUDDL\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n1 2 3\n4 3 12\n3 4 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n3 3 6"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n1 1 4\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 4\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n1 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n2 2 4\n4 3 10\n1 2 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n4 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 1 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n1 2 2\n1 2 3\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 6\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 13\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 1 4\n2 1 3\n3 1 6\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nUDLD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 6\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n2 1 7\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n3 1 5\n4 3 9\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nDURU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 2 2\n1 2 3\n2 1 3\n3 1 4\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRDUU\nDURU\nULLR\n\n2 4\nDDLU\nDDUR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n2 2 4\n1 1 5\n2 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n1 2 2\n1 2 3\n3 2 13\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 6\n4 3 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 4\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 2\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n2 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 10\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nDRUU\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n2 1 7\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nRLLU\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n3 1 7\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 4\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nLRR\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 2 2\n1 1 4\n1 1 4\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRLR\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 2\n1 2 2\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nUR\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 2\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nULDD\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n2 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nLLUR\n\n1 4\nDDLU\nDRDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 1 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 2\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n3 1 5\n3 2 6\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nDRRR\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 1 4\n3 1 4\n4 3 9\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nLU\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n2 2 4\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nURLL\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n1 2 3\n4 1 8\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nDU\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 1 4\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDUUR\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nUDDR\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 11\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDDL\n", "output": ["1 1 1\n1 1 3\n2 1 3\n1 2 2\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n3 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDDRU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 2\n2 1 3\n3 1 5\n4 3 12\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nDLDU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n3 2 6\n3 1 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRDR\nRUUD\nUDRU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 9\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nUURD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 10\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nLD\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n2 1 3\n2 1 3\n1 2 3\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nRLLU\n\n4 4\nDDLU\nUDDR\nUUUU\nDDLR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 1 9\n1 3 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nDRUU\nURUD\nRLLU\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n3 2 6\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nLU\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRUDD\nUUUU\nDRLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 4\n4 3 12\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 3 12\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRDR\nRUUD\nURDU\nULRL\n\n4 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n4 2 8\n1 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nUR\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n1 4\nDDLU\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n1 2 2\n3 1 5\n4 3 12\n1 3 2"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nULDD\nURDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n3 2 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n4 3 12\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nUR\n\n4 4\nRRRD\nRUDU\nDURU\nULLR\n\n4 4\nDDLU\nDRDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 3\n2 1 6\n1 3 5"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nUR\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nDUUR\nURUD\nULLR\n\n4 4\nULDD\nRDDU\nUUUU\nDLDR\n", "output": ["1 1 1\n1 1 3\n1 2 3\n2 1 3\n3 1 5\n3 2 6\n3 1 4"]}, {"input": "7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nLD\nUL\nUR\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n2 4\nDDLU\nRUDD\nUUUU\nRDLD\n", "output": ["1 1 1\n1 1 3\n1 1 4\n2 1 3\n1 2 4\n4 3 12\n1 1 4"]}], "task_id": "codecontest/103", "repair_prompt": ["The automaton is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows of the board are labeled from 1 to n from top to bottom, and the columns from 1 to m from left to right, and the robot can transition from its current position to one of the four neighboring cells by side. Each cell contains one of the symbols 'L', 'R', 'D' or 'U', which indicate the robot's direction of movement upon entering that cell \u2014 left, right, down or up, respectively. The robot may commence its journey on any cell, then proceeds to the adjacent square in the direction specified on the current square in one move. If the robot moves past the boundary of the board or lands on a cell it has previously visited, it breaks (it halts and remains stationary). Robot can choose any cell as the starting cell, with the goal to make the maximum number of steps before it breaks or stops. Determine from which square the robot should begin its movement to perform as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Ensure your solution efficiently handles larger board sizes. Consider edge cases where the board might contain only one row or one column.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completion": "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n\nmain()", "completions": ["def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n\nmain()", "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        \n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for direction, (dx, dy) in directions.items():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] == direction:\n                moves = 1 + dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, set())\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] != '#':\n                moves = dfs(new_x, new_y, visited)\n                max_moves = max(max_moves, moves)\n        \n        visited.remove((x, y))\n        return max_moves + 1\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != '#':\n                visited = set()\n                moves = dfs(i, j, visited)\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        \n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n\nmain()", "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n\nmain()", "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n\nmain()", "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for direction, (dx, dy) in directions.items():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] == direction:\n                moves = 1 + dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, set())\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n\nmain()", "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n\nmain()"], "session_history": {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"For each test case, determine the starting cell for the robot to maximize the number of moves it can make without breaking\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n    ],\n    \"high-level-steps\": [\n      \"Parse the input to extract the number of test cases and board information\",\n      \"Iterate through each test case\",\n      \"For each test case, iterate through each cell on the board and calculate the maximum number of moves the robot can make from that cell\",\n      \"Output the starting cell with the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n"}}, "session_historys": [{"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"For each test case, determine the starting cell for the robot to maximize the number of moves it can make without breaking\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n    ],\n    \"high-level-steps\": [\n      \"Parse the input to extract the number of test cases and board information\",\n      \"Iterate through each test case\",\n      \"For each test case, iterate through each cell on the board and calculate the maximum number of moves the robot can make from that cell\",\n      \"Output the starting cell with the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"Implement a function to determine the maximum number of moves the robot can make starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to get the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\",\n      \"Output the cell coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        \n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        \n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"For each test case, determine the starting cell for the robot to maximize the number of moves it can make without breaking\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to get the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"For each test case, iterate through all cells to find the starting cell that maximizes the number of moves\",\n      \"Output the starting cell coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for direction, (dx, dy) in directions.items():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] == direction:\n                moves = 1 + dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, set())\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 49)"}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for direction, (dx, dy) in directions.items():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] == direction:\n                moves = 1 + dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, set())\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"For each test case, determine the starting cell for the robot to maximize the number of moves it can make without breaking\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to get the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"For each test case, iterate through all cells to find the starting cell that maximizes the number of moves\",\n      \"Output the starting cell coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] != '#':\n                moves = dfs(new_x, new_y, visited)\n                max_moves = max(max_moves, moves)\n        \n        visited.remove((x, y))\n        return max_moves + 1\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != '#':\n                visited = set()\n                moves = dfs(i, j, visited)\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for dx, dy in directions.values():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] != '#':\n                moves = dfs(new_x, new_y, visited)\n                max_moves = max(max_moves, moves)\n        \n        visited.remove((x, y))\n        return max_moves + 1\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != '#':\n                visited = set()\n                moves = dfs(i, j, visited)\n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"subproblems\": [\n    \"Parse the input to extract the number of test cases and the board dimensions along with the board layout\",\n    \"For each test case, determine the starting cell for the robot to make the maximum number of moves\",\n    \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n  ],\n  \"high_level_plan\": [\n    \"Read the input to get the number of test cases\",\n    \"For each test case, read the board dimensions and layout\",\n    \"Iterate through each cell in the board and calculate the maximum number of moves the robot can make from that cell\",\n    \"Track the starting cell with the maximum number of moves\",\n    \"Output the starting cell with the maximum number of moves for each test case\"\n  ]\n}", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        \n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        \n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"Implement a function to determine the maximum number of moves the robot can make starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to get the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\",\n      \"Output the cell coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"Implement a function to determine the maximum number of moves the robot can make starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to get the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\",\n      \"Output the cell coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"Implement a function to determine the maximum number of moves the robot can make starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to get the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves starting from a given cell\",\n      \"Iterate through all cells on the board to find the cell with the maximum number of moves\",\n      \"Output the cell coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        \n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j-1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j+1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i-1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i+1, j, visited)\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    \n    r, c, d = get_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"For each test case, determine the starting cell for the robot to maximize the number of moves it can make without breaking\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n    ],\n    \"major_steps\": [\n      \"Read the input to get the number of test cases\",\n      \"For each test case, parse the input to get the board dimensions and layout\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\",\n      \"For each test case, iterate through all cells to find the starting cell that maximizes the number of moves\",\n      \"Output the starting cell coordinates and the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for direction, (dx, dy) in directions.items():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] == direction:\n                moves = 1 + dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, set())\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: closing parenthesis ')' does not match opening parenthesis '[' (<string>, line 49)"}, "Round_1": {"code": "def calculate_moves(board):\n    n = len(board)\n    m = len(board[0])\n    \n    def valid_move(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y, visited):\n        directions = {'L': (0, -1), 'R': (0, 1), 'D': (1, 0), 'U': (-1, 0)}\n        visited.add((x, y))\n        max_moves = 0\n        \n        for direction, (dx, dy) in directions.items():\n            new_x, new_y = x + dx, y + dy\n            if valid_move(new_x, new_y) and (new_x, new_y) not in visited and board[new_x][new_y] == direction:\n                moves = 1 + dfs(new_x, new_y, visited.copy())\n                max_moves = max(max_moves, moves)\n        \n        return max_moves\n    \n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            moves = dfs(i, j, set())\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i+1, j+1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\nfor _ in range(t):\n    input()  # read the blank line\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = calculate_moves(board)\n    print(r, c, d)\n"}}, {"plan": "{\n  \"plan\": {\n    \"subproblems\": [\n      \"Parse the input to extract the number of test cases and the board dimensions along with the board layout for each test case\",\n      \"For each test case, determine the starting cell for the robot to maximize the number of moves it can make without breaking\",\n      \"Implement a function to calculate the maximum number of moves the robot can make from a given starting cell\"\n    ],\n    \"high-level-steps\": [\n      \"Parse the input to extract the number of test cases and board information\",\n      \"Iterate through each test case\",\n      \"For each test case, iterate through each cell on the board and calculate the maximum number of moves the robot can make from that cell\",\n      \"Output the starting cell with the maximum number of moves for each test case\"\n    ]\n  }\n}", "Round_0": {"code": "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n", "report": "The compilation output of the preceding code is: "}, "Round_1": {"code": "def get_max_moves(board):\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        if board[i][j] == 'L':\n            return 1 + dfs(i, j - 1, visited)\n        elif board[i][j] == 'R':\n            return 1 + dfs(i, j + 1, visited)\n        elif board[i][j] == 'U':\n            return 1 + dfs(i - 1, j, visited)\n        elif board[i][j] == 'D':\n            return 1 + dfs(i + 1, j, visited)\n    \n    n, m = len(board), len(board[0])\n    max_moves = 0\n    start_cell = (1, 1)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            moves = dfs(i, j, visited)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nt = int(input())\ninput()  # Skip the first blank line\nfor _ in range(t):\n    n, m = map(int, input().split())\n    board = [input().strip() for _ in range(n)]\n    r, c, d = get_max_moves(board)\n    print(r, c, d)\n"}}], "scores": [], "pass_results": [false, false, true, true, true, false, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 140, "prompt": "The automaton is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns). The rows of the board are labeled from 1 to n from top to bottom, and the columns from 1 to m from left to right, and the robot can transition from its current position to one of the four neighboring cells by side. Each cell contains one of the symbols 'L', 'R', 'D' or 'U', which indicate the robot's direction of movement upon entering that cell \u2014 left, right, down or up, respectively. The robot may commence its journey on any cell, then proceeds to the adjacent square in the direction specified on the current square in one move. If the robot moves past the boundary of the board or lands on a cell it has previously visited, it breaks (it halts and remains stationary). Robot can choose any cell as the starting cell, with the goal to make the maximum number of steps before it breaks or stops. Determine from which square the robot should begin its movement to perform as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board). Ensure your solution efficiently handles larger board sizes. Consider edge cases where the board might contain only one row or one column.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10000) \u2014 the number of test cases in the test.\n\nEach test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 \u2264 n \u2264 2000; 1 \u2264 m \u2264 2000) \u2014 the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.\n\nIt is guaranteed that the sum of sizes of all boards in the input does not exceed 4\u22c510^6.\n\nOutput\n\nFor each test case, output three integers r, c and d (1 \u2264 r \u2264 n; 1 \u2264 c \u2264 m; d \u2265 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.\n\nExample\n\nInput\n\n\n7\n\n1 1\nR\n\n1 3\nRRL\n\n2 2\nDL\nRU\n\n2 2\nUD\nRU\n\n3 2\nDL\nUL\nRU\n\n4 4\nRRRD\nRUUD\nURUD\nULLR\n\n4 4\nDDLU\nRDDU\nUUUU\nRDLD\n\n\nOutput\n\n\n1 1 1\n1 1 3\n1 1 4\n2 1 3\n3 1 5\n4 3 12\n1 1 4", "mutate_method": "rephrase_one", "save_node": false, "parent_index": 71}
