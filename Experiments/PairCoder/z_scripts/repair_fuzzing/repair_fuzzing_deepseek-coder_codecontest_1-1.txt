['\n[NO]']
./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/
Namespace(dataset='codecontest', split_name='test', model='deepseek-coder', solution_file_name='solutions.json', id_range=None, id_list=None, dir_path='results_repair_fuzzing', method='pair_programming', output_path='./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/', input_path='/data/zlyuaj/muti-agent/PairCoder/outputs/results-codecontest_deepseek-coder/codecontest.jsonl', output_file_name='repair_fuzzing_deepseek-coder_codecontest_1-1', num_generate=10, parallel=0, mutate_method='random', num_round=1000, save_seed=1, recover=0, recover_path='', calc_analyst=1, calc_final_result=1, save_all_seed=0, set_threshold_analyst=1, calc_relative_reward=1, clean_mutate_method=1, split_input=1, mutate_level='sentence', alpha=1.0, beta=1, add_monitor=1, repair_plan=1, repair_code=1, run_multi_gen=1, repair_prompt_num=2)
num_problems: 165
len of loaded seeds: 46
----------------------------------------round: 0------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:0
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n. The length of each book title is m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.28282713890075684
final_output reward: 0
total reward: 0.28282713890075684
add mutated seed into prompt node list
seed_index: 0
mutated_seed_index: 46
reward = 0.28282713890075684
saving......
in recording...
len prompt_nodes
47
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 1------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:1
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.2262926697731018
final_output reward: 0
total reward: 0.2262926697731018
add mutated seed into prompt node list
seed_index: 1
mutated_seed_index: 47
reward = 0.2262926697731018
saving......
in recording...
len prompt_nodes
48
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_1.jsonl
----------------------------------------round: 2------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:2
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 



Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. 

The labyrinth's map is structured as a tree, consisting of n rooms numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through these tunnels.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. To travel from room x to room y, a tunnel must exist between these rooms, and the energy required for

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze has n - 1 tunnels connecting rooms, and travel between rooms requires max(|a_x + a_y|, |a_x - a_y|) energy. The maze can alter the illusion rate of any room with queries of type 1, and queries of type 2 ask for the minimum energy needed to reach the treasure in room v from room u.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3452640175819397
final_output reward: 0
total reward: 0.3452640175819397
add mutated seed into prompt node list
seed_index: 2
mutated_seed_index: 48
reward = 0.3452640175819397
saving......
in recording...
len prompt_nodes
49
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 3------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:3
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek has a new game called Dropping Balls. Initially, Mr. Chanek has a grid a of size n × m

Each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move.

  * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); 
  * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); 
  * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). 



Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2. Mr. Chanek will drop k balls sequentially, each starting from the first row, and on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns.

Determine in which column each ball will end up in (position of the ball after leaving the grid).

--------------------------------------------------
Mr. Chanek has a new game called Dropping Balls, and initially, Mr. Chanek has a grid a of size n × m where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move: * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2, and Mr. Chanek will drop k balls sequentially, each starting from the first row, and on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns. Determine in which column each ball will end up in (position of the ball after leaving the grid).

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has developed a fascinating game called Dropping Balls. In this game, Mr. Chanek has created a grid of size n × m, where each cell (x,y) contains an integer a_{x,y} that dictates the direction the ball will take.

The rules are as follows:
  * If a_{x,y} = 1, the ball will move to the right, to the cell (x, y + 1).
  * If a_{x,y} = 2, the ball will move to the bottom, to the cell (x + 

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
multi-gen-prompt:
 Mr. Chanek has a new game called Dropping Balls. Initially, Mr. Chanek has a grid of size n × m, where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move. The ball will move to the right (next cell is (x, y + 1)) if a_{x,y}=1, to the bottom (next cell is (x + 1, y)) if a_{x,y}=2, or to the left (next cell is (x, y - 1)) if a_{x,

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3174355626106262
final_output reward: 0.4
total reward: 0.7174355626106262
add mutated seed into prompt node list
seed_index: 3
mutated_seed_index: 49
reward = 0.7174355626106262
saving......
in recording...
len prompt_nodes
50
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 4------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:4
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You have the option to remove an element from the current sequence and then concatenate the remaining elements. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Your goal is to remove some elements from a to maximize f(a), using zero or more operations. Determine the largest possible value of f(a

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30289459228515625
final_output reward: 0
total reward: 0.30289459228515625
add mutated seed into prompt node list
seed_index: 4
mutated_seed_index: 50
reward = 0.30289459228515625
saving......
in recording...
len prompt_nodes
51
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 5------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:5
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.

There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.

For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.

To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s, and the rest are represented by 0s. The task is to calculate the sum of the squares of the Euclidean distances from each point (x, y) in the grid to the nearest telephone pole. This sum is required for the optimal planning of the housing complex. Specifically, the supervisor wants the value of the double summation ∑_{x=0}^{n} {∑_{y=0}^{m

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor wants the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help by calculating ∑_{x=0}^{n} {∑_{y=0}^{m

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2919345498085022
final_output reward: 0
total reward: 0.2919345498085022
add mutated seed into prompt node list
seed_index: 5
mutated_seed_index: 51
reward = 0.2919345498085022
saving......
in recording...
len prompt_nodes
52
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 6------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:6
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 



Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

  * He can erase one 'A' and one 'B' from anywhere in the string, regardless of whether they are adjacent.
  * He can erase one 'B' and one 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2. Each turn is independent, and Casimir can choose any of the two actions available.

For

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one letter 'A' and exactly one letter 'B' or exactly one letter 'B' and exactly one letter 'C' from the string in each turn. Each turn decreases the length of the string by 2. Determine if there's a sequence of actions that can lead to an empty string.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.46394622325897217
final_output reward: 0.2
total reward: 0.6639462232589721
add mutated seed into prompt node list
seed_index: 6
mutated_seed_index: 52
reward = 0.6639462232589721
saving......
in recording...
len prompt_nodes
53
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 7------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:7
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n].

This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.

Technically, each cyclic shift consists of two consecutive actions: 

  1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 
  2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. 



For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5].

Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element, instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
analyst reward: 0.2896704077720642
final_output reward: 0
total reward: 0.2896704077720642
add mutated seed into prompt node list
seed_index: 7
mutated_seed_index: 53
reward = 0.2896704077720642
saving......
in recording...
len prompt_nodes
54
initial_seed_num
46
[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:46
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 8------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:8
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

--------------------------------------------------
In fact, the problems E1 and E2 do not have much in common, so you should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
In fact, the problems E1 and E2 are quite distinct. It would be wise to treat them as separate entities.

You are provided with an integer array a[1 … n] = [a_1, a_2, …, a_n]. This array needs to be processed by adding its elements to an initially empty double-ended queue (deque). A deque is a data structure that allows elements to be added to both the beginning and the end. 

The sequence of elements from the array is added to the deque one by one, starting with a_1

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
multi-gen-prompt:
 You are given an integer array a[1 … n] = [a_1, a_2, …, a_n]. You need to find the minimal possible number of inversions in a deque after sequentially adding the elements of the array to the deque, starting with a_1 and finishing with a_n, by choosing whether to add each element to the beginning or the end.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
generating with deepseek-coder
----------updating----------
seed 8 finish fuzzing!
seed_index: 8
mutated_seed_index: 54
current seed length: 45
saving......
in recording...
len prompt_nodes
55
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:45
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 9------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:9
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] containing only zeroes and ones. In each step, the array is replaced by a cyclic shift of itself to the right by d cells, where d is the current step number. Each element of the array is then replaced by the result of a logical "AND" operation with its corresponding element in the shifted array. The process continues until the array consists of only zeroes. Determine if the array will eventually become all zeroes and, if so, find the number of steps required for this to happen.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3224778175354004
final_output reward: 0.3
total reward: 0.6224778175354004
add mutated seed into prompt node list
seed_index: 9
mutated_seed_index: 55
reward = 0.6224778175354004
saving......
in recording...
len prompt_nodes
56
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:45
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 10------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:10
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert. 

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.19429802894592285
final_output reward: 0
total reward: 0.19429802894592285
add mutated seed into prompt node list
seed_index: 10
mutated_seed_index: 56
reward = 0.19429802894592285
saving......
in recording...
len prompt_nodes
57
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:45
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 11------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:11
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Kuzya started going to school. He was given math homework in which he was given an array a of length n and an array of symbols b of length n, consisting of symbols '*' and '/'.

Let's denote a path of calculations for a segment [l; r] (1 ≤ l ≤ r ≤ n) in the following way: 

  * Let x=1 initially. For every i from l to r we will consequently do the following: if b_i= '*', x=x*a_i, and if b_i= '/', then x=(x)/(a_i). Let's call a path of calculations for the segment [l; r] a list of all x that we got during the calculations (the number of them is exactly r - l + 1). 



For example, let a=[7, 12, 3, 5, 4, 10, 9], b=[/, *, /, /, /, *, *], l=2, r=6, then the path of calculations for that segment is [12, 4, 0.8, 0.2, 2].

Let's call a segment [l;r] simple if the path of calculations for it contains only integer numbers. 

Kuzya needs to find the number of simple segments [l;r] (1 ≤ l ≤ r ≤ n). Since he obviously has no time and no interest to do the calculations for each option, he asked you to write a program to get to find that number!

--------------------------------------------------
Kuzya started going to school. He was given math homework in which he was given an array a of length n and an array of symbols b of length n, consisting of symbols '*' and '/'.

Let's denote a path of calculations for a segment [l; r] (1 ≤ l ≤ r ≤ n) in the following way: 

  * Let x=1 initially. At first, x will be initialized to 1. For every i from l to r we will consequently do the following: if b_i= '*', x=x*a_i, and if b_i= '/', then x=(x)/(a_i). Let's call a path of calculations for the segment [l; r] a list of all x that we got during the calculations (the number of them is exactly r - l + 1). 

For example, let a=[7, 12, 3, 5, 4, 10, 9], b=[/, *, /, /, /, *, *], l=2, r=6, then the path of calculations for that segment is [12, 4, 0.8, 0.2, 2].

Let's call a segment [l;r] simple if the path of calculations for it contains only integer numbers. 

Kuzya needs to find the number of simple segments [l;r] (1 ≤ l ≤ r ≤ n). Since he obviously has no time and no interest to do the calculations for each option, he asked you to write a program to get to find that number!

Input

The first line contains a single integer n (2 ≤ n ≤ 10^6).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^6).

The third line contains n symbols without spaces between them — the array b_1, b_2 … b_n (b_i= '/' or b_i= '*' for every 1 ≤ i ≤ n).

Output

Print a single integer — the number of simple segments [l;r].

Examples

Input


3
1 2 3
*/*


Output


2


Input


7
6 4 10 1 2 15 1
*/*/*//


Output


8
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Kuzya started going to school. He was given math homework in which he was given an array a of length n and an array of symbols b of length n, consisting of symbols '*' and '/'.

Let's denote a path of calculations for a segment [l; r] (1 ≤ l ≤ r ≤ n) in the following way: 

  * Let x=1 initially. For every i from l to r, we will consequently perform the following operations: if b_i= '*', then x=x*a_i; if b_i= '/', then x

Input

The first line contains a single integer n (2 ≤ n ≤ 10^6).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^6).

The third line contains n symbols without spaces between them — the array b_1, b_2 … b_n (b_i= '/' or b_i= '*' for every 1 ≤ i ≤ n).

Output

Print a single integer — the number of simple segments [l;r].

Examples

Input


3
1 2 3
*/*


Output


2


Input


7
6 4 10 1 2 15 1
*/*/*//


Output


8
multi-gen-prompt:
 Kuzya started going to school. He was given math homework in which he was given an array a of length n and an array of symbols b of length n, consisting of symbols '*' and '/'. Let's denote a path of calculations for a segment [l; r] (1 ≤ l ≤ r ≤ n) in the following way: * Let x=1 initially. For every i from l to r we will consequently do the following: if b_i= '*', x=x*a_i, and if b_i= '/', then x=(x)/(a_i). Let

Input

The first line contains a single integer n (2 ≤ n ≤ 10^6).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^6).

The third line contains n symbols without spaces between them — the array b_1, b_2 … b_n (b_i= '/' or b_i= '*' for every 1 ≤ i ≤ n).

Output

Print a single integer — the number of simple segments [l;r].

Examples

Input


3
1 2 3
*/*


Output


2


Input


7
6 4 10 1 2 15 1
*/*/*//


Output


8
generating with deepseek-coder
----------updating----------
seed 11 finish fuzzing!
seed_index: 11
mutated_seed_index: 57
current seed length: 44
saving......
in recording...
len prompt_nodes
58
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:44
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_11.jsonl
----------------------------------------round: 12------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:12
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.

Every city has an enjoyment value e. Each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled. (In other words, they pay max t over all the roads on which they traveled.) If a vehicle traverses no roads, they pay 0 toll.

Omkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. (Keep in mind that a tour group with v vehicles can travel only on roads with capacity ≥ v.) Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)

In the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.

--------------------------------------------------
Omkar is hosting tours of his country, Omkarland! There are n cities in Omkarland, and, rather curiously, there are exactly n-1 bidirectional roads connecting the cities to each other. It is assured that you can reach any city from any other city through the road network.

Every city has an enjoyment value e. Each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll of any single road on which they traveled. (In other words, they pay max t over all the roads on which they traveled.) If a vehicle traverses no roads, they pay 0 toll.

Omkar has decided to host q tour groups. Each tour group consists of v vehicles starting at city x. (Keep in mind that a tour group with v vehicles can travel only on roads with capacity ≥ v.) Being the tour organizer, Omkar wants his groups to have as much fun as they possibly can, but also must reimburse his groups for the tolls that they have to pay. Thus, for each tour group, Omkar wants to know two things: first, what is the enjoyment value of the city y with maximum enjoyment value that the tour group can reach from their starting city, and second, how much per vehicle will Omkar have to pay to reimburse the entire group for their trip from x to y? (This trip from x to y will always be on the shortest path from x to y.)

In the case that there are multiple reachable cities with the maximum enjoyment value, Omkar will let his tour group choose which one they want to go to. Therefore, to prepare for all possible scenarios, he wants to know the amount of money per vehicle that he needs to guarantee that he can reimburse the group regardless of which city they choose.

Input

The first line contains two integers n and q (2 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ q ≤ 2 ⋅ 10^5), representing the number of cities and the number of groups, respectively.

The next line contains n integers e_1, e_2, …, e_n (1 ≤ e_i ≤ 10^9), where e_i represents the enjoyment value for city i.

The next n-1 lines each contain four integers a, b, c, and t (1 ≤ a,b ≤ n, 1 ≤ c ≤ 10^9, 1 ≤ t ≤ 10^9), representing an road between city a and city b with capacity c and toll t.

The next q lines each contain two integers v and x (1 ≤ v ≤ 10^9, 1 ≤ x ≤ n), representing the number of vehicles in the tour group and the starting city, respectively.

Output

Output q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.

Examples

Input


5 3
2 2 3 3 3
1 2 4 7
1 3 2 8
2 4 8 2
2 5 1 1
1 3
9 5
6 2


Output


3 8
3 0
3 2


Input


5 5
1 2 3 4 5
1 2 4 1
1 3 3 1
1 4 2 1
2 5 1 1
5 1
4 1
3 1
2 1
1 1


Output


1 0
2 1
3 1
4 1
5 1


Input


5 5
1 2 2 2 2
1 2 5 8
1 3 6 3
1 4 4 5
1 5 7 1
4 1
5 1
6 1
7 1
8 1


Output


2 8
2 8
2 3
2 1
1 0

Note

A map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.

<image>

For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.

For the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.

For the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.

A map of the second sample is shown below:

<image>

For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.

For the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.

For the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.

For the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.

For the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Omkar is organizing tours of his country, Omkarland! There are n cities in Omkarland, and there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.

Each city has an enjoyment value e. Each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll

Input

The first line contains two integers n and q (2 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ q ≤ 2 ⋅ 10^5), representing the number of cities and the number of groups, respectively.

The next line contains n integers e_1, e_2, …, e_n (1 ≤ e_i ≤ 10^9), where e_i represents the enjoyment value for city i.

The next n-1 lines each contain four integers a, b, c, and t (1 ≤ a,b ≤ n, 1 ≤ c ≤ 10^9, 1 ≤ t ≤ 10^9), representing an road between city a and city b with capacity c and toll t.

The next q lines each contain two integers v and x (1 ≤ v ≤ 10^9, 1 ≤ x ≤ n), representing the number of vehicles in the tour group and the starting city, respectively.

Output

Output q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.

Examples

Input


5 3
2 2 3 3 3
1 2 4 7
1 3 2 8
2 4 8 2
2 5 1 1
1 3
9 5
6 2


Output


3 8
3 0
3 2


Input


5 5
1 2 3 4 5
1 2 4 1
1 3 3 1
1 4 2 1
2 5 1 1
5 1
4 1
3 1
2 1
1 1


Output


1 0
2 1
3 1
4 1
5 1


Input


5 5
1 2 2 2 2
1 2 5 8
1 3 6 3
1 4 4 5
1 5 7 1
4 1
5 1
6 1
7 1
8 1


Output


2 8
2 8
2 3
2 1
1 0

Note

A map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.

<image>

For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.

For the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.

For the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.

A map of the second sample is shown below:

<image>

For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.

For the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.

For the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.

For the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.

For the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.
multi-gen-prompt:
 Omkar is hosting tours of his country, Omkarland, with n cities and n-1 bidirectional roads. Each city has an enjoyment value e, and each road has a capacity c and a toll t. Omkar will host q tour groups with v vehicles starting at city x, and he needs to know the maximum enjoyment value city y reachable from x, and the toll per vehicle for the trip from x to y, considering the highest toll on any road traveled. If multiple cities have the same maximum enjoyment value, Omkar allows the tour group to choose. Omkar needs to prepare for all scenarios by

Input

The first line contains two integers n and q (2 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ q ≤ 2 ⋅ 10^5), representing the number of cities and the number of groups, respectively.

The next line contains n integers e_1, e_2, …, e_n (1 ≤ e_i ≤ 10^9), where e_i represents the enjoyment value for city i.

The next n-1 lines each contain four integers a, b, c, and t (1 ≤ a,b ≤ n, 1 ≤ c ≤ 10^9, 1 ≤ t ≤ 10^9), representing an road between city a and city b with capacity c and toll t.

The next q lines each contain two integers v and x (1 ≤ v ≤ 10^9, 1 ≤ x ≤ n), representing the number of vehicles in the tour group and the starting city, respectively.

Output

Output q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.

Examples

Input


5 3
2 2 3 3 3
1 2 4 7
1 3 2 8
2 4 8 2
2 5 1 1
1 3
9 5
6 2


Output


3 8
3 0
3 2


Input


5 5
1 2 3 4 5
1 2 4 1
1 3 3 1
1 4 2 1
2 5 1 1
5 1
4 1
3 1
2 1
1 1


Output


1 0
2 1
3 1
4 1
5 1


Input


5 5
1 2 2 2 2
1 2 5 8
1 3 6 3
1 4 4 5
1 5 7 1
4 1
5 1
6 1
7 1
8 1


Output


2 8
2 8
2 3
2 1
1 0

Note

A map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.

<image>

For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.

For the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.

For the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.

A map of the second sample is shown below:

<image>

For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.

For the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.

For the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.

For the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.

For the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.
generating with deepseek-coder
----------updating----------
seed 12 finish fuzzing!
seed_index: 12
mutated_seed_index: 58
current seed length: 43
saving......
in recording...
len prompt_nodes
59
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 13------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:13
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two days in a row, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 



At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it. You are given n days from Petya's life and you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days during which you need to track the growth and well-being of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes without water for two consecutive days, it will wither and die. 
  * Each day the flower is watered, it will grow by 1 centimeter. 
  * If the flower is watered on both the i-th and

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.29880279302597046
final_output reward: 0.5
total reward: 0.7988027930259705
add mutated seed into prompt node list
seed_index: 13
mutated_seed_index: 59
reward = 0.7988027930259705
saving......
in recording...
len prompt_nodes
60
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 14------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:14
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.

--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.26969361305236816
final_output reward: 0
total reward: 0.26969361305236816
add mutated seed into prompt node list
seed_index: 14
mutated_seed_index: 60
reward = 0.26969361305236816
saving......
in recording...
len prompt_nodes
61
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 15------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:15
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.

Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that only consists of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of different non-negative powers of a given number \( n \). For instance, when \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your help to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, and output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.27479004859924316
final_output reward: 0.2
total reward: 0.4747900485992432
add mutated seed into prompt node list
seed_index: 15
mutated_seed_index: 61
reward = 0.4747900485992432
saving......
in recording...
len prompt_nodes
62
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 16------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:16
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column. The character can move to nearby cells, either next to each other or by going a little corner. But, if the cell has a trap, Monocarp's character will die, and the game will end. To win the level, Monocarp's character must reach the end, which is in the second row and the nth column. Can

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner, but cannot go outside the grid. The goal is to reach (2, n) without landing in a trap cell. Determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.45018649101257324
final_output reward: 0.2
total reward: 0.6501864910125732
add mutated seed into prompt node list
seed_index: 16
mutated_seed_index: 62
reward = 0.6501864910125732
saving......
in recording...
len prompt_nodes
63
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 17------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:17
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

--------------------------------------------------
Monocarp has obtained an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The average value of an array containing n elements is calculated as the total of the elements divided by their count (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements is denoted as k, which is the sum of all elements divided by n. The mean of an array is calculated by adding all the elements and then dividing by the number of elements. Monocarp wants to remove exactly two elements from the array a so that the mean of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i is less than j) such that if the elements at these positions are removed, the mean of the remaining (n

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30008959770202637
final_output reward: 0.1
total reward: 0.40008959770202634
add mutated seed into prompt node list
seed_index: 17
mutated_seed_index: 63
reward = 0.40008959770202634
saving......
in recording...
len prompt_nodes
64
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 18------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:18
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.

Monocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.

Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):

  * the topics of all three selected problems are different; 
  * the difficulties of all three selected problems are different. 



Your task is to determine the number of ways to select three problems for the problemset.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.

Monocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.

Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):

  * the topics of all three selected problems are different; 
  * the difficulties of all three selected problems are different. 



Your task is to determine the number of ways to select three problems for the problemset.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has compiled a diverse set of n problems for an upcoming training session. Each problem is unique, featuring a specific topic (ranging from 1 to n) and a particular difficulty level (also from 1 to n).

To ensure a balanced and engaging problemset, Monocarp plans to choose exactly 3 problems from these n available problems. The selection must adhere to at least one of the following criteria:

1. The topics of the three selected problems are all distinct.
2. The difficulties of the three selected problems are all distinct

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, needs to compose a problemset for a training session. He has n problems, each with a unique topic a_i (integer from 1 to n) and difficulty b_i (integer from 1 to n). He must select exactly 3 problems for the problemset, ensuring that at least one of the following conditions is met:

  * the topics of all three selected problems are different; 
  * the difficulties of all three selected problems are different. 

Determine the number of ways to select these three problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.4383111000061035
final_output reward: 0
total reward: 0.4383111000061035
add mutated seed into prompt node list
seed_index: 18
mutated_seed_index: 64
reward = 0.4383111000061035
saving......
in recording...
len prompt_nodes
65
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 19------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:19
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. A party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.31146472692489624
final_output reward: 0
total reward: 0.31146472692489624
add mutated seed into prompt node list
seed_index: 19
mutated_seed_index: 65
reward = 0.31146472692489624
saving......
in recording...
len prompt_nodes
66
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 20------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:20
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in it's binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on it's edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot, and your mission is to construct factory facilities. However, before you begin, you need to determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will receive N lines, each containing M numbers. These numbers represent the factory tiles, and they range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating the dimensions of a factory construction in rectangle shape: N x M. The data consists of N lines, each containing M numbers representing factory tiles. These numbers range from 0 to 15 and each can be interpreted in binary form to indicate the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is correct. Your task is to print the sizes of the rooms in the factory from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.36318743228912354
final_output reward: 0.3
total reward: 0.6631874322891236
add mutated seed into prompt node list
seed_index: 20
mutated_seed_index: 66
reward = 0.6631874322891236
saving......
in recording...
len prompt_nodes
67
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 21------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:21
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given array a_1, a_2, …, a_n, consisting of non-negative integers.

Let's define operation of "elimination" with integer parameter k (1 ≤ k ≤ n) as follows:

  * Choose k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. 
  * Calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, where \& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND) (notes section contains formal definition). 
  * Subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}; all other elements remain untouched. 



Find all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.

Note that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.

--------------------------------------------------
You are given array a_1, a_2, …, a_n, consisting of non-negative integers.

Let's define operation of "elimination" with integer parameter k (1 ≤ k ≤ n) as follows:

  * Choose k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. 
  * Calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, where \& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). The bitwise AND operation is a binary operation that takes two equal-length binary representations and performs the logical AND operation on each pair of the corresponding bits.
  * Subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}; all other elements remain untouched. 

Find all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.

Note that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, which consists of non-negative integers. The operation of "elimination" is defined with an integer parameter k (1 ≤ k ≤ n). This operation involves the following steps:

1. Choose k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n.
2. Calculate x = a_{i_1} & a_{i_2} & … & a_{i_k}, where & denotes the bitwise AND operation.


Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, consisting of non-negative integers. Let's define the "elimination" operation with an integer parameter k (1 ≤ k ≤ n) as follows: choose k distinct array indices and calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, then subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}; all other elements remain untouched. Find all possible

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
generating with deepseek-coder
----------updating----------
analyst reward: 0.37003612518310547
final_output reward: 0.2
total reward: 0.5700361251831054
add mutated seed into prompt node list
seed_index: 21
mutated_seed_index: 67
reward = 0.5700361251831054
saving......
in recording...
len prompt_nodes
68
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_21.jsonl
----------------------------------------round: 22------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:22
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k). 

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) denotes the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum of the sum ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.34092676639556885
final_output reward: 0.3
total reward: 0.6409267663955689
add mutated seed into prompt node list
seed_index: 22
mutated_seed_index: 68
reward = 0.6409267663955689
saving......
in recording...
len prompt_nodes
69
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:43
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 23------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:23
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Shohag has an integer sequence a_1, a_2, …, a_n. He can perform the following operation any number of times (possibly, zero):

  * Select any positive integer k (it can be different in different operations). 
  * Choose any position in the sequence (possibly the beginning or end of the sequence, or in between any two elements) and insert k into the sequence at this position. 
  * This way, the sequence a changes, and the next operation is performed on this changed sequence. 



For example, if a=[3,3,4] and he selects k = 2, then after the operation he can obtain one of the sequences [\underline{2},3,3,4], [3,\underline{2},3,4], [3,3,\underline{2},4], or [3,3,4,\underline{2}].

Shohag wants this sequence to satisfy the following condition: for each 1 ≤ i ≤ |a|, a_i ≤ i. Here, |a| denotes the size of a.

Help him to find the minimum number of operations that he has to perform to achieve this goal. We can show that under the constraints of the problem it's always possible to achieve this goal in a finite number of operations.

--------------------------------------------------
Shohag has an integer sequence a_1, a_2, …, a_n. He can perform the following operation any number of times (possibly, zero):

  * Select any positive integer k (it can be different in different operations). 
  * Choose any position in the sequence (possibly the beginning or end of the sequence, or in between any two elements) and insert k into the sequence at this position. 
  * This way, the sequence a changes, and the next operation is performed on this changed sequence. 

For example, if a=[3,3,4] and he selects k = 2, then after the operation he can obtain one of the sequences [\underline{2},3,3,4], [3,\underline{2},3,4], [3,3,\underline{2},4], or [3,3,4,\underline{2}].

Shohag wants this sequence to satisfy the following condition: for each 1 ≤ i ≤ |a|, a_i ≤ i. Here, |a| denotes the size of a.

Help him to find the minimum number of operations that he has to perform to achieve this goal. We can show that under the constraints of the problem it's always possible to achieve this goal in a finite number of operations. Assume that Shohag can modify the sequence as needed using the defined operations.

Input

The first line contains a single integer t (1 ≤ t ≤ 200) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the initial length of the sequence.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) — the elements of the sequence.

Output

For each test case, print a single integer — the minimum number of operations needed to perform to achieve the goal mentioned in the statement.

Example

Input


4
3
1 3 4
5
1 2 5 7 4
1
1
3
69 6969 696969


Output


1
3
0
696966

Note

In the first test case, we have to perform at least one operation, as a_2=3>2. We can perform the operation [1, 3, 4] → [1, \underline{2}, 3, 4] (the newly inserted element is underlined), now the condition is satisfied.

In the second test case, Shohag can perform the following operations:

[1, 2, 5, 7, 4] → [1, 2, \underline{3}, 5, 7, 4] → [1, 2, 3, \underline{4}, 5, 7, 4] → [1, 2, 3, 4, 5, \underline{3}, 7, 4].

In the third test case, the sequence already satisfies the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Shohag has a sequence of integers a_1, a_2, …, a_n. He can perform the operation multiple times, where in each operation, he selects a positive integer k and inserts it at any position in the sequence, which can be at the beginning, end, or between elements. This operation changes the sequence, and the next operation is performed on the updated sequence.

Shohag wants the sequence to meet the condition that for every 1 ≤ i ≤ |a|, a_i ≤ i. Here, |a| represents the size of the sequence.



Input

The first line contains a single integer t (1 ≤ t ≤ 200) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the initial length of the sequence.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) — the elements of the sequence.

Output

For each test case, print a single integer — the minimum number of operations needed to perform to achieve the goal mentioned in the statement.

Example

Input


4
3
1 3 4
5
1 2 5 7 4
1
1
3
69 6969 696969


Output


1
3
0
696966

Note

In the first test case, we have to perform at least one operation, as a_2=3>2. We can perform the operation [1, 3, 4] → [1, \underline{2}, 3, 4] (the newly inserted element is underlined), now the condition is satisfied.

In the second test case, Shohag can perform the following operations:

[1, 2, 5, 7, 4] → [1, 2, \underline{3}, 5, 7, 4] → [1, 2, 3, \underline{4}, 5, 7, 4] → [1, 2, 3, 4, 5, \underline{3}, 7, 4].

In the third test case, the sequence already satisfies the condition.
multi-gen-prompt:
 Shohag has an integer sequence a_1, a_2, …, a_n. He can perform the following operation any number of times: select any positive integer k and choose any position to insert k into the sequence, changing the sequence each time. He wants the sequence to satisfy a_i ≤ i for each 1 ≤ i ≤ |a|. Help him find the minimum number of operations to achieve this goal.

Input

The first line contains a single integer t (1 ≤ t ≤ 200) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the initial length of the sequence.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) — the elements of the sequence.

Output

For each test case, print a single integer — the minimum number of operations needed to perform to achieve the goal mentioned in the statement.

Example

Input


4
3
1 3 4
5
1 2 5 7 4
1
1
3
69 6969 696969


Output


1
3
0
696966

Note

In the first test case, we have to perform at least one operation, as a_2=3>2. We can perform the operation [1, 3, 4] → [1, \underline{2}, 3, 4] (the newly inserted element is underlined), now the condition is satisfied.

In the second test case, Shohag can perform the following operations:

[1, 2, 5, 7, 4] → [1, 2, \underline{3}, 5, 7, 4] → [1, 2, 3, \underline{4}, 5, 7, 4] → [1, 2, 3, 4, 5, \underline{3}, 7, 4].

In the third test case, the sequence already satisfies the condition.
generating with deepseek-coder
----------updating----------
seed 23 finish fuzzing!
seed_index: 23
mutated_seed_index: 69
current seed length: 42
saving......
in recording...
len prompt_nodes
70
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:42
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 24------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:24
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of integers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive subarrays, where each element of the original sequence belongs to exactly one subarray. Let k represent the number of resulting subarrays, and h_1, h_2, …, h_k denote the lengths of the longest increasing subsequences of the respective subarrays.

For instance, if the sequence is [2, 5, 3, 1, 4, 3, 2, 2, 5,

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence a such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS)

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2890773415565491
final_output reward: 0
total reward: 0.2890773415565491
add mutated seed into prompt node list
seed_index: 24
mutated_seed_index: 70
reward = 0.2890773415565491
saving......
in recording...
len prompt_nodes
71
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:42
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 25------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:25
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa.

--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2818436026573181
final_output reward: 0
total reward: 0.2818436026573181
add mutated seed into prompt node list
seed_index: 25
mutated_seed_index: 71
reward = 0.2818436026573181
saving......
in recording...
len prompt_nodes
72
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:42
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 26------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:26
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a matrix, consisting of n rows and m columns. The j-th cell of the i-th row contains an integer a_{ij}.

First, you have to color each row of the matrix either red or blue in such a way that at least one row is colored red and at least one row is colored blue.

Then, you have to choose an integer k (1 ≤ k < m) and cut the colored matrix in such a way that the first k columns become a separate matrix (the left matrix) and the last m-k columns become a separate matrix (the right matrix).

The coloring and the cut are called perfect if two properties hold: 

  * every red cell in the left matrix contains an integer greater than every blue cell in the left matrix; 
  * every blue cell in the right matrix contains an integer greater than every red cell in the right matrix. 



Find any perfect coloring and cut, or report that there are none.

--------------------------------------------------
You are provided with a matrix, made up of n rows and m columns. The integer in the j-th cell of the i-th row is a_{ij}.

First, you have to color each row of the matrix either red or blue in such a way that at least one row is colored red and at least one row is colored blue.

Then, you need to select an integer k (1 ≤ k < m) and divide the colored matrix so that the first k columns form a separate matrix (the left matrix) and the last m-k columns form another separate matrix (the right matrix).

The coloring and the cut are named perfect if two properties are satisfied:

  * every red cell in the left matrix contains an integer that is larger than every blue cell in the left matrix;
  * every blue cell in the right matrix contains an integer that is larger than every red cell in the right matrix.

Find any perfect coloring and cut, or report that there are none.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains two integers n and m (2 ≤ n, m ≤ 5 ⋅ 10^5; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the matrix, respectively.

The i-th of the next n lines contains m integers a_{i1}, a_{i2}, ..., a_{im} (1 ≤ a_{ij} ≤ 10^6).

The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print "NO".

Otherwise, first, print "YES". Then a string, consisting of n characters: the i-th character should be 'R' if the i-th row is colored red and 'B' if it's colored blue. The string should contain at least one 'R' and at least one 'B'. Finally, print an integer k (1 ≤ k < m) — the number of columns from the left that are cut.

Example

Input


3
5 5
1 5 8 8 7
5 2 1 4 3
1 6 9 7 5
9 3 3 3 2
1 7 9 9 8
3 3
8 9 8
1 5 3
7 5 7
2 6
3 3 3 2 2 2
1 1 1 4 4 4


Output


YES
BRBRB 1
NO
YES
RB 3

Note

The coloring and the cut for the first testcase:

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a matrix with n rows and m columns. Each cell in the matrix contains an integer, denoted as a_{ij}, where i represents the row index and j represents the column index.

First, you need to color each row of the matrix either red or blue. Your goal is to ensure that at least one row is colored red and at least one row is colored blue.

Next, you must choose an integer k (where 1 ≤ k < m) and cut the matrix along this column. The first k columns will form the left matrix, and the remaining m-k columns will form the

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains two integers n and m (2 ≤ n, m ≤ 5 ⋅ 10^5; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the matrix, respectively.

The i-th of the next n lines contains m integers a_{i1}, a_{i2}, ..., a_{im} (1 ≤ a_{ij} ≤ 10^6).

The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print "NO".

Otherwise, first, print "YES". Then a string, consisting of n characters: the i-th character should be 'R' if the i-th row is colored red and 'B' if it's colored blue. The string should contain at least one 'R' and at least one 'B'. Finally, print an integer k (1 ≤ k < m) — the number of columns from the left that are cut.

Example

Input


3
5 5
1 5 8 8 7
5 2 1 4 3
1 6 9 7 5
9 3 3 3 2
1 7 9 9 8
3 3
8 9 8
1 5 3
7 5 7
2 6
3 3 3 2 2 2
1 1 1 4 4 4


Output


YES
BRBRB 1
NO
YES
RB 3

Note

The coloring and the cut for the first testcase:

<image>
multi-gen-prompt:
 You are given a matrix with n rows and m columns, where the cell in the j-th column of the i-th row contains the integer a_{ij}. You need to color each row either red or blue such that at least one row is red and at least one row is blue. Then, choose an integer k (1 ≤ k < m) to cut the matrix, making the first k columns the left matrix and the last m-k columns the right matrix. The coloring and cut are perfect if every red cell in the left matrix has a value greater than every blue cell in the left matrix, and every blue

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains two integers n and m (2 ≤ n, m ≤ 5 ⋅ 10^5; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the matrix, respectively.

The i-th of the next n lines contains m integers a_{i1}, a_{i2}, ..., a_{im} (1 ≤ a_{ij} ≤ 10^6).

The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print "NO".

Otherwise, first, print "YES". Then a string, consisting of n characters: the i-th character should be 'R' if the i-th row is colored red and 'B' if it's colored blue. The string should contain at least one 'R' and at least one 'B'. Finally, print an integer k (1 ≤ k < m) — the number of columns from the left that are cut.

Example

Input


3
5 5
1 5 8 8 7
5 2 1 4 3
1 6 9 7 5
9 3 3 3 2
1 7 9 9 8
3 3
8 9 8
1 5 3
7 5 7
2 6
3 3 3 2 2 2
1 1 1 4 4 4


Output


YES
BRBRB 1
NO
YES
RB 3

Note

The coloring and the cut for the first testcase:

<image>
generating with deepseek-coder
----------updating----------
seed 26 finish fuzzing!
seed_index: 26
mutated_seed_index: 72
current seed length: 41
saving......
in recording...
len prompt_nodes
73
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:41
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 27------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:27
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from left to right). No time is spent on pressing the keys and on placing your hand over the first letter of the word.

For example, consider a keyboard where the letters from 'a' to 'z' are arranged in consecutive alphabetical order. The letters 'h', 'e', 'l' and 'o' then are on the positions 8, 5, 12 and 15, respectively. Therefore, it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". 

Determine how long it will take to print the word s.

--------------------------------------------------
You are given a keyboard that consists of 26 keys, and the keys are arranged sequentially in one row in a certain order, each corresponding to a unique lowercase Latin letter. You have to type the word s on this keyboard, which also consists only of lowercase Latin letters.

To type a word consecutively one by one, each letter must be typed over the corresponding key and pressed. Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys, with no time spent on pressing the keys and on placing your hand over the first letter of the word.

For example, consider a keyboard where the letters from 'a' to 'z' are arranged in consecutive alphabetical order. The letters 'h', 'e', 'l', and 'o' then are on the positions 8, 5, 12, and 15, respectively, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". 

Determine how long it will take to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the time required to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
----------updating----------
analyst reward: 0.3393946886062622
final_output reward: 0
total reward: 0.3393946886062622
add mutated seed into prompt node list
seed_index: 27
mutated_seed_index: 73
reward = 0.3393946886062622
saving......
in recording...
len prompt_nodes
74
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:41
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 28------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:28
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same. 

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 



Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once.

--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 

Situations in which there are no elements of some color at all are also possible. For example,

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same. Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1; or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
generating with deepseek-coder
----------updating----------
analyst reward: 0.345209538936615
final_output reward: 0
total reward: 0.345209538936615
add mutated seed into prompt node list
seed_index: 28
mutated_seed_index: 74
reward = 0.345209538936615
saving......
in recording...
len prompt_nodes
75
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:41
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 29------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:29
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

--------------------------------------------------
The robot must maximize the number of commands executed without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts executing the commands from the first

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order given. If the robot moves beyond the edge of the board, it falls and breaks. Determine the cell from which the robot should start its movement to execute the most commands without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.23241329193115234
final_output reward: 0.1
total reward: 0.3324132919311523
add mutated seed into prompt node list
seed_index: 29
mutated_seed_index: 75
reward = 0.3324132919311523
saving......
in recording...
len prompt_nodes
76
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:41
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 30------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:30
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively.

The robot can start its movement in any cell. He then moves to the adjacent square in the direction indicated on the current square in one move. 

  * If the robot moves beyond the edge of the board, it falls and breaks. 
  * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). 



Robot can choose any cell as the starting cell. Its goal is to make the maximum number of steps before it breaks or stops.

Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns), with rows numbered 1 to n from top to bottom and columns numbered 1 to m from left to right. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell and moves to the adjacent square in the direction indicated on the current square in one move. * If the robot moves beyond the edge of the board, it falls and breaks. * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n, and the columns from 1 to m, both from top to bottom and left to right, respectively.

The robot can move to adjacent cells based on the symbols written on the current cell. These symbols indicate the direction of movement: 'L' for left, 'R' for right, 'D' for down, and 'U' for up.

The robot starts its movement from any cell on the board. It moves to the adjacent cell in the direction

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
generating with deepseek-coder
----------updating----------
analyst reward: 0.40276360511779785
final_output reward: 0
total reward: 0.40276360511779785
add mutated seed into prompt node list
seed_index: 30
mutated_seed_index: 76
reward = 0.40276360511779785
saving......
in recording...
len prompt_nodes
77
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:41
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 31------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:31
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … <a_n

  * For every i from 2 to n, a_i isn't divisible by a_{i-1}




It can be shown that such an array always exists under the constraints of the problem.

--------------------------------------------------
Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … <a_n, and for every i from 2 to n, a_i isn't divisible by a_{i-1}

It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … < a_n

  * For every i from 2 to n, a_i isn't divisible by a_{i-1}

It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
multi-gen-prompt:
 Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 1 ≤ a_i ≤ 10^9 for every i from 1 to n, a_1 < a_2 < … < a_n, and for every i from 2 to n, a_i isn't divisible by a_{i-1}. It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
generating with deepseek-coder
----------updating----------
analyst reward: 0.36834025382995605
final_output reward: 0
total reward: 0.36834025382995605
add mutated seed into prompt node list
seed_index: 31
mutated_seed_index: 77
reward = 0.36834025382995605
saving......
in recording...
len prompt_nodes
78
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:41
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_31.jsonl
----------------------------------------round: 32------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:32
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given m strings and a tree on n nodes. Each edge has some letter written on it.

You have to answer q queries. Each query is described by 4 integers u, v, l and r. The answer to the query is the total number of occurrences of str(u,v) in strings with indices from l to r. str(u,v) is defined as the string that is made by concatenating letters written on the edges on the shortest path from u to v (in order that they are traversed).

--------------------------------------------------
You need to respond to q queries. Each query is defined by 4 integers u, v, l, and r. The answer to the query is the total number of times str(u,v) appears in strings with indices from l to r. str(u,v) is defined as the string that is created by joining letters written on the edges along the shortest path from u to v (following the order they are crossed).

Input

The first line of the input contains three integers n, m and q (2 ≤ n ≤ 10^5, 1 ≤ m,q ≤ 10^5).

The i-th of the following n-1 lines contains two integers u_i, v_i and a lowercase Latin letter c_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i), denoting the edge between nodes u_i, v_i with a character c_i on it. 

It's guaranteed that these edges form a tree.

The following m lines contain the strings consisting of lowercase Latin letters. The total length of those strings does not exceed 10^5.

Then q lines follow, each containing four integers u, v, l and r (1 ≤ u,v ≤ n, u ≠ v, 1 ≤ l ≤ r ≤ m), denoting the queries. 

Output

For each query print a single integer — the answer to the query.

Examples

Input


2 5 3
1 2 a
aab
abab
aaa
b
a
2 1 1 5
1 2 1 3
2 1 3 5


Output


8
7
4


Input


9 5 6
1 2 a
2 7 c
1 3 b
3 4 b
4 6 b
3 5 a
5 8 b
5 9 c
ababa
cabbb
bac
bbbac
abacaba
2 7 1 4
2 5 1 5
6 3 4 4
6 9 4 5
5 7 3 5
5 3 1 5


Output


3
4
2
1
1
10
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a set of m strings and a tree structure consisting of n nodes. Each edge in the tree is labeled with a specific letter. Your task involves processing q queries, where each query is defined by four integers: u, v, l, and r. The term str(u,v) refers to the string formed by concatenating the letters found on the edges of the shortest path from node u to node v, in the order they are encountered during the traversal.

The objective is to determine the total number of occurrences of str(u,v) within the specified range of strings, where the strings are

Input

The first line of the input contains three integers n, m and q (2 ≤ n ≤ 10^5, 1 ≤ m,q ≤ 10^5).

The i-th of the following n-1 lines contains two integers u_i, v_i and a lowercase Latin letter c_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i), denoting the edge between nodes u_i, v_i with a character c_i on it. 

It's guaranteed that these edges form a tree.

The following m lines contain the strings consisting of lowercase Latin letters. The total length of those strings does not exceed 10^5.

Then q lines follow, each containing four integers u, v, l and r (1 ≤ u,v ≤ n, u ≠ v, 1 ≤ l ≤ r ≤ m), denoting the queries. 

Output

For each query print a single integer — the answer to the query.

Examples

Input


2 5 3
1 2 a
aab
abab
aaa
b
a
2 1 1 5
1 2 1 3
2 1 3 5


Output


8
7
4


Input


9 5 6
1 2 a
2 7 c
1 3 b
3 4 b
4 6 b
3 5 a
5 8 b
5 9 c
ababa
cabbb
bac
bbbac
abacaba
2 7 1 4
2 5 1 5
6 3 4 4
6 9 4 5
5 7 3 5
5 3 1 5


Output


3
4
2
1
1
10
multi-gen-prompt:
 You are provided with m strings and a tree with n nodes, where each edge has a specific letter. You need to address q queries, each specified by four integers u, v, l, and r. The answer to each query is the total count of occurrences of str(u,v) within the strings from index l to r. The string str(u,v) is constructed by concatenating the letters from the edges along the shortest path from node u to node v.

Input

The first line of the input contains three integers n, m and q (2 ≤ n ≤ 10^5, 1 ≤ m,q ≤ 10^5).

The i-th of the following n-1 lines contains two integers u_i, v_i and a lowercase Latin letter c_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i), denoting the edge between nodes u_i, v_i with a character c_i on it. 

It's guaranteed that these edges form a tree.

The following m lines contain the strings consisting of lowercase Latin letters. The total length of those strings does not exceed 10^5.

Then q lines follow, each containing four integers u, v, l and r (1 ≤ u,v ≤ n, u ≠ v, 1 ≤ l ≤ r ≤ m), denoting the queries. 

Output

For each query print a single integer — the answer to the query.

Examples

Input


2 5 3
1 2 a
aab
abab
aaa
b
a
2 1 1 5
1 2 1 3
2 1 3 5


Output


8
7
4


Input


9 5 6
1 2 a
2 7 c
1 3 b
3 4 b
4 6 b
3 5 a
5 8 b
5 9 c
ababa
cabbb
bac
bbbac
abacaba
2 7 1 4
2 5 1 5
6 3 4 4
6 9 4 5
5 7 3 5
5 3 1 5


Output


3
4
2
1
1
10
generating with deepseek-coder
----------updating----------
seed 32 finish fuzzing!
seed_index: 32
mutated_seed_index: 78
current seed length: 40
saving......
in recording...
len prompt_nodes
79
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:40
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 33------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:33
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.29318535327911377
final_output reward: 0
total reward: 0.29318535327911377
add mutated seed into prompt node list
seed_index: 33
mutated_seed_index: 79
reward = 0.29318535327911377
saving......
in recording...
len prompt_nodes
80
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:40
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 34------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:34
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:

  * Choose two indices i and j (1 ≤ i, j ≤ n; i ≠ j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. 



You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). 

What's the minimum possible ugliness you can achieve, after any number of days?

--------------------------------------------------
There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In one day, you are allowed to do the following action:

  * Pick two indices i and j (1 ≤ i, j ≤ n; i ≠ j), and transfer a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. 

You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). 

What's the minimum possible ugliness you can achieve, after any number of days?

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases. Then t cases follow.

The first line of each test case contains one integer n (2 ≤ n ≤ 100) — the number of buildings.

The second line of each test case contains n space separated integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^7) — the heights of the buildings.

Output

For each test case, output a single integer — the minimum possible ugliness of the buildings.

Example

Input


3
3
10 10 10
4
3 2 1 2
5
1 2 3 1 5


Output


0
0
1

Note

In the first test case, the ugliness is already 0.

In the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.

In the third test case, you may do three operations: 

  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], 
  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], 
  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. 

The resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are n block towers arranged in a row, each with a specific height denoted as a_i. As a member of the construction crew, your goal is to enhance the appearance of these towers. On any given day, you can execute the following action:

* Select two distinct indices i and j (with 1 ≤ i, j ≤ n) and transfer a block from tower i to tower j. This operation reduces the height of tower i by 1 and increases the height of tower j by 1.

The visual appeal of these towers is measured by the difference in height between the tallest and the

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases. Then t cases follow.

The first line of each test case contains one integer n (2 ≤ n ≤ 100) — the number of buildings.

The second line of each test case contains n space separated integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^7) — the heights of the buildings.

Output

For each test case, output a single integer — the minimum possible ugliness of the buildings.

Example

Input


3
3
10 10 10
4
3 2 1 2
5
1 2 3 1 5


Output


0
0
1

Note

In the first test case, the ugliness is already 0.

In the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.

In the third test case, you may do three operations: 

  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], 
  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], 
  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. 

The resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.
multi-gen-prompt:
 There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can move a block from tower i to tower j (1 ≤ i, j ≤ n; i ≠ j), which decreases a_i by 1 and increases a_j by 1. The ugliness of the buildings is defined as the height difference between the tallest and shortest buildings, max(a)-min(a). What's the minimum possible ugliness you

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases. Then t cases follow.

The first line of each test case contains one integer n (2 ≤ n ≤ 100) — the number of buildings.

The second line of each test case contains n space separated integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^7) — the heights of the buildings.

Output

For each test case, output a single integer — the minimum possible ugliness of the buildings.

Example

Input


3
3
10 10 10
4
3 2 1 2
5
1 2 3 1 5


Output


0
0
1

Note

In the first test case, the ugliness is already 0.

In the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.

In the third test case, you may do three operations: 

  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], 
  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], 
  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. 

The resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.
generating with deepseek-coder
----------updating----------
seed 34 finish fuzzing!
seed_index: 34
mutated_seed_index: 80
current seed length: 39
saving......
in recording...
len prompt_nodes
81
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:39
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 35------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:35
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = \{1, 4, 3\}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = \{1, 3, 4, 4, 5, 7, 8\}.

Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1,

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the original array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3395649790763855
final_output reward: 0
total reward: 0.3395649790763855
add mutated seed into prompt node list
seed_index: 35
mutated_seed_index: 81
reward = 0.3395649790763855
saving......
in recording...
len prompt_nodes
82
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, False, False, False, False, False, False, False, False, False, False]
total pass@10:39
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 36------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:36
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Polycarp has come up with a new game to play with you. He calls it "A missing bigram".

A bigram of a word is a sequence of two adjacent letters in it.

For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he wipes one of them off the whiteboard.

Finally, Polycarp invites you to guess what the word that he has come up with was.

Your goal is to find any word such that it's possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them.

--------------------------------------------------
Polycarp has come up with a new game to play with you. He calls it "A missing bigram".

A bigram of a word is a sequence of two adjacent letters in it.

For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he wipes one of them off the whiteboard.

Finally, Polycarp invites you to guess what the word that he has come up with was.

Your goal is to find any word such that it's possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. Be sure to consider all possible positions for the missing bigram.

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains a single integer n (3 ≤ n ≤ 100) — the length of the word Polycarp has come up with.

The second line of each testcase contains n-2 bigrams of that word, separated by a single space. Each bigram consists of two letters, each of them is either 'a' or 'b'.

Additional constraint on the input: there exists at least one string such that it is possible to write down all its bigrams, except one, so that the resulting sequence is the same as the sequence in the input. In other words, the answer exists.

Output

For each testcase print a word, consisting of n letters, each of them should be either 'a' or 'b'. It should be possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. 

Example

Input


4
7
ab bb ba aa ba
7
ab ba aa ab ba
3
aa
5
bb ab bb


Output


abbaaba
abaabaa
baa
bbabb

Note

The first two testcases from the example are produced from the word "abbaaba". As listed in the statement, it contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

In the first testcase, the 5-th bigram is removed. 

In the second testcase, the 2-nd bigram is removed. However, that sequence could also have been produced from the word "abaabaa". It contains bigrams "ab", "ba", "aa", "ab", "ba" and "aa". The missing bigram is the 6-th one.

In the third testcase, all of "baa", "aab" and "aaa" are valid answers.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp has come up with a new game to play with you. He calls it "A missing bigram". A bigram of a word is a sequence of two adjacent letters in it. For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba". The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains a single integer n (3 ≤ n ≤ 100) — the length of the word Polycarp has come up with.

The second line of each testcase contains n-2 bigrams of that word, separated by a single space. Each bigram consists of two letters, each of them is either 'a' or 'b'.

Additional constraint on the input: there exists at least one string such that it is possible to write down all its bigrams, except one, so that the resulting sequence is the same as the sequence in the input. In other words, the answer exists.

Output

For each testcase print a word, consisting of n letters, each of them should be either 'a' or 'b'. It should be possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. 

Example

Input


4
7
ab bb ba aa ba
7
ab ba aa ab ba
3
aa
5
bb ab bb


Output


abbaaba
abaabaa
baa
bbabb

Note

The first two testcases from the example are produced from the word "abbaaba". As listed in the statement, it contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

In the first testcase, the 5-th bigram is removed. 

In the second testcase, the 2-nd bigram is removed. However, that sequence could also have been produced from the word "abaabaa". It contains bigrams "ab", "ba", "aa", "ab", "ba" and "aa". The missing bigram is the 6-th one.

In the third testcase, all of "baa", "aab" and "aaa" are valid answers.
multi-gen-prompt:
 Polycarp has come up with a new game to play with you. He calls it "A missing bigram". A bigram of a word is a sequence of two adjacent letters in it. For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba". The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains a single integer n (3 ≤ n ≤ 100) — the length of the word Polycarp has come up with.

The second line of each testcase contains n-2 bigrams of that word, separated by a single space. Each bigram consists of two letters, each of them is either 'a' or 'b'.

Additional constraint on the input: there exists at least one string such that it is possible to write down all its bigrams, except one, so that the resulting sequence is the same as the sequence in the input. In other words, the answer exists.

Output

For each testcase print a word, consisting of n letters, each of them should be either 'a' or 'b'. It should be possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. 

Example

Input


4
7
ab bb ba aa ba
7
ab ba aa ab ba
3
aa
5
bb ab bb


Output


abbaaba
abaabaa
baa
bbabb

Note

The first two testcases from the example are produced from the word "abbaaba". As listed in the statement, it contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

In the first testcase, the 5-th bigram is removed. 

In the second testcase, the 2-nd bigram is removed. However, that sequence could also have been produced from the word "abaabaa". It contains bigrams "ab", "ba", "aa", "ab", "ba" and "aa". The missing bigram is the 6-th one.

In the third testcase, all of "baa", "aab" and "aaa" are valid answers.
generating with deepseek-coder
----------updating----------
seed 36 finish fuzzing!
seed_index: 36
mutated_seed_index: 82
current seed length: 38
saving......
in recording...
len prompt_nodes
83
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, False, False, False, False, False, False, False, False, False]
total pass@10:38
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 37------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:37
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given an array a of n integers, and another integer k such that 2k ≤ n.

You have to perform exactly k operations with this array. In one operation, you have to choose two elements of the array (let them be a_i and a_j; they can be equal or different, but their positions in the array must not be the same), remove them from the array, and add ⌊ (a_i)/(a_j) ⌋ to your score, where ⌊ x/y ⌋ is the maximum integer not exceeding x/y.

Initially, your score is 0. After you perform exactly k operations, you add all the remaining elements of the array to the score.

Calculate the minimum possible score you can get.

--------------------------------------------------
You receive an array a of n integers, along with another integer k such that 2k ≤ n.

You have to perform exactly k operations with this array. In one operation, you have to choose two elements of the array (let them be a_i and a_j; they can be equal or different, but their positions in the array must not be the same), remove them from the array, and add ⌊ (a_i)/(a_j) ⌋ to your score, where ⌊ x/y ⌋ is the maximum integer not exceeding x/y.

Initially, your score is 0. Once you complete k operations, all the remaining elements of the array are added to the score.

Determine the minimum achievable score.

Input

The first line of the input contains one integer t (1 ≤ t ≤ 500) — the number of test cases.

Each test case consists of two lines. The first line contains two integers n and k (1 ≤ n ≤ 100; 0 ≤ k ≤ ⌊ n/2 ⌋).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 2 ⋅ 10^5).

Output

Print one integer — the minimum possible score you can get.

Example

Input


5
7 3
1 1 1 2 1 3 1
5 1
5 5 5 5 5
4 2
1 3 3 7
2 0
4 2
9 2
1 10 10 1 10 2 7 10 3


Output


2
16
0
6
16

Note

Let's consider the example test.

In the first test case, one way to obtain a score of 2 is the following one:

  1. choose a_7 = 1 and a_4 = 2 for the operation; the score becomes 0 + ⌊ 1/2 ⌋ = 0, the array becomes [1, 1, 1, 1, 3]; 
  2. choose a_1 = 1 and a_5 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [1, 1, 1]; 
  3. choose a_1 = 1 and a_2 = 1 for the operation; the score becomes 0 + ⌊ 1/1 ⌋ = 1, the array becomes [1]; 
  4. add the remaining element 1 to the score, so the resulting score is 2. 



In the second test case, no matter which operations you choose, the resulting score is 16.

In the third test case, one way to obtain a score of 0 is the following one:

  1. choose a_1 = 1 and a_2 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [3, 7]; 
  2. choose a_1 = 3 and a_2 = 7 for the operation; the score becomes 0 + ⌊ 3/7 ⌋ = 0, the array becomes empty; 
  3. the array is empty, so the score doesn't change anymore. 



In the fourth test case, no operations can be performed, so the score is the sum of the elements of the array: 4 + 2 = 6.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with an array a consisting of n integers, along with an integer k, where 2k is less than or equal to n. The task is to perform exactly k operations on this array. In each operation, you must select two elements from the array (denoted as a_i and a_j), remove them from the array, and add the result of the floor division of a_i by a_j to your score. The floor division result, denoted as ⌊ a_i / a_j ⌋, is the largest integer not exceeding the division of a_i by a_j

Input

The first line of the input contains one integer t (1 ≤ t ≤ 500) — the number of test cases.

Each test case consists of two lines. The first line contains two integers n and k (1 ≤ n ≤ 100; 0 ≤ k ≤ ⌊ n/2 ⌋).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 2 ⋅ 10^5).

Output

Print one integer — the minimum possible score you can get.

Example

Input


5
7 3
1 1 1 2 1 3 1
5 1
5 5 5 5 5
4 2
1 3 3 7
2 0
4 2
9 2
1 10 10 1 10 2 7 10 3


Output


2
16
0
6
16

Note

Let's consider the example test.

In the first test case, one way to obtain a score of 2 is the following one:

  1. choose a_7 = 1 and a_4 = 2 for the operation; the score becomes 0 + ⌊ 1/2 ⌋ = 0, the array becomes [1, 1, 1, 1, 3]; 
  2. choose a_1 = 1 and a_5 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [1, 1, 1]; 
  3. choose a_1 = 1 and a_2 = 1 for the operation; the score becomes 0 + ⌊ 1/1 ⌋ = 1, the array becomes [1]; 
  4. add the remaining element 1 to the score, so the resulting score is 2. 



In the second test case, no matter which operations you choose, the resulting score is 16.

In the third test case, one way to obtain a score of 0 is the following one:

  1. choose a_1 = 1 and a_2 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [3, 7]; 
  2. choose a_1 = 3 and a_2 = 7 for the operation; the score becomes 0 + ⌊ 3/7 ⌋ = 0, the array becomes empty; 
  3. the array is empty, so the score doesn't change anymore. 



In the fourth test case, no operations can be performed, so the score is the sum of the elements of the array: 4 + 2 = 6.
multi-gen-prompt:
 You are given an array a of n integers, and another integer k such that 2k ≤ n. You have to perform exactly k operations with this array. In one operation, you have to choose two elements of the array (let them be a_i and a_j; they can be equal or different, but their positions in the array must not be the same), remove them from the array, and add ⌊ (a_i)/(a_j) ⌋ to your score, where ⌊ x/y ⌋ is the maximum integer not exceeding x/y. Initially, your

Input

The first line of the input contains one integer t (1 ≤ t ≤ 500) — the number of test cases.

Each test case consists of two lines. The first line contains two integers n and k (1 ≤ n ≤ 100; 0 ≤ k ≤ ⌊ n/2 ⌋).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 2 ⋅ 10^5).

Output

Print one integer — the minimum possible score you can get.

Example

Input


5
7 3
1 1 1 2 1 3 1
5 1
5 5 5 5 5
4 2
1 3 3 7
2 0
4 2
9 2
1 10 10 1 10 2 7 10 3


Output


2
16
0
6
16

Note

Let's consider the example test.

In the first test case, one way to obtain a score of 2 is the following one:

  1. choose a_7 = 1 and a_4 = 2 for the operation; the score becomes 0 + ⌊ 1/2 ⌋ = 0, the array becomes [1, 1, 1, 1, 3]; 
  2. choose a_1 = 1 and a_5 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [1, 1, 1]; 
  3. choose a_1 = 1 and a_2 = 1 for the operation; the score becomes 0 + ⌊ 1/1 ⌋ = 1, the array becomes [1]; 
  4. add the remaining element 1 to the score, so the resulting score is 2. 



In the second test case, no matter which operations you choose, the resulting score is 16.

In the third test case, one way to obtain a score of 0 is the following one:

  1. choose a_1 = 1 and a_2 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [3, 7]; 
  2. choose a_1 = 3 and a_2 = 7 for the operation; the score becomes 0 + ⌊ 3/7 ⌋ = 0, the array becomes empty; 
  3. the array is empty, so the score doesn't change anymore. 



In the fourth test case, no operations can be performed, so the score is the sum of the elements of the array: 4 + 2 = 6.
generating with deepseek-coder
----------updating----------
seed 37 finish fuzzing!
seed_index: 37
mutated_seed_index: 83
current seed length: 37
saving......
in recording...
len prompt_nodes
84
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, False, False, False, False, False, False]
total pass@10:37
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 38------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:38
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Consider edge cases with strings of length zero and one.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it is composed of two identical consecutive strings. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, non-square examples are "aaa", "abaaab", and "abcdabc". The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3638935089111328
final_output reward: 0
total reward: 0.3638935089111328
add mutated seed into prompt node list
seed_index: 38
mutated_seed_index: 84
reward = 0.3638935089111328
saving......
in recording...
len prompt_nodes
85
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, False, False, False, False, False, False]
total pass@10:37
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 39------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:39
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Polycarp likes squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp likes squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing, meaning he likes those numbers that are either a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.33346986770629883
final_output reward: 0.2
total reward: 0.5334698677062988
add mutated seed into prompt node list
seed_index: 39
mutated_seed_index: 85
reward = 0.5334698677062988
saving......
in recording...
len prompt_nodes
86
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, False, False, False, False, False, False]
total pass@10:37
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 40------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:40
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Tanya is learning how to add numbers, but so far she is not doing it correctly. She is adding two numbers a and b using the following algorithm:

  1. If one of the numbers is shorter than the other, Tanya adds leading zeros so that the numbers are the same length. 
  2. The numbers are processed from right to left (that is, from the least significant digits to the most significant). 
  3. In the first step, she adds the last digit of a to the last digit of b and writes their sum in the answer. 
  4. At each next step, she performs the same operation on each pair of digits in the same place and writes the result to the left side of the answer. 



For example, the numbers a = 17236 and b = 3465 Tanya adds up as follows:

$$$ \large{ \begin{array}{r} + \begin{array}{r} 17236\\\ 03465\\\ \end{array} \\\ \hline \begin{array}{r} 1106911 \end{array} \end{array}} $$$

  * calculates the sum of 6 + 5 = 11 and writes 11 in the answer. 
  * calculates the sum of 3 + 6 = 9 and writes the result to the left side of the answer to get 911. 
  * calculates the sum of 2 + 4 = 6 and writes the result to the left side of the answer to get 6911. 
  * calculates the sum of 7 + 3 = 10, and writes the result to the left side of the answer to get 106911. 
  * calculates the sum of 1 + 0 = 1 and writes the result to the left side of the answer and get 1106911. 



As a result, she gets 1106911.

You are given two positive integers a and s. Find the number b such that by adding a and b as described above, Tanya will get s. Or determine that no suitable b exists.

--------------------------------------------------
Tanya is learning how to add numbers, but so far she is not doing it correctly. She is adding two numbers a and b using the following algorithm:

  1. If one of the numbers is shorter than the other, Tanya adds leading zeros so that the numbers are the same length. 
  2. The numbers are processed from right to left (that is, from the least significant digits to the most significant). 
  3. In the first step, she adds the last digit of a to the last digit of b and writes their sum in the answer. 
  4. At each next step, she performs the same operation on each pair of digits in the same place and writes the result to the left side of the answer. 



For example, the numbers a = 17236 and b = 3465 Tanya adds up as follows:

$$$ \large{ \begin{array}{r} + \begin{array}{r} 17236\\\ 03465\\\ \end{array} \\\ \hline \begin{array}{r} 1106911 \end{array} \end{array}} $$$

  * calculates the sum of 6 + 5 = 11 and writes 11 in the answer. 
  * calculates the sum of 3 + 6 = 9 and writes the result to the left side of the answer to get 911. 
  * calculates the sum of 2 + 4 = 6 and writes the result to the left side of the answer to get 6911. 
  * calculates the sum of 7 + 3 = 10, and writes the result to the left side of the answer to get 106911. 
  * calculates the sum of 1 + 0 = 1 and writes the result to the left side of the answer and get 1106911. 



As a result, she gets 1106911.

You are given two positive integers a and s. Find the number b such that by adding a and b as described above, Tanya will get s. Or determine that no suitable b exists. Consider edge cases where s has more digits than expected due to high digit sums and where leading zeros for b may be necessary.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Each test case consists of a single line containing two positive integers a and s (1 ≤ a < s ≤ 10^{18}) separated by a space.

Output

For each test case print the answer on a separate line.

If the solution exists, print a single positive integer b. The answer must be written without leading zeros. If multiple answers exist, print any of them.

If no suitable number b exists, output -1.

Example

Input


6
17236 1106911
1 5
108 112
12345 1023412
1 11
1 20


Output


3465
4
-1
90007
10
-1

Note

The first test case is explained in the main part of the statement.

In the third test case, we cannot choose b that satisfies the problem statement.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Tanya is learning to add numbers, but she is having trouble with it. She adds two numbers a and b by following these steps:

1. If one of the numbers is shorter than the other, Tanya adds leading zeros to make both numbers the same length.
2. She starts adding the numbers from the right, or the least significant digits, and works her way to the left.
3. In the first step, she adds the last digit of a to the last digit of b and writes down their sum at the end of the result.
4. For each subsequent step, she adds the corresponding digits

Input

The first line of input data contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Each test case consists of a single line containing two positive integers a and s (1 ≤ a < s ≤ 10^{18}) separated by a space.

Output

For each test case print the answer on a separate line.

If the solution exists, print a single positive integer b. The answer must be written without leading zeros. If multiple answers exist, print any of them.

If no suitable number b exists, output -1.

Example

Input


6
17236 1106911
1 5
108 112
12345 1023412
1 11
1 20


Output


3465
4
-1
90007
10
-1

Note

The first test case is explained in the main part of the statement.

In the third test case, we cannot choose b that satisfies the problem statement.
multi-gen-prompt:
 Tanya is learning to add numbers incorrectly, aligning them from right to left and adding digits from the least significant to the most significant. For example, with a = 17236 and s = 1106911, she would find b = 3465. Determine if a suitable b exists for any given a and s.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Each test case consists of a single line containing two positive integers a and s (1 ≤ a < s ≤ 10^{18}) separated by a space.

Output

For each test case print the answer on a separate line.

If the solution exists, print a single positive integer b. The answer must be written without leading zeros. If multiple answers exist, print any of them.

If no suitable number b exists, output -1.

Example

Input


6
17236 1106911
1 5
108 112
12345 1023412
1 11
1 20


Output


3465
4
-1
90007
10
-1

Note

The first test case is explained in the main part of the statement.

In the third test case, we cannot choose b that satisfies the problem statement.
generating with deepseek-coder
----------updating----------
seed 40 finish fuzzing!
seed_index: 40
mutated_seed_index: 86
current seed length: 36
saving......
in recording...
len prompt_nodes
87
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, False, False, False, False]
total pass@10:36
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 41------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:41
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer from 1 to n. A sequence of this nature is referred to as a permutation. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not. You will be handling q queries, each of which can be of two types:

1. Swap the elements at positions x and y in

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.32610422372817993
final_output reward: 0
total reward: 0.32610422372817993
add mutated seed into prompt node list
seed_index: 41
mutated_seed_index: 87
reward = 0.32610422372817993
saving......
in recording...
len prompt_nodes
88
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, False, False, False, False]
total pass@10:36
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_41.jsonl
----------------------------------------round: 42------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:42
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not.

Unfortunately, you've lost a piece of paper with the array a. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with information you have about equality or non-equality of corresponding pairs?

--------------------------------------------------
You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not. Unfortunately, you've lost a piece of paper with the array a, and you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with information you have about equality or non-equality of corresponding pairs?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not. Unfortunately, you've lost a piece of paper with the array a. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
multi-gen-prompt:
 You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers, you wrote down whether the numbers in the pair were equal or not. Unfortunately, you've lost the array a, and you're concerned that the information about the equality or non-equality of neighboring elements might be inconsistent. Is there any array a that could be consistent with this information?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.42498779296875
final_output reward: 0.5
total reward: 0.92498779296875
add mutated seed into prompt node list
seed_index: 42
mutated_seed_index: 88
reward = 0.92498779296875
saving......
in recording...
len prompt_nodes
89
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, False, False, False, False]
total pass@10:36
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 43------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:43
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have an array of integers (initially empty).

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 



Find the resulting array after performing all the queries.

--------------------------------------------------
You possess an initially empty list of numbers. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 



Determine the final array after executing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts as empty. 

You need to handle a series of queries, each of which can be one of two types: 

  * "1 x" means you add the number x to the end of the array.
  * "2 x y" means you replace every occurrence of the number x in the array with the number y.

After processing all the queries, what will the final array look like?

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.25145262479782104
final_output reward: 0
total reward: 0.25145262479782104
add mutated seed into prompt node list
seed_index: 43
mutated_seed_index: 89
reward = 0.25145262479782104
saving......
in recording...
len prompt_nodes
90
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, False, False, False, False]
total pass@10:36
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 44------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:44
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3.

You are asked to break exactly one of them into two pieces in such a way that: 

  * both pieces have positive (strictly greater than 0) integer length; 
  * the total length of the pieces is equal to the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 



A square is also considered a rectangle.

Determine if it's possible to do that.

--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers.

You are asked to break exactly one of them into two pieces in such a way that: 

  * both pieces have positive (strictly greater than 0) integer length; 
  * the total length of the pieces is equal to the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 

A square is also considered a rectangle.

Determine if it's possible to do that.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3523094058036804
final_output reward: 0.4
total reward: 0.7523094058036804
add mutated seed into prompt node list
seed_index: 44
mutated_seed_index: 90
reward = 0.7523094058036804
saving......
in recording...
len prompt_nodes
91
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, False, False, False, False]
total pass@10:36
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 45------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:45
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points. If the student does not answer the j-th question correctly, he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points are distributed accordingly.

Petya knows that each student expects to get a certain number of points, x_i, for the test. He wants to determine the permutation p that maximizes the surprise value of the results, which is calculated as the sum of the absolute differences between the expected points and the actual points received by each student, ∑_{i

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher with n students who have taken a test with m questions. Each student's performance is known, with a record of which questions they answered correctly. The points for each question are unique and range from 1 to m, and each student's score is the sum of points for the questions they answered correctly. Petya aims to maximize the total surprise value of the students' scores, which is calculated as the sum of the absolute differences between the expected and actual scores for each student. Your task is to find a permutation p of points that maximizes this surprise value.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.22155135869979858
final_output reward: 0
total reward: 0.22155135869979858
add mutated seed into prompt node list
seed_index: 45
mutated_seed_index: 91
reward = 0.22155135869979858
saving......
in recording...
len prompt_nodes
92
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, False, False, False, False]
total pass@10:36
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 46------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:88
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not. Unfortunately, you've lost a piece of paper with the array a, and you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with information you have about equality or non-equality of corresponding pairs?

--------------------------------------------------
You had n positive integers a_1, a_2, ..., a_n arranged in a circle. You wrote down whether the numbers in each adjacent pair (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1) are the same or different. Unfortunately, you've lost a piece of paper with the array a, and you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with information you have about equality or non-equality of corresponding pairs?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not. Unfortunately, you've lost a piece of paper with the array a. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
multi-gen-prompt:
 You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers, you wrote down whether the numbers in the pair were equal or not. Unfortunately, you've lost the array a, and you're concerned that the information about the equality or non-equality of neighboring elements might be inconsistent. Is there any array a that could be consistent with this information?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
seed 88 finish fuzzing!
seed_index: 88
mutated_seed_index: 92
current seed length: 35
saving......
in recording...
len prompt_nodes
93
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 47------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:59
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it. You are given n days from Petya's life and you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; you are given n days from Petya's life and you have to determine what happened with his flower in the end. The flower grows as follows: * If the flower isn't watered for two days in a row, it dies. * If the flower is watered in the i-th day, it grows by 1 centimeter. * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. * If the flower is not watered in the i-th day, it does not grow. At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days, during which you need to track the growth and eventual fate of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes un-watered for two consecutive days, it will wither away. 
  * If the flower is watered on the i-th day, it will increase in height by 1 centimeter. 
  * If the flower is

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.28948062658309937
final_output reward: 0
total reward: 0.28948062658309937
add mutated seed into prompt node list
seed_index: 59
mutated_seed_index: 93
reward = 0.28948062658309937
saving......
in recording...
len prompt_nodes
94
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 48------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:90
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers.

You are asked to break exactly one of them into two pieces in such a way that: 

  * both pieces have positive (strictly greater than 0) integer length; 
  * the total length of the pieces is equal to the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 

A square is also considered a rectangle.

Determine if it's possible to do that.

--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive (strictly greater than 0) integer length and the total length of the pieces is equal to the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total length equals the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31567156314849854
final_output reward: 0
total reward: 0.31567156314849854
add mutated seed into prompt node list
seed_index: 90
mutated_seed_index: 94
reward = 0.31567156314849854
saving......
in recording...
len prompt_nodes
95
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 49------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:49
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek has a new game called Dropping Balls, and initially, Mr. Chanek has a grid a of size n × m where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move: * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2, and Mr. Chanek will drop k balls sequentially, each starting from the first row, and on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns. Determine in which column each ball will end up in (position of the ball after leaving the grid).

--------------------------------------------------
Mr. Chanek has a new game called Dropping Balls, and initially, Mr. Chanek has a grid a of size n × m where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move: * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2, and Mr. Chanek will drop k balls sequentially, each starting from the first row on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns, so determine in which column each ball will end up in (position of the ball after leaving the grid).

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has developed a captivating game called Dropping Balls. In this game, a grid of size n × m is used, where each cell (x,y) contains an integer a_{x,y} that dictates the direction the ball will take.

The ball's movement is determined by the value of a_{x,y}:
- If a_{x,y} = 1, the ball moves to the right to the next cell (x, y + 1).
- If a_{x,y} = 2, the ball moves downwards to the next cell (x +

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
multi-gen-prompt:
 Mr. Chanek has a new game called Dropping Balls. Initially, Mr. Chanek has a grid of size n × m, where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move. The ball will move to the right (next cell is (x, y + 1)) if a_{x,y}=1, to the bottom (next cell is (x + 1, y)) if a_{x,y}=2, or to the left (next cell is (x, y - 1)) if a_{x,

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
generating with deepseek-coder
----------updating----------
analyst reward: 0.24614733457565308
final_output reward: 0
total reward: 0.24614733457565308
add mutated seed into prompt node list
seed_index: 49
mutated_seed_index: 95
reward = 0.24614733457565308
saving......
in recording...
len prompt_nodes
96
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 50------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:52
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don't have to be adjacent.

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

  * He can erase one 'A' and one 'B' from anywhere in the string, regardless of whether they are adjacent.
  * He can erase one 'B' and one 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2. Each turn is independent, and Casimir can choose any of the two actions available.

For

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3490217924118042
final_output reward: 0
total reward: 0.3490217924118042
add mutated seed into prompt node list
seed_index: 52
mutated_seed_index: 96
reward = 0.3490217924118042
saving......
in recording...
len prompt_nodes
97
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 51------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:66
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot, and your mission is to construct factory facilities. However, before you begin, you need to determine the dimensions of the factory and the number of rooms it contains. You have been provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles, and they can range from 0 to 15. Each of these numbers should be examined in its binary form. By doing so, you can determine which sides of the tile have walls. For instance

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating the dimensions of a factory construction in rectangle shape: N x M. The data consists of N lines, each containing M numbers representing factory tiles. These numbers range from 0 to 15 and each can be interpreted in binary to indicate the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is correct. Your task is to print the sizes of the rooms in the factory from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3969076871871948
final_output reward: 0
total reward: 0.3969076871871948
add mutated seed into prompt node list
seed_index: 66
mutated_seed_index: 97
reward = 0.3969076871871948
saving......
in recording...
len prompt_nodes
98
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_51.jsonl
----------------------------------------round: 52------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:62
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1. It is also possible to move if |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column. The character can move to nearby cells, either next to each other or by going a little bit diagonally. But, Monocarp can't go outside the grid. There are some dangerous spots called traps where if the character goes, the game ends. The goal is for Monocarp's character to reach the end of the level, which is the

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into traps. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.44327300786972046
final_output reward: 0
total reward: 0.44327300786972046
add mutated seed into prompt node list
seed_index: 62
mutated_seed_index: 98
reward = 0.44327300786972046
saving......
in recording...
len prompt_nodes
99
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 53------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:68
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of the sum ∑_{i=1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30800360441207886
final_output reward: 0
total reward: 0.30800360441207886
add mutated seed into prompt node list
seed_index: 68
mutated_seed_index: 99
reward = 0.30800360441207886
saving......
in recording...
len prompt_nodes
100
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 54------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:55
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, noting that the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, and its elements can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning the array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$. 2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}. Then each element of the array a_i

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.299153208732605
final_output reward: 0.3
total reward: 0.599153208732605
add mutated seed into prompt node list
seed_index: 55
mutated_seed_index: 100
reward = 0.599153208732605
saving......
in recording...
len prompt_nodes
101
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 55------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:67
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given array a_1, a_2, …, a_n, consisting of non-negative integers.

Let's define operation of "elimination" with integer parameter k (1 ≤ k ≤ n) as follows:

  * Choose k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. 
  * Calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, where \& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). The bitwise AND operation is a binary operation that takes two equal-length binary representations and performs the logical AND operation on each pair of the corresponding bits.
  * Subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}; all other elements remain untouched. 

Find all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.

Note that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.

--------------------------------------------------
You are given array a_1, a_2, …, a_n, consisting of non-negative integers.

Let's define operation of "elimination" with integer parameter k (1 ≤ k ≤ n) as follows:

  * Choose k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. Select k indices from the array such that 1 ≤ i_1 < i_2 < … < i_k ≤ n. These indices must be distinct and in increasing order.
  * Calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, where \& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). The bitwise AND operation is a binary operation that takes two equal-length binary representations and performs the logical AND operation on each pair of the corresponding bits.
  * Subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}; all other elements remain untouched. 

Find all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.

Note that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, which consists of non-negative integers. The operation of "elimination" is defined with an integer parameter k (1 ≤ k ≤ n). This operation involves choosing k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. The next step is to calculate x, which is the result of the bitwise AND operation applied to a_{i_1}, a_{i_2}, …, a_{i_k}. After that, x is subtracted

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, consisting of non-negative integers. Let's define the "elimination" operation with an integer parameter k (1 ≤ k ≤ n) as follows: choose k distinct array indices and calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, where \& denotes the bitwise AND operation; subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}, while

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
generating with deepseek-coder
----------updating----------
analyst reward: 0.353377103805542
final_output reward: 0
total reward: 0.353377103805542
add mutated seed into prompt node list
seed_index: 67
mutated_seed_index: 101
reward = 0.353377103805542
saving......
in recording...
len prompt_nodes
102
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 56------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:85
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp likes squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

--------------------------------------------------
Polycarp is fond of the squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with the following sequence of numbers he likes: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp likes. This means counting the number of integers x that are either a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.36245614290237427
final_output reward: 0.3
total reward: 0.6624561429023743
add mutated seed into prompt node list
seed_index: 85
mutated_seed_index: 102
reward = 0.6624561429023743
saving......
in recording...
len prompt_nodes
103
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 57------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:61
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that only consists of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that only consists of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of different non-negative powers of a given number \( n \). For instance, with \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your help to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, considering it modulo 10^9+7 if it's too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.2801327705383301
final_output reward: 0
total reward: 0.2801327705383301
add mutated seed into prompt node list
seed_index: 61
mutated_seed_index: 103
reward = 0.2801327705383301
saving......
in recording...
len prompt_nodes
104
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 58------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:64
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.

Monocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n). It also has a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.

Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):

  * the topics of all three selected problems are different; 
  * the difficulties of all three selected problems are different. 



Your task is to determine the number of ways to select three problems for the problemset.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has gathered a total of n problems, all of which are new to his students. Each problem is uniquely identified by its topic, denoted as a_i (ranging from 1 to n), and its difficulty, represented by b_i (also ranging from 1 to n).

Monocarp aims to choose exactly 3 problems from these n problems to form a problemset. The selection must meet at least one of the following criteria:

1. The topics of the three selected problems are distinct.
2. The difficulties of the

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, needs to compose a problemset for a training session. He has n problems, each with a unique topic a_i (integer from 1 to n) and difficulty b_i (integer from 1 to n). He must select exactly 3 problems for the problemset, ensuring they meet at least one of the following conditions: the topics are all different, or the difficulties are all different. The task is to find the number of ways to select these three problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2400866150856018
final_output reward: 0.1
total reward: 0.3400866150856018
add mutated seed into prompt node list
seed_index: 64
mutated_seed_index: 104
reward = 0.3400866150856018
saving......
in recording...
len prompt_nodes
105
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, False, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:35
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 59------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:76
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns), with rows numbered 1 to n from top to bottom and columns numbered 1 to m from left to right. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell and moves to the adjacent square in the direction indicated on the current square in one move. * If the robot moves beyond the edge of the board, it falls and breaks. * If the robot appears in the cell it already visited before, it breaks (it stops and doesn't move anymore). Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns), with rows numbered 1 to n from top to bottom and columns numbered 1 to m from left to right. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can start its movement in any cell, moving to the adjacent square in the indicated direction; if it moves beyond the board, it falls and breaks, or if it revisits a cell, it breaks. Robot can choose any cell as the starting cell, and its goal is to make the maximum number of steps before it breaks or stops. Determine from which square the robot should start its movement in order to execute as many commands as possible. A command is considered successfully completed if the robot has moved from the square on which that command was written (it does not matter whether to another square or beyond the edge of the board).

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of dimensions n × m (n rows and m columns). The rows are numbered from 1 to n, with the top row being 1 and the bottom row being n. Similarly, the columns are numbered from 1 to m, with the leftmost column being 1 and the rightmost column being m.

The robot can move from its current cell to one of the four adjacent cells, depending on the symbol written on the cell. The symbols 'L', 'R', 'D', and 'U' represent moving left, right, down, and up, respectively

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
generating with deepseek-coder
----------updating----------
seed 76 finish fuzzing!
seed_index: 76
mutated_seed_index: 105
current seed length: 34
saving......
in recording...
len prompt_nodes
106
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:34
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 60------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:63
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp has obtained an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The average value of an array containing n elements is calculated as the total of the elements divided by their count (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

--------------------------------------------------
Monocarp wonders if there's a systematic approach to identifying such pairs beyond brute-force methods.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements is denoted as k, which is the sum of all elements divided by the number of elements (n). The mean of an array is calculated by adding all the elements and then dividing by the number of elements. Monocarp wants to remove exactly two elements from the array a so that the mean of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i is less than j) in the array a such that if the elements at these positions are

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2779945731163025
final_output reward: 0
total reward: 0.2779945731163025
add mutated seed into prompt node list
seed_index: 63
mutated_seed_index: 106
reward = 0.2779945731163025
saving......
in recording...
len prompt_nodes
107
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, False, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:34
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 61------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:77
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … <a_n, and for every i from 2 to n, a_i isn't divisible by a_{i-1}

It can be shown that such an array always exists under the constraints of the problem.

--------------------------------------------------
Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold:

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … < a_n. The array should be increasing. Additionally, for every i from 2 to n, a_i isn't divisible by a_{i-1}

It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … <a_n

  * For every i from 2 to n, a_i isn't divisible by a_{i-1}

It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
multi-gen-prompt:
 Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 1 ≤ a_i ≤ 10^9 for every i from 1 to n, a_1 < a_2 < … < a_n, and for every i from 2 to n, a_i isn't divisible by a_{i-1}. It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
generating with deepseek-coder
----------updating----------
seed 77 finish fuzzing!
seed_index: 77
mutated_seed_index: 107
current seed length: 33
saving......
in recording...
len prompt_nodes
108
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_61.jsonl
----------------------------------------round: 62------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:84
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Consider edge cases with strings of length zero and one.

--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Consider edge cases with strings of length zero and one. Ensure to handle strings with special characters appropriately.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square because they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by writing another string twice in a row. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, "aaa", "abaaab", and "abcdabc" are not considered square. The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3984391689300537
final_output reward: 0
total reward: 0.3984391689300537
add mutated seed into prompt node list
seed_index: 84
mutated_seed_index: 108
reward = 0.3984391689300537
saving......
in recording...
len prompt_nodes
109
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 63------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:48
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). Help them, so you can get a portion of the treasure! Be sure to consider optimal strategies for handling multiple queries efficiently.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. 

The labyrinth is structured with n rooms, each numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through multiple tunnels.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. To travel from room x to room y, a tunnel must exist between x and y, and the energy required for this journey is calculated as

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze can alter the illusion rate of any room. Queries include updating the illusion rate of a room and finding the minimum energy required to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3532280921936035
final_output reward: 0.2
total reward: 0.5532280921936035
add mutated seed into prompt node list
seed_index: 48
mutated_seed_index: 109
reward = 0.5532280921936035
saving......
in recording...
len prompt_nodes
110
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 64------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:74
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large.

--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large. The solution should consider time complexity effectively for both small and large values of n.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 

Situations in which there are no elements of some color at all are also possible. For example,

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same. Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1; or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3321036696434021
final_output reward: 0
total reward: 0.3321036696434021
add mutated seed into prompt node list
seed_index: 74
mutated_seed_index: 110
reward = 0.3321036696434021
saving......
in recording...
len prompt_nodes
111
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 65------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:81
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Consider the possibility of duplicate values in the array a when deriving it from b.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31981438398361206
final_output reward: 0
total reward: 0.31981438398361206
add mutated seed into prompt node list
seed_index: 81
mutated_seed_index: 111
reward = 0.31981438398361206
saving......
in recording...
len prompt_nodes
112
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 66------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:73
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given a keyboard that consists of 26 keys, and the keys are arranged sequentially in one row in a certain order, each corresponding to a unique lowercase Latin letter. You have to type the word s on this keyboard, which also consists only of lowercase Latin letters.

To type a word consecutively one by one, each letter must be typed over the corresponding key and pressed. Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys, with no time spent on pressing the keys and on placing your hand over the first letter of the word.

For example, consider a keyboard where the letters from 'a' to 'z' are arranged in consecutive alphabetical order. The letters 'h', 'e', 'l', and 'o' then are on the positions 8, 5, 12, and 15, respectively, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". 

Determine how long it will take to print the word s.

--------------------------------------------------
You are given a keyboard that consists of 26 keys, and the keys are arranged sequentially in one row in a certain order, each corresponding to a unique lowercase Latin letter, and you have to type the word s on this keyboard, which also consists only of lowercase Latin letters. To type a word consecutively one by one, each letter must be typed over the corresponding key and pressed. Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys, with no time spent on pressing the keys and on placing your hand over the first letter of the word. For example, consider a keyboard where the letters from 'a' to 'z' are arranged in consecutive alphabetical order. The letters 'h', 'e', 'l', and 'o' then are on the positions 8, 5, 12, and 15, respectively, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Determine how long it will take to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the total time required to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\nYou are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.\n\nYou have to type the word s on this keyboard. It also consists only of lowercase Latin letters.\n\nTo type a word, you need to type all its letters consecutively one by one. To type each letter you must position your hand exactly over the corresponding key and press it.\n\nMoving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from left to right). No time is spent on pressing the keys and on placing your hand over the first letter of the word.\n\nFor example, consider a keyboard where the letters from \'a\' to \'z\' are arranged in consecutive alphabetical order. The letters \'h\', \'e\', \'l\' and \'o\' then are on the positions 8, 5, 12 and 15, respectively. Therefore, it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". \n\nDetermine how long it will take to print the word s.\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nThe first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from \'a\' to \'z\' appears exactly once on the keyboard.\n\nThe second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.\n\nExample\n\nInput\n\n\n5\nabcdefghijklmnopqrstuvwxyz\nhello\nabcdefghijklmnopqrstuvwxyz\ni\nabcdefghijklmnopqrstuvwxyz\ncodeforces\nqwertyuiopasdfghjklzxcvbnm\nqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\nqwertyuiopasdfghjklzxcvbnm\nabacaba\n\n\nOutput\n\n\n13\n0\n68\n0\n74\n[plan]\n- name: \nMapping and Summation Solution\n\n- content: \nFor each test case, create a mapping of each letter to its position on the keyboard. Then, iterate through the word, calculating the time to type each letter by finding the absolute difference between the positions of consecutive letters. Sum these differences to get the total time.\n\nApproach:\n1. Read the keyboard layout and create a dictionary mapping each letter to its position.\n2. For each word in the test cases, initialize a total time variable.\n3. Iterate through the word, using the dictionary to find the position of each letter and calculate the time to type it.\n4. Sum these times to get the total typing time for the word.\n5. Output the total typing time for each word.\n\n\n\n## Answer 3:\n\n'}]
----------updating----------
analyst reward: 0.3260335922241211
final_output reward: 0
total reward: 0.3260335922241211
add mutated seed into prompt node list
seed_index: 73
mutated_seed_index: 112
reward = 0.3260335922241211
saving......
in recording...
len prompt_nodes
113
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 67------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:75
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The robot must maximize the number of commands executed without falling off the board.

--------------------------------------------------
The robot needs to optimize the quantity of commands carried out while staying on the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, with each command represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts its movement from any cell on the

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. The goal is to determine the cell from which the robot should start its movement to execute the most commands without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.2173721194267273
final_output reward: 0.2
total reward: 0.4173721194267273
add mutated seed into prompt node list
seed_index: 75
mutated_seed_index: 113
reward = 0.4173721194267273
saving......
in recording...
len prompt_nodes
114
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 68------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:87
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n items is a list of length n that includes each number from 1 to n precisely once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer from 1 to n. A sequence of this nature is referred to as a permutation. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will be handling a series of queries, each of which can be of two types:

1. Swap the elements at positions

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3140408396720886
final_output reward: 0
total reward: 0.3140408396720886
add mutated seed into prompt node list
seed_index: 87
mutated_seed_index: 114
reward = 0.3140408396720886
saving......
in recording...
len prompt_nodes
115
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 69------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:65
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia have strict rules on what a successful party is, which is a gathering of exactly 5 people where either all are friends or none are friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered successful if either all the people at the party are friends with each other, allowing them to all talk to each other without worrying about talking to someone they are not friends with, or no two people at the party are friends with

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, considering it successful if all attendees are friends or none are. A party consists of exactly 5 people. Help them organize a successful party or determine it's impossible.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.39417797327041626
final_output reward: 0.5
total reward: 0.8941779732704163
add mutated seed into prompt node list
seed_index: 65
mutated_seed_index: 115
reward = 0.8941779732704163
saving......
in recording...
len prompt_nodes
116
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 70------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:50
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You have the option to remove an element from the current sequence and concatenate the remaining elements together. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the new sequence will be [4, 2, 1]. Your goal is to remove some elements from a to maximize f(a), using zero or more such operations. Determine the maximum possible value of f(

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2924550175666809
final_output reward: 0.2
total reward: 0.4924550175666809
add mutated seed into prompt node list
seed_index: 50
mutated_seed_index: 116
reward = 0.4924550175666809
saving......
in recording...
len prompt_nodes
117
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 71------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:79
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros added to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3303685188293457
final_output reward: 0.4
total reward: 0.7303685188293457
add mutated seed into prompt node list
seed_index: 79
mutated_seed_index: 117
reward = 0.7303685188293457
saving......
in recording...
len prompt_nodes
118
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_71.jsonl
----------------------------------------round: 72------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:51
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s in the array a. For each point (x, y) in the grid, S(x, y) is defined as the square of the Euclidean distance to the nearest telephone pole. This distance is calculated using the formula (x_2 - x_1)^2 + (y_2 - y_1)^2. The project supervisor needs the sum of all S(x, y) values for all points

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor wants the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help by calculating ∑_{x=0}^{n} {∑_{y=0}^{m

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2308661937713623
final_output reward: 0.5
total reward: 0.7308661937713623
add mutated seed into prompt node list
seed_index: 51
mutated_seed_index: 118
reward = 0.7308661937713623
saving......
in recording...
len prompt_nodes
119
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 73------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:53
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element, instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left. You get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
analyst reward: 0.21521061658859253
final_output reward: 0
total reward: 0.21521061658859253
add mutated seed into prompt node list
seed_index: 53
mutated_seed_index: 119
reward = 0.21521061658859253
saving......
in recording...
len prompt_nodes
120
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 74------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:70
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if the original sequence is [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of the subarrays. Determine if it's possible to split the sequence such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS) of

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.27885448932647705
final_output reward: 0.1
total reward: 0.37885448932647703
add mutated seed into prompt node list
seed_index: 70
mutated_seed_index: 120
reward = 0.37885448932647703
saving......
in recording...
len prompt_nodes
121
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 75------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:0
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is denoted by the book title — a string s_i numbered from 1 to n, each having a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.31615114212036133
final_output reward: 0
total reward: 0.31615114212036133
add mutated seed into prompt node list
seed_index: 0
mutated_seed_index: 121
reward = 0.31615114212036133
saving......
in recording...
len prompt_nodes
122
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 76------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:71
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring.

In one step, you can choose any index i and replace s_i with character a or b.

What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Reminder:

The number of occurrences of string d in s as substring is the number of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of times the string ab appears in s as a substring. In the same way, \operatorname{BA}(s) is the number of times ba appears in s as a substring.

In a single operation, you are allowed to choose any index i and change s_i to character a or b.

What is the fewest number of operations needed to make \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The number of times string d appears in s as substring is the count of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.25592994689941406
final_output reward: 0
total reward: 0.25592994689941406
add mutated seed into prompt node list
seed_index: 71
mutated_seed_index: 122
reward = 0.25592994689941406
saving......
in recording...
len prompt_nodes
123
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 77------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:60
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.

--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the way elements are ordered in each part does not change. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.23893439769744873
final_output reward: 0.1
total reward: 0.3389343976974487
add mutated seed into prompt node list
seed_index: 60
mutated_seed_index: 123
reward = 0.3389343976974487
saving......
in recording...
len prompt_nodes
124
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 78------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:89
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You possess an initially empty list of numbers. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — add the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 



Determine the final array after executing all the queries.

--------------------------------------------------
You own an initially blank list of numbers. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 



Determine the final array after executing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts as empty. You need to handle a series of queries, each of which can either add a number to the end of the array or replace all instances of one number with another in the array. After processing all the queries, you need to determine the final state of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.22801047563552856
final_output reward: 0
total reward: 0.22801047563552856
add mutated seed into prompt node list
seed_index: 89
mutated_seed_index: 124
reward = 0.22801047563552856
saving......
in recording...
len prompt_nodes
125
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 79------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:47
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.19515812397003174
final_output reward: 0.3
total reward: 0.4951581239700317
add mutated seed into prompt node list
seed_index: 47
mutated_seed_index: 125
reward = 0.4951581239700317
saving......
in recording...
len prompt_nodes
126
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 80------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:91
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points. If the student does not answer the j-th question correctly, he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya appreciates the challenge and trusts that enhancing this system could provide a more engaging and meaningful learning experience for his students.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points are distributed accordingly. Petya knows the expected points each student should get, which is represented by x_i. He wants to find a distribution of points p such that the difference between the expected points and the actual points each student gets is maximized. This difference is calculated as the sum of the absolute differences for all students, ∑_{i=1}^{

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. P

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.20444625616073608
final_output reward: 0.2
total reward: 0.4044462561607361
add mutated seed into prompt node list
seed_index: 91
mutated_seed_index: 126
reward = 0.4044462561607361
saving......
in recording...
len prompt_nodes
127
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 81------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:56
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert. 

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert. 

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.16851532459259033
final_output reward: 0
total reward: 0.16851532459259033
add mutated seed into prompt node list
seed_index: 56
mutated_seed_index: 127
reward = 0.16851532459259033
saving......
in recording...
len prompt_nodes
128
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_81.jsonl
----------------------------------------round: 82------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:100
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, noting that the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, and its elements can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning the array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$. 2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, noting that the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 1. In this process, first a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with its elements defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning the array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$, then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}. Then each element of the array a_i

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.26122069358825684
final_output reward: 0
total reward: 0.26122069358825684
add mutated seed into prompt node list
seed_index: 100
mutated_seed_index: 128
reward = 0.26122069358825684
saving......
in recording...
len prompt_nodes
129
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 83------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:102
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp is fond of the squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

--------------------------------------------------
Polycarp enjoys the squared and cubed values of positive whole numbers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing, meaning he likes those numbers that are either the square of a positive integer or the cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.387132465839386
final_output reward: 0
total reward: 0.387132465839386
add mutated seed into prompt node list
seed_index: 102
mutated_seed_index: 129
reward = 0.387132465839386
saving......
in recording...
len prompt_nodes
130
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 84------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:115
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia have strict rules on what a successful party is, which is a gathering of exactly 5 people where either all are friends or none are friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people. These people are numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia have strict rules on what a successful party is, which is a gathering of exactly 5 people where either all are friends or none are friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. A party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.39068490266799927
final_output reward: 0
total reward: 0.39068490266799927
add mutated seed into prompt node list
seed_index: 115
mutated_seed_index: 130
reward = 0.39068490266799927
saving......
in recording...
len prompt_nodes
131
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 85------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:93
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; you are given n days from Petya's life and you have to determine what happened with his flower in the end. The flower grows as follows: * If the flower isn't watered for two days in a row, it dies. * If the flower is watered in the i-th day, it grows by 1 centimeter. * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. * If the flower is not watered in the i-th day, it does not grow. At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; you are given n days from Petya's life and you have to determine what happened with his flower in the end. The flower grows as follows: * If the flower isn't watered for two days in a row, it dies. * If the flower is watered in the i-th day, it grows by 1 centimeter. * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. * If the flower is not watered in the i-th day, it does not grow. At the beginning of the 1-st day the flower is 1 centimeter tall. Consider edge cases where Petya has only 1 day or the pattern involves alternating days of watering and not watering. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. Due to his busy schedule, he sometimes neglects to water it, which can be concerning for its growth. You are provided with a timeline of n days, during which you need to track the flower's condition and determine its final height.

The flower's growth pattern is as follows:
- If the flower goes without water for two consecutive days, it will wither and die.
- If the flower is watered on the i-th day, it will grow by 1 centimeter.
- If the flower is watered on both the i-th

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.25066471099853516
final_output reward: 0
total reward: 0.25066471099853516
add mutated seed into prompt node list
seed_index: 93
mutated_seed_index: 131
reward = 0.25066471099853516
saving......
in recording...
len prompt_nodes
132
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 86------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:62
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character, which begins in cell (1, 1) — located at the crossing of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But remember, if the cell has traps, Monocarp's character will die, and the game will end. The goal is for Monocarp's character to reach the end of the grid, which is in

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into traps. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4157955050468445
final_output reward: 0.1
total reward: 0.5157955050468445
add mutated seed into prompt node list
seed_index: 62
mutated_seed_index: 132
reward = 0.5157955050468445
saving......
in recording...
len prompt_nodes
133
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 87------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:44
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3.

You are asked to break exactly one of them into two pieces in such a way that: 

  * both pieces have positive (strictly greater than 0) integer length; 
  * the total length of the pieces is equal to the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 



A square is also considered a rectangle.

Determine if it's possible to do that.

--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3.

You are required to divide one of them into two sections in such a manner that:

  * both sections have positive (strictly greater than 0) integer length; 
  * the total length of the sections matches the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 



A square is also considered a rectangle.

Determine if it's possible to do that.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31299686431884766
final_output reward: 0.2
total reward: 0.5129968643188476
add mutated seed into prompt node list
seed_index: 44
mutated_seed_index: 133
reward = 0.5129968643188476
saving......
in recording...
len prompt_nodes
134
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 88------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:97
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data, you notice that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to create factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles, ranging from 0 to 15, and each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating a rectangular factory construction with dimensions N x M. The data consists of N lines, each containing M numbers representing factory tiles. Each number ranges from 0 to 15, and each number's binary representation indicates the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is correct. Your task is to print the sizes of the factory rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3953070044517517
final_output reward: 0
total reward: 0.3953070044517517
add mutated seed into prompt node list
seed_index: 97
mutated_seed_index: 134
reward = 0.3953070044517517
saving......
in recording...
len prompt_nodes
135
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 89------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:52
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string. These letters don't have to be adjacent; 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. In each turn, he can perform one of two actions:

1. Erase one 'A' and one 'B' from anywhere in the string, regardless of whether they are adjacent.
2. Erase one 'B' and one 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2. The actions are independent, meaning Casimir can choose any of the two actions in each turn.

For instance

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.39445960521698
final_output reward: 0
total reward: 0.39445960521698
add mutated seed into prompt node list
seed_index: 52
mutated_seed_index: 135
reward = 0.39445960521698
saving......
in recording...
len prompt_nodes
136
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 90------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:117
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros added to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

--------------------------------------------------
Monocarp wrote down a couple of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros appended to its end. 

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers, can you assist him in doing so?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.33248353004455566
final_output reward: 0
total reward: 0.33248353004455566
add mutated seed into prompt node list
seed_index: 117
mutated_seed_index: 136
reward = 0.33248353004455566
saving......
in recording...
len prompt_nodes
137
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 91------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:118
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
Mr. Chanek's city can be depicted as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s, and other cells are 0s. The task is to calculate the sum of the squares of the Euclidean distances from each cell in the grid to the nearest telephone pole. 

To optimize the housing complex construction, the project supervisor needs to find the total sum of these distances for all cells in the grid. This involves calculating the distance from each cell to the nearest pole and then summing these distances.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor wants the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Find ∑_{x=0}^{n} {∑_{y=0}^{m} {

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3327941298484802
final_output reward: 0
total reward: 0.3327941298484802
add mutated seed into prompt node list
seed_index: 118
mutated_seed_index: 137
reward = 0.3327941298484802
saving......
in recording...
len prompt_nodes
138
initial_seed_num
46
[False, False, False, False, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:33
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_91.jsonl
----------------------------------------round: 92------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:95
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek has a new game called Dropping Balls, and initially, Mr. Chanek has a grid a of size n × m where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move: * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2, and Mr. Chanek will drop k balls sequentially, each starting from the first row on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns, so determine in which column each ball will end up in (position of the ball after leaving the grid).

--------------------------------------------------
Mr. Chanek has a new game called Dropping Balls, and initially, Mr. Chanek has a grid a of size n × m where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move: * a_{x,y}=1 — the ball will move to the right (the next cell is (x, y + 1)); * a_{x,y}=2 — the ball will move to the bottom (the next cell is (x + 1, y)); * a_{x,y}=3 — the ball will move to the left (the next cell is (x, y - 1)). Every time a ball leaves a cell (x,y), the integer a_{x,y} will change to 2, and Mr. Chanek will drop k balls sequentially, each starting from the first row on the c_1, c_2, ..., c_k-th (1 ≤ c_i ≤ m) columns, so determine in which column each ball will end up in (position of the ball after leaving the grid). Assume the grid is infinite in size in terms of dropping the ball down.

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has developed a captivating game called Dropping Balls. In this game, a grid of size n × m is used, where each cell (x,y) contains an integer a_{x,y} that dictates the direction the ball will take.

The ball's movement is determined by the value of a_{x,y}:
- If a_{x,y} = 1, the ball moves to the right to the next cell (x, y + 1).
- If a_{x,y} = 2, the ball moves downwards to the next cell (x +

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
multi-gen-prompt:
 Mr. Chanek has a new game called Dropping Balls. Initially, Mr. Chanek has a grid of size n × m, where each cell (x,y) contains an integer a_{x,y} denoting the direction of how the ball will move. The ball will move to the right (next cell is (x, y + 1)) if a_{x,y}=1, to the bottom (next cell is (x + 1, y)) if a_{x,y}=2, or to the left (next cell is (x, y - 1)) if a_{x,

Input

The first line contains three integers n, m, and k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10^5) — the size of the grid and the number of balls dropped by Mr. Chanek.

The i-th of the next n lines contains m integers a_{i,1},a_{i,2},…,a_{i,m} (1 ≤ a_{i,j} ≤ 3). It will satisfy a_{i, 1} ≠ 3 and a_{i, m} ≠ 1.

The next line contains k integers c_1, c_2, …, c_k (1 ≤ c_i ≤ m) — the balls' column positions dropped by Mr. Chanek sequentially.

Output

Output k integers — the i-th integer denoting the column where the i-th ball will end.

Examples

Input


5 5 3
1 2 3 3 3
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
1 2 1


Output


2 2 1 


Input


1 2 2
1 3
1 2


Output


1 2 

Note

In the first example, the first ball will drop as follows. Note that the cell (1, 1) will change direction to the bottom direction.

<image>

The second and third balls will drop as follows. 

<image>

All balls will be dropped from the first row and on the c_1, c_2, ..., c_k-th columns respectively. A ball will stop dropping once it leaves the grid.
generating with deepseek-coder
----------updating----------
seed 95 finish fuzzing!
seed_index: 95
mutated_seed_index: 138
current seed length: 32
saving......
in recording...
len prompt_nodes
139
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:32
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 93------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:68
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k). Consider edge cases where k equals 1 or n to ensure the problem constraints are handled appropriately.

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of the sum ∑_{i=1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3756188154220581
final_output reward: 0.4
total reward: 0.7756188154220581
add mutated seed into prompt node list
seed_index: 68
mutated_seed_index: 139
reward = 0.7756188154220581
saving......
in recording...
len prompt_nodes
140
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, False, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:32
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 94------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:101
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given array a_1, a_2, …, a_n, consisting of non-negative integers.

Let's define operation of "elimination" with integer parameter k (1 ≤ k ≤ n) as follows:

  * Choose k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. Select k indices from the array such that 1 ≤ i_1 < i_2 < … < i_k ≤ n. These indices must be distinct and in increasing order.
  * Calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, where \& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). The bitwise AND operation is a binary operation that takes two equal-length binary representations and performs the logical AND operation on each pair of the corresponding bits.
  * Subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}; all other elements remain untouched. 

Find all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.

Note that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.

--------------------------------------------------
You are given array a_1, a_2, …, a_n, consisting of non-negative integers.

Let's define operation of "elimination" with integer parameter k (1 ≤ k ≤ n) as follows:

  * Choose k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. Select k indices from the array such that 1 ≤ i_1 < i_2 < … < i_k ≤ n. These indices must be distinct and in increasing order.
  * Calculate x = a_{i_1} ~ \& ~ a_{i_2} ~ \& ~ … ~ \& ~ a_{i_k}, where \& denotes the [bitwise AND operation](https://en.wikipedia.org/wiki/Bitwise_operation#AND). The bitwise AND operation is a binary operation. It takes two equal-length binary representations and performs the logical AND operation on each pair of the corresponding bits.
  * Subtract x from each of a_{i_1}, a_{i_2}, …, a_{i_k}; all other elements remain untouched. 

Find all possible values of k, such that it's possible to make all elements of array a equal to 0 using a finite number of elimination operations with parameter k. It can be proven that exists at least one possible k for any array a.

Note that you firstly choose k and only after that perform elimination operations with value k you've chosen initially.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, which consists of non-negative integers. The operation of "elimination" is defined with an integer parameter k (1 ≤ k ≤ n). This operation involves choosing k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. The next step is to calculate x as the result of the bitwise AND operation applied to a_{i_1}, a_{i_2}, …, a_{i_k}. This bitwise AND operation is a binary

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, consisting of non-negative integers. Let's define the "elimination" operation with an integer parameter k (1 ≤ k ≤ n) as follows: choose k distinct array indices and calculate the bitwise AND of the elements at these indices, then subtract this result from each of the chosen elements; all other elements remain unchanged. Find all possible values of k such that it's possible to make all elements of the array equal to 0 using a finite number of elimination operations with parameter k.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
generating with deepseek-coder
----------updating----------
seed 101 finish fuzzing!
seed_index: 101
mutated_seed_index: 140
current seed length: 31
saving......
in recording...
len prompt_nodes
141
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 95------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:48
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert landscape filled with deceptive illusions.

The labyrinth's map is structured as a tree, composed of n rooms numbered sequentially from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms.

Each room i (where 1 ≤ i ≤ n) is characterized by an illusion rate, denoted as a_i. The energy required to travel from room x to room y is determined by the formula max(|a_x

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze has n - 1 tunnels connecting rooms, and travel between rooms requires max(|a_x + a_y|, |a_x - a_y|) energy. The maze can alter the illusion rate of any room with queries of type 1, and queries of type 2 ask for the minimum energy needed to reach the treasure in room v from room u.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.38560807704925537
final_output reward: 0
total reward: 0.38560807704925537
add mutated seed into prompt node list
seed_index: 48
mutated_seed_index: 141
reward = 0.38560807704925537
saving......
in recording...
len prompt_nodes
142
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 96------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:116
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value. Remember that the sequence's indices are not adjusted after removing elements.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You have the option to remove an element from the current sequence and concatenate the remaining elements together. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Your goal is to remove some elements from a to maximize f(a), using zero or more operations. Determine the largest possible value of f(a

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3650074005126953
final_output reward: 0
total reward: 0.3650074005126953
add mutated seed into prompt node list
seed_index: 116
mutated_seed_index: 142
reward = 0.3650074005126953
saving......
in recording...
len prompt_nodes
143
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 97------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:104
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has gathered a total of n problems, all of which are new to his students. Each problem is uniquely identified by its topic (an integer from 1 to n) and its difficulty (another integer also ranging from 1 to n).

Monocarp aims to choose exactly 3 problems from these n problems to form a problemset. The selection must meet at least one of the following criteria:

1. The topics of the three selected problems are distinct.
2. The difficulties of the three selected problems are distinct.

Your

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, needs to compose a problemset for a training session. He has n problems, each with a unique topic a_i (integer from 1 to n) and difficulty b_i (integer from 1 to n). He must select exactly 3 problems for the problemset, ensuring they meet at least one of the following conditions: the topics are all different, or the difficulties are all different. The task is to find the number of ways to select these three problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2525235414505005
final_output reward: 0.5
total reward: 0.7525235414505005
add mutated seed into prompt node list
seed_index: 104
mutated_seed_index: 143
reward = 0.7525235414505005
saving......
in recording...
len prompt_nodes
144
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 98------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:103
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that only consists of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that only consists of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Ensure your solution is efficient enough to handle large inputs.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of different non-negative powers of a given number \( n \). For instance, with \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your help to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, considering it modulo 10^9+7 if it's too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.19564074277877808
final_output reward: 0
total reward: 0.19564074277877808
add mutated seed into prompt node list
seed_index: 103
mutated_seed_index: 144
reward = 0.19564074277877808
saving......
in recording...
len prompt_nodes
145
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 99------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:84
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Consider edge cases with strings of length zero and one.

--------------------------------------------------
A string is called square if it is some string written twice in a row. For instance, "aa" is a square string. Moreover, "abcabc", "abab", and "baabaa" are also examples of square strings. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Consider edge cases with strings of length zero and one.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it is composed of two identical consecutive strings. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Non-square examples are "aaa", "abaaab", and "abcdabc". The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.35621339082717896
final_output reward: 0
total reward: 0.35621339082717896
add mutated seed into prompt node list
seed_index: 84
mutated_seed_index: 145
reward = 0.35621339082717896
saving......
in recording...
len prompt_nodes
146
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 100------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:113
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The robot needs to optimize the quantity of commands carried out while staying on the board.

--------------------------------------------------
The robot needs to optimize the quantity of commands carried out while staying on the board. Consider edge cases where commands may lead the robot to the boundary of the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts executing the commands from the first

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. The goal is to determine the cell from which the robot should start its movement to execute the most commands without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.2543407678604126
final_output reward: 0.1
total reward: 0.3543407678604126
add mutated seed into prompt node list
seed_index: 113
mutated_seed_index: 146
reward = 0.3543407678604126
saving......
in recording...
len prompt_nodes
147
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 101------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:125
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate. It is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.22758716344833374
final_output reward: 0
total reward: 0.22758716344833374
add mutated seed into prompt node list
seed_index: 125
mutated_seed_index: 147
reward = 0.22758716344833374
saving......
in recording...
len prompt_nodes
148
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_101.jsonl
----------------------------------------round: 102------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:106
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp wonders if there's a systematic approach to identifying such pairs beyond brute-force methods.

--------------------------------------------------
Monocarp wonders if there's a systematic approach to identifying such pairs beyond brute-force methods. He wonders if there is a more efficient way to achieve this. This curiosity drives him to look for alternatives.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements, denoted as k, is calculated by dividing the sum of all elements by the number of elements (n). Monocarp wants to remove two elements from the array a such that the mean of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i is less than j) in the array a, where removing the elements at these positions will result in the mean of the remaining elements being equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2957528829574585
final_output reward: 0.1
total reward: 0.3957528829574585
add mutated seed into prompt node list
seed_index: 106
mutated_seed_index: 148
reward = 0.3957528829574585
saving......
in recording...
len prompt_nodes
149
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 103------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:110
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large. The solution should consider time complexity effectively for both small and large values of n.

--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. Every single element must be painted with one of these two colors.

One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large. The solution should consider time complexity effectively for both small and large values of n.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 

Situations in which there are no elements of some color at all are also possible. For example,

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same. Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1; or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
generating with deepseek-coder
----------updating----------
analyst reward: 0.32502615451812744
final_output reward: 0
total reward: 0.32502615451812744
add mutated seed into prompt node list
seed_index: 110
mutated_seed_index: 149
reward = 0.32502615451812744
saving......
in recording...
len prompt_nodes
150
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 104------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:112
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a keyboard that consists of 26 keys, and the keys are arranged sequentially in one row in a certain order, each corresponding to a unique lowercase Latin letter, and you have to type the word s on this keyboard, which also consists only of lowercase Latin letters. To type a word consecutively one by one, each letter must be typed over the corresponding key and pressed. Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys, with no time spent on pressing the keys and on placing your hand over the first letter of the word. For example, consider a keyboard where the letters from 'a' to 'z' are arranged in consecutive alphabetical order. The letters 'h', 'e', 'l', and 'o' then are on the positions 8, 5, 12, and 15, respectively, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Determine how long it will take to print the word s.

--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. To enter characters in sequence one after another, every letter is required to be typed by hitting the corresponding key. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, with no time allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order. The letters 'h', 'e', 'l', and 'o' then occupy the positions 8, 5, 12, and 15, respectively, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the time required to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
----------updating----------
analyst reward: 0.30706697702407837
final_output reward: 0
total reward: 0.30706697702407837
add mutated seed into prompt node list
seed_index: 112
mutated_seed_index: 150
reward = 0.30706697702407837
saving......
in recording...
len prompt_nodes
151
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 105------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:120
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if the original sequence is [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence a such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS)

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.27056199312210083
final_output reward: 0.2
total reward: 0.47056199312210084
add mutated seed into prompt node list
seed_index: 120
mutated_seed_index: 151
reward = 0.47056199312210084
saving......
in recording...
len prompt_nodes
152
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 106------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:81
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31161439418792725
final_output reward: 0.1
total reward: 0.4116143941879272
add mutated seed into prompt node list
seed_index: 81
mutated_seed_index: 152
reward = 0.4116143941879272
saving......
in recording...
len prompt_nodes
153
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 107------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:22
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k). 

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) indicate the smallest possible value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k). 

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of the sum ∑_{i=1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3655381202697754
final_output reward: 0.6
total reward: 0.9655381202697754
add mutated seed into prompt node list
seed_index: 22
mutated_seed_index: 153
reward = 0.9655381202697754
saving......
in recording...
len prompt_nodes
154
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 108------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:114
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n items is a list of length n that includes each number from 1 to n precisely once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You have a permutation p consisting of n elements. A permutation of n items is a list of length n that contains each integer from 1 to n exactly once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer ranging from 1 to n. A permutation of n elements is defined as an array of length n that includes each integer from 1 to n exactly once. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will receive a series of queries to perform on this permutation.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.32355499267578125
final_output reward: 0.2
total reward: 0.5235549926757812
add mutated seed into prompt node list
seed_index: 114
mutated_seed_index: 154
reward = 0.5235549926757812
saving......
in recording...
len prompt_nodes
155
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 109------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:153
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) indicate the smallest possible value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k). 

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k). 

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3386955261230469
final_output reward: 0
total reward: 0.3386955261230469
add mutated seed into prompt node list
seed_index: 153
mutated_seed_index: 155
reward = 0.3386955261230469
saving......
in recording...
len prompt_nodes
156
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 110------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:46
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n. The length of each book title is m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

--------------------------------------------------
Andi and Budi were tasked with organizing their shelf containing n books. Each book is represented by the book title — a string s_i numbered from 1 to n. The length of each book title is m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.26485735177993774
final_output reward: 0.3
total reward: 0.5648573517799378
add mutated seed into prompt node list
seed_index: 46
mutated_seed_index: 156
reward = 0.5648573517799378
saving......
in recording...
len prompt_nodes
157
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 111------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:45
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. The numbers are arranged in a particular order. This sequence forms a permutation which spans the entire range from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each student, it is known which questions they have answered correctly and which they have not.

If a student answers the j-th question correctly, they earn p_j points (otherwise, they earn 0 points). The points for the questions are distributed in such a way that the array p consists of numbers from 1 to m, and it is a permutation.

Petya knows that each student expects to score x_i points on the test. To determine the level of surprise at

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. P

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.27847522497177124
final_output reward: 0.5
total reward: 0.7784752249717712
add mutated seed into prompt node list
seed_index: 45
mutated_seed_index: 157
reward = 0.7784752249717712
saving......
in recording...
len prompt_nodes
158
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_111.jsonl
----------------------------------------round: 112------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:123
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the way elements are ordered in each part does not change. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.

--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the way elements are ordered in each part does not change. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.24680346250534058
final_output reward: 0
total reward: 0.24680346250534058
add mutated seed into prompt node list
seed_index: 123
mutated_seed_index: 158
reward = 0.24680346250534058
saving......
in recording...
len prompt_nodes
159
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 113------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:133
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3.

You are required to divide one of them into two sections in such a manner that:

  * both sections have positive (strictly greater than 0) integer length; 
  * the total length of the sections matches the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 



A square is also considered a rectangle.

Determine if it's possible to do that.

--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You are required to divide one of them into two sections in such a manner that both sections have positive (strictly greater than 0) integer length and the total length of the sections matches the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick used as one of the sides. Determine if this is possible.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3215898275375366
final_output reward: 0
total reward: 0.3215898275375366
add mutated seed into prompt node list
seed_index: 133
mutated_seed_index: 159
reward = 0.3215898275375366
saving......
in recording...
len prompt_nodes
160
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 114------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:16
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and the first column. The character can move to nearby cells, either next to each other or by going a little corner. But, if the cell has a trap, Monocarp's character will die, and the game will end. To win the level, Monocarp's character must reach the end, which is in the second row and the nth column.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. There are traps in some cells, and reaching cell (2, n) completes the level. Determine if it is possible for Monocarp to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4236016869544983
final_output reward: 0
total reward: 0.4236016869544983
add mutated seed into prompt node list
seed_index: 16
mutated_seed_index: 160
reward = 0.4236016869544983
saving......
in recording...
len prompt_nodes
161
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 115------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:122
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a string s of length n consisting of characters a and/or b.

Let \operatorname{AB}(s) be the number of times the string ab appears in s as a substring. In the same way, \operatorname{BA}(s) is the number of times ba appears in s as a substring.

In a single operation, you are allowed to choose any index i and change s_i to character a or b.

What is the fewest number of operations needed to make \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The number of times string d appears in s as substring is the count of indices i (1 ≤ i ≤ |s| - |d| + 1) such that substring s_i s_{i + 1} ... s_{i + |d| - 1} is equal to d. For example, \operatorname{AB}(aabbbabaa) = 2 since there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

--------------------------------------------------
You have a string s with a length of n composed of the characters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can select any index i and switch s_i to the character a or b.

What is the minimum number of changes required to make \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.29445987939834595
final_output reward: 0
total reward: 0.29445987939834595
add mutated seed into prompt node list
seed_index: 122
mutated_seed_index: 161
reward = 0.29445987939834595
saving......
in recording...
len prompt_nodes
162
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 116------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:119
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left. You get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

--------------------------------------------------
The next generation external memory incorporates an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it’s cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left. This results in the segment [8, 3, 2] which then substitutes the original components of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
analyst reward: 0.2809094190597534
final_output reward: 0.5
total reward: 0.7809094190597534
add mutated seed into prompt node list
seed_index: 119
mutated_seed_index: 162
reward = 0.7809094190597534
saving......
in recording...
len prompt_nodes
163
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 117------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:39
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp likes squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing. This means counting the number of integers x, where x is a square of a positive integer or a cube of a positive integer (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.3267514109611511
final_output reward: 0.2
total reward: 0.5267514109611511
add mutated seed into prompt node list
seed_index: 39
mutated_seed_index: 163
reward = 0.5267514109611511
saving......
in recording...
len prompt_nodes
164
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 118------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:130
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people. These people are numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia have strict rules on what a successful party is, which is a gathering of exactly 5 people where either all are friends or none are friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people. These people are numbered from 1 to N. There are exactly M pairs of people. These people are friends with each other. The people of Baltia have strict rules on what a successful party is, which is a gathering of exactly 5 people where either all are friends or none are friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.2601606845855713
final_output reward: 0
total reward: 0.2601606845855713
add mutated seed into prompt node list
seed_index: 130
mutated_seed_index: 164
reward = 0.2601606845855713
saving......
in recording...
len prompt_nodes
165
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 119------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:124
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You own an initially blank list of numbers. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 



Determine the final array after executing all the queries.

--------------------------------------------------
You own an initially blank list of numbers. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts as empty. 

You need to handle a series of queries, each of which can be one of two types: 

1. "1 x" - This means you add the number x to the end of the array. 
2. "2 x y" - This means you replace every occurrence of the number x in the array with the number y. 

After processing all the queries, what will be the final state of the array?

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.24296802282333374
final_output reward: 0.1
total reward: 0.3429680228233337
add mutated seed into prompt node list
seed_index: 124
mutated_seed_index: 165
reward = 0.3429680228233337
saving......
in recording...
len prompt_nodes
166
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 120------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:128
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, noting that the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 1. In this process, first a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with its elements defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning the array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$, then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, noting that the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 1. In this process, first a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with its elements defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning the array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$, then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation. Analyze the time complexity of your solution.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}. Then each element of the array a_i

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.25715136528015137
final_output reward: 0
total reward: 0.25715136528015137
add mutated seed into prompt node list
seed_index: 128
mutated_seed_index: 166
reward = 0.25715136528015137
saving......
in recording...
len prompt_nodes
167
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 121------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:157
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. The numbers are arranged in a particular order. This sequence forms a permutation which spans the entire range from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m, arranged in a particular order that spans the entire range from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each student, it is known which questions they have answered correctly and which they have not. If a student answers the j-th question correctly, they earn p_j points (otherwise, they earn 0 points). The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that they expect to get x_i points for the test. Petya wants to find a

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. P

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3036661148071289
final_output reward: 0
total reward: 0.3036661148071289
add mutated seed into prompt node list
seed_index: 157
mutated_seed_index: 167
reward = 0.3036661148071289
saving......
in recording...
len prompt_nodes
168
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_121.jsonl
----------------------------------------round: 122------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:143
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his learners have encountered yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has compiled a diverse set of n problems for an upcoming training session. Each problem is unique, featuring a specific topic (ranging from 1 to n) and a particular difficulty level (also from 1 to n). To ensure a balanced and engaging problem set, Monocarp needs to select exactly 3 problems that meet at least one of the following criteria:

1. The topics of the three selected problems are all distinct.
2. The difficulties of the three selected problems are all distinct.

Your role is to calculate the total number

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, has n problems, each with a unique topic a_i and difficulty b_i. He needs to select exactly 3 problems for a training session, ensuring that at least one of the following conditions is met: the topics of all three selected problems are different, or the difficulties of all three selected problems are different. Determine the number of ways to select these three problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.28573036193847656
final_output reward: 0
total reward: 0.28573036193847656
add mutated seed into prompt node list
seed_index: 143
mutated_seed_index: 168
reward = 0.28573036193847656
saving......
in recording...
len prompt_nodes
169
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 123------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:134
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data, you notice that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the dimensions and number of rooms in the factory. When you look at the data, you notice that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to set up factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles and can range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating a rectangular factory construction with dimensions N x M. The data consists of N lines, each containing M numbers representing factory tiles. These numbers range from 0 to 15 and each can be interpreted in binary form to indicate the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is guaranteed to be correct. Your task is to print the sizes of the factory rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3734279274940491
final_output reward: 0.2
total reward: 0.573427927494049
add mutated seed into prompt node list
seed_index: 134
mutated_seed_index: 169
reward = 0.573427927494049
saving......
in recording...
len prompt_nodes
170
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 124------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:96
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don't have to be adjacent.

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don't have to be adjacent.

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this? Assume that you have unlimited turns to achieve this goal.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

  * He can erase one 'A' and one 'B' from anywhere in the string, regardless of whether they are adjacent.
  * He can erase one 'B' and one 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2. Each turn is independent, and Casimir can choose any of the two actions available.

For

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.37701356410980225
final_output reward: 0
total reward: 0.37701356410980225
add mutated seed into prompt node list
seed_index: 96
mutated_seed_index: 170
reward = 0.37701356410980225
saving......
in recording...
len prompt_nodes
171
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 125------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:127
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert. 

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations to determine the closest feasible split.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of the durations of the concerts as small as possible. The duration of the concert is the sum of the durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.18388736248016357
final_output reward: 0.1
total reward: 0.28388736248016355
add mutated seed into prompt node list
seed_index: 127
mutated_seed_index: 171
reward = 0.28388736248016355
saving......
in recording...
len prompt_nodes
172
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 126------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:93
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; you are given n days from Petya's life and you have to determine what happened with his flower in the end. The flower grows as follows: * If the flower isn't watered for two days in a row, it dies. * If the flower is watered in the i-th day, it grows by 1 centimeter. * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. * If the flower is not watered in the i-th day, it does not grow. At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; you are given n days from Petya's life and you have to determine what happened with his flower in the end. The flower develops as described below: * If the flower isn't watered for two days consecutively, it dies. * If the flower is watered in the i-th day, it grows by 1 centimeter. * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. * If the flower is not watered in the i-th day, it does not grow. At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days, during which you need to track the growth and eventual fate of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes un-watered for two consecutive days, it will wither away. 
  * If the flower is watered on the i-th day, it will increase in height by 1 centimeter. 
  * If the flower is

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.24043595790863037
final_output reward: 0.2
total reward: 0.4404359579086304
add mutated seed into prompt node list
seed_index: 93
mutated_seed_index: 172
reward = 0.4404359579086304
saving......
in recording...
len prompt_nodes
173
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 127------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:136
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp wrote down a couple of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros appended to its end. 

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

--------------------------------------------------
Monocarp jotted a few numbers on a whiteboard. Each number follows a specific pattern: a positive integer x followed by p zeroes at its end. 

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Monocarp then asks you to compare these two numbers, and you are asked to help him with this task.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.353945791721344
final_output reward: 0.5
total reward: 0.853945791721344
add mutated seed into prompt node list
seed_index: 136
mutated_seed_index: 173
reward = 0.853945791721344
saving......
in recording...
len prompt_nodes
174
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 128------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:137
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek's city can be depicted as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
Mr. Chanek's city can be depicted as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), let S(x, y) be defined as the squared Euclidean distance between the nearest pole and (x, y), with the squared Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s, and other cells are 0s. The task is to calculate the sum of the squares of the Euclidean distances from each cell in the grid to the nearest telephone pole. This sum is needed to optimize the housing complex construction plan. Specifically, the supervisor wants the value of the double sum ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor wants the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Find ∑_{x=0}^{n} {∑_{y=0}^{m} {

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.34464991092681885
final_output reward: 0
total reward: 0.34464991092681885
add mutated seed into prompt node list
seed_index: 137
mutated_seed_index: 174
reward = 0.34464991092681885
saving......
in recording...
len prompt_nodes
175
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 129------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:2
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 



Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones. Their mission is to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y. It takes max(|a_x + a_y|, |a_x - a_y|) energy to make this journey. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. 

The labyrinth is structured with n rooms, each numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through multiple tunnels.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. To travel from room x to room y, a tunnel must exist between x and y, and the energy required for this journey is calculated as

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in locating a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changes to the illusion rate of any room. Queries include updating the illusion rate of a room and finding the minimum energy required to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3659623861312866
final_output reward: 0
total reward: 0.3659623861312866
add mutated seed into prompt node list
seed_index: 2
mutated_seed_index: 175
reward = 0.3659623861312866
saving......
in recording...
len prompt_nodes
176
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 130------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:155
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k). 

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) denotes the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum of the sum ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3819695711135864
final_output reward: 0
total reward: 0.3819695711135864
add mutated seed into prompt node list
seed_index: 155
mutated_seed_index: 176
reward = 0.3819695711135864
saving......
in recording...
len prompt_nodes
177
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 131------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:162
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The next generation external memory incorporates an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it’s cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left. This results in the segment [8, 3, 2] which then substitutes the original components of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

--------------------------------------------------
The next generation external memory incorporates an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions. The first action is to select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it’s cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left. This results in the segment [8, 3, 2] which then substitutes the original components of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
analyst reward: 0.2762419581413269
final_output reward: 0
total reward: 0.2762419581413269
add mutated seed into prompt node list
seed_index: 162
mutated_seed_index: 177
reward = 0.2762419581413269
saving......
in recording...
len prompt_nodes
178
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_131.jsonl
----------------------------------------round: 132------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:0
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

--------------------------------------------------
Andi and Budi received a task to organize their shelf containing n books. Each book is identified by the book title — a string s_i numbered from 1 to n, each having length m. Andi wishes to arrange the books in lexicographical ascending order, while Budi wants to arrange them in lexicographical descending order.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.2871609926223755
final_output reward: 0
total reward: 0.2871609926223755
add mutated seed into prompt node list
seed_index: 0
mutated_seed_index: 178
reward = 0.2871609926223755
saving......
in recording...
len prompt_nodes
179
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 133------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:163
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers. Polycarp derives joy from squares and cubes of positive whole numbers. He finds special pleasure in numbers that are either perfect squares or perfect cubes. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing, meaning he likes those numbers that are either a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.35423630475997925
final_output reward: 0
total reward: 0.35423630475997925
add mutated seed into prompt node list
seed_index: 163
mutated_seed_index: 179
reward = 0.35423630475997925
saving......
in recording...
len prompt_nodes
180
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 134------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:160
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level. You need to implement an efficient algorithm to solve this problem considering the constraints.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But it's important to remember that Monocarp can't go outside the grid. There are some cells with traps in them, and if Monocarp's character lands in one of those cells, the game

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. There are traps in some cells, and reaching cell (2, n) completes the level. Determine if it is possible for Monocarp to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4002273678779602
final_output reward: 0
total reward: 0.4002273678779602
add mutated seed into prompt node list
seed_index: 160
mutated_seed_index: 180
reward = 0.4002273678779602
saving......
in recording...
len prompt_nodes
181
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 135------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:108
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Consider edge cases with strings of length zero and one. Ensure to handle strings with special characters appropriately.

--------------------------------------------------
A string is called square if it is some string written twice in a row; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Consider edge cases with strings of length zero and one. Ensure to handle strings with special characters appropriately.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical consecutive strings. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, "aaa", "abaaab", and "abcdabc" are not considered square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.39823514223098755
final_output reward: 0
total reward: 0.39823514223098755
add mutated seed into prompt node list
seed_index: 108
mutated_seed_index: 181
reward = 0.39823514223098755
saving......
in recording...
len prompt_nodes
182
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 136------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:142
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value. Remember that the sequence's indices are not adjusted after removing elements.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the amount of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value. Remember that the sequence's indices are not adjusted after removing elements.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You can select one element from the current sequence and eliminate it, then join the remaining elements together. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Your objective is to remove some elements from a to maximize f(a), using zero or more operations. Determine the maximum possible value of f(a

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.45027005672454834
final_output reward: 0.2
total reward: 0.6502700567245483
add mutated seed into prompt node list
seed_index: 142
mutated_seed_index: 182
reward = 0.6502700567245483
saving......
in recording...
len prompt_nodes
183
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 137------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:154
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have a permutation p consisting of n elements. A permutation of n items is a list of length n that contains each integer from 1 to n exactly once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You have a permutation p consisting of n elements. A permutation of n items is a sequence of length n that includes every integer from 1 to n precisely once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer ranging from 1 to n. A permutation of n elements is defined as an array of length n that includes each integer from 1 to n exactly once. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will receive a series of queries to perform on this permutation.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31276261806488037
final_output reward: 0.1
total reward: 0.41276261806488035
add mutated seed into prompt node list
seed_index: 154
mutated_seed_index: 183
reward = 0.41276261806488035
saving......
in recording...
len prompt_nodes
184
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 138------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:70
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays; for example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if we split the sequence [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence a such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS)

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.25716692209243774
final_output reward: 0.5
total reward: 0.7571669220924377
add mutated seed into prompt node list
seed_index: 70
mutated_seed_index: 184
reward = 0.7571669220924377
saving......
in recording...
len prompt_nodes
185
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 139------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:111
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Consider the possibility of duplicate values in the array a when deriving it from b.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. He only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1,

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the original array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2897952198982239
final_output reward: 0.7
total reward: 0.9897952198982238
add mutated seed into prompt node list
seed_index: 111
mutated_seed_index: 185
reward = 0.9897952198982238
saving......
in recording...
len prompt_nodes
186
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 140------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:29
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The sequence of commands s executed by the robot is given, and each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', triggering movement to the left, right, down, or up, respectively.

The robot can start its movement in any cell, and it executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, and a command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge; if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column), moves right, right, down, left, up, and up, and ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m. The robot can move from its current cell to adjacent cells in four directions: left, right, down, and up. The robot starts executing a sequence of commands s, where each command is represented by one of the symbols 'L', 'R', 'D', or 'U'. If the robot moves beyond the board's edge, it will fall off and the command is not considered successfully executed. The goal is to find the starting cell that allows the robot to execute the maximum number of commands without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. The task is to determine the cell from which the robot should start its movement to execute as many commands as possible without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.20120447874069214
final_output reward: 0
total reward: 0.20120447874069214
add mutated seed into prompt node list
seed_index: 29
mutated_seed_index: 186
reward = 0.20120447874069214
saving......
in recording...
len prompt_nodes
187
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 141------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:159
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You are required to divide one of them into two sections in such a manner that both sections have positive (strictly greater than 0) integer length and the total length of the sections matches the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that.

--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You are required to divide one of them into two sections in such a manner that both sections have positive (strictly greater than 0) integer length. The total length of the sections matches the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick used as one of the sides. Determine if this is possible.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3527824282646179
final_output reward: 0.4
total reward: 0.7527824282646179
add mutated seed into prompt node list
seed_index: 159
mutated_seed_index: 187
reward = 0.7527824282646179
saving......
in recording...
len prompt_nodes
188
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_141.jsonl
----------------------------------------round: 142------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:148
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp wonders if there's a systematic approach to identifying such pairs beyond brute-force methods. He wonders if there is a more efficient way to achieve this. This curiosity drives him to look for alternatives.

--------------------------------------------------
Monocarp wonders if there's a systematic approach to identifying such pairs beyond brute-force methods and if there is a more efficient way to achieve this. This curiosity drives him to look for alternatives.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements is k, which is the sum of all elements divided by n. Monocarp wants to remove two elements from this array so that the mean of the remaining (n - 2) elements is still k. Your task is to find the number of pairs [i, j] (where i < j) such that if the elements at these positions are removed, the mean of the remaining elements will still be k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.28851521015167236
final_output reward: 0
total reward: 0.28851521015167236
add mutated seed into prompt node list
seed_index: 148
mutated_seed_index: 188
reward = 0.28851521015167236
saving......
in recording...
len prompt_nodes
189
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 143------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:117
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros added to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a distinct pattern. The pattern is a positive integer x with p zeros added to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3685051202774048
final_output reward: 0
total reward: 0.3685051202774048
add mutated seed into prompt node list
seed_index: 117
mutated_seed_index: 189
reward = 0.3685051202774048
saving......
in recording...
len prompt_nodes
190
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 144------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:152
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Note that each element in a is positive and distinct.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.35799098014831543
final_output reward: 0
total reward: 0.35799098014831543
add mutated seed into prompt node list
seed_index: 152
mutated_seed_index: 190
reward = 0.35799098014831543
saving......
in recording...
len prompt_nodes
191
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 145------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:169
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the dimensions and number of rooms in the factory. When you look at the data, you notice that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest.

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the dimensions and number of rooms in the factory. When you examine the data, you observe that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to create factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you observe N lines, each containing M numbers. These numbers represent the factory tiles, ranging from 0 to 15, and each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is 1

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating a rectangular construction with dimensions N x M. The data consists of N lines, each containing M numbers representing factory tiles. These numbers range from 0 to 15 and each can be interpreted in binary form to indicate the presence of walls on its sides: North, East, South, and West. The construction is guaranteed to have walls on its edges. Your task is to determine the size of the rooms within the factory and print them from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3581814765930176
final_output reward: 0
total reward: 0.3581814765930176
add mutated seed into prompt node list
seed_index: 169
mutated_seed_index: 191
reward = 0.3581814765930176
saving......
in recording...
len prompt_nodes
192
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 146------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:149
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. Every single element must be painted with one of these two colors.

One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large. The solution should consider time complexity effectively for both small and large values of n.

--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. Every single element must be painted with one of these two colors.

One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large. The solution should consider time complexity effectively for both small and large values of n. Ensure that your solution handles arrays with duplicate integers appropriately.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 

Situations in which there are no elements of some color at all are also possible. For example,

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same. Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1; or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
generating with deepseek-coder
----------updating----------
analyst reward: 0.34447038173675537
final_output reward: 0
total reward: 0.34447038173675537
add mutated seed into prompt node list
seed_index: 149
mutated_seed_index: 192
reward = 0.34447038173675537
saving......
in recording...
len prompt_nodes
193
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 147------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:15
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.

Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers.

Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers and has been given a problem by his teacher, Yeltsa Kcir. The problem involves a sequence that includes only special numbers. A number is considered special if it can be expressed as a sum of different non-negative powers of a given number n. For instance, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, whereas 9 is not. Theofanis needs help in finding the k-th special number in this sequence,

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, considering it modulo 10^9+7 if it's too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\nTheofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet\'s call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).\n\nOutput\n\nFor each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]\n[plan]\n- name: \nBinary Representation Based Solution\n\n- content: \nFor each test case, we can represent the k-th special number as a sum of different non-negative powers of \\( n \\) using its binary representation. Each bit in the binary representation of \\( k \\) indicates whether a particular power of \\( n \\) is included in the sum. For example, if \\( k \\) in binary is 1101, it means the special number is \\( n^3 + n^2 + n^0 \\).\n\nTo solve the problem:\n1. Iterate through the bits of \\( k \\) starting from the least significant bit.\n2. For each bit that is set (i.e., 1), add the corresponding power of \\( n \\) to the result.\n3. Return the result modulo \\( 10^9+7 \\).\n\nThis approach leverages the properties of binary numbers and ensures that we generate special numbers in increasing order.\n\nEdge cases to consider:\n- When \\( k = 1 \\), the smallest special number is always 1.\n- For very large values of \\( n \\) and \\( k \\), ensure that the result is computed modulo \\( 10^9+7 \\).\n\n\n\n## Answer 3:\n\n'}]
----------updating----------
analyst reward: 0.15064334869384766
final_output reward: 0
total reward: 0.15064334869384766
add mutated seed into prompt node list
seed_index: 15
mutated_seed_index: 193
reward = 0.15064334869384766
saving......
in recording...
len prompt_nodes
194
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 148------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:150
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. To enter characters in sequence one after another, every letter is required to be typed by hitting the corresponding key. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, with no time allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order. The letters 'h', 'e', 'l', and 'o' then occupy the positions 8, 5, 12, and 15, respectively, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, with no time allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys, each corresponding to a unique lowercase Latin letter. The keys are arranged sequentially in one row. You need to type the word s on this keyboard, which also consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter is zero. Determine how long it will take to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
----------updating----------
analyst reward: 0.26982688903808594
final_output reward: 0
total reward: 0.26982688903808594
add mutated seed into prompt node list
seed_index: 150
mutated_seed_index: 194
reward = 0.26982688903808594
saving......
in recording...
len prompt_nodes
195
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 149------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:184
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays; for example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. The number of resulting subarrays is denoted by k. The lengths of the longest increasing subsequences of corresponding subarrays are represented by h_1, h_2, …, h_k. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if we split the sequence [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of the subarrays. Determine if it's possible to split the sequence such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS) of

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2804885506629944
final_output reward: 0
total reward: 0.2804885506629944
add mutated seed into prompt node list
seed_index: 184
mutated_seed_index: 195
reward = 0.2804885506629944
saving......
in recording...
len prompt_nodes
196
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 150------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:147
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate. It is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate. It is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes. Make sure to consider edge cases in your solution, such as when n is small or all elements are the same.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.25127846002578735
final_output reward: 0
total reward: 0.25127846002578735
add mutated seed into prompt node list
seed_index: 147
mutated_seed_index: 196
reward = 0.25127846002578735
saving......
in recording...
len prompt_nodes
197
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 151------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:126
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya appreciates the challenge and trusts that enhancing this system could provide a more engaging and meaningful learning experience for his students.

--------------------------------------------------
Petya appreciates the challenge and trusts that enhancing this system could provide a more engaging learning experience for his students. He believes that it has the potential to be much more meaningful. As a result, he's motivated to make improvements.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points are distributed accordingly. Petya knows the expected points each student should get, which is denoted by x_i. He wants to find a distribution of points p such that the difference between the expected points and the actual points each student gets is maximized. The surprise value of the results is calculated as the sum of the absolute differences between the expected points and the actual points

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher with n students who have taken a test with m questions. Each student's performance is known, with a record of which questions they answered correctly. The points for each question are unique and range from 1 to m. Petya wants to maximize the surprise value of the students' test results, defined as ∑_{i=1}^{n} |x_i - r_i|, where x_i is the expected points a student anticipates getting and r_i is the actual points received. Your task is to find a permutation p of the points that maximizes this surprise value

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.1925486922264099
final_output reward: 0
total reward: 0.1925486922264099
add mutated seed into prompt node list
seed_index: 126
mutated_seed_index: 197
reward = 0.1925486922264099
saving......
in recording...
len prompt_nodes
198
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_151.jsonl
----------------------------------------round: 152------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:6
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 



Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

1. Erase exactly one letter 'A' and exactly one letter 'B' from anywhere in the string, regardless of whether they are adjacent.
2. Erase exactly one letter 'B' and exactly one letter 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2, as the two chosen letters are removed. The actions are independent,

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.48683327436447144
final_output reward: 0
total reward: 0.48683327436447144
add mutated seed into prompt node list
seed_index: 6
mutated_seed_index: 198
reward = 0.48683327436447144
saving......
in recording...
len prompt_nodes
199
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 153------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:94
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive (strictly greater than 0) integer length and the total length of the pieces is equal to the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that.

--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive (strictly greater than 0) integer length and the total length of the pieces is equal to the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that. Ensure to evaluate each possible breaking scenario for adherence to the conditions mentioned.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.32846683263778687
final_output reward: 0.3
total reward: 0.6284668326377869
add mutated seed into prompt node list
seed_index: 94
mutated_seed_index: 199
reward = 0.6284668326377869
saving......
in recording...
len prompt_nodes
200
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 154------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:131
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; you are given n days from Petya's life and you have to determine what happened with his flower in the end. The flower grows as follows: * If the flower isn't watered for two days in a row, it dies. * If the flower is watered in the i-th day, it grows by 1 centimeter. * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. * If the flower is not watered in the i-th day, it does not grow. At the beginning of the 1-st day the flower is 1 centimeter tall. Consider edge cases where Petya has only 1 day or the pattern involves alternating days of watering and not watering. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; you are given n days from Petya's life and you have to determine what happened with his flower in the end. The flower grows as follows: * If the flower isn't watered for two days in a row, it dies. * If the flower is watered in the i-th day, it grows by 1 centimeter. * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. * If the flower is not watered in the i-th day, it does not grow. At the beginning of the 1-st day the flower is 1 centimeter tall. Consider edge cases where Petya has only 1 day or the pattern involves alternating days of watering and not watering. What is its height after n days? Ensure that your solution efficiently handles cases with large values of n.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower, but he often neglects to water it. You are provided with a timeline of n days based on Petya's records. Your task is to assess the fate of the flower over these days. 

The flower's growth pattern is as follows: 

  * If the flower goes without water for two consecutive days, it will wither away. 
  * If the flower is watered on the i-th day, it will increase in height by 1 centimeter. 
  * If the flower is watered on both the i-th and the

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.2577672004699707
final_output reward: 0.2
total reward: 0.4577672004699707
add mutated seed into prompt node list
seed_index: 131
mutated_seed_index: 200
reward = 0.4577672004699707
saving......
in recording...
len prompt_nodes
201
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 155------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:164
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people. These people are numbered from 1 to N. There are exactly M pairs of people. These people are friends with each other. The people of Baltia have strict rules on what a successful party is, which is a gathering of exactly 5 people where either all are friends or none are friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people. These people are numbered from 1 to N. There are exactly M pairs of people. These people are friends with each other. The people of Baltia have strict rules on what a successful party is, which is a gathering of exactly 5 people. It can be a gathering where either all are friends or none are friends. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them that

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party with exactly 5 people, considering it successful if all are friends or none are. Help them organize a successful party or determine it's impossible.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.31275588274002075
final_output reward: 0.2
total reward: 0.5127558827400207
add mutated seed into prompt node list
seed_index: 164
mutated_seed_index: 201
reward = 0.5127558827400207
saving......
in recording...
len prompt_nodes
202
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 156------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:158
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. This means that the way elements are ordered in each part does not change. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. The current order of elements in each part does not change after the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x be the last element of the array a. The array a is then partitioned into two parts: a left part containing elements not greater than x, and a right part containing elements strictly greater than x. The order of elements in each part is preserved. The array is then replaced with the concatenation of the left and right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion operation proceeds as follows: [2, 4, 1,

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.23465090990066528
final_output reward: 0
total reward: 0.23465090990066528
add mutated seed into prompt node list
seed_index: 158
mutated_seed_index: 202
reward = 0.23465090990066528
saving......
in recording...
len prompt_nodes
203
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 157------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:2
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 



Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

You need to efficiently handle the queries on a dynamically changing graph.

Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert landscape filled with deceptive illusions.

The labyrinth's map is structured as a tree, composed of n rooms numbered sequentially from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms via multiple tunnels.

Each room i (where 1 ≤ i ≤ n) is characterized by an illusion rate, denoted as a_i. The energy required to travel from room x to room y is determined by the formula max(|

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze can alter the illusion rate of any room. Queries include updating the illusion rate of a room or finding the minimum energy required to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.34495311975479126
final_output reward: 0.1
total reward: 0.44495311975479124
add mutated seed into prompt node list
seed_index: 2
mutated_seed_index: 203
reward = 0.44495311975479124
saving......
in recording...
len prompt_nodes
204
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 158------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:68
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. The function \(c(l, r)\) represents the count of integer pairs. These pairs satisfy both the boundary and gcd conditions. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3617812991142273
final_output reward: 0.4
total reward: 0.7617812991142273
add mutated seed into prompt node list
seed_index: 68
mutated_seed_index: 204
reward = 0.7617812991142273
saving......
in recording...
len prompt_nodes
205
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 159------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:128
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, noting that the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 1. In this process, first a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with its elements defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning the array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$, then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, noting that the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 1. In this process, first a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with its elements defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, meaning the array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$, then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator. For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1]. The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Assume you have unlimited computational resources to simulate this operation. The original array will be reset in every step until it reaches the end of the process.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] containing only zeroes and ones. In each step, the array is replaced by a cyclic shift of itself to the right by d cells, where d is the current step number. Each element of the array is then replaced by the result of a logical "AND" operation with its corresponding element in the shifted array. The process continues until the array consists of only zeroes. Determine if the array will eventually become all zeroes and, if so, find the number of steps required.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3260854482650757
final_output reward: 0
total reward: 0.3260854482650757
add mutated seed into prompt node list
seed_index: 128
mutated_seed_index: 205
reward = 0.3260854482650757
saving......
in recording...
len prompt_nodes
206
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 160------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:161
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have a string s with a length of n composed of the characters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can select any index i and switch s_i to the character a or b.

What is the minimum number of changes required to make \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

--------------------------------------------------
You possess a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31122124195098877
final_output reward: 0.3
total reward: 0.6112212419509888
add mutated seed into prompt node list
seed_index: 161
mutated_seed_index: 206
reward = 0.6112212419509888
saving......
in recording...
len prompt_nodes
207
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 161------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:168
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his learners have encountered yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his learners have encountered yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has gathered a total of n problems, all of which are new to his students. Each problem is uniquely identified by its topic, denoted as a_i (ranging from 1 to n), and its difficulty, represented by b_i (also ranging from 1 to n).

Monocarp aims to choose exactly 3 problems from these n problems to form a problemset. The selection must meet at least one of the following criteria:

1. The topics of the three selected problems are distinct.
2. The difficulties of the

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, needs to compose a problemset for a training session. He has n problems, each with a unique topic a_i (integer from 1 to n) and difficulty b_i (integer from 1 to n). He must select exactly 3 problems for the problemset, ensuring that at least one of the following conditions is met:

  * the topics of all three selected problems are different; 
  * the difficulties of all three selected problems are different. 

Determine the number of ways to select three problems for the problem

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3426804542541504
final_output reward: 0.1
total reward: 0.44268045425415037
add mutated seed into prompt node list
seed_index: 168
mutated_seed_index: 207
reward = 0.44268045425415037
saving......
in recording...
len prompt_nodes
208
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_161.jsonl
----------------------------------------round: 162------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:165
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You own an initially blank list of numbers. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

--------------------------------------------------
You possess a list of numbers that begins as empty. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts as empty. You need to handle a series of queries, each of which can either add a number to the end of the array or replace all instances of one number with another in the array. After processing all the queries, you need to determine the final state of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.24260133504867554
final_output reward: 0
total reward: 0.24260133504867554
add mutated seed into prompt node list
seed_index: 165
mutated_seed_index: 208
reward = 0.24260133504867554
saving......
in recording...
len prompt_nodes
209
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 163------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:160
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid with two rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Assist Monocarp in figuring out if it is feasible to finish the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But remember, if the cell has traps, Monocarp's character will die, and the game will end. The goal is for Monocarp's character to reach the end of the level, which is the

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into a trap. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.40499216318130493
final_output reward: 0.4
total reward: 0.804992163181305
add mutated seed into prompt node list
seed_index: 160
mutated_seed_index: 209
reward = 0.804992163181305
saving......
in recording...
len prompt_nodes
210
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 164------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:182
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the amount of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value. Remember that the sequence's indices are not adjusted after removing elements.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can choose an element from the present sequence and delete it. After deletion, you combine the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value. Remember that the sequence's indices are not adjusted after removing elements.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You have the option to remove an element from the current sequence and concatenate the remaining elements together. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Your goal is to remove some elements from a to maximize f(a), using zero or more operations. Determine the largest possible value of f(a

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.4827302098274231
final_output reward: 0
total reward: 0.4827302098274231
add mutated seed into prompt node list
seed_index: 182
mutated_seed_index: 210
reward = 0.4827302098274231
saving......
in recording...
len prompt_nodes
211
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 165------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:179
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers. Polycarp derives joy from squares and cubes of positive whole numbers. He finds special pleasure in numbers that are either perfect squares or perfect cubes. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers, deriving joy from these numbers. He finds special pleasure in numbers that are either perfect squares or perfect cubes. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing. This means counting the number of integers x, where x is a square of a positive integer or a cube of a positive integer (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.34304946660995483
final_output reward: 0.3
total reward: 0.6430494666099549
add mutated seed into prompt node list
seed_index: 179
mutated_seed_index: 211
reward = 0.6430494666099549
saving......
in recording...
len prompt_nodes
212
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 166------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:174
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek's city can be depicted as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), let S(x, y) be defined as the squared Euclidean distance between the nearest pole and (x, y), with the squared Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He wants to construct a housing complex in the city. There are several telephone poles on the plane, represented by a grid a of dimensions (n + 1) × (m + 1) with a telephone pole located at (x, y) if a_{x, y} = 1. For any given point (x, y), let S(x, y) be the squared Euclidean distance between the nearest pole and (x, y), with the squared Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To enhance the building plan, the project supervisor requests the total of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane, which consists of a grid of size (n + 1) × (m + 1). Within this grid, there are telephone poles indicated by 1s in the grid.

For each point (x, y) in the grid, S(x, y) is defined as the square of the Euclidean distance to the nearest telephone pole. This distance is calculated using the formula (x_2 - x_1)^2 + (y_2 - y_1)^2.

The project supervisor needs the sum of all S(x,

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). To optimize the building plan, the project supervisor asks you the sum of all S(x

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.27142810821533203
final_output reward: 0.1
total reward: 0.371428108215332
add mutated seed into prompt node list
seed_index: 174
mutated_seed_index: 212
reward = 0.371428108215332
saving......
in recording...
len prompt_nodes
213
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 167------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:68
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k). Ensure to explain the edge cases and constraints clearly.

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) denotes the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of ∑_{i=1}^{k}{

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3407752513885498
final_output reward: 0.2
total reward: 0.5407752513885498
add mutated seed into prompt node list
seed_index: 68
mutated_seed_index: 213
reward = 0.5407752513885498
saving......
in recording...
len prompt_nodes
214
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 168------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:180
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level. You need to implement an efficient algorithm to solve this problem considering the constraints.

--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level consists of a rectangular grid with 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level. You need to implement an efficient algorithm to solve this problem considering the constraints.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column. The character can move to nearby cells, either next to each other or by going a little bit further. But, be careful, because some cells have traps, and if Monocarp's character lands in one of those trap-filled cells, the game ends, and Monocarp loses. The goal is for Monocarp's character to reach the

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into traps. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.40579754114151
final_output reward: 0.5
total reward: 0.90579754114151
add mutated seed into prompt node list
seed_index: 180
mutated_seed_index: 214
reward = 0.90579754114151
saving......
in recording...
len prompt_nodes
215
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 169------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:121
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is denoted by the book title — a string s_i numbered from 1 to n, each having a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is denoted by the book title — a string s_i numbered from 1 to n, each having a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

Implement a function that performs this custom sorting on an array of book titles.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.2444269061088562
final_output reward: 0
total reward: 0.2444269061088562
add mutated seed into prompt node list
seed_index: 121
mutated_seed_index: 215
reward = 0.2444269061088562
saving......
in recording...
len prompt_nodes
216
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 170------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:187
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You are required to divide one of them into two sections in such a manner that both sections have positive (strictly greater than 0) integer length. The total length of the sections matches the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that.

--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You are required to divide one of them into two sections in such a manner that both sections have positive (strictly greater than 0) integer length. The total length of the sections matches the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that. When dividing a stick, ensure choosing an optimal division point that facilitates rectangle formation.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3234611749649048
final_output reward: 0
total reward: 0.3234611749649048
add mutated seed into prompt node list
seed_index: 187
mutated_seed_index: 216
reward = 0.3234611749649048
saving......
in recording...
len prompt_nodes
217
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 171------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:98
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1. It is also possible to move if |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game, and now he wants to complete the first level of this game. A level is a rectangular grid consisting of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, so, formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 or |y_1 - y_2| ≤ 1, and obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the beginning, in the first row and first column. The character can move to nearby cells, either next to each other or by going a little corner. But, if the character goes into a cell with traps, Monocarp loses, and the game ends. To win, the character must reach the end, which is the second row and the last column. Can Monocarp help his character reach the end without getting caught in a

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. There are traps in some cells, and reaching cell (2, n) completes the level. Determine if it is possible for Monocarp to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.44638800621032715
final_output reward: 0.1
total reward: 0.5463880062103271
add mutated seed into prompt node list
seed_index: 98
mutated_seed_index: 217
reward = 0.5463880062103271
saving......
in recording...
len prompt_nodes
218
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_171.jsonl
----------------------------------------round: 172------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:38
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is called square if it is a certain string repeated twice in succession. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical consecutive strings. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, examples of non-square strings are "aaa", "abaaab", and "abcdabc". The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3618360757827759
final_output reward: 0
total reward: 0.3618360757827759
add mutated seed into prompt node list
seed_index: 38
mutated_seed_index: 218
reward = 0.3618360757827759
saving......
in recording...
len prompt_nodes
219
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 173------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:198
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don't have to be adjacent. Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

1. Erase exactly one letter 'A' and exactly one letter 'B' from anywhere in the string, regardless of whether they are adjacent.
2. Erase exactly one letter 'B' and exactly one letter 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2, as the two chosen letters are removed. The actions are independent,

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one letter 'A' and exactly one letter 'B' or exactly one letter 'B' and exactly one letter 'C' from the string in each turn. Each turn decreases the length of the string by 2. Determine if there's a sequence of actions that can lead to an empty string.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3654692769050598
final_output reward: 0
total reward: 0.3654692769050598
add mutated seed into prompt node list
seed_index: 198
mutated_seed_index: 219
reward = 0.3654692769050598
saving......
in recording...
len prompt_nodes
220
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 174------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:171
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations to determine the closest feasible split.

--------------------------------------------------
Luntik has decided to try singing. He has a collection of songs with varying durations. Specifically, he has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations. This will determine the closest feasible split.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.17744898796081543
final_output reward: 0.3
total reward: 0.4774489879608154
add mutated seed into prompt node list
seed_index: 171
mutated_seed_index: 220
reward = 0.4774489879608154
saving......
in recording...
len prompt_nodes
221
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 175------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:117
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros added to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

--------------------------------------------------
Monocarp recorded a couple of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros appended to the end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.32789939641952515
final_output reward: 0
total reward: 0.32789939641952515
add mutated seed into prompt node list
seed_index: 117
mutated_seed_index: 221
reward = 0.32789939641952515
saving......
in recording...
len prompt_nodes
222
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 176------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:183
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have a permutation p consisting of n elements. A permutation of n items is a sequence of length n that includes every integer from 1 to n precisely once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You possess a permutation \( p \) made up of \( n \) elements. A permutation of \( n \) items is a sequence of length \( n \) that includes every integer from 1 to \( n \) precisely once, so for example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You need to execute \( q \) queries.

There are two types of queries:

  * 1 x y — swap \( p_x \) and \( p_y \). 
  * 2 i k — display the number that \( i \) will become if we assign \( i = p_i \) k times. 


Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer from 1 to n. A sequence of this nature is referred to as a permutation. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not. You will be handling q queries, each of which can be of two types:

1. Swap the elements at positions x and y in

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3168923854827881
final_output reward: 0
total reward: 0.3168923854827881
add mutated seed into prompt node list
seed_index: 183
mutated_seed_index: 222
reward = 0.3168923854827881
saving......
in recording...
len prompt_nodes
223
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 177------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:185
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. He only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Polycarp only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1,

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the original array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3217881917953491
final_output reward: 0
total reward: 0.3217881917953491
add mutated seed into prompt node list
seed_index: 185
mutated_seed_index: 223
reward = 0.3217881917953491
saving......
in recording...
len prompt_nodes
224
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 178------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:177
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The next generation external memory incorporates an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions. The first action is to select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 2. Then you replace the segment a[l … r] with it’s cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left. This results in the segment [8, 3, 2] which then substitutes the original components of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

--------------------------------------------------
The next generation external memory incorporates an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions. The first action is to select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. These indices are chosen such that they satisfy the given constraint. 2. Then you replace the segment a[l … r] with it’s cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left. This results in the segment [8, 3, 2] which then substitutes the original components of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
analyst reward: 0.23285049200057983
final_output reward: 0
total reward: 0.23285049200057983
add mutated seed into prompt node list
seed_index: 177
mutated_seed_index: 224
reward = 0.23285049200057983
saving......
in recording...
len prompt_nodes
225
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 179------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:85
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp likes squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

--------------------------------------------------
Polycarp enjoys squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a specified integer n, determine how many numbers from 1 to n are among Polycarp’s favorites. Put differently, calculate how many such x exist that x is the square of a positive integer or the cube of a positive integer (or both simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing, meaning he likes those numbers that are either a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.34963250160217285
final_output reward: 0
total reward: 0.34963250160217285
add mutated seed into prompt node list
seed_index: 85
mutated_seed_index: 225
reward = 0.34963250160217285
saving......
in recording...
len prompt_nodes
226
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 180------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:176
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. In this context, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.33224308490753174
final_output reward: 0
total reward: 0.33224308490753174
add mutated seed into prompt node list
seed_index: 176
mutated_seed_index: 226
reward = 0.33224308490753174
saving......
in recording...
len prompt_nodes
227
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 181------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:175
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones. Their mission is to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y. It takes max(|a_x + a_y|, |a_x - a_y|) energy to make this journey. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones. Their mission is to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y. It takes max(|a_x + a_y|, |a_x - a_y|) energy to make this journey. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure! Ensure efficiency due to constraints on the number of rooms and queries.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in searching for a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. 

The labyrinth's map is structured as a tree, composed of n rooms numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms.

Each room i (1 ≤ i ≤ n) is characterized by an illusion rate, denoted as a_i. To navigate from room x to room y, a tunnel must exist between these rooms, and the energy required for this journey is determined

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. Queries include updating the illusion rate of a room and finding the minimum energy required to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.37887507677078247
final_output reward: 0.2
total reward: 0.5788750767707824
add mutated seed into prompt node list
seed_index: 175
mutated_seed_index: 227
reward = 0.5788750767707824
saving......
in recording...
len prompt_nodes
228
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_181.jsonl
----------------------------------------round: 182------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:191
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the dimensions and number of rooms in the factory. When you examine the data, you observe that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest.

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the dimensions and number of rooms in the factory. When you examine the data, you observe that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. Ensure your solution is efficient in both time and space complexity.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to create factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles and can range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating a rectangular factory construction with dimensions N x M. The data consists of N lines, each containing M numbers representing factory tiles. These numbers range from 0 to 15 and each can be interpreted in binary to reveal the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is guaranteed to be correct. Your task is to determine and print the sizes of the factory rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3600146770477295
final_output reward: 0.2
total reward: 0.5600146770477294
add mutated seed into prompt node list
seed_index: 191
mutated_seed_index: 228
reward = 0.5600146770477294
saving......
in recording...
len prompt_nodes
229
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 183------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:29
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. For this problem, consider edge cases where the robot starts near the borders of the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts executing the commands from the first

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. The goal is to determine the cell from which the robot should start its movement to execute the most commands without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.2088850736618042
final_output reward: 0
total reward: 0.2088850736618042
add mutated seed into prompt node list
seed_index: 29
mutated_seed_index: 229
reward = 0.2088850736618042
saving......
in recording...
len prompt_nodes
230
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 184------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:59
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it. You are given n days from Petya's life and you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; given n days from Petya's life, you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days, during which you need to track the growth and eventual fate of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes un-watered for two consecutive days, it will wither away. 
  * If the flower is watered on the i-th day, it will increase in height by 1 centimeter. 
  * If the flower is

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.29305893182754517
final_output reward: 0
total reward: 0.29305893182754517
add mutated seed into prompt node list
seed_index: 59
mutated_seed_index: 230
reward = 0.29305893182754517
saving......
in recording...
len prompt_nodes
231
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 185------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:206
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You possess a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

--------------------------------------------------
You possess a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications. Assume that the input string has a length of at least 2, allowing at least one valid comparison of adjacent characters.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2959641218185425
final_output reward: 0
total reward: 0.2959641218185425
add mutated seed into prompt node list
seed_index: 206
mutated_seed_index: 231
reward = 0.2959641218185425
saving......
in recording...
len prompt_nodes
232
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 186------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:65
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other. This makes it so that they can all talk to each other without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them that it's

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. A party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.307506263256073
final_output reward: 0
total reward: 0.307506263256073
add mutated seed into prompt node list
seed_index: 65
mutated_seed_index: 232
reward = 0.307506263256073
saving......
in recording...
len prompt_nodes
233
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 187------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:188
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp wonders if there's a systematic approach to identifying such pairs beyond brute-force methods and if there is a more efficient way to achieve this. This curiosity drives him to look for alternatives.

--------------------------------------------------
Monocarp is curious if there's a systematic method for finding such pairs beyond brute-force techniques and if a more efficient solution exists. This curiosity drives him to look for alternatives.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements is calculated by dividing the sum of all elements by the number of elements, which is denoted as k. Monocarp wants to remove two elements from this array such that the mean of the remaining (n - 2) elements is still k. Your task is to find the number of pairs of positions [i, j] where i is less than j, and after removing the elements at these positions, the mean of the remaining elements is still k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. The mean of an array is the sum of its elements divided by the number of elements. Monocarp wants to delete exactly two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs of positions [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3076701760292053
final_output reward: 0
total reward: 0.3076701760292053
add mutated seed into prompt node list
seed_index: 188
mutated_seed_index: 233
reward = 0.3076701760292053
saving......
in recording...
len prompt_nodes
234
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 188------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:151
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho is curious about whether the sequence a can be split in a manner such that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k equals 0. It is a question you have to answer whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if the original sequence is [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of the subarrays. Determine if it's possible to split the sequence such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS) of

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.270491361618042
final_output reward: 0.2
total reward: 0.470491361618042
add mutated seed into prompt node list
seed_index: 151
mutated_seed_index: 234
reward = 0.470491361618042
saving......
in recording...
len prompt_nodes
235
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 189------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:192
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. Every single element must be painted with one of these two colors.

One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large. The solution should consider time complexity effectively for both small and large values of n. Ensure that your solution handles arrays with duplicate integers appropriately.

--------------------------------------------------
You have an array of integers a with length n. The array's elements might be either identical or varied.

Each array element has a color, either blue or red. There are no elements without a color in the array. Every single element must be painted with one of these two colors.

One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations where there are no elements of a particular color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large. The solution should consider time complexity effectively for both small and large values of n. Ensure that your solution handles arrays with duplicate integers appropriately.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 

Situations in which there are no elements of some color at all are also possible. For example,

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same. Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1; or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3064383268356323
final_output reward: 0
total reward: 0.3064383268356323
add mutated seed into prompt node list
seed_index: 192
mutated_seed_index: 235
reward = 0.3064383268356323
saving......
in recording...
len prompt_nodes
236
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 190------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:209
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid with two rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Assist Monocarp in figuring out if it is feasible to finish the level.

--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level is a rectangular grid with two rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner; formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Assist Monocarp in figuring out if it is feasible to finish the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But it's important to remember that Monocarp can't go outside the grid. There are some cells with traps in them, and if Monocarp's character lands in one of those cells, the game

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner, but cannot go outside the grid. The goal is to reach (2, n) without landing in a trap cell. Determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4332353472709656
final_output reward: 0
total reward: 0.4332353472709656
add mutated seed into prompt node list
seed_index: 209
mutated_seed_index: 236
reward = 0.4332353472709656
saving......
in recording...
len prompt_nodes
237
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 191------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:143
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different. Alternatively, the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has compiled a diverse set of n problems for an upcoming training session. Each problem is unique, featuring a specific topic (ranging from 1 to n) and a particular difficulty level (also from 1 to n). To ensure a balanced and engaging problemset, Monocarp needs to select exactly 3 problems that meet at least one of the following criteria:

1. The topics of the three selected problems are all distinct.
2. The difficulties of the three selected problems are all distinct.

Your role is to calculate the total number

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, has n problems, each with a unique topic a_i and difficulty b_i. He needs to select exactly 3 problems for a training session, ensuring that at least one of the following conditions is met: the topics of all three selected problems are different, or the difficulties of all three selected problems are different. Determine the number of ways to select these three problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2174014449119568
final_output reward: 0
total reward: 0.2174014449119568
add mutated seed into prompt node list
seed_index: 143
mutated_seed_index: 237
reward = 0.2174014449119568
saving......
in recording...
len prompt_nodes
238
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_191.jsonl
----------------------------------------round: 192------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:194
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, with no time allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys. However, no time is allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the total time required to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
----------updating----------
analyst reward: 0.2930564880371094
final_output reward: 0
total reward: 0.2930564880371094
add mutated seed into prompt node list
seed_index: 194
mutated_seed_index: 238
reward = 0.2930564880371094
saving......
in recording...
len prompt_nodes
239
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 193------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:167
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m, arranged in a particular order that spans the entire range from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly. It is also known which questions he has not answered correctly.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m, arranged in a particular order that spans the entire range from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points for each correct answer are known.

Petya knows that each student expects to get a certain number of points, x_i, for the test. The surprise value of the results for the students is calculated as the sum of the absolute differences between the expected points and the actual points each student has received.

Your task is to help Petya

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher with n students who have taken a test with m questions. Each student's performance is known, with a record of which questions they answered correctly. The points for each question are unique and range from 1 to m. Petya wants to maximize the surprise value of the students' test results, defined as ∑_{i=1}^{n} |x_i - r_i|, where x_i is the expected points a student anticipates getting and r_i is the actual points received. Your task is to find a permutation p of the points that maximizes this surprise value

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.30506396293640137
final_output reward: 0
total reward: 0.30506396293640137
add mutated seed into prompt node list
seed_index: 167
mutated_seed_index: 239
reward = 0.30506396293640137
saving......
in recording...
len prompt_nodes
240
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 194------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:2
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 



Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This structure makes it possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Chanek Jones, a skilled adventurer, has returned to assist his distant relative, Indiana Jones, in an exciting quest to uncover a hidden treasure in a maze buried beneath a desert filled with deceptive illusions. The maze is structured as a tree with n rooms, each numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through multiple tunnels.

Each room i (1 ≤ i ≤ n) has an illusion rate a_i. The energy required to travel from room x to room y is determined by the maximum of the absolute values of the sums and differences of the illusion

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. Queries include updating the illusion rate of a room and finding the minimum energy required to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.390699565410614
final_output reward: 0.1
total reward: 0.490699565410614
add mutated seed into prompt node list
seed_index: 2
mutated_seed_index: 240
reward = 0.490699565410614
saving......
in recording...
len prompt_nodes
241
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 195------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:210
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can choose an element from the present sequence and delete it. After deletion, you combine the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value. Remember that the sequence's indices are not adjusted after removing elements.

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can choose an element from the present sequence and delete it, combining the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations, and find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value, remembering that the sequence's indices are not adjusted after removing elements.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You can select one element from the current sequence and eliminate it, then combine the remaining elements into a new sequence. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Your objective is to remove some elements from a to maximize f(a), using zero or more operations. Determine the maximum possible value of

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.4594493508338928
final_output reward: 0.1
total reward: 0.5594493508338928
add mutated seed into prompt node list
seed_index: 210
mutated_seed_index: 241
reward = 0.5594493508338928
saving......
in recording...
len prompt_nodes
242
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 196------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:9
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You receive an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up solely of zeros and ones. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules:

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be expressed as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It implies that the entire array a^{→ d} can be depicted as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.


For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}. Then each element of the array a_i

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2743867039680481
final_output reward: 0.5
total reward: 0.7743867039680481
add mutated seed into prompt node list
seed_index: 9
mutated_seed_index: 242
reward = 0.7743867039680481
saving......
in recording...
len prompt_nodes
243
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 197------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:242
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You receive an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up solely of zeros and ones. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules:

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be expressed as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It implies that the entire array a^{→ d} can be depicted as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.


For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You receive an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up solely of zeros and ones, noting that in this problem, unlike the others, the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 

1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with the elements of this array expressed as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, implying that the entire array a^{→ d} can be depicted as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$. 

2. Then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n -

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.25028061866760254
final_output reward: 0
total reward: 0.25028061866760254
add mutated seed into prompt node list
seed_index: 242
mutated_seed_index: 243
reward = 0.25028061866760254
saving......
in recording...
len prompt_nodes
244
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 198------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:193
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers.

Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order modulo 10^9+7 since this number may be too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, so his teacher, Yeltsa Kcir, assigned him a task involving a sequence composed solely of special numbers.

A positive number is considered special if it can be expressed as the sum of different non-negative powers of a given number \( n \). For instance, with \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your assistance to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, and output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.3162690997123718
final_output reward: 0
total reward: 0.3162690997123718
add mutated seed into prompt node list
seed_index: 193
mutated_seed_index: 244
reward = 0.3162690997123718
saving......
in recording...
len prompt_nodes
245
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 199------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:125
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

--------------------------------------------------
Mr. Chanek has an array a made up of n integers. The prettiness value of a is defined as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Alternatively, the prettiness value of the array a is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for each pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.22380924224853516
final_output reward: 0
total reward: 0.22380924224853516
add mutated seed into prompt node list
seed_index: 125
mutated_seed_index: 245
reward = 0.22380924224853516
saving......
in recording...
len prompt_nodes
246
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 200------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:38
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is called square if it is some string written twice in a row. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is called square if it is some string written twice in a row; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by writing a string twice in a row. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, "aaa", "abaaab", and "abcdabc" are not considered square. Given a string s, the task is to determine whether it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.31385910511016846
final_output reward: 0
total reward: 0.31385910511016846
add mutated seed into prompt node list
seed_index: 38
mutated_seed_index: 246
reward = 0.31385910511016846
saving......
in recording...
len prompt_nodes
247
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 201------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:198
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don’t have to be adjacent. Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

1. Erase exactly one letter 'A' and exactly one letter 'B' from anywhere in the string, regardless of whether they are adjacent.
2. Erase exactly one letter 'B' and exactly one letter 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2, as these letters are removed. The actions are independent, meaning Casimir

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions: he can erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). Each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.4347383379936218
final_output reward: 0
total reward: 0.4347383379936218
add mutated seed into prompt node list
seed_index: 198
mutated_seed_index: 247
reward = 0.4347383379936218
saving......
in recording...
len prompt_nodes
248
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_201.jsonl
----------------------------------------round: 202------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:199
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive (strictly greater than 0) integer length and the total length of the pieces is equal to the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that. Ensure to evaluate each possible breaking scenario for adherence to the conditions mentioned.

--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers. You are asked to break exactly one of them into two pieces. You must break the stick in such a way that both pieces have positive (strictly greater than 0) integer length and the total length of the pieces is equal to the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that. Ensure to evaluate each possible breaking scenario for adherence to the conditions mentioned.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30652767419815063
final_output reward: 0
total reward: 0.30652767419815063
add mutated seed into prompt node list
seed_index: 199
mutated_seed_index: 248
reward = 0.30652767419815063
saving......
in recording...
len prompt_nodes
249
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 203------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:212
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He wants to construct a housing complex in the city. There are several telephone poles on the plane, represented by a grid a of dimensions (n + 1) × (m + 1) with a telephone pole located at (x, y) if a_{x, y} = 1. For any given point (x, y), let S(x, y) be the squared Euclidean distance between the nearest pole and (x, y), with the squared Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To enhance the building plan, the project supervisor requests the total of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He is interested in building a housing complex within the city. There are several telephone poles on the plane, represented by a grid a of dimensions (n + 1) × (m + 1) with a telephone pole located at (x, y) if a_{x, y} = 1. For any given point (x, y), let S(x, y) be the squared Euclidean distance between the nearest pole and (x, y), with the squared Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To enhance the building plan, the project supervisor requests the total of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s, and other cells are 0s. The task is to calculate the sum of the squares of the Euclidean distances from each cell in the grid to the nearest telephone pole. This sum is needed to optimize the housing complex construction plan. Specifically, you need to find the value of the double sum ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor wants the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help by calculating ∑_{x=0}^{n} {∑_{y=0}^{m

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.27374720573425293
final_output reward: 0
total reward: 0.27374720573425293
add mutated seed into prompt node list
seed_index: 212
mutated_seed_index: 249
reward = 0.27374720573425293
saving......
in recording...
len prompt_nodes
250
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 204------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:39
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp likes squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive numerical values. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing. This means counting the number of integers x, where x is a square of a positive integer or a cube of a positive integer (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.24907684326171875
final_output reward: 0
total reward: 0.24907684326171875
add mutated seed into prompt node list
seed_index: 39
mutated_seed_index: 250
reward = 0.24907684326171875
saving......
in recording...
len prompt_nodes
251
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 205------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:189
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a distinct pattern. The pattern is a positive integer x with p zeros added to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

--------------------------------------------------
Monocarp jotted down a pair of numbers on a whiteboard. Both numbers adhere to a distinct pattern. The pattern is a positive integer x with p zeros added to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively. Keep in mind any edge cases that may arise when comparing numbers with varying lengths of trailing zeros.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3908357620239258
final_output reward: 0
total reward: 0.3908357620239258
add mutated seed into prompt node list
seed_index: 189
mutated_seed_index: 251
reward = 0.3908357620239258
saving......
in recording...
len prompt_nodes
252
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 206------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:68
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. This means that the greatest common divisor of i and j must be greater than or equal to l, for all pairs. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, the GCD of integers i and j is the largest number that divides both i and j without leaving a remainder.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of the sum ∑_{i

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3501492738723755
final_output reward: 0.1
total reward: 0.45014927387237547
add mutated seed into prompt node list
seed_index: 68
mutated_seed_index: 252
reward = 0.45014927387237547
saving......
in recording...
len prompt_nodes
253
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 207------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:202
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given an array a of length n.

Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. The current order of elements in each part does not change after the operation. This means that the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.

For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

--------------------------------------------------
You have an array `a` with a length of `n`.

Let's define the eversion operation. Let `x` be equal to `a_n`. Then array `a` is divided into two sections: left and right. The left section contains elements of `a` that are less than or equal to `x` (≤ `x`). The right section contains elements of `a` that are greater than `x` (> `x`). The order of elements in each section remains the same as before the operation. The current sequence of elements in each portion does not change after the operation. This implies that the partition is stable. Then the array is replaced with the joining of the left and the right sections.

For instance, if the array `a` is [2, 4, 1, 5, 3], the eversion proceeds like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We begin with the array `a` and conduct eversions on this array. We can prove that after several eversions the array `a` ceases to change. Output the minimal number `k` such that the array stops altering after `k` eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.2546257972717285
final_output reward: 0.2
total reward: 0.4546257972717285
add mutated seed into prompt node list
seed_index: 202
mutated_seed_index: 253
reward = 0.4546257972717285
saving......
in recording...
len prompt_nodes
254
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 208------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:178
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Andi and Budi received a task to organize their shelf containing n books. Each book is identified by the book title — a string s_i numbered from 1 to n, each having length m. Andi wishes to arrange the books in lexicographical ascending order, while Budi wants to arrange them in lexicographical descending order.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

--------------------------------------------------
Andi and Budi received a task to organize their shelf containing n books. Each book is identified by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi wishes to arrange the books in lexicographical ascending order, while Budi wants to arrange them in lexicographical descending order.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.23544198274612427
final_output reward: 0.3
total reward: 0.5354419827461243
add mutated seed into prompt node list
seed_index: 178
mutated_seed_index: 254
reward = 0.5354419827461243
saving......
in recording...
len prompt_nodes
255
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 209------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:220
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a collection of songs with varying durations. Specifically, he has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations. This will determine the closest feasible split.

--------------------------------------------------
Luntik has decided to try singing. He has a collection of songs with varying durations, specifically one-minute songs, two-minute songs, and three-minute songs, which he wants to distribute into two concerts with every song included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible.

The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution and use an approach that considers the sum of durations to determine the closest feasible split.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.14509856700897217
final_output reward: 0
total reward: 0.14509856700897217
add mutated seed into prompt node list
seed_index: 220
mutated_seed_index: 255
reward = 0.14509856700897217
saving......
in recording...
len prompt_nodes
256
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 210------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:132
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character, which begins in cell (1, 1) — located at the crossing of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game and he wants to complete the first level, which is a rectangular grid consisting of 2 rows and n columns. Monocarp controls a character starting in cell (1, 1) — located at the crossing of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner; formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. There are traps in some cells, and if Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and the first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But it's important to remember that Monocarp can't go outside the grid. There are some cells with traps in them, and if Monocarp's character lands in one of those cells, the

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into a trap. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.40107452869415283
final_output reward: 0
total reward: 0.40107452869415283
add mutated seed into prompt node list
seed_index: 132
mutated_seed_index: 256
reward = 0.40107452869415283
saving......
in recording...
len prompt_nodes
257
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 211------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:208
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You possess a list of numbers that begins as empty. 

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

--------------------------------------------------
You have a list of numbers that initially is empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts as empty. You need to handle a series of queries, each of which can either add a number to the end of the array or replace all instances of one number with another in the array. After processing all the queries, you need to determine the final state of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.2300686240196228
final_output reward: 0
total reward: 0.2300686240196228
add mutated seed into prompt node list
seed_index: 208
mutated_seed_index: 257
reward = 0.2300686240196228
saving......
in recording...
len prompt_nodes
258
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_211.jsonl
----------------------------------------round: 212------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:190
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Note that each element in a is positive and distinct.

--------------------------------------------------
Polycarp possessed an array a of 3 positive numbers and composed the totals of all non-empty subsequences of this array, sorted them in increasing order, and produced an array b of 7 numbers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Note that each element in a is positive and distinct.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3463926911354065
final_output reward: 0
total reward: 0.3463926911354065
add mutated seed into prompt node list
seed_index: 190
mutated_seed_index: 258
reward = 0.3463926911354065
saving......
in recording...
len prompt_nodes
259
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 213------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:203
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

You need to efficiently handle the queries on a dynamically changing graph.

Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, allowing travel between each pair of rooms through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate, and going from the x-th room to the y-th room, via an existing tunnel, takes max(|a_x + a_y|, |a_x - a_y|) energy, where |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, leading Chanek and Indiana to ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). You need to efficiently handle the queries on a dynamically changing graph. Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in searching for a hidden treasure within a maze located beneath a desert landscape filled with deceptive appearances.

The labyrinth's map is structured as a tree, composed of n rooms numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through these passages.

Each room i (1 ≤ i ≤ n) is characterized by an illusion rate, denoted as a_i. To move from room x to room y, a tunnel must exist between these rooms, and the energy required for this

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. The energy required to travel between rooms x and y is max(|a_x + a_y|, |a_x - a_y|). Queries can update the illusion rate of a room or find the minimum energy to reach a secret treasure from a starting room.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3456314206123352
final_output reward: 0
total reward: 0.3456314206123352
add mutated seed into prompt node list
seed_index: 203
mutated_seed_index: 259
reward = 0.3456314206123352
saving......
in recording...
len prompt_nodes
260
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 214------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:195
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. The number of resulting subarrays is denoted by k. The lengths of the longest increasing subsequences of corresponding subarrays are represented by h_1, h_2, …, h_k. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n and now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. The number of resulting subarrays is denoted by k. The lengths of the longest increasing subsequences of corresponding subarrays are represented by h_1, h_2, …, h_k. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0, and you have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}, and for example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Your task is to implement a function that efficiently checks the possibility based on the above conditions.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if we split the sequence [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence a such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS)

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31337618827819824
final_output reward: 0.3
total reward: 0.6133761882781983
add mutated seed into prompt node list
seed_index: 195
mutated_seed_index: 260
reward = 0.6133761882781983
saving......
in recording...
len prompt_nodes
261
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 215------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:20
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Because from each number you know on which side the tile has walls. For example number 10 in it's binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on it's edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. 

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M.

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Each of these numbers should be assessed by converting them into binary. Because from each number you know on which side the tile has walls. For example number 10 in it's binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West.

It is guaranteed that the construction always has walls on it's edges. The input will be correct.

Your task is to print the size of the rooms from biggest to smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to create factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles and can range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating the dimensions of a factory construction in rectangle shape: N x M. The data consists of N lines, each containing M numbers representing factory tiles. Each number can range from 0 to 15, and each number's binary representation indicates the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is correct. Your task is to print the sizes of the rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3201236128807068
final_output reward: 0.1
total reward: 0.42012361288070676
add mutated seed into prompt node list
seed_index: 20
mutated_seed_index: 261
reward = 0.42012361288070676
saving......
in recording...
len prompt_nodes
262
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 216------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:41
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but [1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] do not qualify as permutations. Your task is to handle q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer ranging from 1 to n. A permutation of n elements is defined as an array of length n that includes each integer from 1 to n exactly once. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will receive a series of queries to execute.

The

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 







































Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3092835545539856
final_output reward: 0
total reward: 0.3092835545539856
add mutated seed into prompt node list
seed_index: 41
mutated_seed_index: 262
reward = 0.3092835545539856
saving......
in recording...
len prompt_nodes
263
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 217------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:230
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; given n days from Petya's life, you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; given n days from Petya's life, you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days? Consider edge cases where n is very small or where the pattern of watering is such that the flower dies early.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days during which you need to track the growth and well-being of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes without water for two consecutive days, it will wither and die. 
  * Each day the flower is watered, it will grow by 1 centimeter. 
  * If the flower is watered on both the i-th and

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.29639434814453125
final_output reward: 0.4
total reward: 0.6963943481445313
add mutated seed into prompt node list
seed_index: 230
mutated_seed_index: 263
reward = 0.6963943481445313
saving......
in recording...
len prompt_nodes
264
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 218------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:232
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other. This makes it so that they can all talk to each other without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party with strict rules on what a party is and when it's successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it's considered successful if either all the people at the party are friends with each other and can all talk without worrying, or no two people at the party are friends with each other (so everyone can just be on their phones without bothering anyone else). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them that it's

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.29395830631256104
final_output reward: 0.2
total reward: 0.49395830631256105
add mutated seed into prompt node list
seed_index: 232
mutated_seed_index: 264
reward = 0.49395830631256105
saving......
in recording...
len prompt_nodes
265
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 219------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:198
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent), therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

  * He can erase one 'A' and one 'B' from anywhere in the string, regardless of whether they are adjacent.
  * He can erase one 'B' and one 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2. Each turn is independent, meaning Casimir can choose any of the two actions available.

For

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or exactly one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.4082346558570862
final_output reward: 0
total reward: 0.4082346558570862
add mutated seed into prompt node list
seed_index: 198
mutated_seed_index: 265
reward = 0.4082346558570862
saving......
in recording...
len prompt_nodes
266
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 220------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:7
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n].

This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.

Technically, each cyclic shift consists of two consecutive actions: 

  1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. 
  2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. 



For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5].

Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.

--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n].

This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.

Technically, each cyclic shift consists of two consecutive actions:

  1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment.
  2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.

For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5].

Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Ensure your solution efficiently uses the cyclic shifts for optimal sorting.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
analyst reward: 0.28859347105026245
final_output reward: 0.1
total reward: 0.38859347105026243
add mutated seed into prompt node list
seed_index: 7
mutated_seed_index: 266
reward = 0.38859347105026243
saving......
in recording...
len prompt_nodes
267
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 221------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:99
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of the sum ∑_{i=1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3107157349586487
final_output reward: 0.4
total reward: 0.7107157349586487
add mutated seed into prompt node list
seed_index: 99
mutated_seed_index: 267
reward = 0.7107157349586487
saving......
in recording...
len prompt_nodes
268
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_221.jsonl
----------------------------------------round: 222------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:156
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Andi and Budi were tasked with organizing their shelf containing n books. Each book is represented by the book title — a string s_i numbered from 1 to n. The length of each book title is m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

--------------------------------------------------
Andi and Budi were tasked with organizing their shelf containing n books. Each book is represented by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.23212283849716187
final_output reward: 0
total reward: 0.23212283849716187
add mutated seed into prompt node list
seed_index: 156
mutated_seed_index: 268
reward = 0.23212283849716187
saving......
in recording...
len prompt_nodes
269
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 223------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:243
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You receive an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up solely of zeros and ones, noting that in this problem, unlike the others, the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 

1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with the elements of this array expressed as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, implying that the entire array a^{→ d} can be depicted as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$. 

2. Then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You receive an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up solely of zeros and ones, noting that in this problem, unlike the others, the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 

1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with the elements of this array expressed as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, implying that the entire array a^{→ d} can be depicted as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$. 

2. Then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Consider edge cases where the array may already consist entirely of zeros initially.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}. Then each element of the array a_i

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2988411784172058
final_output reward: 0
total reward: 0.2988411784172058
add mutated seed into prompt node list
seed_index: 243
mutated_seed_index: 269
reward = 0.2988411784172058
saving......
in recording...
len prompt_nodes
270
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 224------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:186
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The sequence of commands s executed by the robot is given, and each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', triggering movement to the left, right, down, or up, respectively.

The robot can start its movement in any cell, and it executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, and a command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge; if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column), moves right, right, down, left, up, and up, and ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

--------------------------------------------------
The robot is situated on a checkered rectangular board measuring n × m (n rows and m columns). The rows are numbered from 1 to n from the top to the bottom, and the columns are numbered from 1 to m from left to right.

The sequence of commands s executed by the robot is given, and each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', triggering movement to the left, right, down, or up, respectively.

The robot can start its movement in any cell, and it executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, and a command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge; if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot begins from cell (2, 1) (second row, first column), proceeds right, right, down, left, up, and up, and finishes in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, with each command represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts its movement from any cell on the

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. Determine the cell from which the robot should start its movement to execute as many commands as possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.19196593761444092
final_output reward: 0.3
total reward: 0.4919659376144409
add mutated seed into prompt node list
seed_index: 186
mutated_seed_index: 270
reward = 0.4919659376144409
saving......
in recording...
len prompt_nodes
271
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 225------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:241
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can choose an element from the present sequence and delete it, combining the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations, and find the largest possible f(a). Your task is to determine the strategy to achieve this maximum value, remembering that the sequence's indices are not adjusted after removing elements.

--------------------------------------------------
Mr. Chanek provides you with a sequence a enumerated from 1 to n. Define f(a) as the number of indices where a_i = i. You can select an item from the current sequence and remove it, merging the leftover elements together. For example, if you extract the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to excise some elements from a to enhance f(a), using zero or more actions, and identify the largest attainable f(a). Your task is to determine the strategy to achieve this maximum value, remembering that the sequence's indices are not adjusted after removing elements.

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You have the option to remove an element from the current sequence and then concatenate the remaining elements. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the new sequence will be [4, 2, 1]. Your goal is to remove some elements from a to maximize f(a), using zero or more operations. Determine the maximum possible value of f(a

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.4787238836288452
final_output reward: 0
total reward: 0.4787238836288452
add mutated seed into prompt node list
seed_index: 241
mutated_seed_index: 271
reward = 0.4787238836288452
saving......
in recording...
len prompt_nodes
272
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 226------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:263
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; given n days from Petya's life, you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days? Consider edge cases where n is very small or where the pattern of watering is such that the flower dies early.

--------------------------------------------------
Petya has got an interesting flower and is a busy person, so he sometimes forgets to water it; given n days from Petya's life, you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two days in a row, it dies.
  * If the flower is watered in the i-th day, it grows by 1 centimeter.
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1.
  * If the flower is not watered in the i-th day, it does not grow.

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days? Consider edge cases where n is very small or where the pattern of watering is such that the flower dies early. Validate your solution with various input scenarios to ensure accuracy.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days, during which you need to track the growth and well-being of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes without water for two consecutive days, it will wither and die. 
  * Each day the flower is watered, it will grow by 1 centimeter. 
  * If the flower is watered on both the i-th

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.25353479385375977
final_output reward: 0
total reward: 0.25353479385375977
add mutated seed into prompt node list
seed_index: 263
mutated_seed_index: 272
reward = 0.25353479385375977
saving......
in recording...
len prompt_nodes
273
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 227------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:218
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
A string is called square if it is a certain string repeated twice in succession. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square.

--------------------------------------------------
A string is called square if it is a certain string repeated twice in succession. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Ensure your solution achieves the desired efficiency for large inputs.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it is composed of two identical consecutive strings. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, non-square examples are "aaa", "abaaab", and "abcdabc". The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3168136477470398
final_output reward: 0
total reward: 0.3168136477470398
add mutated seed into prompt node list
seed_index: 218
mutated_seed_index: 273
reward = 0.3168136477470398
saving......
in recording...
len prompt_nodes
274
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 228------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:197
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya appreciates the challenge and trusts that enhancing this system could provide a more engaging learning experience for his students. He believes that it has the potential to be much more meaningful. As a result, he's motivated to make improvements.

--------------------------------------------------
Petya appreciates the challenge and trusts that enhancing this system could provide a more engaging learning experience for his students. He believes that it has the potential to be much more meaningful. He thinks that its usefulness could be significantly improved. Therefore, Petya is motivated to make improvements.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points are distributed accordingly. Petya knows the expected points each student should get, which is represented by x_i. He wants to find a permutation p that maximizes the surprise value of the results, which is calculated as the sum of the absolute differences between the expected points (x_i) and the actual points received (r_i) by each student.


Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. P

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.23669147491455078
final_output reward: 0
total reward: 0.23669147491455078
add mutated seed into prompt node list
seed_index: 197
mutated_seed_index: 274
reward = 0.23669147491455078
saving......
in recording...
len prompt_nodes
275
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 229------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:233
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is curious if there's a systematic method for finding such pairs beyond brute-force techniques and if a more efficient solution exists. This curiosity drives him to look for alternatives.

--------------------------------------------------
Monocarp is curious if there's a systematic method for finding such pairs beyond brute-force techniques and if a more efficient solution exists. This curiosity is something that constantly motivates him. It drives him to look for alternatives.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements, denoted as k, is calculated by dividing the sum of all elements by the number of elements (n). Monocarp wants to remove two elements from the array a such that the mean of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i is less than j) in the array a, where removing the elements at these positions will result in the mean of the remaining elements being equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.29802948236465454
final_output reward: 0
total reward: 0.29802948236465454
add mutated seed into prompt node list
seed_index: 233
mutated_seed_index: 275
reward = 0.29802948236465454
saving......
in recording...
len prompt_nodes
276
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 230------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:231
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You possess a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications. Assume that the input string has a length of at least 2, allowing at least one valid comparison of adjacent characters.

--------------------------------------------------
You possess a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications. Assume that the input string has a length of at least 2, allowing at least one valid comparison of adjacent characters. To achieve this balance, consider the impact of each modification on both \operatorname{AB}(s) and \operatorname{BA}(s).

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3280978798866272
final_output reward: 0.2
total reward: 0.5280978798866272
add mutated seed into prompt node list
seed_index: 231
mutated_seed_index: 276
reward = 0.5280978798866272
saving......
in recording...
len prompt_nodes
277
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 231------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:214
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level consists of a rectangular grid with 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level. You need to implement an efficient algorithm to solve this problem considering the constraints.

--------------------------------------------------
Monocarp is participating in a computer game. Now he intends to finish the first stage of this game.

A level consists of a rectangular grid with 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. It is clear that it is prohibited to go outside the grid. Under no circumstances should the character step outside the boundaries of the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level. You need to implement an efficient algorithm to solve this problem considering the constraints.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But remember, if the cell has traps, Monocarp's character will die, and the game will end. The goal is for Monocarp's character to reach the end of the grid, which is in

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. There are traps in some cells, and reaching cell (2, n) completes the level. Determine if it is possible for Monocarp to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.44486403465270996
final_output reward: 0
total reward: 0.44486403465270996
add mutated seed into prompt node list
seed_index: 214
mutated_seed_index: 277
reward = 0.44486403465270996
saving......
in recording...
len prompt_nodes
278
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_231.jsonl
----------------------------------------round: 232------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:226
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. In this context, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. In this context, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j. In this specific instance, the term \operatorname{gcd}(i, j) indicates the greatest common divisor (GCD). It is the largest positive integer that divides both i and j without leaving a remainder. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) denotes the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum of the sum ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3529435992240906
final_output reward: 0
total reward: 0.3529435992240906
add mutated seed into prompt node list
seed_index: 226
mutated_seed_index: 278
reward = 0.3529435992240906
saving......
in recording...
len prompt_nodes
279
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 233------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:216
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You are required to divide one of them into two sections in such a manner that both sections have positive (strictly greater than 0) integer length. The total length of the sections matches the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that. When dividing a stick, ensure choosing an optimal division point that facilitates rectangle formation.

--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You must separate one of them into two pieces in such a way that both pieces possess positive (strictly greater than 0) integer length. The combined length of the pieces equals the stick's original length; it's feasible to build a rectangle with the resulting four sticks so that each stick acts as exactly one of its sides. A square is also regarded as a rectangle. Determine if it's achievable to accomplish that. When dividing a stick, ensure selecting an optimal division point that aids rectangle formation.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3434695601463318
final_output reward: 0.2
total reward: 0.5434695601463317
add mutated seed into prompt node list
seed_index: 216
mutated_seed_index: 279
reward = 0.5434695601463317
saving......
in recording...
len prompt_nodes
280
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, False, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:31
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 234------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:74
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large.

--------------------------------------------------
You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element in the array is painted in either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1;
  * or you can select any red element and increase its value by 1.

Situations in which there are no elements of some color at all are also possible. For example, if the whole array is colored blue or red, one of the operations becomes unavailable.

Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

In other words, check whether there exists a sequence of steps (possibly empty) such that after applying it, the array a contains in some order all numbers from 1 to n (inclusive), each exactly once. Consider edge cases where n is very small or very large.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 

Situations in which there are no elements of some color at all are also possible. For example,

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same. Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1; or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
generating with deepseek-coder
----------updating----------
seed 74 finish fuzzing!
seed_index: 74
mutated_seed_index: 280
current seed length: 30
saving......
in recording...
len prompt_nodes
281
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 235------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:244
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order modulo 10^9+7 since this number may be too large.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order modulo 10^9+7 since this number may be too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of different non-negative powers of a given number \( n \). For instance, when \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your help to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, considering it modulo 10^9+7 if it's too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.3311064839363098
final_output reward: 0
total reward: 0.3311064839363098
add mutated seed into prompt node list
seed_index: 244
mutated_seed_index: 281
reward = 0.3311064839363098
saving......
in recording...
len prompt_nodes
282
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 236------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:24
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. He will split the sequence a into one or more consecutive subarrays. The sequence will be split such that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5]. It has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if the original sequence is [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence a such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS)

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.29113495349884033
final_output reward: 0.1
total reward: 0.3911349534988403
add mutated seed into prompt node list
seed_index: 24
mutated_seed_index: 282
reward = 0.3911349534988403
saving......
in recording...
len prompt_nodes
283
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 237------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:250
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Polycarp enjoys squares and cubes of positive numerical values. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive numerical values. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure your solution is efficient for large values of n.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with the following sequence of numbers he likes: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp likes. This means counting the number of integers x that are either a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.26780664920806885
final_output reward: 0.2
total reward: 0.46780664920806886
add mutated seed into prompt node list
seed_index: 250
mutated_seed_index: 283
reward = 0.46780664920806886
saving......
in recording...
len prompt_nodes
284
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 238------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:261
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M.

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Each of these numbers should be assessed by converting them into binary. Because from each number you know on which side the tile has walls. For example number 10 in it's binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West.

It is guaranteed that the construction always has walls on it's edges. The input will be correct.

Your task is to print the size of the rooms from biggest to smallest.

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M.

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls. For example number 10 in it's binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West.

It is guaranteed that the construction always has walls on it's edges. The input will be correct.

Your task is to print the size of the rooms from biggest to smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to create factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles and can range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating a rectangular factory construction with dimensions N x M. The data consists of N lines, each containing M numbers representing factory tiles. These numbers range from 0 to 15 and each can be interpreted in binary form to indicate the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is guaranteed to be correct. Your task is to print the sizes of the factory rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3543074131011963
final_output reward: 0.2
total reward: 0.5543074131011962
add mutated seed into prompt node list
seed_index: 261
mutated_seed_index: 284
reward = 0.5543074131011962
saving......
in recording...
len prompt_nodes
285
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 239------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:221
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp recorded a couple of numbers on a whiteboard. Both numbers adhere to a distinct pattern: a positive integer x with p zeros appended to the end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any necessary operations you might need to compare numbers of this form effectively.

--------------------------------------------------
Monocarp recorded a couple of numbers on a whiteboard, and both numbers adhere to a distinct pattern: a positive integer x with p zeros appended to the end. Now Monocarp asks you to compare these two numbers—can you help him by considering any necessary operations you might need to compare numbers of this form effectively?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3174450993537903
final_output reward: 0.1
total reward: 0.41744509935379026
add mutated seed into prompt node list
seed_index: 221
mutated_seed_index: 285
reward = 0.41744509935379026
saving......
in recording...
len prompt_nodes
286
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 240------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:237
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different. Alternatively, the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i, which is an integer from 1 to n. The i-th problem also has a difficulty b_i, which is an integer from 1 to n. All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different. Alternatively, the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has compiled a diverse set of n problems for an upcoming training session. Each problem is unique, featuring a specific topic (ranging from 1 to n) and a particular difficulty level (also from 1 to n). To ensure a balanced and engaging problem set, Monocarp must select exactly 3 problems that meet at least one of the following criteria:

1. The topics of the three selected problems are all distinct.
2. The difficulties of the three selected problems are all distinct.

Your objective is to calculate the total number of

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, has n problems, each with a unique topic a_i and difficulty b_i. He needs to select exactly 3 problems for a training session, ensuring that the selected problems satisfy at least one of the following conditions: the topics of all three are different, or the difficulties of all three are different. Determine the number of ways to select these three problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2092360258102417
final_output reward: 0
total reward: 0.2092360258102417
add mutated seed into prompt node list
seed_index: 237
mutated_seed_index: 286
reward = 0.2092360258102417
saving......
in recording...
len prompt_nodes
287
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 241------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:240
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This structure makes it possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, assisting his long-lost relative Indiana Jones, to discover a hidden treasure in a maze buried beneath a desert filled with illusions.

The map of the labyrinth forms a graph with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This structure makes it possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it requires max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. The labyrinth's map is structured as a tree, consisting of n rooms numbered from 1 to n, interconnected by n - 1 tunnels that allow travel between any two rooms.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. The energy required to traverse from room x to room y is determined by the maximum of the absolute values of the sums and differences between the illusion rates

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. Queries can update the illusion rate of a room or find the minimum energy needed to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.37541449069976807
final_output reward: 0
total reward: 0.37541449069976807
add mutated seed into prompt node list
seed_index: 240
mutated_seed_index: 287
reward = 0.37541449069976807
saving......
in recording...
len prompt_nodes
288
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_241.jsonl
----------------------------------------round: 242------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:264
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party with strict rules on what a party is and when it's successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it's considered successful if either all the people at the party are friends with each other and can all talk without worrying, or no two people at the party are friends with each other (so everyone can just be on their phones without bothering anyone else). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party with strict rules on what a party is and when it's successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it's considered successful if either all the people at the party are friends with each other and can all talk without worrying about anything at all, or no two people at the party are friends with each other (so everyone can just be on their phones without bothering anyone else). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\n On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no\n\nInput\n\nThe first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).\n\nOutput\n\nIf it\'s possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it\'s not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n[plan]\n- name: \nBrute Force Search\n\n- content: \nThe brute force approach involves checking all possible combinations of 5 people from the list of N people to see if they form a successful party. This can be done using a nested loop to generate all combinations of 5 people and then checking if all people in the combination are friends or if none are friends. If a successful party is found, the combination is printed. If no successful party is found after checking all combinations, -1 is printed.\n\n**Solution Approach:**\n1. Generate all possible combinations of 5 people from the list of N people.\n2. For each combination, check if all people in the combination are friends or if none are friends.\n3. If a successful party is found, print the combination.\n4. If no successful party is found after checking all combinations, print -1.\n\n**Handling Edge Cases:**\n- The solution handles cases where there are fewer than 5 people or fewer than the required number of friendships to form a successful party.\n- It ensures that each pair of friends is unique and does not repeat.\n- It accounts for self-friendships by allowing a person to be friends with themselves.\n\n\n\n## Answer 3:\n\n'}]
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\n On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no\n\nInput\n\nThe first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).\n\nOutput\n\nIf it\'s possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it\'s not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n[plan]\n- name: \nBrute Force Search\n\n- content: \nThe brute force approach involves checking all possible combinations of 5 people from the list of N people to see if they form a successful party. This can be done using a nested loop to generate all combinations of 5 people and then checking if all people in the combination are friends or if none are friends. If a successful party is found, the combination is printed. If no successful party is found after checking all combinations, -1 is printed.\n\n**Solution Approach:**\n1. Generate all possible combinations of 5 people from the list of N people.\n2. For each combination, check if all people in the combination are friends or if none are friends.\n3. If a successful party is found, print the combination.\n4. If no successful party is found after checking all combinations, print -1.\n\n**Handling Edge Cases:**\n- The solution handles cases where there are fewer than 5 people or fewer than the required number of friendships to form a successful party.\n- It ensures that each pair of friends is unique and does not repeat.\n- It accounts for self-friendships by allowing a person to be friends with themselves.\n\n\n\n## Answer 3:\n\n'}]
----------updating----------
analyst reward: 0.3703228235244751
final_output reward: 0
total reward: 0.3703228235244751
add mutated seed into prompt node list
seed_index: 264
mutated_seed_index: 288
reward = 0.3703228235244751
saving......
in recording...
len prompt_nodes
289
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 243------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:238
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys. However, no time is allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, but no time is allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the time required to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\n You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.\n\nYou have to type the word s on this keyboard. It also consists only of lowercase Latin letters.\n\nTo type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.\n\nMoving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nThe first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from \'a\' to \'z\' appears exactly once on the keyboard.\n\nThe second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.\n\nExample\n\nInput\n\n\n5\nabcdefghijklmnopqrstuvwxyz\nhello\nabcdefghijklmnopqrstuvwxyz\ni\nabcdefghijklmnopqrstuvwxyz\ncodeforces\nqwertyuiopasdfghjklzxcvbnm\nqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\nqwertyuiopasdfghjklzxcvbnm\nabacaba\n\n\nOutput\n\n\n13\n0\n68\n0\n74\n[plan]\n- name: \nBrute Force Solution\n\n- content: \nThis solution involves a brute-force approach where we manually calculate the position of each character in the word `s` on the given keyboard for each test case.\n\n**Steps:**\n1. For each test case, iterate through the word `s`.\n2. For each character, find its position in the keyboard by iterating through the keyboard string.\n3. Calculate the time to move from the current position to the next position based on the absolute difference.\n4. Sum up all the times for the word and output the total time for each test case.\n\nThis solution ensures functional correctness by addressing all possible valid inputs and edge cases, including repeated letters and empty words, as it directly calculates the time for each character transition.\n\n\n\n## Answer 3:\n\n'}]
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\n You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.\n\nYou have to type the word s on this keyboard. It also consists only of lowercase Latin letters.\n\nTo type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.\n\nMoving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nThe first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from \'a\' to \'z\' appears exactly once on the keyboard.\n\nThe second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.\n\nExample\n\nInput\n\n\n5\nabcdefghijklmnopqrstuvwxyz\nhello\nabcdefghijklmnopqrstuvwxyz\ni\nabcdefghijklmnopqrstuvwxyz\ncodeforces\nqwertyuiopasdfghjklzxcvbnm\nqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\nqwertyuiopasdfghjklzxcvbnm\nabacaba\n\n\nOutput\n\n\n13\n0\n68\n0\n74\n[plan]\n- name: \nBrute Force Solution\n\n- content: \nThis solution involves a brute-force approach where we manually calculate the position of each character in the word `s` on the given keyboard for each test case.\n\n**Steps:**\n1. For each test case, iterate through the word `s`.\n2. For each character, find its position in the keyboard by iterating through the keyboard string.\n3. Calculate the time to move from the current position to the next position based on the absolute difference.\n4. Sum up all the times for the word and output the total time for each test case.\n\nThis solution ensures functional correctness by addressing all possible valid inputs and edge cases, including repeated letters and empty words, as it directly calculates the time for each character transition.\n\n\n\n## Answer 3:\n\n'}]
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\n You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.\n\nYou have to type the word s on this keyboard. It also consists only of lowercase Latin letters.\n\nTo type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.\n\nMoving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nThe first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from \'a\' to \'z\' appears exactly once on the keyboard.\n\nThe second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.\n\nExample\n\nInput\n\n\n5\nabcdefghijklmnopqrstuvwxyz\nhello\nabcdefghijklmnopqrstuvwxyz\ni\nabcdefghijklmnopqrstuvwxyz\ncodeforces\nqwertyuiopasdfghjklzxcvbnm\nqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\nqwertyuiopasdfghjklzxcvbnm\nabacaba\n\n\nOutput\n\n\n13\n0\n68\n0\n74\n[plan]\n- name: \nBrute Force Solution\n\n- content: \nThis solution involves a brute-force approach where we manually calculate the position of each character in the word `s` on the given keyboard for each test case.\n\n**Steps:**\n1. For each test case, iterate through the word `s`.\n2. For each character, find its position in the keyboard by iterating through the keyboard string.\n3. Calculate the time to move from the current position to the next position based on the absolute difference.\n4. Sum up all the times for the word and output the total time for each test case.\n\nThis solution ensures functional correctness by addressing all possible valid inputs and edge cases, including repeated letters and empty words, as it directly calculates the time for each character transition.\n\n\n\n## Answer 3:\n\n'}]
Failed to call GPT API
----------updating----------
analyst reward: 0.24863862991333008
final_output reward: 0
total reward: 0.24863862991333008
add mutated seed into prompt node list
seed_index: 238
mutated_seed_index: 289
reward = 0.24863862991333008
saving......
in recording...
len prompt_nodes
290
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 244------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:223
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Polycarp only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

--------------------------------------------------
Polycarp possessed an array a of 3 positive numbers and listed the sums of all non-empty subsequences of this array, arranged them in non-decreasing order, and obtained an array b of 7 numbers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Polycarp only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.35884255170822144
final_output reward: 0
total reward: 0.35884255170822144
add mutated seed into prompt node list
seed_index: 223
mutated_seed_index: 290
reward = 0.35884255170822144
saving......
in recording...
len prompt_nodes
291
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 245------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:219
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don't have to be adjacent. Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don't have to be adjacent to each other in the string. Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

1. Erase exactly one letter 'A' and exactly one letter 'B' from anywhere in the string, regardless of whether they are adjacent.
2. Erase exactly one letter 'B' and exactly one letter 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2, as these letters are removed. The actions are independent, meaning Casimir

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or exactly one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3390371799468994
final_output reward: 0
total reward: 0.3390371799468994
add mutated seed into prompt node list
seed_index: 219
mutated_seed_index: 291
reward = 0.3390371799468994
saving......
in recording...
len prompt_nodes
292
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 246------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:253
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have an array `a` with a length of `n`.

Let's define the eversion operation. Let `x` be equal to `a_n`. Then array `a` is divided into two sections: left and right. The left section contains elements of `a` that are less than or equal to `x` (≤ `x`). The right section contains elements of `a` that are greater than `x` (> `x`). The order of elements in each section remains the same as before the operation. The current sequence of elements in each portion does not change after the operation. This implies that the partition is stable. Then the array is replaced with the joining of the left and the right sections.

For instance, if the array `a` is [2, 4, 1, 5, 3], the eversion proceeds like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We begin with the array `a` and conduct eversions on this array. We can prove that after several eversions the array `a` ceases to change. Output the minimal number `k` such that the array stops altering after `k` eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

--------------------------------------------------
You have an array `a` with a length of `n`.

Let's explain the eversion procedure. Let `x` be equal to `a_n`. In that case, array `a` is split into two parts: left and right. The left part includes elements of `a` which are less than or equal to `x` (≤ `x`). The right part includes elements of `a` which are greater than `x` (> `x`). The arrangement of elements in each part remains unchanged as it was before the procedure. The current sequence of elements in each portion does not alter after the procedure. This suggests that the partition is stable. Then the array is substituted with the combination of the left and the right parts.

For example, if the array `a` is [2, 4, 1, 5, 3], the eversion continues like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array `a` and perform eversions on this array. We can demonstrate that after a number of eversions the array `a` ceases to change. Output the smallest number `k` so that the array stops changing after `k` eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.2754477262496948
final_output reward: 0
total reward: 0.2754477262496948
add mutated seed into prompt node list
seed_index: 253
mutated_seed_index: 292
reward = 0.2754477262496948
saving......
in recording...
len prompt_nodes
293
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 247------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:245
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek has an array a made up of n integers. The prettiness value of a is defined as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

Alternatively, the prettiness value of the array a is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for each pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

--------------------------------------------------
Mr. Chanek possesses an array a consisting of n integers. The prettiness value of a is defined as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of the array a is the cumulative total of \gcd(a_i, a_j) ⋅ \gcd(i, j) for each pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.2503319978713989
final_output reward: 0
total reward: 0.2503319978713989
add mutated seed into prompt node list
seed_index: 245
mutated_seed_index: 293
reward = 0.2503319978713989
saving......
in recording...
len prompt_nodes
294
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 248------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:229
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. For this problem, consider edge cases where the robot starts near the borders of the board.

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. For this problem, consider edge cases where the robot starts near the borders of the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, with each command represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts its movement from any cell on the

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. Determine the cell from which the robot should start its movement to execute as many commands as possible.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.19871222972869873
final_output reward: 0.2
total reward: 0.39871222972869874
add mutated seed into prompt node list
seed_index: 229
mutated_seed_index: 294
reward = 0.39871222972869874
saving......
in recording...
len prompt_nodes
295
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 249------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:266
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n].

This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.

Technically, each cyclic shift consists of two consecutive actions:

  1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment.
  2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.

For example, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5].

Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Ensure your solution efficiently uses the cyclic shifts for optimal sorting.

--------------------------------------------------
The new generation external memory includes an array of integers a[1 … n] = [a_1, a_2, …, a_n].

This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.

Technically, each cyclic shift consists of two consecutive actions:

  1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment.
  2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.

For instance, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5].

Organize the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Ensure your solution efficiently uses the cyclic shifts for optimal sorting.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
analyst reward: 0.25117236375808716
final_output reward: 0
total reward: 0.25117236375808716
add mutated seed into prompt node list
seed_index: 266
mutated_seed_index: 295
reward = 0.25117236375808716
saving......
in recording...
len prompt_nodes
296
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 250------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:249
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He is interested in building a housing complex within the city. There are several telephone poles on the plane, represented by a grid a of dimensions (n + 1) × (m + 1) with a telephone pole located at (x, y) if a_{x, y} = 1. For any given point (x, y), let S(x, y) be the squared Euclidean distance between the nearest pole and (x, y), with the squared Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To enhance the building plan, the project supervisor requests the total of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
Mr. Chanek's city can be represented as a plane. He is interested in building a housing complex within the city. There are several telephone poles on the plane, represented by a grid a of dimensions (n + 1) × (m + 1) with a telephone pole located at (x, y) if a_{x, y} = 1. For any given point (x, y), let S(x, y) be the squared Euclidean distance between the nearest pole and (x, y), with the squared Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To enhance the building plan, the project supervisor requests the total of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m. Make sure to consider edge cases in your solution.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s, and other cells are 0s. The task is to calculate the sum of the squares of the Euclidean distances from each cell in the grid to the nearest telephone pole. This sum is needed to optimize the housing complex construction plan. Specifically, the supervisor wants the value of the double sum ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, which is represented by a grid of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). To optimize the building plan, the project supervisor asks you the sum of all S(x,

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.32879215478897095
final_output reward: 0.3
total reward: 0.628792154788971
add mutated seed into prompt node list
seed_index: 249
mutated_seed_index: 296
reward = 0.628792154788971
saving......
in recording...
len prompt_nodes
297
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 251------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:284
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M.

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can go from 0 to 15. Each of these numbers should be looked in its binary form. Each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls. For example number 10 in it's binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West.

It is guaranteed that the construction always has walls on it's edges. The input will be correct.

Your task is to print the size of the rooms from biggest to smallest.

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M.

Then in the next N lines you have M numbers, which represent factory tiles and they can go from 0 to 15, and each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls, for example number 10 in its binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side, so it goes North, East, South, West.

It is guaranteed that the construction always has walls on its edges. The input will be correct.

Your task is to print the size of the rooms from biggest to smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to create factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles and can range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating a rectangular factory construction with dimensions N x M. The data consists of N lines, each containing M numbers representing factory tiles. Each number ranges from 0 to 15, and each number's binary representation indicates the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is correct. Your task is to print the sizes of the rooms in descending order.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.37043124437332153
final_output reward: 0
total reward: 0.37043124437332153
add mutated seed into prompt node list
seed_index: 284
mutated_seed_index: 297
reward = 0.37043124437332153
saving......
in recording...
len prompt_nodes
298
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_251.jsonl
----------------------------------------round: 252------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:262
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n containing each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] do not qualify as permutations. Your task is to handle q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n. This array contains each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] do not qualify as permutations. Your task is to handle q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer ranging from 1 to n. A permutation of n elements is defined as an array of length n that includes each integer from 1 to n exactly once. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will receive a series of queries to execute.

The

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30894148349761963
final_output reward: 0.1
total reward: 0.4089414834976196
add mutated seed into prompt node list
seed_index: 262
mutated_seed_index: 298
reward = 0.4089414834976196
saving......
in recording...
len prompt_nodes
299
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 253------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:283
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp enjoys squares and cubes of positive numerical values. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure your solution is efficient for large values of n.

--------------------------------------------------
Polycarp takes pleasure in squares and cubes of positive numerical values. Here is the start of the sequence of numbers he favors: 1, 4, 8, 9, .... 

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously). Ensure your solution is efficient for large values of n.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing. This means counting the number of integers x, where x is a square of a positive integer or a cube of a positive integer (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.2737119197845459
final_output reward: 0.1
total reward: 0.3737119197845459
add mutated seed into prompt node list
seed_index: 283
mutated_seed_index: 299
reward = 0.3737119197845459
saving......
in recording...
len prompt_nodes
300
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 254------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:217
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is playing a computer game, and now he wants to complete the first level of this game. A level is a rectangular grid consisting of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, so, formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 or |y_1 - y_2| ≤ 1, and obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game, and now he wants to complete the first level of this game. A level is a rectangular grid consisting of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, so, formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 or |y_1 - y_2| ≤ 1. Moving outside the grid is not allowed under any circumstances, therefore it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character ends up in such a cell, he dies, and the game finishes.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and the first column. The character can move to nearby cells, either next to each other or by going a little bit diagonally. But, Monocarp can't go outside the grid. There are some dangerous cells called traps where if the character goes, the game ends. The goal is for Monocarp's character to reach the end of the level, which is

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner, but cannot go outside the grid. The goal is to reach (2, n) without landing in a trap cell. Determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.45067644119262695
final_output reward: 0.2
total reward: 0.6506764411926269
add mutated seed into prompt node list
seed_index: 217
mutated_seed_index: 300
reward = 0.6506764411926269
saving......
in recording...
len prompt_nodes
301
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 255------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:282
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. He will split the sequence a into one or more consecutive subarrays. The sequence will be split such that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5]. It has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. He will split the sequence a into one or more consecutive subarrays such that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5]. It has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if the original sequence is [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence a such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS)

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.28801554441452026
final_output reward: 0
total reward: 0.28801554441452026
add mutated seed into prompt node list
seed_index: 282
mutated_seed_index: 301
reward = 0.28801554441452026
saving......
in recording...
len prompt_nodes
302
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 256------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:248
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers. You are asked to break exactly one of them into two pieces. You must break the stick in such a way that both pieces have positive (strictly greater than 0) integer length and the total length of the pieces is equal to the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that. Ensure to evaluate each possible breaking scenario for adherence to the conditions mentioned.

--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers. You are asked to break exactly one of them into two pieces. You must break the stick in such a way that both pieces have positive (strictly greater than 0) integer length and the total length of the pieces is equal to the original length of the stick; it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. A square is also considered a rectangle. Determine if it's possible to do that. Ensure to evaluate each possible breaking scenario for adherence to the conditions mentioned. Consider edge cases where the lengths are minimal or maximal under given constraints.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total length equals the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.316472589969635
final_output reward: 0
total reward: 0.316472589969635
add mutated seed into prompt node list
seed_index: 248
mutated_seed_index: 302
reward = 0.316472589969635
saving......
in recording...
len prompt_nodes
303
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 257------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:139
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k). Consider edge cases where k equals 1 or n to ensure the problem constraints are handled appropriately.

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k). Consider edge cases where k equals 1 or n to ensure the problem constraints are handled appropriately.

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) denotes the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of the sum ∑_{i=1}^{

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3803789019584656
final_output reward: 0
total reward: 0.3803789019584656
add mutated seed into prompt node list
seed_index: 139
mutated_seed_index: 303
reward = 0.3803789019584656
saving......
in recording...
len prompt_nodes
304
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 258------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:9
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Keep in mind that in this problem, unlike the others, the array indexes are numbered from zero. They are not numbered from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] containing only zeroes and ones. In each step, the array is cyclically shifted to the right by d cells, and then each element is replaced by the logical "AND" of the original element and its shifted counterpart. The process continues until the array becomes all zeroes, and you need to determine the number of steps required.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30406683683395386
final_output reward: 0.5
total reward: 0.8040668368339539
add mutated seed into prompt node list
seed_index: 9
mutated_seed_index: 304
reward = 0.8040668368339539
saving......
in recording...
len prompt_nodes
305
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 259------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:304
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Keep in mind that in this problem, unlike the others, the array indexes are numbered from zero. They are not numbered from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Keep in mind that in this problem, unlike the others, the array indexes are numbered from zero. You should note that they are not numbered from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, you should also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] containing only zeroes and ones. In each step, the array is replaced by a cyclic shift of itself to the right by d cells, where d is the current step number. Each element of the array is then replaced by the result of a logical "AND" operation with its corresponding element in the shifted array. The process continues until the array consists of only zeroes. Determine if the array will eventually become all zeroes and, if so, find the number of steps required for this to happen.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2814236879348755
final_output reward: 0
total reward: 0.2814236879348755
add mutated seed into prompt node list
seed_index: 304
mutated_seed_index: 305
reward = 0.2814236879348755
saving......
in recording...
len prompt_nodes
306
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 260------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:2
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 



Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them so each pair of rooms can be traveled between through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate and to go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it and Chanek and Indiana would ask q queries. There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones, a skilled helper, has returned to assist his distant relative, Indiana Jones, in an adventure to uncover a hidden treasure in a maze buried beneath a desert filled with deceptive appearances.

The maze is structured as a tree with n rooms, each numbered from 1 to n, interconnected by n - 1 tunnels, allowing travel between any two rooms through these tunnels.

Each room i (1 ≤ i ≤ n) has an illusion rate a_i. To traverse from room x to room y, a tunnel must exist between x and y, and the energy required is determined by the

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze has n - 1 tunnels connecting rooms, and travel between rooms requires max(|a_x + a_y|, |a_x - a_y|) energy. The maze can alter the illusion rate of any room with queries of type 1, and queries of type 2 ask for the minimum energy needed to reach the treasure in room v from room u.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.375694215297699
final_output reward: 0.1
total reward: 0.47569421529769895
add mutated seed into prompt node list
seed_index: 2
mutated_seed_index: 306
reward = 0.47569421529769895
saving......
in recording...
len prompt_nodes
307
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 261------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:246
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
A string is called square if it is some string written twice in a row; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s determine if it is square.

--------------------------------------------------
A string is referred to as square if it consists of a certain string repeated consecutively; for instance, the strings "aa", "abcabc", "abab" and "baabaa" qualify as square, whereas the strings "aaa", "abaaab" and "abcdabc" do not. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by writing a string twice in a row. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, "aaa", "abaaab", and "abcdabc" are not considered square. Given a string s, determine whether it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.25606387853622437
final_output reward: 0
total reward: 0.25606387853622437
add mutated seed into prompt node list
seed_index: 246
mutated_seed_index: 307
reward = 0.25606387853622437
saving......
in recording...
len prompt_nodes
308
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_261.jsonl
----------------------------------------round: 262------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:257
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have a list of numbers that initially is empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

--------------------------------------------------
You have a list of numbers that initially is empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. This means if x appears more than once in the array, all its occurrences should be replaced with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts empty. You need to handle a certain number of queries, which can be of two types: 

1. "1 x" - This means you add the number x to the end of the array.
2. "2 x y" - This means you replace every occurrence of the number x in the array with the number y.

After processing all the queries, what will be the final state of the array?

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.22860872745513916
final_output reward: 0
total reward: 0.22860872745513916
add mutated seed into prompt node list
seed_index: 257
mutated_seed_index: 308
reward = 0.22860872745513916
saving......
in recording...
len prompt_nodes
309
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 263------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:33
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.280021607875824
final_output reward: 0
total reward: 0.280021607875824
add mutated seed into prompt node list
seed_index: 33
mutated_seed_index: 309
reward = 0.280021607875824
saving......
in recording...
len prompt_nodes
310
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 264------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:254
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Andi and Budi received a task to organize their shelf containing n books. Each book is identified by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi wishes to arrange the books in lexicographical ascending order, while Budi wants to arrange them in lexicographical descending order.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

--------------------------------------------------
Andi and Budi received a task to organize their shelf containing n books. Each book is identified by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi wishes to arrange the books in lexicographical ascending order, while Budi wants to arrange them in lexicographical descending order.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Write a function to determine the order of books on the shelf following this rule.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.2751312255859375
final_output reward: 0.3
total reward: 0.5751312255859375
add mutated seed into prompt node list
seed_index: 254
mutated_seed_index: 310
reward = 0.5751312255859375
saving......
in recording...
len prompt_nodes
311
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 265------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:13
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two days in a row, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 



At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower. Petya is a busy person, so he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 



At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days, during which you need to assess the fate of Petya's flower.

The flower's growth pattern is as follows:

* If the flower goes without water for two consecutive days, it will wither and die.
* If the flower is watered on the i-th day, it will grow by 1 centimeter.
* If the flower is watered on both the i-th and the (i-1

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.282992959022522
final_output reward: 0.4
total reward: 0.682992959022522
add mutated seed into prompt node list
seed_index: 13
mutated_seed_index: 311
reward = 0.682992959022522
saving......
in recording...
len prompt_nodes
312
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 266------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:311
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Petya has got an interesting flower. Petya is a busy person, so he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 



At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got a fascinating plant. Petya is a busy person, so he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days, during which you need to track the growth and eventual fate of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes un-watered for two consecutive days, it will wither away. 
  * If the flower is watered on the i-th day, it will increase in height by 1 centimeter. 
  * If the flower is

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.2398192286491394
final_output reward: 0.1
total reward: 0.3398192286491394
add mutated seed into prompt node list
seed_index: 311
mutated_seed_index: 312
reward = 0.3398192286491394
saving......
in recording...
len prompt_nodes
313
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 267------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:16
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. 

A level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and it is obviously prohibited to go outside the grid.

There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column. The character can move to nearby cells, either next to each other or by going a little bit diagonally. But, Monocarp can't go outside the grid.

There are some dangerous spots in the grid called traps. If Monocarp's character lands on a trap, he loses and the game ends. To win the level, Mon

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner, but cannot go outside the grid. The goal is to reach (2, n) without landing in a trap cell. Determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4787134528160095
final_output reward: 0.4
total reward: 0.8787134528160095
add mutated seed into prompt node list
seed_index: 16
mutated_seed_index: 313
reward = 0.8787134528160095
saving......
in recording...
len prompt_nodes
314
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 268------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:313
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. 

A level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and it is obviously prohibited to go outside the grid.

There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. A level is a rectangular grid of 2 rows and n columns, where Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column. Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and it is obviously prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column. The character can move to nearby cells, either next to each other or by going a little corner. But, if the cell has a trap, Monocarp's character will die, and the game will end. The goal is for Monocarp's character to reach the end of the level, which is the last column in the second row. Can

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into traps. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4728941321372986
final_output reward: 0
total reward: 0.4728941321372986
add mutated seed into prompt node list
seed_index: 313
mutated_seed_index: 314
reward = 0.4728941321372986
saving......
in recording...
len prompt_nodes
315
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 269------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False, False]
current seed index:271
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek provides you with a sequence a enumerated from 1 to n. Define f(a) as the number of indices where a_i = i. You can select an item from the current sequence and remove it, merging the leftover elements together. For example, if you extract the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to excise some elements from a to enhance f(a), using zero or more actions, and identify the largest attainable f(a). Your task is to determine the strategy to achieve this maximum value, remembering that the sequence's indices are not adjusted after removing elements.

--------------------------------------------------
Mr. Chanek provides you with a sequence a enumerated from 1 to n. Define f(a) as the number of indices where a_i = i. You can select an item from the current sequence and remove it, merging the leftover elements together. For example, if you extract the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to excise some elements from a to enhance f(a), using zero or more actions, and identify the largest attainable f(a). Your task is to determine the strategy to achieve this maximum value, remembering that the sequence's indices are not adjusted after removing elements. Make sure to carefully consider how the removal of elements affects the current sequence in order to maximize f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You have the option to remove an element from the current sequence and concatenate the remaining elements together. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the new sequence will be [4, 2, 1]. Your goal is to remove some elements from a to maximize f(a), using zero or more operations. Determine the maximum possible value of f(a

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.49393415451049805
final_output reward: 0
total reward: 0.49393415451049805
add mutated seed into prompt node list
seed_index: 271
mutated_seed_index: 315
reward = 0.49393415451049805
saving......
in recording...
len prompt_nodes
316
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 270------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:231
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You possess a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications. Assume that the input string has a length of at least 2, allowing at least one valid comparison of adjacent characters.

--------------------------------------------------
You have a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) denote the number of times the sequence ab appears in s as a substring. Similarly, \operatorname{BA}(s) represents how frequently ba shows up in s as a substring.

In one operation, you can select any index i and change s_i to the letter a or b.

What is the minimum number of changes required to make \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications. Assume that the input string has a length of at least 2, allowing at least one valid comparison of adjacent characters.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3197203278541565
final_output reward: 0.4
total reward: 0.7197203278541565
add mutated seed into prompt node list
seed_index: 231
mutated_seed_index: 316
reward = 0.7197203278541565
saving......
in recording...
len prompt_nodes
317
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 271------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:171
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations to determine the closest feasible split.

--------------------------------------------------
Luntik has decided to try singing. He has a collection of one-minute songs, two-minute songs and three-minute songs. Specifically, he has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations to determine the closest feasible split.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.17747879028320312
final_output reward: 0
total reward: 0.17747879028320312
add mutated seed into prompt node list
seed_index: 171
mutated_seed_index: 317
reward = 0.17747879028320312
saving......
in recording...
len prompt_nodes
318
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_271.jsonl
----------------------------------------round: 272------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:244
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order modulo 10^9+7 since this number may be too large.

--------------------------------------------------
Theofanis really enjoys sequences of positive integers, thus his instructor (Yeltsa Kcir) assigned him a challenge pertaining to a sequence composed solely of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order modulo 10^9+7 since this number may be too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of different non-negative powers of a given number \( n \). For instance, with \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your help to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, and output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.32993417978286743
final_output reward: 0
total reward: 0.32993417978286743
add mutated seed into prompt node list
seed_index: 244
mutated_seed_index: 318
reward = 0.32993417978286743
saving......
in recording...
len prompt_nodes
319
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 273------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:16
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns. Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner. Formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1. Obviously, it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and the first column. The character can move to nearby cells, either next to each other or by going a little bit diagonally. But, Monocarp can't go outside the grid. There are some dangerous spots called traps in the grid where if the character goes, the game ends. To win the level, Monocarp's character must reach the end, which

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into traps. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.44749587774276733
final_output reward: 0.4
total reward: 0.8474958777427674
add mutated seed into prompt node list
seed_index: 16
mutated_seed_index: 319
reward = 0.8474958777427674
saving......
in recording...
len prompt_nodes
320
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 274------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:319
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level. Consider edge cases where the path might be blocked entirely.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and the first column. The character can move to nearby cells, either next to each other or by going a little bit diagonally. But, Monocarp can't go outside the grid. There are some dangerous spots called traps in the grid where if the character goes, the game ends. To win the level, Monocarp's character must reach the end, which

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into traps. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.393619179725647
final_output reward: 0
total reward: 0.393619179725647
add mutated seed into prompt node list
seed_index: 319
mutated_seed_index: 320
reward = 0.393619179725647
saving......
in recording...
len prompt_nodes
321
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 275------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:288
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party with strict rules on what a party is and when it's successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it's considered successful if either all the people at the party are friends with each other and can all talk without worrying about anything at all, or no two people at the party are friends with each other (so everyone can just be on their phones without bothering anyone else). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party with strict rules on what a party is and when it's successful. On the island of Baltia, a party is a gathering of exactly 5 people. It is considered successful if either all the people at the party are friends with each other and can all talk without worrying about anything at all, or no two people at the party are friends with each other (so everyone can just be on their phones without bothering anyone else). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, which must include exactly 5 people. A party is considered successful if all the attendees are friends with each other or if none of them are friends with each other. Determine if such a party can be organized, and if so, help them plan it. If it's impossible, inform them.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.36123985052108765
final_output reward: 0.2
total reward: 0.5612398505210876
add mutated seed into prompt node list
seed_index: 288
mutated_seed_index: 321
reward = 0.5612398505210876
saving......
in recording...
len prompt_nodes
322
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 276------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:29
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. You need to consider edge cases where the robot might not move at all.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, with each command represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts its movement from any cell on the

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command moves the robot left, right, down, or up. The robot starts its movement from any cell and executes the commands in the order given. If a command moves the robot beyond the edge of the board, it breaks. Determine the starting cell to maximize the number of commands executed without breaking.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.23374438285827637
final_output reward: 0.2
total reward: 0.4337443828582764
add mutated seed into prompt node list
seed_index: 29
mutated_seed_index: 322
reward = 0.4337443828582764
saving......
in recording...
len prompt_nodes
323
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 277------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:239
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions, and for each student, it is known which questions he has answered correctly. It is also known which questions he has not answered correctly.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m, arranged in a particular order that spans the entire range from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test and wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is determined to ensure that the results of the test reflect the diversity of skill among his students, regardless of their individual expectations.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points for each correct answer are known.

Petya knows that each student expects to get a certain number of points, x_i, for the test. The surprise value of the results for the students is calculated as the sum of the absolute differences between the expected points and the actual points each student has received.

Your task is to help Petya

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher with n students who have taken a test with m questions. Each student's performance is known, with a record of which questions they answered correctly. The points for each question are unique and range from 1 to m, and each student's expected score is x_i. The surprise value of the results is calculated as ∑_{i=1}^{n} |x_i - r_i|, where r_i is the actual score the student received. Your task is to find a permutation p of points that maximizes this surprise value. If there are multiple solutions, provide any

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.18118250370025635
final_output reward: 0.1
total reward: 0.2811825037002563
add mutated seed into prompt node list
seed_index: 239
mutated_seed_index: 323
reward = 0.2811825037002563
saving......
in recording...
len prompt_nodes
324
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 278------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:52
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent); 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this? Consider edge cases where the string might already be empty or where only one type of action is possible until the string is empty.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

  * He can erase one 'A' and one 'B' from anywhere in the string, regardless of whether they are adjacent.
  * He can erase one 'B' and one 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2. Each turn is independent, meaning Casimir can choose any of the two actions available.

For

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or exactly one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.2982833981513977
final_output reward: 0
total reward: 0.2982833981513977
add mutated seed into prompt node list
seed_index: 52
mutated_seed_index: 324
reward = 0.2982833981513977
saving......
in recording...
len prompt_nodes
325
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 279------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:298
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n. This array contains each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] do not qualify as permutations. Your task is to handle q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times. 

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n. This array contains each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations. In contrast, arrays like [1, 2, 4] do not meet the permutation criteria. Similarly, [4, 3, 2, 1, 2] fails to qualify as a permutation. Your task is to handle q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer ranging from 1 to n. A permutation of n elements is defined as an array of length n that includes each integer from 1 to n exactly once. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will receive a series of queries to execute.

The

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.28682583570480347
final_output reward: 0
total reward: 0.28682583570480347
add mutated seed into prompt node list
seed_index: 298
mutated_seed_index: 325
reward = 0.28682583570480347
saving......
in recording...
len prompt_nodes
326
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 280------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:306
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them so each pair of rooms can be traveled between through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate and to go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it and Chanek and Indiana would ask q queries. There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones has returned, assisting his long-lost family member Indiana Jones, in searching for a hidden treasure within a maze beneath a desert filled with illusions. The labyrinth's map resembles a tree with n rooms labeled from 1 to n and n - 1 tunnels linking them so every pair of rooms can be accessed through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate and to move from the x-th room to the y-th room, a connecting tunnel between x and y must exist, with energy cost computed as max(|a_x + a_y|, |a_x - a_y|). |z| signifies the absolute value of z. To deter grave robbers, the maze can adjust the illusion rate of any room, and Chanek and Indiana will pose q queries. There are two types of queries to be processed:

  * 1\ u\ c — The illusion rate of the x-th room is altered to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana inquire about the least sum of energy required to retrieve the secret treasure from room v if they start at room u (1 ≤ u, v ≤ n). 

Assist them, so you can acquire a share of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in searching for a hidden treasure within a maze located beneath a desert filled with deceptive illusions. The labyrinth's map is structured as a tree, consisting of n rooms numbered from 1 to n, interconnected by n - 1 tunnels that allow travel between any two rooms.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. The energy required to traverse from room x to room y depends on the sum or difference of their illusion rates, with the energy being the maximum of these values

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. Queries can update the illusion rate of a room or find the minimum energy needed to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.38072091341018677
final_output reward: 0
total reward: 0.38072091341018677
add mutated seed into prompt node list
seed_index: 306
mutated_seed_index: 326
reward = 0.38072091341018677
saving......
in recording...
len prompt_nodes
327
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 281------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:297
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know how big the factory is and how many rooms it has. When you look at the data you see that you have the dimensions of the construction, which is in rectangle shape: N x M.

Then in the next N lines you have M numbers, which represent factory tiles and they can go from 0 to 15, and each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls, for example number 10 in its binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side, so it goes North, East, South, West.

It is guaranteed that the construction always has walls on its edges. The input will be correct.

Your task is to print the size of the rooms from biggest to smallest.

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the size and number of rooms in the factory, and you see that you have the dimensions of the construction, which is in rectangle shape: N x M. Then in the next N lines you have M numbers, which represent factory tiles and they can go from 0 to 15, and each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls, for example number 10 in its binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side, so it goes North, East, South, West. It is guaranteed that the construction always has walls on its edges. The input will be correct. Your task is to print the size of the rooms from biggest to smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot, and your mission is to construct factory facilities. However, before you begin, you need to determine the dimensions of the factory and the number of rooms it contains. You have been provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will receive N lines, each containing M numbers. These numbers represent the factory tiles, and they range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot. You need to determine the size of the factory's rooms by analyzing the dimensions of the construction and the binary representation of the factory tiles. The factory is in a rectangular shape with dimensions N x M, and each tile's binary representation indicates the presence of walls on its sides (North, East, South, West). The input is guaranteed to be correct, and your task is to print the sizes of the rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.409831166267395
final_output reward: 0
total reward: 0.409831166267395
add mutated seed into prompt node list
seed_index: 297
mutated_seed_index: 327
reward = 0.409831166267395
saving......
in recording...
len prompt_nodes
328
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_281.jsonl
----------------------------------------round: 282------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:211
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers, deriving joy from these numbers. He finds special pleasure in numbers that are either perfect squares or perfect cubes. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers, deriving joy from these numbers and finds special pleasure in numbers that are either perfect squares or perfect cubes. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing, meaning he likes those numbers that are either a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.3417542576789856
final_output reward: 0
total reward: 0.3417542576789856
add mutated seed into prompt node list
seed_index: 211
mutated_seed_index: 328
reward = 0.3417542576789856
saving......
in recording...
len prompt_nodes
329
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 283------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:304
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Keep in mind that in this problem, unlike the others, the array indexes are numbered from zero. They are not numbered from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, and unlike the others, the array indexes are numbered from zero, not from one. In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with elements defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] containing only zeroes and ones. In each step, the array is cyclically shifted to the right by d cells, and then each element is replaced by the logical "AND" of the original element and its shifted counterpart. The process continues until the array becomes all zeroes, and you need to determine the number of steps required.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2815869450569153
final_output reward: 0
total reward: 0.2815869450569153
add mutated seed into prompt node list
seed_index: 304
mutated_seed_index: 329
reward = 0.2815869450569153
saving......
in recording...
len prompt_nodes
330
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 284------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:204
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. The function \(c(l, r)\) represents the count of integer pairs. These pairs satisfy both the boundary and gcd conditions. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. The function \(c(l, r)\) represents the count of integer pairs. These pairs satisfy both the boundary and gcd conditions. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences. The integer sequences must satisfy the condition 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.39487624168395996
final_output reward: 0
total reward: 0.39487624168395996
add mutated seed into prompt node list
seed_index: 204
mutated_seed_index: 330
reward = 0.39487624168395996
saving......
in recording...
len prompt_nodes
331
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 285------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:258
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp possessed an array a of 3 positive numbers and composed the totals of all non-empty subsequences of this array, sorted them in increasing order, and produced an array b of 7 numbers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. Note that each element in a is positive and distinct.

--------------------------------------------------
Polycarp had an array a containing 3 positive numbers and calculated the sums of all non-empty subsequences of this array, listed them in ascending order, and created an array b of 7 elements. For example, if a = {1, 4, 3}, then Polycarp listed 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he obtained an array b = {1, 3, 4, 4, 5, 7, 8}. Sadly, Polycarp misplaced array a. He only retains array b. Assist him in reconstructing array a. Remember that each item in a is positive and distinct.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2973834276199341
final_output reward: 0.6
total reward: 0.8973834276199341
add mutated seed into prompt node list
seed_index: 258
mutated_seed_index: 331
reward = 0.8973834276199341
saving......
in recording...
len prompt_nodes
332
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 286------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:275
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is curious if there's a systematic method for finding such pairs beyond brute-force techniques and if a more efficient solution exists. This curiosity is something that constantly motivates him. It drives him to look for alternatives.

--------------------------------------------------
Monocarp is curious if there's a systematic method for finding such pairs beyond brute-force techniques and if a more efficient solution exists. This curiosity constantly motivates him to look for alternatives.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements, denoted as k, is calculated by dividing the sum of all elements by the number of elements (n). Monocarp wants to remove two elements from the array a such that the mean of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i is less than j) in the array a, where removing the elements at these positions will result in the mean of the remaining elements being equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2858845591545105
final_output reward: 0
total reward: 0.2858845591545105
add mutated seed into prompt node list
seed_index: 275
mutated_seed_index: 332
reward = 0.2858845591545105
saving......
in recording...
len prompt_nodes
333
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 287------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:215
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is denoted by the book title — a string s_i numbered from 1 to n, each having a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

Implement a function that performs this custom sorting on an array of book titles.

--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is denoted by the book title — a string s_i numbered from 1 to n, each having a length of m. Andi really wants to sort the book lexicographically ascending. On the other hand, Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 

Implement a function that performs this custom sorting on an array of book titles.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.23219412565231323
final_output reward: 0
total reward: 0.23219412565231323
add mutated seed into prompt node list
seed_index: 215
mutated_seed_index: 333
reward = 0.23219412565231323
saving......
in recording...
len prompt_nodes
334
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 288------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:314
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. A level is a rectangular grid of 2 rows and n columns, where Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column. Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and it is obviously prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. A level is a rectangular grid of 2 rows and n columns, where Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column, and the character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and it is obviously prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and the first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But remember, if the cell has traps, Monocarp's character will die, and the game will end. The goal is for Monocarp's character to reach the end of the grid, which is

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. There are traps in some cells, and reaching cell (2, n) completes the level. Determine if it is possible for Monocarp to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.5155707597732544
final_output reward: 0
total reward: 0.5155707597732544
add mutated seed into prompt node list
seed_index: 314
mutated_seed_index: 334
reward = 0.5155707597732544
saving......
in recording...
len prompt_nodes
335
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 289------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:207
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his learners have encountered yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his learners have encountered yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has compiled a diverse set of n problems for an upcoming training session. Each problem is unique, featuring a specific topic (ranging from 1 to n) and a particular difficulty level (also from 1 to n).

To ensure a balanced and engaging problemset, Monocarp plans to choose exactly 3 problems. The selection must adhere to one of the following criteria:

1. The topics of the three selected problems are all distinct.
2. The difficulties of the three selected problems are all distinct.

Your objective is to

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, has n problems, each with a unique topic a_i and difficulty b_i. He needs to select 3 problems for a training session, ensuring that at least one of the following conditions is met: the topics of all three selected problems are different, or the difficulties of all three selected problems are different. Determine the number of ways to select these problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3060545325279236
final_output reward: 0
total reward: 0.3060545325279236
add mutated seed into prompt node list
seed_index: 207
mutated_seed_index: 335
reward = 0.3060545325279236
saving......
in recording...
len prompt_nodes
336
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 290------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:137
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Mr. Chanek's city can be depicted as a plane. He wants to build a housing complex in the city. There are some telephone poles on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
The city where Mr. Chanek resides can be illustrated as a plane. He wants to build a housing complex in the city. Some telephone poles are situated on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s in the array a. For each point (x, y) in the grid, S(x, y) is defined as the square of the Euclidean distance to the nearest telephone pole. This distance is calculated using the formula (x_2 - x_1)^2 + (y_2 - y_1)^2. The project supervisor wants the sum of all S(x, y) values for all points

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor wants the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Find ∑_{x=0}^{n} {∑_{y=0}^{m} {

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.32925379276275635
final_output reward: 0
total reward: 0.32925379276275635
add mutated seed into prompt node list
seed_index: 137
mutated_seed_index: 336
reward = 0.32925379276275635
saving......
in recording...
len prompt_nodes
337
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 291------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:24
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Note that finding the longest increasing subsequence in each subarray requires careful implementation for correctness and efficiency.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of integers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive subarrays, where each element of the original sequence belongs to exactly one subarray. Let k represent the number of resulting subarrays, and h_1, h_2, …, h_k denote the lengths of the longest increasing subsequences of the respective subarrays.

For instance, if the sequence is [2, 5, 3, 1, 4, 3, 2, 2, 5,

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of the subarrays. Determine if it's possible to split the sequence such that the bitwise XOR of h_1, h_2, …, h_k is 0. The LIS of a sequence is the longest

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.28299498558044434
final_output reward: 0
total reward: 0.28299498558044434
add mutated seed into prompt node list
seed_index: 24
mutated_seed_index: 337
reward = 0.28299498558044434
saving......
in recording...
len prompt_nodes
338
initial_seed_num
46
[False, False, False, True, False, False, False, False, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:30
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_291.jsonl
----------------------------------------round: 292------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:295
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The new generation external memory includes an array of integers a[1 … n] = [a_1, a_2, …, a_n].

This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.

Technically, each cyclic shift consists of two consecutive actions:

  1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment.
  2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.

For instance, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5].

Organize the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Ensure your solution efficiently uses the cyclic shifts for optimal sorting.

--------------------------------------------------
The new generation external memory includes an array of integers a[1 … n] = [a_1, a_2, …, a_n].

This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.

Technically, each cyclic shift consists of two consecutive actions:

  1. You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment.
  2. Then you replace the segment a[l … r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1. Additionally, the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2 and provides another example.

For instance, if a = [1, \color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 … 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment. In the end you get a = [1, \color{blue}{8, 3, 2}, 5].

Organize the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted. Ensure your solution efficiently uses the cyclic shifts for optimal sorting.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------updating----------
seed 295 finish fuzzing!
seed_index: 295
mutated_seed_index: 338
current seed length: 29
saving......
in recording...
len prompt_nodes
339
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:29
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 293------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:290
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Polycarp possessed an array a of 3 positive numbers and listed the sums of all non-empty subsequences of this array, arranged them in non-decreasing order, and obtained an array b of 7 numbers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Polycarp only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

--------------------------------------------------
Polycarp possessed an array a of 3 positive numbers and listed the sums of all non-empty subsequences of this array, arranged them in non-decreasing order, and obtained an array b of 7 numbers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Polycarp only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers.

For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.429482638835907
final_output reward: 0.5
total reward: 0.929482638835907
add mutated seed into prompt node list
seed_index: 290
mutated_seed_index: 339
reward = 0.929482638835907
saving......
in recording...
len prompt_nodes
340
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:29
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 294------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:312
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Petya has got a fascinating plant. Petya is a busy person, so he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got a fascinating plant, but as a busy person, he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter, and if watered in both the i-th and (i-1)-th day (i > 1), it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. Due to his busy schedule, he sometimes neglects to water it, which can be concerning for its growth. You are provided with a timeline of n days, during which you need to track the flower's condition and determine its final height.

The flower's growth pattern is as follows:

* If the flower goes without water for two consecutive days, it will wither and die.
* If the flower is watered on the i-th day, it will grow by 1 centimeter.
* If the flower is watered on both the i-

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.22520524263381958
final_output reward: 0.1
total reward: 0.32520524263381956
add mutated seed into prompt node list
seed_index: 312
mutated_seed_index: 340
reward = 0.32520524263381956
saving......
in recording...
len prompt_nodes
341
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:29
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 295------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:322
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. You need to consider edge cases where the robot might not move at all.

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. You need to consider edge cases where the robot might not move at all. Consider that the initial position of the robot could significantly affect the number of successful moves.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts executing the commands from the first

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. The goal is to determine the cell from which the robot should start its movement to execute the most commands without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.22236472368240356
final_output reward: 0
total reward: 0.22236472368240356
add mutated seed into prompt node list
seed_index: 322
mutated_seed_index: 341
reward = 0.22236472368240356
saving......
in recording...
len prompt_nodes
342
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:29
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 296------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:279
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You must separate one of them into two pieces in such a way that both pieces possess positive (strictly greater than 0) integer length. The combined length of the pieces equals the stick's original length; it's feasible to build a rectangle with the resulting four sticks so that each stick acts as exactly one of its sides. A square is also regarded as a rectangle. Determine if it's achievable to accomplish that. When dividing a stick, ensure selecting an optimal division point that aids rectangle formation.

--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You must separate one of them into two pieces in such a way that both pieces possess positive (strictly greater than 0) integer length, and the combined length of the pieces equals the stick's original length; it's feasible to build a rectangle with the resulting four sticks so that each stick acts as exactly one of its sides. A square is also regarded as a rectangle. Determine if it's achievable to accomplish that. When dividing a stick, ensure selecting an optimal division point that aids rectangle formation.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2765231728553772
final_output reward: 0
total reward: 0.2765231728553772
add mutated seed into prompt node list
seed_index: 279
mutated_seed_index: 342
reward = 0.2765231728553772
saving......
in recording...
len prompt_nodes
343
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:29
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 297------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:196
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate. It is the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes. Make sure to consider edge cases in your solution, such as when n is small or all elements are the same.

--------------------------------------------------
Mr. Chanek possesses an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

To put it differently, the beautification value of the array a is the aggregate. It is the collective result of summing \gcd(a_i, a_j) ⋅ \gcd(i, j) for every pair (i, j). 

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Efficient computation is necessary due to potential large input sizes. Make sure to consider edge cases in your solution, such as when n is small or all elements are the same.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.26731181144714355
final_output reward: 0
total reward: 0.26731181144714355
add mutated seed into prompt node list
seed_index: 196
mutated_seed_index: 343
reward = 0.26731181144714355
saving......
in recording...
len prompt_nodes
344
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, False, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:29
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 298------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:206
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You possess a string s of length n made up of the letters a and/or b.

Let \operatorname{AB}(s) represent how many times the string ab appears in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The frequency with which string d appears in s as a substring is determined by counting indices i (1 ≤ i ≤ |s| - |d| + 1) where substring s_i s_{i + 1} ... s_{i + |d| - 1} matches d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

--------------------------------------------------
You have a string s of length n consisting of the letters a and/or b.

Let \operatorname{AB}(s) denote how often the pattern ab is found in s as a substring. Similarly, \operatorname{BA}(s) denotes the number of instances ba shows up in s as a substring.

In one operation, you can choose any index i and change s_i to the character a or b.

What is the least number of modifications needed to achieve \operatorname{AB}(s) equal to \operatorname{BA}(s)?

Reminder:

The number of times a string d occurs in s as a substring is calculated by counting indices i (1 ≤ i ≤ |s| - |d| + 1) for which the substring s_i s_{i + 1} ... s_{i + |d| - 1} coincides with d. For example, \operatorname{AB}(aabbbabaa) = 2 because there are two indices i: i = 2 where aabbbabaa and i = 6 where aabbbabaa. Ensure your solution efficiently balances the counts with minimal modifications.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------updating----------
seed 206 finish fuzzing!
seed_index: 206
mutated_seed_index: 344
current seed length: 28
saving......
in recording...
len prompt_nodes
345
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 299------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:309
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Each of these numbers follows a specific format. They are a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2648378014564514
final_output reward: 0
total reward: 0.2648378014564514
add mutated seed into prompt node list
seed_index: 309
mutated_seed_index: 345
reward = 0.2648378014564514
saving......
in recording...
len prompt_nodes
346
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 300------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:289
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence, each representing an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, but no time is allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence. Each of these keys represents an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, but no time is allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the time required to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
----------updating----------
analyst reward: 0.23358112573623657
final_output reward: 0
total reward: 0.23358112573623657
add mutated seed into prompt node list
seed_index: 289
mutated_seed_index: 346
reward = 0.23358112573623657
saving......
in recording...
len prompt_nodes
347
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 301------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:320
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp is playing a computer game. Now he wants to complete the first level of this game.

A level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character, which starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column.

Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid.

There are traps in some cells. If Monocarp's character finds himself in such a cell, he dies, and the game ends.

To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n.

Help Monocarp determine if it is possible to complete the level. Consider edge cases where the path might be blocked entirely.

--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of a game where a level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column. Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level, considering edge cases where the path might be blocked entirely.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and the first column. The character can move to nearby cells, either next to each other or by going a little bit further. But, be careful, because some cells have traps, and if Monocarp's character steps on them, the game ends, and he loses. The goal is for Monocarp's character to reach the end of the level, which is

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. There are traps in some cells, and reaching cell (2, n) completes the level. Determine if it is possible for Monocarp to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.40099066495895386
final_output reward: 0
total reward: 0.40099066495895386
add mutated seed into prompt node list
seed_index: 320
mutated_seed_index: 347
reward = 0.40099066495895386
saving......
in recording...
len prompt_nodes
348
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_301.jsonl
----------------------------------------round: 302------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:227
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones. Their mission is to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y. It takes max(|a_x + a_y|, |a_x - a_y|) energy to make this journey. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure! Ensure efficiency due to constraints on the number of rooms and queries.

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones. Their mission is to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y. It takes max(|a_x + a_y|, |a_x - a_y|) energy to make this journey. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure! Ensure efficiency due to constraints on the number of rooms and queries. Keep in mind that evolving strategies might be necessary to handle modification queries efficiently.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. The labyrinth's map is structured as a tree, consisting of n rooms numbered from 1 to n, interconnected by n - 1 tunnels that allow travel between any two rooms.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. The energy required to traverse from room x to room y depends on the sum or difference of their illusion rates, with the energy cost being the absolute

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. The energy required to travel between rooms x and y is max(|a_x + a_y|, |a_x - a_y|). Queries can update the illusion rate of a room or find the minimum energy to reach a secret treasure from two given rooms.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.40530824661254883
final_output reward: 0
total reward: 0.40530824661254883
add mutated seed into prompt node list
seed_index: 227
mutated_seed_index: 348
reward = 0.40530824661254883
saving......
in recording...
len prompt_nodes
349
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 303------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:292
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have an array `a` with a length of `n`.

Let's explain the eversion procedure. Let `x` be equal to `a_n`. In that case, array `a` is split into two parts: left and right. The left part includes elements of `a` which are less than or equal to `x` (≤ `x`). The right part includes elements of `a` which are greater than `x` (> `x`). The arrangement of elements in each part remains unchanged as it was before the procedure. The current sequence of elements in each portion does not alter after the procedure. This suggests that the partition is stable. Then the array is substituted with the combination of the left and the right parts.

For example, if the array `a` is [2, 4, 1, 5, 3], the eversion continues like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array `a` and perform eversions on this array. We can demonstrate that after a number of eversions the array `a` ceases to change. Output the smallest number `k` so that the array stops changing after `k` eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

--------------------------------------------------
You possess an array `a` with a length of `n`.

Let's explain the eversion procedure. Let `x` be equal to `a_n`. In that case, array `a` is split into two parts: left and right. The left part includes elements of `a` which are less than or equal to `x` (≤ `x`). The right part includes elements of `a` which are greater than `x` (> `x`). The order of items in each section stays the same as it was prior to the procedure. The current sequence of elements in each portion does not alter after the procedure. This suggests that the partition is stable. Then the array is substituted with the combination of the left and the right parts.

For example, if the array `a` is [2, 4, 1, 5, 3], the eversion continues like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array `a` and perform eversions on this array. We can demonstrate that after a number of eversions the array `a` ceases to change. Output the smallest number `k` so that the array stops changing after `k` eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.2820265293121338
final_output reward: 0
total reward: 0.2820265293121338
add mutated seed into prompt node list
seed_index: 292
mutated_seed_index: 349
reward = 0.2820265293121338
saving......
in recording...
len prompt_nodes
350
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 304------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:65
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party. They have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other. This means that everyone can just be on their phones without anyone else bothering them. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered successful if either all the people at the party are friends with each other, allowing them to all talk to each other without any issues, or no two people at the party are friends with each other, ensuring everyone can use their

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party with exactly 5 people, considering it successful if all are friends or none are. Please help them organize a successful party or inform them it's impossible.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.33904266357421875
final_output reward: 0
total reward: 0.33904266357421875
add mutated seed into prompt node list
seed_index: 65
mutated_seed_index: 350
reward = 0.33904266357421875
saving......
in recording...
len prompt_nodes
351
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 305------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:273
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
A string is called square if it is a certain string repeated twice in succession. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Ensure your solution achieves the desired efficiency for large inputs.

--------------------------------------------------
A string is called square if it is a certain string repeated twice in succession; for example, the strings "aa", "abcabc", "abab" and "baabaa" are square, but the strings "aaa", "abaaab" and "abcdabc" are not square. For a given string s determine if it is square. Ensure your solution achieves the desired efficiency for large inputs.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by writing another string twice in a row. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, "aaa", "abaaab", and "abcdabc" are not considered square. The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.2952752113342285
final_output reward: 0
total reward: 0.2952752113342285
add mutated seed into prompt node list
seed_index: 273
mutated_seed_index: 351
reward = 0.2952752113342285
saving......
in recording...
len prompt_nodes
352
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 306------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:278
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. In this context, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j. In this specific instance, the term \operatorname{gcd}(i, j) indicates the greatest common divisor (GCD). It is the largest positive integer that divides both i and j without leaving a remainder. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. In this context, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j. The greatest common divisor (GCD) is the largest positive integer that divides both i and j without leaving a remainder. In this specific instance, the term \operatorname{gcd}(i, j) indicates the greatest common divisor (GCD). It is the largest positive integer that divides both i and j without leaving a remainder. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum of the sum ∑_{i=1}^{

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3504480719566345
final_output reward: 0.1
total reward: 0.4504480719566345
add mutated seed into prompt node list
seed_index: 278
mutated_seed_index: 352
reward = 0.4504480719566345
saving......
in recording...
len prompt_nodes
353
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 307------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:152
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, arranged them in ascending order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array. He then arranged them in ascending order and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1,

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3058624267578125
final_output reward: 0
total reward: 0.3058624267578125
add mutated seed into prompt node list
seed_index: 152
mutated_seed_index: 353
reward = 0.3058624267578125
saving......
in recording...
len prompt_nodes
354
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 308------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:247
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. These letters don’t have to be adjacent. Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string. Therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

  * He can erase one 'A' and one 'B' from anywhere in the string, regardless of whether they are adjacent.
  * He can erase one 'B' and one 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2. Each turn is independent, and Casimir can choose any of the two actions available.

For

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.3378623127937317
final_output reward: 0
total reward: 0.3378623127937317
add mutated seed into prompt node list
seed_index: 247
mutated_seed_index: 354
reward = 0.3378623127937317
saving......
in recording...
len prompt_nodes
355
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 309------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:327
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the size and number of rooms in the factory, and you see that you have the dimensions of the construction, which is in rectangle shape: N x M. Then in the next N lines you have M numbers, which represent factory tiles and they can go from 0 to 15, and each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls, for example number 10 in its binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side, so it goes North, East, South, West. It is guaranteed that the construction always has walls on its edges. The input will be correct. Your task is to print the size of the rooms from biggest to smallest.

--------------------------------------------------
You've received data from a Bubble bot. Your role involves constructing factory infrastructures, but prior to beginning, you need to determine the size and quantity of rooms within the factory, and you notice that you have the layout measurements, which come in a rectangular format: N x M. Then in the next N lines you have M numbers, which represent factory tiles and they can go from 0 to 15, and each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls, for example number 10 in its binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side, so it goes North, East, South, West. It is guaranteed that the construction always has walls on its edges. The input will be correct. Your task is to print the size of the rooms from biggest to smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot that indicates you need to create factory facilities. To begin, you must determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will see N lines, each containing M numbers. These numbers represent the factory tiles and can range from 0 to 15. Each number should be examined in its binary form. By doing this, you can determine which sides of the tile have walls. For instance, the number 10 in binary is 

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating the dimensions of a factory construction in rectangle shape: N x M. The data consists of N lines, each containing M numbers representing factory tiles. Each number can range from 0 to 15, and each number's binary representation indicates the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is correct. Your task is to print the sizes of the rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3956153392791748
final_output reward: 0.1
total reward: 0.4956153392791748
add mutated seed into prompt node list
seed_index: 327
mutated_seed_index: 355
reward = 0.4956153392791748
saving......
in recording...
len prompt_nodes
356
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 310------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:305
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Keep in mind that in this problem, unlike the others, the array indexes are numbered from zero. You should note that they are not numbered from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, you should also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only, where the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells, with elements defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n, indicating that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$.

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing; for a given array a, determine whether it will consist of only zeros at the end of the process and, if yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}. Then each element of the array a_i

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2494359016418457
final_output reward: 0.3
total reward: 0.5494359016418457
add mutated seed into prompt node list
seed_index: 305
mutated_seed_index: 356
reward = 0.5494359016418457
saving......
in recording...
len prompt_nodes
357
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 311------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:144
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that only consists of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Ensure your solution is efficient enough to handle large inputs.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that only consists of special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special. This is because it can be written as 4^0 + 4^2 = 1 + 16 = 17. However, 9 is not special, since it does not fit that criterion.

Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Ensure your solution is efficient enough to handle large inputs.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of different non-negative powers of a given number \( n \). For instance, with \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your help to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, and output it modulo 10^9+7.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.22916996479034424
final_output reward: 0
total reward: 0.22916996479034424
add mutated seed into prompt node list
seed_index: 144
mutated_seed_index: 357
reward = 0.22916996479034424
saving......
in recording...
len prompt_nodes
358
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_311.jsonl
----------------------------------------round: 312------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:250
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Polycarp enjoys squares and cubes of positive numerical values. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive numerical values, with a sequence of numbers he likes including: 1, 4, 8, 9, .... For a given number n, count the number of integers from 1 to n that Polycarp likes by finding the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing. This means counting the number of x values where x is a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.30728888511657715
final_output reward: 0
total reward: 0.30728888511657715
add mutated seed into prompt node list
seed_index: 250
mutated_seed_index: 358
reward = 0.30728888511657715
saving......
in recording...
len prompt_nodes
359
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 313------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:325
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n. This array contains each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations. In contrast, arrays like [1, 2, 4] do not meet the permutation criteria. Similarly, [4, 3, 2, 1, 2] fails to qualify as a permutation. Your task is to handle q queries.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n. This array contains each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations. In contrast, arrays like [1, 2, 4] do not meet the permutation criteria. Similarly, [4, 3, 2, 1, 2] fails to qualify as a permutation. Your task is to handle q queries. Note that all operations should be completed within optimal time complexity.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer ranging from 1 to n. A permutation of n elements is defined as an array of length n that includes each integer from 1 to n exactly once. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will receive a series of queries to execute.

The

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, which can be of two types:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2971789836883545
final_output reward: 0.2
total reward: 0.4971789836883545
add mutated seed into prompt node list
seed_index: 325
mutated_seed_index: 359
reward = 0.4971789836883545
saving......
in recording...
len prompt_nodes
360
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 314------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False, False, False]
current seed index:315
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek provides you with a sequence a enumerated from 1 to n. Define f(a) as the number of indices where a_i = i. You can select an item from the current sequence and remove it, merging the leftover elements together. For example, if you extract the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to excise some elements from a to enhance f(a), using zero or more actions, and identify the largest attainable f(a). Your task is to determine the strategy to achieve this maximum value, remembering that the sequence's indices are not adjusted after removing elements. Make sure to carefully consider how the removal of elements affects the current sequence in order to maximize f(a).

--------------------------------------------------
Mr. Chanek provides you with a sequence a enumerated from 1 to n. Define f(a) as the number of indices where a_i = i. You can select an item from the current sequence and remove it. The elements that remain will be merged together to form a new sequence. For example, if you extract the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to excise some elements from a to enhance f(a), using zero or more actions, and identify the largest attainable f(a). Your task is to determine the strategy to achieve this maximum value, remembering that the sequence's indices are not adjusted after removing elements. Make sure to carefully consider how the removal of elements affects the current sequence in order to maximize f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You can select one element from the current sequence and eliminate it, then combine the remaining elements into a new sequence. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Your objective is to remove some elements from a to maximize f(a), using zero or more operations. Determine the maximum possible value of

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.5042624771595001
final_output reward: 0.2
total reward: 0.7042624771595001
add mutated seed into prompt node list
seed_index: 315
mutated_seed_index: 360
reward = 0.7042624771595001
saving......
in recording...
len prompt_nodes
361
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 315------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:334
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. A level is a rectangular grid of 2 rows and n columns, where Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column, and the character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and it is obviously prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. A level is a rectangular grid of 2 rows and n columns, where Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column, and the character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and going off the grid is strictly forbidden. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But it's important to remember that Monocarp can't go outside the grid. There are some cells with traps in them, and if Monocarp's character lands in one of those cells, the game

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into a trap. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4141801595687866
final_output reward: 0
total reward: 0.4141801595687866
add mutated seed into prompt node list
seed_index: 334
mutated_seed_index: 361
reward = 0.4141801595687866
saving......
in recording...
len prompt_nodes
362
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 316------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:45
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|, where r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points. Otherwise, he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points are distributed accordingly.

Petya knows that each student expects to get a certain number of points, x_i, for the test. He wants to determine the permutation p that maximizes the surprise value of the results, which is calculated as the sum of the absolute differences between the expected points and the actual points received by each student, ∑_{i

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher with n students who have taken a test with m questions. Each student's performance is known, with a record of which questions they answered correctly. The points for each question are unique and range from 1 to m, and each student's expected score is x_i. The surprise value of the results is calculated as ∑_{i=1}^{n} |x_i - r_i|, where r_i is the actual score the i-th student received. Your task is to find a permutation p of points that maximizes this surprise value. If there are multiple solutions

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.20215266942977905
final_output reward: 0.4
total reward: 0.6021526694297791
add mutated seed into prompt node list
seed_index: 45
mutated_seed_index: 362
reward = 0.6021526694297791
saving......
in recording...
len prompt_nodes
363
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 317------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:362
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points. Otherwise, he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points. If the student does not answer the j-th question correctly, then he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each question, the points are given as a permutation of numbers from 1 to m. Each student has answered some questions correctly, and the points are distributed accordingly.

Petya knows that each student expects to get a certain number of points, x_i, for the test. He wants to determine the permutation p that maximizes the surprise value of the results, which is calculated as the sum of the absolute differences between the expected points and the actual points received by each student, ∑_{i

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. P

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.22043746709823608
final_output reward: 0
total reward: 0.22043746709823608
add mutated seed into prompt node list
seed_index: 362
mutated_seed_index: 363
reward = 0.22043746709823608
saving......
in recording...
len prompt_nodes
364
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 318------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:337
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Note that finding the longest increasing subsequence in each subarray requires careful implementation for correctness and efficiency.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will divide the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it's feasible to divide the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Note that discovering the longest increasing subsequence in each subarray requires careful implementation for correctness and efficiency.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if we split the sequence [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of the subarrays. Determine if it's possible to split the sequence such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS) of

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.27739787101745605
final_output reward: 0.4
total reward: 0.6773978710174561
add mutated seed into prompt node list
seed_index: 337
mutated_seed_index: 364
reward = 0.6773978710174561
saving......
in recording...
len prompt_nodes
365
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 319------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:364
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. Now he will divide the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it's feasible to divide the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Note that discovering the longest increasing subsequence in each subarray requires careful implementation for correctness and efficiency.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n, and now he will divide the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it's feasible to divide the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end, and note that discovering the longest increasing subsequence in each subarray requires careful implementation for correctness and efficiency.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if we split the sequence [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS) of

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.296488881111145
final_output reward: 0
total reward: 0.296488881111145
add mutated seed into prompt node list
seed_index: 364
mutated_seed_index: 365
reward = 0.296488881111145
saving......
in recording...
len prompt_nodes
366
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 320------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:340
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Petya has got a fascinating plant, but as a busy person, he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows:

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter, and if watered in both the i-th and (i-1)-th day (i > 1), it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got a fascinating plant, but as a busy person, he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter, and if watered in both the i-th and (i-1)-th day (i > 1), it grows by 5 centimeters instead of 1, and if the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower, which he adores. However, he is quite busy and sometimes neglects to water it. You are provided with a timeline of n days based on Petya's daily schedule, and your task is to assess the final state of the flower.

The flower's growth pattern is as follows: 

  * If the flower goes without water for two consecutive days, it will wither away. 
  * If the flower is watered on the i-th day, it will increase in height by 1 centimeter. 
  * If the flower is

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.19554316997528076
final_output reward: 0
total reward: 0.19554316997528076
add mutated seed into prompt node list
seed_index: 340
mutated_seed_index: 366
reward = 0.19554316997528076
saving......
in recording...
len prompt_nodes
367
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 321------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:326
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Chanek Jones has returned, assisting his long-lost family member Indiana Jones, in searching for a hidden treasure within a maze beneath a desert filled with illusions. The labyrinth's map resembles a tree with n rooms labeled from 1 to n and n - 1 tunnels linking them so every pair of rooms can be accessed through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate and to move from the x-th room to the y-th room, a connecting tunnel between x and y must exist, with energy cost computed as max(|a_x + a_y|, |a_x - a_y|). |z| signifies the absolute value of z. To deter grave robbers, the maze can adjust the illusion rate of any room, and Chanek and Indiana will pose q queries. There are two types of queries to be processed:

  * 1\ u\ c — The illusion rate of the x-th room is altered to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana inquire about the least sum of energy required to retrieve the secret treasure from room v if they start at room u (1 ≤ u, v ≤ n). 

Assist them, so you can acquire a share of the treasure!

--------------------------------------------------
Chanek Jones has returned, assisting his long-lost family member Indiana Jones, in searching for a hidden treasure within a maze beneath a desert filled with illusions. The labyrinth's map resembles a tree with n rooms labeled from 1 to n and n - 1 tunnels linking them so every pair of rooms can be accessed through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate and to move from the x-th room to the y-th room, a connecting tunnel between x and y must exist, with energy cost computed as max(|a_x + a_y|, |a_x - a_y|). |z| signifies the absolute value of z. To deter grave robbers, the maze can adjust the illusion rate of any room, and Chanek and Indiana will pose q queries. There are two types of queries to be processed:

  * 1\ u\ c — The illusion rate of the x-th room is altered to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana inquire about the least sum of energy required to retrieve the secret treasure from room v if they start at room u (1 ≤ u, v ≤ n). 

Assist them, so you can acquire a share of the treasure! Remember to optimize your solution for efficiency, as the maze contains up to 100,000 rooms.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. 

The labyrinth is structured as a tree, consisting of n rooms numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through these tunnels.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. The energy required to travel from room x to room y is determined by the maximum of the absolute values of the sums and differences

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. Queries can update the illusion rate of a room or find the minimum energy needed to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.40966302156448364
final_output reward: 0.1
total reward: 0.5096630215644836
add mutated seed into prompt node list
seed_index: 326
mutated_seed_index: 367
reward = 0.5096630215644836
saving......
in recording...
len prompt_nodes
368
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_321.jsonl
----------------------------------------round: 322------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:310
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Andi and Budi received a task to organize their shelf containing n books. Each book is identified by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi wishes to arrange the books in lexicographical ascending order, while Budi wants to arrange them in lexicographical descending order.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Write a function to determine the order of books on the shelf following this rule.

--------------------------------------------------
Andi and Budi received a task to organize their shelf containing n books. Each book is identified by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi wishes to arrange the books in lexicographical ascending order, while Budi wants to arrange them in lexicographical descending order.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

Write a function to determine the order of books on the shelf following this rule. Each book title must be compared based on this unique arrangement rule.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.2814735770225525
final_output reward: 0
total reward: 0.2814735770225525
add mutated seed into prompt node list
seed_index: 310
mutated_seed_index: 368
reward = 0.2814735770225525
saving......
in recording...
len prompt_nodes
369
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 323------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:308
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You have a list of numbers that initially is empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. This means if x appears more than once in the array, all its occurrences should be replaced with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations.

--------------------------------------------------
You have a list of numbers that initially is empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. This means if x appears more than once in the array, all its occurrences should be replaced with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations. 

Make sure to handle cases where there are no occurrences of x to be replaced.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts as empty. You need to handle a series of queries, each of which can either add a number to the end of the array or replace all instances of one number with another in the array. After processing all the queries, you need to determine the final state of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.24784773588180542
final_output reward: 0.2
total reward: 0.44784773588180543
add mutated seed into prompt node list
seed_index: 308
mutated_seed_index: 369
reward = 0.44784773588180543
saving......
in recording...
len prompt_nodes
370
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 324------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:9
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. 

It means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

  2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator. 



For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are presented with an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up entirely of zeroes and ones. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

1. Initially, a new array a^{→ d} is established as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It indicates that the full array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process stops when the array no longer changes. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] containing only zeroes and ones. In each step, the array is cyclically shifted to the right by d cells, and then each element is replaced by the logical "AND" of the original element and its shifted counterpart. The process continues until the array becomes all zeroes, and you need to determine the number of steps required.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\nYou are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{→ d}_i, where \\& is a logical "AND" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n[plan]\n- name: \nCyclic Shift and Logical AND Simulation\n\n- content: \nThe solution involves simulating the process of cyclic shifting and applying logical AND operations iteratively until the array becomes all zeroes or detects that it will never become all zeroes.\n\n1. **Initialization**: For each test case, read the array size `n` and the shift distance `d`. Read the array elements.\n2. **Simulation Loop**:\n   - Perform the cyclic shift to get `a_shifted`.\n   - Apply the logical AND operation between the original array and the shifted array.\n   - Check if the array has changed after the operation. If not, break the loop as it will not change further.\n   - If the array becomes all zeroes, record the number of steps and break the loop.\n3. **Output**: For each test case, output the number of steps it took to become all zeroes, or -1 if it never becomes all zeroes.\n\n\n\n## Answer 3:\n\n'}]
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\nYou are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{→ d}_i, where \\& is a logical "AND" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.\n[plan]\n- name: \nCyclic Shift and Logical AND Simulation\n\n- content: \nThe solution involves simulating the process of cyclic shifting and applying logical AND operations iteratively until the array becomes all zeroes or detects that it will never become all zeroes.\n\n1. **Initialization**: For each test case, read the array size `n` and the shift distance `d`. Read the array elements.\n2. **Simulation Loop**:\n   - Perform the cyclic shift to get `a_shifted`.\n   - Apply the logical AND operation between the original array and the shifted array.\n   - Check if the array has changed after the operation. If not, break the loop as it will not change further.\n   - If the array becomes all zeroes, record the number of steps and break the loop.\n3. **Output**: For each test case, output the number of steps it took to become all zeroes, or -1 if it never becomes all zeroes.\n\n\n\n## Answer 3:\n\n'}]
----------updating----------
analyst reward: 0.2723183035850525
final_output reward: 0.1
total reward: 0.37231830358505247
add mutated seed into prompt node list
seed_index: 9
mutated_seed_index: 370
reward = 0.37231830358505247
saving......
in recording...
len prompt_nodes
371
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 325------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:336
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The city where Mr. Chanek resides can be illustrated as a plane. He wants to build a housing complex in the city. Some telephone poles are situated on the plane, represented by a grid a of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), with the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) being (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
The city where Mr. Chanek resides can be illustrated as a plane. He wants to build a housing complex in the city. Some telephone poles are situated on the plane. They are represented by a grid of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). The square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is calculated as (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane, which consists of a grid of size (n + 1) × (m + 1). Within this grid, there are telephone poles indicated by 1s in the grid array a.

For each point (x, y) in the grid, S(x, y) is defined as the square of the Euclidean distance to the nearest telephone pole. This distance is calculated using the formula (x_2 - x_1)^2 + (y_2 - y_1)^2, where (x_1, y_1) is the

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor needs the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help by calculating ∑_{x=0}^{n} {∑_{y=0}^{m

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2556738257408142
final_output reward: 0.1
total reward: 0.3556738257408142
add mutated seed into prompt node list
seed_index: 336
mutated_seed_index: 371
reward = 0.3556738257408142
saving......
in recording...
len prompt_nodes
372
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 326------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:19
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, maintaining very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.3300243020057678
final_output reward: 0.1
total reward: 0.4300243020057678
add mutated seed into prompt node list
seed_index: 19
mutated_seed_index: 372
reward = 0.4300243020057678
saving......
in recording...
len prompt_nodes
373
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 327------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:317
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Luntik has decided to try singing. He has a collection of one-minute songs, two-minute songs and three-minute songs. Specifically, he has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations to determine the closest feasible split.

--------------------------------------------------
Luntik has decided to try singing. He has a collection of one-minute songs, two-minute songs and three-minute songs. Specifically, he has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert.

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the total length of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution. To assist with this problem, use an approach that considers the sum of durations to determine the closest feasible split.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (1 minute), b (2 minutes), and c (3 minutes). He needs to distribute them into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
----------updating----------
analyst reward: 0.14902275800704956
final_output reward: 0.2
total reward: 0.34902275800704957
add mutated seed into prompt node list
seed_index: 317
mutated_seed_index: 373
reward = 0.34902275800704957
saving......
in recording...
len prompt_nodes
374
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 328------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:213
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k). Ensure to explain the edge cases and constraints clearly.

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k). It is important to ensure to explain the edge cases and constraints clearly. The task may involve understanding the behavior of the function for small values of n and k and examining how it scales with larger numbers.

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) denotes the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum of the sum ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.35618650913238525
final_output reward: 0.1
total reward: 0.45618650913238523
add mutated seed into prompt node list
seed_index: 213
mutated_seed_index: 374
reward = 0.45618650913238523
saving......
in recording...
len prompt_nodes
375
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 329------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:345
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard. Each of these numbers follows a specific format. They are a positive integer x with p zeros appended to its end.

Now Monocarp asks you to compare these two numbers. Can you help him? Consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and each of these numbers follows a specific format: they are a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers; can you help him and consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3534885048866272
final_output reward: 0
total reward: 0.3534885048866272
add mutated seed into prompt node list
seed_index: 345
mutated_seed_index: 375
reward = 0.3534885048866272
saving......
in recording...
len prompt_nodes
376
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 330------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:270
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
The robot is situated on a checkered rectangular board measuring n × m (n rows and m columns). The rows are numbered from 1 to n from the top to the bottom, and the columns are numbered from 1 to m from left to right.

The sequence of commands s executed by the robot is given, and each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', triggering movement to the left, right, down, or up, respectively.

The robot can start its movement in any cell, and it executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, and a command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge; if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot begins from cell (2, 1) (second row, first column), proceeds right, right, down, left, up, and up, and finishes in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible.

--------------------------------------------------
The robot can start its movement in any cell, and it executes the commands starting from the first one, strictly in the order in which they are listed in s; if the robot moves beyond the edge of the board, it falls and breaks, and a command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge; if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot begins from cell (2, 1) (second row, first column), proceeds right, right, down, left, up, and up, and finishes in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. Consider all possible starting cells and choose the one that maximizes the number of commands executed.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts executing the commands from the first

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order given. If the robot moves beyond the edge of the board, it breaks. Determine the cell from which the robot should start its movement to execute the most commands without breaking.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.26274216175079346
final_output reward: 0.3
total reward: 0.5627421617507935
add mutated seed into prompt node list
seed_index: 270
mutated_seed_index: 376
reward = 0.5627421617507935
saving......
in recording...
len prompt_nodes
377
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 331------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:286
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i, which is an integer from 1 to n. The i-th problem also has a difficulty b_i, which is an integer from 1 to n. All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different. Alternatively, the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i, which is an integer from 1 to n. The i-th problem also has a difficulty b_i, which is an integer from 1 to n. All problems are different, meaning that there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different. Another way they can satisfy the condition is for the difficulties of all three selected problems to be different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has compiled a diverse set of n problems for an upcoming training session. Each problem is unique, featuring a specific topic (ranging from 1 to n) and a particular difficulty level (also from 1 to n).

To ensure a balanced and engaging problemset, Monocarp plans to choose exactly 3 problems from these n available problems. The selection must meet at least one of the following criteria:

1. The topics of the three selected problems are all distinct.
2. The difficulties of the three selected problems are all distinct.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, has n problems, each with a unique topic a_i and difficulty b_i. He needs to select exactly 3 problems for a training session, ensuring that at least one of the following conditions is met: the topics of all three selected problems are different, or the difficulties of all three selected problems are different. Determine the number of ways to select these three problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2044053077697754
final_output reward: 0.3
total reward: 0.5044053077697754
add mutated seed into prompt node list
seed_index: 286
mutated_seed_index: 377
reward = 0.5044053077697754
saving......
in recording...
len prompt_nodes
378
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_331.jsonl
----------------------------------------round: 332------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:90
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, which are all integers.

You are asked to break exactly one of them into two pieces in such a way that: 

  * both pieces have positive (strictly greater than 0) integer length; 
  * the total length of the pieces is equal to the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 

A square is also considered a rectangle.

Determine if it's possible to do that.

--------------------------------------------------
There exist three sticks with lengths l_1, l_2, and l_3, and all of them are whole numbers.

You are asked to break exactly one of them into two pieces in such a way that: 

  * both pieces have positive (strictly greater than 0) integer length; 
  * the total length of the pieces is equal to the original length of the stick; 
  * it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. 

A square is also considered a rectangle.

Determine if it's possible to do that.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick used as one of the sides. Determine if this is possible.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total length equals the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.308951735496521
final_output reward: 0
total reward: 0.308951735496521
add mutated seed into prompt node list
seed_index: 90
mutated_seed_index: 378
reward = 0.308951735496521
saving......
in recording...
len prompt_nodes
379
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 333------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:355
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You've received data from a Bubble bot. Your role involves constructing factory infrastructures, but prior to beginning, you need to determine the size and quantity of rooms within the factory, and you notice that you have the layout measurements, which come in a rectangular format: N x M. Then in the next N lines you have M numbers, which represent factory tiles and they can go from 0 to 15, and each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls, for example number 10 in its binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side, so it goes North, East, South, West. It is guaranteed that the construction always has walls on its edges. The input will be correct. Your task is to print the size of the rooms from biggest to smallest.

--------------------------------------------------
You've received data from a Bubble bot. Your role involves constructing factory infrastructures, but prior to beginning, you need to determine the size and quantity of rooms within the factory, and you notice that you have the layout measurements, given in rectangular form: N x M. Then in the next N lines you have M numbers, which represent factory tiles and they can go from 0 to 15, and each of these numbers should be assessed by converting them into binary representation. Because from each number you know on which side the tile has walls, for example number 10 in its binary form is 1010, which means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side, so it goes North, East, South, West. It is guaranteed that the construction always has walls on its edges. The input will be correct. Your task is to display the sizes of the rooms, ordered from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot, and your mission is to determine the size of the factory's rooms. To do this, you need to first understand the layout of the factory, which is in a rectangular shape represented by N x M dimensions. 

In the data provided, each of the N lines contains M numbers, each ranging from 0 to 15. These numbers are crucial as they represent the factory tiles and indicate the presence of walls on each side in their binary form. For instance, the number 10 in binary is 1010, which means it has a wall on the

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating the dimensions of a factory construction in rectangle shape: N x M. The data consists of N lines, each containing M numbers representing factory tiles. Each number can range from 0 to 15, and each number's binary representation indicates the presence of walls on its sides: North, East, South, and West. The factory's walls are guaranteed to be on its edges, and the input is correct. Your task is to print the sizes of the rooms from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.3641809821128845
final_output reward: 0
total reward: 0.3641809821128845
add mutated seed into prompt node list
seed_index: 355
mutated_seed_index: 379
reward = 0.3641809821128845
saving......
in recording...
len prompt_nodes
380
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 334------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:135
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string. These letters don't have to be adjacent; 
  * or he can erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only. Each turn he can choose to do one of the two following actions:

  * he can either remove exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string. These letters don't have to be adjacent; 
  * Alternatively, he may delete exactly one letter 'B' and exactly one letter 'C' from random positions in the string (these letters don't need to be next to each other). 

Therefore, each turn the length of the string is decreased exactly by 2. All turns are independent so for each turn, Casimir can choose any of two possible actions.

For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example.

For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

1. Erase exactly one letter 'A' and exactly one letter 'B' from anywhere in the string, regardless of whether they are adjacent.
2. Erase exactly one letter 'B' and exactly one letter 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2, as these letters are removed. The actions are independent, meaning Casimir

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. Each turn, he can either erase exactly one letter 'A' and exactly one letter 'B' or exactly one letter 'B' and exactly one letter 'C' from the string. Each turn decreases the length of the string by 2. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.283939003944397
final_output reward: 0
total reward: 0.283939003944397
add mutated seed into prompt node list
seed_index: 135
mutated_seed_index: 380
reward = 0.283939003944397
saving......
in recording...
len prompt_nodes
381
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 335------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:347
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of a game where a level is a rectangular grid of 2 rows and n columns, and Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column. Monocarp's character can move from one cell to another in one step if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level, considering edge cases where the path might be blocked entirely.

--------------------------------------------------
Monocarp is playing a computer game and currently aims to finish the initial stage of a game where the level consists of a rectangular grid with 2 rows and n columns, and Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column. Monocarp's character can shift from one cell to another in a single move if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level, considering edge cases where the path might be blocked entirely.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But it's important to remember that Monocarp can't go outside the grid. There are some cells with traps in them, and if Monocarp's character lands in one of those cells, the game

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner, but cannot go outside the grid. The goal is to reach (2, n) without landing in a trap cell. Determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.36981314420700073
final_output reward: 0.2
total reward: 0.5698131442070007
add mutated seed into prompt node list
seed_index: 347
mutated_seed_index: 381
reward = 0.5698131442070007
saving......
in recording...
len prompt_nodes
382
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 336------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:223
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Polycarp only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8, and after sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Polycarp only has the array b left and needs help to restore the array a while considering the possibility of duplicate values in the array a when deriving it from b. Ensure that the solution is efficient for the given constraints.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1,

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3393908143043518
final_output reward: 0.1
total reward: 0.4393908143043518
add mutated seed into prompt node list
seed_index: 223
mutated_seed_index: 382
reward = 0.4393908143043518
saving......
in recording...
len prompt_nodes
383
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 337------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:307
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
A string is referred to as square if it consists of a certain string repeated consecutively; for instance, the strings "aa", "abcabc", "abab" and "baabaa" qualify as square, whereas the strings "aaa", "abaaab" and "abcdabc" do not. For a given string s determine if it is square.

--------------------------------------------------
A string is called square if it is made up of a specific string repeated one after another; for instance, the strings "aa", "abcabc", "abab" and "baabaa" qualify as square, whereas the strings "aaa", "abaaab" and "abcdabc" do not. For a given string s determine if it is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by writing another string twice in a row. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, "aaa", "abaaab", and "abcdabc" are not considered square. The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.2899998426437378
final_output reward: 0
total reward: 0.2899998426437378
add mutated seed into prompt node list
seed_index: 307
mutated_seed_index: 383
reward = 0.2899998426437378
saving......
in recording...
len prompt_nodes
384
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 338------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:17
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

--------------------------------------------------
Monocarp has got an array a consisting of n numbers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements, denoted as k, is calculated by dividing the sum of all elements by the number of elements (n). Monocarp wants to remove two elements from the array a such that the mean of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i is less than j) in the array a, where removing the elements at these positions will result in the mean of the remaining elements being equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. He wants to delete two elements from a so that the mean of the remaining (n - 2) elements is still k. Calculate the number of pairs [i, j] (i < j) such that deleting the elements at these positions keeps the mean of the remaining elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2737964987754822
final_output reward: 0
total reward: 0.2737964987754822
add mutated seed into prompt node list
seed_index: 17
mutated_seed_index: 384
reward = 0.2737964987754822
saving......
in recording...
len prompt_nodes
385
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 339------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:225
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Polycarp enjoys squares and cubes of positive integers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a specified integer n, determine how many numbers from 1 to n are among Polycarp’s favorites. Put differently, calculate how many such x exist that x is the square of a positive integer or the cube of a positive integer (or both simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

--------------------------------------------------
Polycarp enjoys squares and cubes of positive integers; here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, .... For a specified integer n, determine how many numbers from 1 to n are among Polycarp’s favorites. Put differently, calculate how many such x exist that x is the square of a positive integer or the cube of a positive integer (or both simultaneously). Ensure you consider both squares and cubes without double-counting numbers that are both.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing. This means counting the number of integers x, where x is a square of a positive integer or a cube of a positive integer (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.2861964702606201
final_output reward: 0
total reward: 0.2861964702606201
add mutated seed into prompt node list
seed_index: 225
mutated_seed_index: 385
reward = 0.2861964702606201
saving......
in recording...
len prompt_nodes
386
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 340------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:287
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Chanek Jones is back, assisting his long-lost relative Indiana Jones, to discover a hidden treasure in a maze buried beneath a desert filled with illusions.

The map of the labyrinth forms a graph with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This structure makes it possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it requires max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, assisting his long-lost relative Indiana Jones, to discover a hidden treasure in a maze buried beneath a desert filled with illusions.

The map of the labyrinth forms a graph with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This structure makes it possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it requires max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure! Be sure to consider optimal strategies for both updating and querying the illusion rates efficiently.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. 

The labyrinth is structured with n rooms, each numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through multiple tunnels.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. To travel from room x to room y, a tunnel must exist between x and y, and the energy required for this journey is calculated as

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze allows changing the illusion rate of any room and has tunnels connecting rooms. The energy needed to travel between rooms x and y is max(|a_x + a_y|, |a_x - a_y|). Queries can update the illusion rate of a room or find the minimum energy to reach a secret treasure from a starting room.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.41016024351119995
final_output reward: 0
total reward: 0.41016024351119995
add mutated seed into prompt node list
seed_index: 287
mutated_seed_index: 386
reward = 0.41016024351119995
saving......
in recording...
len prompt_nodes
387
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 341------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:359
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n. This array contains each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations. In contrast, arrays like [1, 2, 4] do not meet the permutation criteria. Similarly, [4, 3, 2, 1, 2] fails to qualify as a permutation. Your task is to handle q queries. Note that all operations should be completed within optimal time complexity.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

--------------------------------------------------
You are given a permutation p of n elements. A permutation of n elements is an array of length n. This array contains each integer from 1 to n exactly once. An example would be [1, 2, 3] and [4, 3, 5, 1, 2], which are permutations. In contrast, arrays like [1, 2, 4] do not meet the permutation criteria. Likewise, [4, 3, 2, 1, 2] does not qualify as a permutation. Your task is to handle q queries. Note that all operations should be completed within optimal time complexity.

There are two types of queries:

  * 1 x y — swap p_x and p_y. 
  * 2 i k — print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are provided with a sequence p consisting of n elements, where each element is a unique integer ranging from 1 to n. A permutation of n elements is defined as an array of length n that includes each integer from 1 to n exactly once. For instance, [1, 2, 3] and [4, 3, 5, 1, 2] are examples of permutations, whereas [1, 2, 4] and [4, 3, 2, 1, 2] are not considered permutations. You will receive a series of queries to perform on this permutation.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
multi-gen-prompt:
 You are given a permutation p of n elements, which is an array of length n containing each integer from 1 to n exactly once. You need to perform q queries, with two types: 1 x y to swap p_x and p_y, and 2 i k to print the number that i will become if we assign i = p_i k times.

Input

The first line contains two integers n and q (1 ≤ n, q ≤ 10^5).

The second line contains n integers p_1, p_2, ..., p_n.

Each of the next q lines contains three integers. The first integer is t (1 ≤ t ≤ 2) — type of query. If t = 1, then the next two integers are x and y (1 ≤ x, y ≤ n; x ≠ y) — first-type query. If t = 2, then the next two integers are i and k (1 ≤ i, k ≤ n) — second-type query.

It is guaranteed that there is at least one second-type query.

Output

For every second-type query, print one integer in a new line — answer to this query.

Examples

Input


5 4
5 3 4 2 1
2 3 1
2 1 2
1 1 3
2 1 2


Output


4
1
2


Input


5 9
2 3 5 1 4
2 3 5
2 5 5
2 5 1
2 5 3
2 5 4
1 5 4
2 5 3
2 2 5
2 5 1


Output


3
5
4
2
3
3
3
1

Note

In the first example p = \{5, 3, 4, 2, 1\}. 

The first query is to print p_3. The answer is 4.

The second query is to print p_{p_1}. The answer is 1.

The third query is to swap p_1 and p_3. Now p = \{4, 3, 5, 2, 1\}.

The fourth query is to print p_{p_1}. The answer is 2.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2917678952217102
final_output reward: 0
total reward: 0.2917678952217102
add mutated seed into prompt node list
seed_index: 359
mutated_seed_index: 387
reward = 0.2917678952217102
saving......
in recording...
len prompt_nodes
388
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_341.jsonl
----------------------------------------round: 342------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:372
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, maintaining very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, maintaining very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Ensure that the solution efficiently handles the constraints and edge cases.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered successful if either all the people at the party are friends with each other, allowing them to all talk to each other without worrying about talking to someone they are not friends with, or no two people at the party are friends with

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.353493332862854
final_output reward: 0
total reward: 0.353493332862854
add mutated seed into prompt node list
seed_index: 372
mutated_seed_index: 388
reward = 0.353493332862854
saving......
in recording...
len prompt_nodes
389
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 343------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:370
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are presented with an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up entirely of zeroes and ones. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

1. Initially, a new array a^{→ d} is established as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It indicates that the full array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process stops when the array no longer changes. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] consisting solely of zeroes and ones. Keep in mind that in this problem, unlike others, the array indices start at zero, not at one.

In one step, the array a is replaced by another array of length n according to the following rules: 

1. Initially, a new array a^{→ d} is established as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It indicates that the full array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process halts when the array no longer changes. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. First, a new array a^{→ d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}. Then each element of the array a_i

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.27596062421798706
final_output reward: 0.3
total reward: 0.5759606242179871
add mutated seed into prompt node list
seed_index: 370
mutated_seed_index: 389
reward = 0.5759606242179871
saving......
in recording...
len prompt_nodes
390
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 344------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:294
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. For this problem, consider edge cases where the robot starts near the borders of the board.

--------------------------------------------------
The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom. The columns are numbered from 1 to m from left to right.

The robot is able to move from the current cell to one of the four cells adjacent by side. The robot can move up, down, left, or right from its current cell.

The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.

The robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.

The robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 × 3, if the robot starts a sequence of actions s="RRDLUU" ("right", "right", "down", "left", "up", "up") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).

<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).

Determine the cell from which the robot should start its movement in order to execute as many commands as possible. For this problem, consider edge cases where the robot starts near the borders of the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from its current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, with each command represented by one of the symbols 'L', 'R', 'D', or 'U', corresponding to moving left, right, down, or up, respectively.

The robot starts its movement from any cell on the

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m. The robot can move from the current cell to one of the four adjacent cells. The sequence of commands s is executed by the robot, where each command is denoted by 'L', 'R', 'D', or 'U'. The robot starts its movement from any cell and executes the commands in the order they are listed. If the robot moves beyond the edge of the board, it falls and breaks. The goal is to determine the cell from which the robot should start its movement to execute the most commands without falling off the board.

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

In the description of each test case, the first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' — the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.

It is guaranteed that the total length of s over all test cases does not exceed 10^6.

Output

Print t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 ≤ r ≤ n) and c (1 ≤ c ≤ m), separated by a space — the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.

If there are several such cells, you may output any of them.

Example

Input


4
1 1
L
1 2
L
3 3
RRDLUU
4 3
LUURRDDLLLUU


Output


1 1
1 2
2 1
3 2
generating with deepseek-coder
----------updating----------
analyst reward: 0.20815187692642212
final_output reward: 0
total reward: 0.20815187692642212
add mutated seed into prompt node list
seed_index: 294
mutated_seed_index: 390
reward = 0.20815187692642212
saving......
in recording...
len prompt_nodes
391
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 345------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:1
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

--------------------------------------------------
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7! Consider edge cases where the array might contain equal values or where n is small.

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
multi-gen-prompt:
 Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as the sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j). Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
generating with deepseek-coder
----------updating----------
analyst reward: 0.2521742582321167
final_output reward: 0
total reward: 0.2521742582321167
add mutated seed into prompt node list
seed_index: 1
mutated_seed_index: 391
reward = 0.2521742582321167
saving......
in recording...
len prompt_nodes
392
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 346------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:252
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. This means that the greatest common divisor of i and j must be greater than or equal to l, for all pairs. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. This means that the greatest common divisor of i and j must be greater than or equal to l. It must hold for all pairs. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n and let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n. 

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum value of the sum ∑_{i=1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.31980234384536743
final_output reward: 0.2
total reward: 0.5198023438453674
add mutated seed into prompt node list
seed_index: 252
mutated_seed_index: 392
reward = 0.5198023438453674
saving......
in recording...
len prompt_nodes
393
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 347------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:361
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. A level is a rectangular grid of 2 rows and n columns, where Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column, and the character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and going off the grid is strictly forbidden. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

--------------------------------------------------
Monocarp is playing a computer game and now he wants to complete the first level of this game. A level is a rectangular grid of 2 rows and n columns, where Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column, and the character can move from one cell to another in one step if the cells are adjacent by side and/or corner, i.e., it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, and moving out of the grid is strictly not allowed. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But remember, if the cell has traps, Monocarp's character will die, and the game will end. The goal is for Monocarp's character to reach the end of the grid, which is in

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side and/or corner, but cannot go outside the grid. The goal is to reach (2, n) without landing in a trap cell. Determine if it is possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.42306238412857056
final_output reward: 0.1
total reward: 0.5230623841285705
add mutated seed into prompt node list
seed_index: 361
mutated_seed_index: 393
reward = 0.5230623841285705
saving......
in recording...
len prompt_nodes
394
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 348------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:301
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. He will split the sequence a into one or more consecutive subarrays such that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5]. It has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n. He will split the sequence a into one or more consecutive subarrays such that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays.

For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1].

YouKn0wWho wonders if it is possible to split the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible.

The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5]. It has length 3.

An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Consider edge cases where the sequence might be already sorted or contain duplicate elements.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of integers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive subarrays, where each element of the original sequence belongs to exactly one subarray. Let k represent the number of resulting subarrays, and h_1, h_2, …, h_k denote the lengths of the longest increasing subsequences of the respective subarrays.

For instance, if the sequence is [2, 5, 3, 1, 4, 3, 2, 2, 5,

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of the subarrays. Determine if it's possible to split the sequence such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS) of

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2716757655143738
final_output reward: 0.1
total reward: 0.37167576551437376
add mutated seed into prompt node list
seed_index: 301
mutated_seed_index: 394
reward = 0.37167576551437376
saving......
in recording...
len prompt_nodes
395
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 349------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:389
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] consisting solely of zeroes and ones. Keep in mind that in this problem, unlike others, the array indices start at zero, not at one.

In one step, the array a is replaced by another array of length n according to the following rules: 

1. Initially, a new array a^{→ d} is established as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It indicates that the full array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process halts when the array no longer changes. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] consisting solely of zeroes and ones. Keep in mind that in this problem, unlike others, the array indices start at zero, not at one.

In one step, the array a is replaced by another array of length n according to the following rules:

1. Initially, a new array a^{→ d} is established as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It indicates that the full array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

2. Then each element of the array a_i is replaced by a_i \& a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0 \& 1, 0 \& 0, 1 \& 0, 1 \& 1], that is [0, 0, 0, 1].

The process halts when the array no longer changes. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. You must ensure that the solution is efficient and works within time limits for large inputs.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] containing only zeroes and ones. In one step, the array a is replaced by another array of length n according to the following rules: 1. Define a^{→ d} as a cyclic shift of the array a to the right by d cells, where a^{→ d}_i = a_{(i + n - d) mod n}. 2. Replace each element a_i with a_i  \&  a^{→ d}_i.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30375176668167114
final_output reward: 0
total reward: 0.30375176668167114
add mutated seed into prompt node list
seed_index: 389
mutated_seed_index: 395
reward = 0.30375176668167114
saving......
in recording...
len prompt_nodes
396
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 350------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:363
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he gets p_j points. If the student does not answer the j-th question correctly, then he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he earns p_j points. If the student does not answer the j-th question correctly, then he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each student, it is known which questions they have answered correctly and which they have not.

If a student answers the j-th question correctly, they earn p_j points (otherwise, they earn 0 points). The points for the questions are distributed in such a way that the array p consists of numbers from 1 to m, and each number appears exactly once.

Petya knows that each student expects to score x_i points on the test. To determine the level of surprise

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). The points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. P

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.29133325815200806
final_output reward: 0.2
total reward: 0.49133325815200807
add mutated seed into prompt node list
seed_index: 363
mutated_seed_index: 396
reward = 0.49133325815200807
saving......
in recording...
len prompt_nodes
397
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 351------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False, False]
current seed index:346
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are provided with a keyboard that includes 26 keys, organized in a single row in a specific sequence. Each of these keys represents an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, but no time is allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

--------------------------------------------------
You are provided with a keyboard consisting of 26 keys, laid out in a single line following a particular arrangement. Each of these keys represents an individual lowercase Latin letter, and your task is to input the word s on this keyboard, which is composed solely of lowercase Latin letters. Transitioning the hand between the keys consumes time equivalent to the absolute value of the difference between the positions of these keys, but no time is allotted for pressing the keys or positioning your hand on the first letter of the word. For example, imagine a keyboard where the letters from 'a' to 'z' are arranged in successive alphabetical order, so it will take |5 - 8| + |12 - 5| + |12 - 12| + |15 - 12| = 13 units of time to type the word "hello". Calculate the time needed to type the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given a keyboard that consists of 26 keys. The keys are arranged sequentially in one row in a certain order. Each key corresponds to a unique lowercase Latin letter.

You have to type the word s on this keyboard. It also consists only of lowercase Latin letters.

To type a word, you need to type all its letters consecutively one by one. To type each letter, you must position your hand exactly over the corresponding key and press it.

Moving the hand between the keys takes time which is equal to the absolute value of the difference between positions of these keys (the keys are numbered from

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
multi-gen-prompt:
 You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the total time required to print the word s.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases.

The first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from 'a' to 'z' appears exactly once on the keyboard.

The second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.

Example

Input


5
abcdefghijklmnopqrstuvwxyz
hello
abcdefghijklmnopqrstuvwxyz
i
abcdefghijklmnopqrstuvwxyz
codeforces
qwertyuiopasdfghjklzxcvbnm
qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
qwertyuiopasdfghjklzxcvbnm
abacaba


Output


13
0
68
0
74
generating with deepseek-coder
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a coding plan from the analyst and the original requirement from user, you task is to judge whether the plan need further inteperate based on the following perspective. If the plan need further inteperate, please provide some insight for the coder based on the following perspective.\n1. Identift the core concept(key words, important concept) of the requirement, and explain the meaning of core concept.\n2. Identify all the phrase showing quantity relationship (greater than, more than, two times, two multiply two, as much as) in the requirement, and explain the meaning of them in the requirement,then show how to implement them in code.\n3. Identify all degree adverb (largest, greatest, best, shorest) in the requirement, and explain the meaning of them  in the requirement, then show how to implement them in code.\n4. For the steps in plan, check if some steps should be implement simultaneously (in one code block or if-else statement), and explain the implementation\n5. Based on the requirement and analysis, identify the edge case of the question, generate three edge case based on the format of edge cases in the requirement, and identify the correct output of edge case and explain it.\n6. Based on the requirement and analysis, identify if extra code needed to handle the edge cases, or it could be solved in by considering original logic.\n\n- The format of your output should be:\n\n# [core concept]\n    <core concept>\n    Explanation: ...\n\n# [phrase showing quantity relationship]\n    <phrase1>: <explanation> \n   ...\n   \n# [degree adverb] \n    <degree adverb1>: <explanation> \n   ... \n\n# [code logic]\n(check if there are steps should be considered simultaneously)\n\n# [edge case] \n    <edge case1> = <expected output>\n    Explanation:\n    ...\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n\n\n\n# For example:\n## Prompt 1:\n\n[requirement]\ndef how_many_times(string: str, substring: str) -> int:\n\'\'\' Find how many times a specific substring appears within the original string. Include overlapping instances.\n>>> how_many_times(\'\', \'a\')\n    0\n    >>> how_many_times(\'aaa\', \'a\')\n    3\n    >>> how_many_times(\'aaaa\', \'aa\')\n    3\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the length of the original string",\n      "Identify the length of the substring",\n      "Iterate through the original string to find all occurrences of the substring",\n      "Count the number of occurrences found"\n    ],\n    "steps": [\n      "Get the input string and substring from the user",\n      "Initialize a counter variable to keep track of the number of occurrences",\n      "Iterate through the original string using a sliding window approach",\n      "Check if the current substring matches the input substring",\n      "If a match is found, increment the counter variable",\n      "Return the final count of occurrences"\n    ]\n  }\n}\n\n## Answer 1:\n\n# [core concept]\n    \'overlapping\'\n    In the requirement it means that we could count the overlapping apperance of substring in the original string\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The step 3-5 should be implement simultaneously\n    "Iterate through the original string using a sliding window approach",\n    "Check if the current substring matches the input substring",\n    "If a match is found, increment the counter variable"\n    This could be done by writing one for loop to iterate through the orginal string, extract every substring with the size of substring, check if it match the input substring and increment the counter variable if a match is found\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    explanation: \'\' appears four times in the orginal string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n\n## Prompt 2:\n\n[requirement]\ndef search(lst):\t\n\'\'\'You are given a non-empty list of positive integers. Return the largest integer that is more than zero and appears at least as many times as the integer itself. If no such a value exist, return -1.\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the frequency of each integer in the list",\n      "Find the largest integer that appears at least as many times as itself",\n      "Handle the case where no such integer exists"\n    ],\n    "steps": [\n      "Create a dictionary to store the frequency of each integer in the list",\n      "Iterate through the list and update the frequency in the dictionary",\n      "Iterate through the dictionary to find the largest integer that meets the condition",\n      "Return the result or -1 if no such integer exists"\n    ]\n  }\n}\n}\n\n## Answer 2:\n\n# [core concept] \n    \'positive\': means that all interger in the list is > 0\n\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find interger > 0\n    \'at least as many times\': means that we need to find the interger whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the bigest interger that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps shoule be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    explanation: number 2 appears one time, number 3 appears two times,number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest interger that meets the need. \n\n## Prompt 3:\n[requirement]\n You are given a keyboard with 26 keys arranged sequentially in one row, each key corresponding to a unique lowercase Latin letter. You need to type the word s on this keyboard, which consists only of lowercase Latin letters. To type each letter, you must position your hand exactly over the corresponding key, and moving the hand between the keys takes time equal to the absolute value of the difference between the positions of these keys. The time spent on pressing the keys and placing the hand over the first letter of the word is zero. Determine the total time required to print the word s.\n\nInput\n\nThe first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nThe first line of a description contains a keyboard — a string of length 26, which consists only of lowercase Latin letters. Each of the letters from \'a\' to \'z\' appears exactly once on the keyboard.\n\nThe second line of the description contains the word s. The word has a length from 1 to 50 letters inclusive and consists of lowercase Latin letters.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to the test case is the minimal time it takes to type the word s on the given keyboard.\n\nExample\n\nInput\n\n\n5\nabcdefghijklmnopqrstuvwxyz\nhello\nabcdefghijklmnopqrstuvwxyz\ni\nabcdefghijklmnopqrstuvwxyz\ncodeforces\nqwertyuiopasdfghjklzxcvbnm\nqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\nqwertyuiopasdfghjklzxcvbnm\nabacaba\n\n\nOutput\n\n\n13\n0\n68\n0\n74\n[plan]\n- name: \nBrute Force Solution\n\n- content: \n- Iterate through each character in the word s.\n- For each character, find its position on the keyboard.\n- Calculate the time to move from the current position to the next position by taking the absolute difference between the positions.\n- Sum up all the times to get the total time.\n- Handle edge cases such as an empty word or a word with only one character.\n\n\n\n## Answer 3:\n\n'}]
----------updating----------
analyst reward: 0.2608509063720703
final_output reward: 0
total reward: 0.2608509063720703
add mutated seed into prompt node list
seed_index: 346
mutated_seed_index: 397
reward = 0.2608509063720703
saving......
in recording...
len prompt_nodes
398
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_351.jsonl
----------------------------------------round: 352------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False, False]
current seed index:349
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
You possess an array `a` with a length of `n`.

Let's explain the eversion procedure. Let `x` be equal to `a_n`. In that case, array `a` is split into two parts: left and right. The left part includes elements of `a` which are less than or equal to `x` (≤ `x`). The right part includes elements of `a` which are greater than `x` (> `x`). The order of items in each section stays the same as it was prior to the procedure. The current sequence of elements in each portion does not alter after the procedure. This suggests that the partition is stable. Then the array is substituted with the combination of the left and the right parts.

For example, if the array `a` is [2, 4, 1, 5, 3], the eversion continues like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array `a` and perform eversions on this array. We can demonstrate that after a number of eversions the array `a` ceases to change. Output the smallest number `k` so that the array stops changing after `k` eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

--------------------------------------------------
You possess an array `a` with a length of `n`.

Let's explain the eversion procedure. Let `x` be equal to `a_n`, in that case, array `a` is split into two parts: left and right; the left part includes elements of `a` which are less than or equal to `x` (≤ `x`), and the right part includes elements of `a` which are greater than `x` (> `x`). The order of items in each section stays the same as it was prior to the procedure. The current sequence of elements in each portion does not alter after the procedure. This suggests that the partition is stable. Then the array is substituted with the combination of the left and the right parts.

For example, if the array `a` is [2, 4, 1, 5, 3], the eversion continues like this: [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5].

We start with the array `a` and perform eversions on this array. We can demonstrate that after a number of eversions the array `a` ceases to change. Output the smallest number `k` so that the array stops changing after `k` eversions. Ensure that your function is optimized for large input sizes and runs efficiently within time limits.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i.e., the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
multi-gen-prompt:
 You are given an array a of length n. Let's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (≤ x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line contains a single integer n (1 ≤ n ≤ 2 ⋅ 10^5).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

For each test case print a single integer k — the number of eversions after which the array stops changing.

Example

Input


3
5
2 4 1 5 3
5
5 3 2 4 1
4
1 1 1 1


Output


1
2
0

Note

Consider the fist example.

  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] → [2, 1, 3], [4, 5] → [2, 1, 3, 4, 5]. 
  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] → [2, 1, 3, 4, 5], [] → [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. 



Consider the second example. 

  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] → [1], [5, 3, 2, 4] → [1, 5, 3, 2, 4]. 
  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] → [1, 3, 2, 4], [5] → [1, 3, 2, 4, 5]. 
  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] → [1, 3, 2, 4, 5], [] → [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. 
generating with deepseek-coder
----------updating----------
analyst reward: 0.24797946214675903
final_output reward: 0.1
total reward: 0.347979462146759
add mutated seed into prompt node list
seed_index: 349
mutated_seed_index: 398
reward = 0.347979462146759
saving......
in recording...
len prompt_nodes
399
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 353------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:281
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order modulo 10^9+7 since this number may be too large.

--------------------------------------------------
Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence consisting of only special numbers. Let's refer to a positive integer as special if it can be expressed as a sum of distinct non-negative powers of n; for instance, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order modulo 10^9+7 since this number may be too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Theofanis is fascinated by sequences of positive integers, and his teacher, Yeltsa Kcir, has given him a challenging problem involving a sequence composed only of special numbers. A special number is defined as one that can be expressed as a sum of different non-negative powers of a given number \( n \). For instance, with \( n = 4 \), the number 17 is special because it can be written as \( 4^0 + 4^2 = 1 + 16 = 17 \), whereas 9 is not.

Theofanis needs your help to determine the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
multi-gen-prompt:
 Theofanis likes sequences of positive integers, and his teacher gave him a problem about a sequence with special numbers. A number is special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, 17 is special (4^0 + 4^2 = 1 + 16 = 17), but 9 is not. Help Theofanis find the k-th special number in increasing order, considering it modulo 10^9+7 if it's too large.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first and only line of each test case contains two integers n and k (2 ≤ n ≤ 10^9; 1 ≤ k ≤ 10^9).

Output

For each test case, print one integer — the k-th special number in increasing order modulo 10^9+7.

Example

Input


3
3 4
2 12
105 564


Output


9
12
3595374

Note

For n = 3 the sequence is [1,3,4,9...]
generating with deepseek-coder
----------updating----------
analyst reward: 0.3058353066444397
final_output reward: 0
total reward: 0.3058353066444397
add mutated seed into prompt node list
seed_index: 281
mutated_seed_index: 399
reward = 0.3058353066444397
saving......
in recording...
len prompt_nodes
400
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 354------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:375
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and each of these numbers follows a specific format: they are a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers; can you help him and consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process?

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and each of these numbers follows a specific format: they are a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers; can you help him and consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process? Ensure that your solution efficiently handles scenarios where the input size becomes considerably large due to the number of zeros appended.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Monocarp then asks you to compare these two numbers, and you are asked to help him with this task.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.35702788829803467
final_output reward: 0.3
total reward: 0.6570278882980347
add mutated seed into prompt node list
seed_index: 375
mutated_seed_index: 400
reward = 0.6570278882980347
saving......
in recording...
len prompt_nodes
401
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 355------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:259
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, allowing travel between each pair of rooms through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate, and going from the x-th room to the y-th room, via an existing tunnel, takes max(|a_x + a_y|, |a_x - a_y|) energy, where |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, leading Chanek and Indiana to ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). You need to efficiently handle the queries on a dynamically changing graph. Help them, so you can get a portion of the treasure!

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, allowing travel between each pair of rooms through several tunnels. The i-th room (1 ≤ i ≤ n) has an illusion rate, and traveling from the x-th room to the y-th room via an existing tunnel takes max(|a_x + a_y|, |a_x - a_y|) energy, where |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, leading Chanek and Indiana to ask q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). You need to efficiently handle the queries on a dynamically changing graph; help them, so you can get a portion of the treasure!

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. 

The labyrinth is structured with n rooms, each numbered from 1 to n, interconnected by n - 1 tunnels, allowing for traversal between any two rooms through multiple tunnels.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. To travel from room x to room y, a tunnel must exist between x and y, and the energy required for this journey is calculated as

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze can alter the illusion rate of any room. Queries include updating the illusion rate of a room or finding the minimum energy required to travel from one room to another.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.35790157318115234
final_output reward: 0.1
total reward: 0.4579015731811523
add mutated seed into prompt node list
seed_index: 259
mutated_seed_index: 401
reward = 0.4579015731811523
saving......
in recording...
len prompt_nodes
402
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 356------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:352
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. In this context, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j. The greatest common divisor (GCD) is the largest positive integer that divides both i and j without leaving a remainder. In this specific instance, the term \operatorname{gcd}(i, j) indicates the greatest common divisor (GCD). It is the largest positive integer that divides both i and j without leaving a remainder. Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

--------------------------------------------------
For two positive integers l and r (l ≤ r) let c(l, r) denote the count of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and \operatorname{gcd}(i, j) ≥ l. In this context, \operatorname{gcd}(i, j) refers to the greatest common divisor of integers i and j. The greatest common divisor (GCD) is the largest positive integer that divides both i and j without leaving a remainder. It is the largest positive integer that divides both i and j without leaving a remainder. In this specific instance, the term \operatorname{gcd}(i, j) indicates the greatest common divisor (GCD). Here, \operatorname{gcd}(i, j) is the [greatest common divisor (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) represent the minimum attainable value of ∑_{i=1}^{k}{c(x_i+1,x_{i+1})} over all integer sequences 0=x_1 < x_2 < … < x_{k} < x_{k+1}=n.

Help YouKn0wWho find f(n, k).

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) represent the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and the greatest common divisor (GCD) of i and j is at least l. Here, \operatorname{gcd}(i, j) denotes the greatest common divisor of integers i and j.

YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) be the minimum of the sum ∑_{i=1}^{k

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
multi-gen-prompt:
 For two positive integers l and r (l ≤ r), let c(l, r) denote the number of integer pairs (i, j) such that l ≤ i ≤ j ≤ r and gcd(i, j) ≥ l. Here, gcd(i, j) is the greatest common divisor (GCD) of integers i and j. YouKn0wWho has two integers n and k where 1 ≤ k ≤ n. Let f(n, k) denote the minimum of ∑_{i=1}^{k}{c(x_i+1

Input

The first line contains a single integer t (1 ≤ t ≤ 3 ⋅ 10^5) — the number of test cases.

The first and only line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 10^5). 

Output

For each test case, print a single integer — f(n, k).

Example

Input


4
6 2
4 4
3 1
10 3


Output


8
4
6
11

Note

In the first test case, YouKn0wWho can select the sequence [0, 2, 6]. So f(6, 2) = c(1, 2) + c(3, 6) = 3 + 5 = 8 which is the minimum possible.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3548382520675659
final_output reward: 0.1
total reward: 0.4548382520675659
add mutated seed into prompt node list
seed_index: 352
mutated_seed_index: 402
reward = 0.4548382520675659
saving......
in recording...
len prompt_nodes
403
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 357------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:342
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3. You must separate one of them into two pieces in such a way that both pieces possess positive (strictly greater than 0) integer length, and the combined length of the pieces equals the stick's original length; it's feasible to build a rectangle with the resulting four sticks so that each stick acts as exactly one of its sides. A square is also regarded as a rectangle. Determine if it's achievable to accomplish that. When dividing a stick, ensure selecting an optimal division point that aids rectangle formation.

--------------------------------------------------
There are three sticks with integer lengths l_1, l_2 and l_3, and you must separate one of them into two pieces with positive integer length such that the combined length equals the stick's original length; it's feasible to build a rectangle with the resulting four sticks so that each stick acts as exactly one of its sides, where a square is also regarded as a rectangle. Determine if it's achievable to accomplish that. When dividing a stick, ensure selecting an optimal division point that aids rectangle formation.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total is equal to the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.257415771484375
final_output reward: 0
total reward: 0.257415771484375
add mutated seed into prompt node list
seed_index: 342
mutated_seed_index: 403
reward = 0.257415771484375
saving......
in recording...
len prompt_nodes
404
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 358------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:366
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Petya has got a fascinating plant, but as a busy person, he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter, and if watered in both the i-th and (i-1)-th day (i > 1), it grows by 5 centimeters instead of 1, and if the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got a fascinating plant, but as a busy person, he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter, and if watered in both the i-th and (i-1)-th day (i > 1), it grows by 5 centimeters instead of 1, and if the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days? Ensure to consider each day's impact on the flower's growth or survival.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower as a gift. However, due to his busy schedule, he sometimes neglects to water it. You are provided with a timeline of n days during which you need to track the growth and well-being of Petya's flower. 

The flower's growth pattern is as follows: 

  * If the flower goes without water for two consecutive days, it will wither and die. 
  * Each day the flower is watered, it will grow by 1 centimeter. 
  * If the flower is watered on both the i-th and

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.2843579053878784
final_output reward: 0.4
total reward: 0.6843579053878784
add mutated seed into prompt node list
seed_index: 366
mutated_seed_index: 404
reward = 0.6843579053878784
saving......
in recording...
len prompt_nodes
405
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 359------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:268
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Andi and Budi were tasked with organizing their shelf containing n books. Each book is represented by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

--------------------------------------------------
Andi and Budi were tasked with organizing their shelf containing n books. Each book is represented by the book title — a string s_i numbered from 1 to n. Each book title has a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.

This problem requires implementing a custom sorting function to achieve the desired order.

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------updating----------
analyst reward: 0.2505596876144409
final_output reward: 0.1
total reward: 0.3505596876144409
add mutated seed into prompt node list
seed_index: 268
mutated_seed_index: 405
reward = 0.3505596876144409
saving......
in recording...
len prompt_nodes
406
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 360------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:50
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. After removing it, you concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

--------------------------------------------------
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i.

You can pick an element from the current sequence and remove it. When you remove an element, the remaining elements are concatenated together into a new sequence. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1].

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek provides you with a sequence a indexed from 1 to n. The function f(a) is defined as the count of indices where a_i equals i. You can select an element from the current sequence and eliminate it, then combine the remaining elements into a new sequence. For instance, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. Your objective is to remove some elements from a to maximize f(a), using zero or more operations. Determine the maximum possible value of

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
multi-gen-prompt:
 Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
generating with deepseek-coder
----------updating----------
analyst reward: 0.28574156761169434
final_output reward: 0.1
total reward: 0.3857415676116943
add mutated seed into prompt node list
seed_index: 50
mutated_seed_index: 406
reward = 0.3857415676116943
saving......
in recording...
len prompt_nodes
407
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 361------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:353
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array. He then arranged them in ascending order and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a.

--------------------------------------------------
Polycarp had an array a of 3 positive integers and wrote out the sums of all non-empty subsequences of this array. He then arranged them in ascending order and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1, 3, 4, 4, 5, 7, 8}. Unfortunately, Polycarp lost the array a. He only has the array b left. Help him to restore the array a. For the purposes of this problem, assume all integers are distinct unless otherwise stated.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp had an array a of 3 positive integers. He wrote out the sums of all non-empty subsequences of this array, sorted them in non-decreasing order, and got an array b of 7 integers. For example, if a = {1, 4, 3}, then Polycarp wrote out 1, 4, 3, 1 + 4 = 5, 1 + 3 = 4, 4 + 3 = 7, 1 + 4 + 3 = 8. After sorting, he got an array b = {1,

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
multi-gen-prompt:
 Polycarp had an array b of 7 integers, which were the sums of all non-empty subsequences of the original array a of 3 positive integers, sorted in non-decreasing order. Help Polycarp restore the original array a.

Input

The first line contains one integer t (1 ≤ t ≤ 5000) — the number of test cases.

Each test case consists of one line which contains 7 integers b_1, b_2, ..., b_7 (1 ≤ b_i ≤ 10^9; b_i ≤ b_{i+1}). 

Additional constraint on the input: there exists at least one array a which yields this array b as described in the statement.

Output

For each test case, print 3 integers — a_1, a_2 and a_3. If there can be several answers, print any of them.

Example

Input


5
1 3 4 4 5 7 8
1 2 3 4 5 6 7
300000000 300000000 300000000 600000000 600000000 600000000 900000000
1 1 2 999999998 999999999 999999999 1000000000
1 2 2 3 3 4 5


Output


1 4 3
4 1 2
300000000 300000000 300000000
999999998 1 1
1 2 2

Note

The subsequence of the array a is a sequence that can be obtained from a by removing zero or more of its elements.

Two subsequences are considered different if index sets of elements included in them are different. That is, the values of the elements don't matter in the comparison of subsequences. In particular, any array of length 3 has exactly 7 different non-empty subsequences.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3128310441970825
final_output reward: 0
total reward: 0.3128310441970825
add mutated seed into prompt node list
seed_index: 353
mutated_seed_index: 407
reward = 0.3128310441970825
saving......
in recording...
len prompt_nodes
408
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_361.jsonl
----------------------------------------round: 362------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False]
current seed index:371
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
The city where Mr. Chanek resides can be illustrated as a plane. He wants to build a housing complex in the city. Some telephone poles are situated on the plane. They are represented by a grid of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). The square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is calculated as (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

--------------------------------------------------
The city where Mr. Chanek resides can be illustrated as a plane, and he wants to build a housing complex in the city. Some telephone poles are situated on the plane represented by a grid of size (n + 1) × (m + 1) with a telephone pole at (x, y) if a_{x, y} = 1. For any given point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), which is calculated as (x_2 - x_1)^2 + (y_2 - y_1)^2 between two points (x_1, y_1) and (x_2, y_2). To optimize the building plan, the project supervisor asks for the sum of all S(x, y) for every 0 ≤ x ≤ n and 0 ≤ y ≤ m. Assist him by determining the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}. Ensure that your solution is efficient to handle larger values of n and m.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). In this grid, there are telephone poles indicated by 1s in the array a. For each point (x, y) in the grid, S(x, y) is defined as the square of the Euclidean distance to the nearest telephone pole. This distance is calculated using the formula (x_2 - x_1)^2 + (y_2 - y_1)^2. The project supervisor wants to know the total sum of all S(x, y) values

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
multi-gen-prompt:
 Mr. Chanek's city is represented as a plane with a grid of size (n + 1) × (m + 1). There are telephone poles at points where a_{x, y} = 1. For each point (x, y), S(x, y) is the square of the Euclidean distance to the nearest pole. The project supervisor wants the sum of all S(x, y) for 0 ≤ x ≤ n and 0 ≤ y ≤ m. Find ∑_{x=0}^{n} {∑_{y=0}^{m} {

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2522433400154114
final_output reward: 0
total reward: 0.2522433400154114
add mutated seed into prompt node list
seed_index: 371
mutated_seed_index: 408
reward = 0.2522433400154114
saving......
in recording...
len prompt_nodes
409
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 363------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:381
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp is playing a computer game and currently aims to finish the initial stage of a game where the level consists of a rectangular grid with 2 rows and n columns, and Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column. Monocarp's character can shift from one cell to another in a single move if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level, considering edge cases where the path might be blocked entirely.

--------------------------------------------------
Monocarp is playing a computer game and currently aims to finish the initial stage of a game where the level consists of a rectangular grid with 2 rows and n columns, and Monocarp controls a character that starts in cell (1, 1) — at the intersection of the 1-st row and the 1-st column. Monocarp's character can shift from one cell to another in a single move if the cells are adjacent by side and/or corner, and formally, it is possible to move from cell (x_1, y_1) to cell (x_2, y_2) in one step if |x_1 - x_2| ≤ 1 and |y_1 - y_2| ≤ 1, while it is prohibited to go outside the grid. There are traps in some cells, and if Monocarp's character finds himself in such a cell, he dies, and the game ends. To complete a level, Monocarp's character should reach cell (2, n) — at the intersection of row 2 and column n. Help Monocarp determine if it is possible to complete the level, considering edge cases where the path might be blocked entirely. Ensure to take into account all possible configurations of traps and paths in your solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp is playing a computer game, and he needs to finish the first level. The level is a big grid with 2 rows and n columns. Monocarp's character starts at the very first cell, which is in the first row and first column.

Monocarp's character can move to nearby cells in the grid, either next to each other or by going diagonally. But remember, if the cell has traps, Monocarp's character will die, and the game will end.

The goal is for Monocarp's character to reach the end of the level, which

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
multi-gen-prompt:
 Monocarp is playing a computer game and needs to complete the first level, which is a 2-row, n-column grid. His character starts at (1, 1) and can move to adjacent cells by side or corner. Moving is prohibited outside the grid. The goal is to reach (2, n) without falling into traps. Determine if it's possible to complete the level.

Input

The first line contains a single integer t (1 ≤ t ≤ 100) — the number of test cases. Then the test cases follow. Each test case consists of three lines.

The first line contains a single integer n (3 ≤ n ≤ 100) — the number of columns.

The next two lines describe the level. The i-th of these lines describes the i-th line of the level — the line consists of the characters '0' and '1'. The character '0' corresponds to a safe cell, the character '1' corresponds to a trap cell.

Additional constraint on the input: cells (1, 1) and (2, n) are safe.

Output

For each test case, output YES if it is possible to complete the level, and NO otherwise.

Example

Input


4
3
000
000
4
0011
1100
4
0111
1110
6
010101
101010


Output


YES
YES
NO
YES

Note

Consider the example from the statement.

In the first test case, one of the possible paths is (1, 1) → (2, 2) → (2, 3).

In the second test case, one of the possible paths is (1, 1) → (1, 2) → (2, 3) → (2, 4).

In the fourth test case, one of the possible paths is (1, 1) → (2, 2) → (1, 3) → (2, 4) → (1, 5) → (2, 6).
generating with deepseek-coder
----------updating----------
analyst reward: 0.4021291732788086
final_output reward: 0
total reward: 0.4021291732788086
add mutated seed into prompt node list
seed_index: 381
mutated_seed_index: 409
reward = 0.4021291732788086
saving......
in recording...
len prompt_nodes
410
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 364------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:265
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string (these letters don't have to be adjacent) or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string (these letters don't have to be adjacent), therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). There are also many other options for a turn aside from this particular example. For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

--------------------------------------------------
Casimir has a string s which consists of capital Latin letters 'A', 'B', and 'C' only, and each turn he can choose to do one of the following actions: he can either erase exactly one letter 'A' and exactly one letter 'B' from arbitrary places of the string or erase exactly one letter 'B' and exactly one letter 'C' from arbitrary places in the string, therefore, each turn the length of the string is decreased exactly by 2. For example, with s = "ABCABC" he can obtain a string s = "ACBC" in one turn (by erasing the first occurrence of 'B' and the second occurrence of 'A'). For a given string s determine whether there is a sequence of actions leading to an empty string. In other words, Casimir's goal is to erase all letters from the string. Is there a way to do this?

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Casimir has a string s that consists only of capital Latin letters 'A', 'B', and 'C'. Each turn, he can choose to perform one of two actions:

1. Erase exactly one letter 'A' and exactly one letter 'B' from anywhere in the string, regardless of whether they are adjacent.
2. Erase exactly one letter 'B' and exactly one letter 'C' from anywhere in the string, regardless of whether they are adjacent.

Each action reduces the length of the string by 2, as the two chosen letters are removed. The actions are independent,

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
multi-gen-prompt:
 Casimir has a string s consisting of capital Latin letters 'A', 'B', and 'C' only. He can either erase exactly one 'A' and one 'B' or one 'B' and one 'C' from the string in each turn, decreasing the string's length by 2 each time. Determine if there's a sequence of actions that can lead to an empty string by erasing all letters.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case is described by one string s, for which you need to determine if it can be fully erased by some sequence of turns. The string s consists of capital letters 'A', 'B', 'C' and has a length from 1 to 50 letters, inclusive.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if there is a way to fully erase the corresponding string and NO otherwise.

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).

Example

Input


6
ABACAB
ABBA
AC
ABC
CABCBB
BCBCBCBCBCBCBCBC


Output


NO
YES
NO
NO
YES
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.4149344563484192
final_output reward: 0
total reward: 0.4149344563484192
add mutated seed into prompt node list
seed_index: 265
mutated_seed_index: 410
reward = 0.4149344563484192
saving......
in recording...
len prompt_nodes
411
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 365------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:388
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, maintaining very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Ensure that the solution efficiently handles the constraints and edge cases.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, maintaining very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Pay special attention to optimizing the solution for scalability with larger values of N and M.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, considering it successful if all attendees are friends or none are. A party consists of exactly 5 people. Help them organize a successful party or inform them it's impossible.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.38677024841308594
final_output reward: 0.3
total reward: 0.686770248413086
add mutated seed into prompt node list
seed_index: 388
mutated_seed_index: 411
reward = 0.686770248413086
saving......
in recording...
len prompt_nodes
412
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 366------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:335
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his learners have encountered yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small.

--------------------------------------------------
Monocarp is the coach of the Berland State University programming teams and decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his learners have encountered yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Consider edge cases where the number of problems is very small. Ensure the solution is efficient for larger values of n as well.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has compiled a diverse set of n problems for an upcoming training session. Each problem is uniquely identified by its topic (an integer from 1 to n) and its difficulty (another integer also ranging from 1 to n).

Monocarp aims to choose exactly 3 problems from these n problems to form the problemset. The selection must meet at least one of the following criteria:

1. The topics of the three selected problems are all distinct.
2. The difficulties of the three selected problems are all distinct.

Your goal

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, needs to compose a problemset for a training session. He has n problems, each with a unique topic a_i (integer from 1 to n) and difficulty b_i (integer from 1 to n). He must select exactly 3 problems for the problemset, ensuring that at least one of the following conditions is met:

  * the topics of all three selected problems are different; 
  * the difficulties of all three selected problems are different. 

Determine the number of ways to select three problems for the problem

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2647511959075928
final_output reward: 0.2
total reward: 0.4647511959075928
add mutated seed into prompt node list
seed_index: 335
mutated_seed_index: 412
reward = 0.4647511959075928
saving......
in recording...
len prompt_nodes
413
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 367------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:163
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers. Here is the beginning of the sequence of numbers he likes: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

--------------------------------------------------
Polycarp enjoys squares and cubes of positive whole numbers. Here is the start of the sequence of numbers he prefers: 1, 4, 8, 9, ....

For a given number n, count the number of integers from 1 to n that Polycarp likes. In other words, find the number of such x that x is a square of a positive integer number or a cube of a positive integer number (or both a square and a cube simultaneously).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Polycarp enjoys the squares and cubes of positive integers. He starts with this sequence: 1, 4, 8, 9, .... For a given number n, determine how many integers from 1 to n Polycarp finds appealing, meaning he likes those numbers that are either a square of a positive integer or a cube of a positive integer (or both).

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
multi-gen-prompt:
 Polycarp likes numbers that are either squares or cubes of positive integers, or both. For a given number n, determine the count of such numbers from 1 to n that he likes.

Input

The first line contains an integer t (1 ≤ t ≤ 20) — the number of test cases.

Then t lines contain the test cases, one per line. Each of the lines contains one integer n (1 ≤ n ≤ 10^9).

Output

For each test case, print the answer you are looking for — the number of integers from 1 to n that Polycarp likes.

Example

Input


6
10
1
25
1000000000
999999999
500000000


Output


4
1
6
32591
32590
23125
generating with deepseek-coder
----------updating----------
analyst reward: 0.33759546279907227
final_output reward: 0
total reward: 0.33759546279907227
add mutated seed into prompt node list
seed_index: 163
mutated_seed_index: 413
reward = 0.33759546279907227
saving......
in recording...
len prompt_nodes
414
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 368------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False]
current seed index:228
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the dimensions and number of rooms in the factory. When you examine the data, you observe that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. Ensure your solution is efficient in both time and space complexity.

--------------------------------------------------
You have received data from a Bubble bot. You know your task is to make factory facilities, but before you even start, you need to know the dimensions and number of rooms in the factory. When you examine the data, you observe that you have the measurements of the construction. The data provides a clear indication that the construction dimensions are important. The dimensions are crucial for understanding the layout, and they play a key role in planning. This construction is in rectangle shape: N x M. 

Then in the next N lines you have M numbers. These numbers represent factory tiles and they can vary from 0 to 15. Each of these numbers should be looked in its binary form because from each number you know on which side the tile has walls. For example number 10 in its binary form is 1010. This means that it has a wall from the North side, it doesn't have a wall from the East, it has a wall on the South side and it doesn't have a wall on the West side. So it goes North, East, South, West. 

It is guaranteed that the construction always has walls on its edges. The input will be correct. 

Your task is to print the size of the rooms from biggest to smallest. Ensure your solution is efficient in both time and space complexity.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have received data from a Bubble bot, and your mission is to construct factory facilities. However, before you begin, you need to determine the dimensions of the factory and the number of rooms it contains. You are provided with the construction dimensions, which are in the shape of a rectangle: N x M. 

Following this, you will receive N lines, each containing M numbers. These numbers represent the factory tiles, and they range from 0 to 15. Each of these numbers should be examined in its binary form. By doing so, you can determine which sides of the tile have walls. For instance, the

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
multi-gen-prompt:
 You have received data from a Bubble bot indicating a rectangular construction with dimensions N x M. The data consists of N lines, each containing M numbers representing factory tiles. Each number can range from 0 to 15, and each number's binary representation indicates the presence of walls on its sides: North, East, South, and West. The input guarantees that the construction has walls on its edges. Your task is to determine and print the sizes of the rooms in the factory from the largest to the smallest.

Input

The first line has two numbers which are N and M, the size of the construction. Both are integers: 

n (1 ≤ n ≤ 10^3)

m (1 ≤ m ≤ 10^3)

Next N x M numbers represent each tile of construction.

Output

Once you finish processing the data your output consists of one line sorted from biggest to smallest room sizes. 

Example

Input


4 5
9 14 11 12 13
5 15 11 6 7
5 9 14 9 14
3 2 14 3 14


Output


9 4 4 2 1 
generating with deepseek-coder
----------updating----------
analyst reward: 0.38017594814300537
final_output reward: 0
total reward: 0.38017594814300537
add mutated seed into prompt node list
seed_index: 228
mutated_seed_index: 414
reward = 0.38017594814300537
saving......
in recording...
len prompt_nodes
415
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 369------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False]
current seed index:400
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and each of these numbers follows a specific format: they are a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers; can you help him and consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process? Ensure that your solution efficiently handles scenarios where the input size becomes considerably large due to the number of zeros appended.

--------------------------------------------------
Monocarp wrote down two numbers on a whiteboard, and each of these numbers follows a specific format: they are a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers; can you help him and consider any edge cases that might arise from extremely large values of x or p, which could affect the comparison process? Ensure that your solution efficiently handles scenarios where the input size becomes considerably large due to the number of zeros appended. Remember to consider the feasibility and efficiency of your solution in scenarios where computational resources are limited.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers, can you assist him in doing so?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each being a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------updating----------
analyst reward: 0.30993348360061646
final_output reward: 0
total reward: 0.30993348360061646
add mutated seed into prompt node list
seed_index: 400
mutated_seed_index: 415
reward = 0.30993348360061646
saving......
in recording...
len prompt_nodes
416
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 370------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:411
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, maintaining very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Pay special attention to optimizing the solution for scalability with larger values of N and M.

--------------------------------------------------
On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, requiring the gathering of exactly 5 people which is successful if either all party members are friends or no two are friends so everyone can be on their phones. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Pay special attention to optimizing the solution for scalability with larger values of N and M.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party, but they have strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered successful if either all the people at the party are friends with each other or no two people at the party are friends with each other. Please help the people of Baltia organize a successful party or tell them that it's

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
multi-gen-prompt:
 On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a party of exactly 5 people, which is considered successful if all are friends or none are friends. Help them organize a successful party or determine it's impossible.

Input

The first line contains two integer numbers, N (5 ≤ N ≤ 2*10^5) and M (0 ≤ M ≤ 2*10^5) – the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 ≤ U_i,V_i ≤ N) – meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i ≠ V_i).

Output

If it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.

Examples

Input


6 3
1 4
4 2
5 4


Output


1 2 3 5 6


Input


5 4
1 2
2 3
3 4
4 5


Output


-1
generating with deepseek-coder
----------updating----------
analyst reward: 0.4209691882133484
final_output reward: 0.1
total reward: 0.5209691882133484
add mutated seed into prompt node list
seed_index: 411
mutated_seed_index: 416
reward = 0.5209691882133484
saving......
in recording...
len prompt_nodes
417
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 371------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:273
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
A string is called square if it is a certain string repeated twice in succession. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Ensure your solution achieves the desired efficiency for large inputs.

--------------------------------------------------
A string is called square if it is a certain string repeated twice in succession. For example, the strings "aa", "abcabc", "abab" and "baabaa" are square. But the strings "aaa", "abaaab" and "abcdabc" are not square.

For a given string s determine if it is square. Ensure your solution achieves the desired efficiency for large inputs. Make sure to handle both even and odd length strings appropriately in your implementation.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 A string is considered square if it can be formed by concatenating two identical strings together. For instance, the strings "aa", "abcabc", and "abab" are examples of square strings. However, the strings "aaa", "abaaab", and "abcdabc" are not considered square as they do not consist of two identical strings concatenated.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
multi-gen-prompt:
 A string is considered square if it can be formed by writing another string twice in a row. Examples of square strings include "aa", "abcabc", "abab", and "baabaa". Conversely, "aaa", "abaaab", and "abcdabc" are not considered square. The task is to determine if a given string s is square.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 100) —the number of test cases.

This is followed by t lines, each containing a description of one test case. The given strings consist only of lowercase Latin letters and have lengths between 1 and 100 inclusive.

Output

For each test case, output on a separate line:

  * YES if the string in the corresponding test case is square, 
  * NO otherwise. 



You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).

Example

Input


10
a
aa
aaa
aaaa
abab
abcabc
abacaba
xxyy
xyyx
xyxy


Output


NO
YES
NO
YES
YES
YES
NO
NO
NO
YES
generating with deepseek-coder
----------updating----------
analyst reward: 0.31552523374557495
final_output reward: 0
total reward: 0.31552523374557495
add mutated seed into prompt node list
seed_index: 273
mutated_seed_index: 417
reward = 0.31552523374557495
saving......
in recording...
len prompt_nodes
418
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
------------------------------
saving original node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_original_node.jsonl
------------------------------
saving node into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_node_371.jsonl
----------------------------------------round: 372------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:384
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
Monocarp has got an array a consisting of n numbers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

--------------------------------------------------
Monocarp has got an array a consisting of n numbers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). 

The mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).

Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.

Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array contains distinct integers only.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Monocarp has an array a with n elements. The mean of these elements is denoted as k, which is the sum of all elements divided by the number of elements (n). The mean of an array is calculated by adding all the elements together and then dividing by the number of elements. Monocarp wants to remove exactly two elements from the array a so that the mean of the remaining (n - 2) elements is still equal to k. Your task is to find the number of pairs of positions [i, j] (where i is less than j) in the array a such that if the elements at these positions

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
multi-gen-prompt:
 Monocarp has an array a of n integers, and k is the mean of these elements. The task is to find the number of pairs [i, j] (i < j) where deleting the elements at these positions keeps the mean of the remaining (n - 2) elements equal to k.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array.

The second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).

Example

Input


4
4
8 8 8 8
3
50 20 10
5
1 4 7 3 5
7
1 2 3 4 5 6 7


Output


6
0
2
3

Note

In the first example, any pair of elements can be removed since all of them are equal.

In the second example, there is no way to delete two elements so the mathematic mean doesn't change.

In the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2607405185699463
final_output reward: 0
total reward: 0.2607405185699463
add mutated seed into prompt node list
seed_index: 384
mutated_seed_index: 418
reward = 0.2607405185699463
saving......
in recording...
len prompt_nodes
419
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 373------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:396
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not.

If the student answers the j-th question correctly, he earns p_j points. If the student does not answer the j-th question correctly, then he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test.

Your task is to help Petya find such a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

--------------------------------------------------
Petya is a math instructor. n of his pupils have completed a test composed of m questions. For each pupil, it is known which questions they have answered accurately and which ones they haven't.

If the student answers the j-th question correctly, he earns p_j points. If the student does not answer the j-th question correctly, then he gets 0 points. Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m.

For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑_{i=1}^{n} |x_i - r_i|. Here, r_i is the number of points that the i-th student has got for the test.

Your task is to assist Petya in finding that permutation p for which the surprise value of the results is as large as possible. If there are multiple answers, print any of them.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya is a math teacher. He has n students, and each student has written a test with m questions. For each student, it is known which questions they have answered correctly and which they have not.

For each question, the points awarded are known and form a permutation of the numbers from 1 to m. This means that each question has a unique number of points associated with it, ranging from 1 to m.

Petya knows the expected points each student should get for the test, denoted as x_i. The surprise value of the results for the students is calculated as the sum of the

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
multi-gen-prompt:
 Petya is a math teacher. n of his students has written a test consisting of m questions. For each student, it is known which questions he has answered correctly and which he has not. If the student answers the j-th question correctly, he gets p_j points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m. For the i-th student, Petya knows that he expects to get x_i points for the test. Petya wonders how unexpected the results could be

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of test cases.

The first line of each test case contains two integers n and m (1 ≤ n ≤ 10; 1 ≤ m ≤ 10^4) — the number of students and the number of questions, respectively.

The second line contains n integers x_1, x_2, ..., x_n (0 ≤ x_i ≤ (m(m+1))/(2)), where x_i is the number of points that the i-th student expects to get.

This is followed by n lines, the i-th line contains the string s_i (|s_i| = m; s_{i, j} ∈ \{0, 1\}), where s_{i, j} is 1 if the i-th student has answered the j-th question correctly, and 0 otherwise.

The sum of m for all test cases does not exceed 10^4.

Output

For each test case, print m integers — a permutation p for which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.

Example

Input


3
4 3
5 1 2 2
110
100
101
100
4 4
6 2 0 10
1001
0010
0110
0101
3 6
20 3 15
010110
000101
111111


Output


3 1 2 
2 3 4 1 
3 1 4 5 2 6 
generating with deepseek-coder
----------updating----------
analyst reward: 0.292827844619751
final_output reward: 0
total reward: 0.292827844619751
add mutated seed into prompt node list
seed_index: 396
mutated_seed_index: 419
reward = 0.292827844619751
saving......
in recording...
len prompt_nodes
420
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 374------------------------------
----------selecting seed----------
path & finish
[False, False, False, False, False, False, False, False]
current seed index:369
----------mutating----------
--------------------------------------------------
add_1_sentence_at_end
--------------------------------------------------
You have a list of numbers that initially is empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. This means if x appears more than once in the array, all its occurrences should be replaced with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations. 

Make sure to handle cases where there are no occurrences of x to be replaced.

--------------------------------------------------
You have a list of numbers that initially is empty.

You have to perform q queries. Each query is of one of two types: 

  * "1 x" — append the element x to the end of the array; 
  * "2 x y" — replace all occurrences of x in the array with y. This means if x appears more than once in the array, all its occurrences should be replaced with y. 

Determine the final array after executing all the queries. Consider edge cases such as multiple identical elements and empty arrays during replacement or insertion operations. 

Make sure to handle cases where there are no occurrences of x to be replaced. Pay attention to the order of operations, as it can affect the final state of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You have an array of integers that starts as empty. You need to handle a series of queries, each of which can either add a number to the end of the array or replace all occurrences of a specific number with another number in the array. After processing all the queries, you need to determine the final state of the array.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
multi-gen-prompt:
 You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types: "1 x" — add the element x to the end of the array; "2 x y" — replace all occurrences of x in the array with y. Find the resulting array after performing all the queries.

Input

The first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries.

Next q lines contain queries (one per line). Each query is of one of two types: 

  * "1 x" (1 ≤ x ≤ 5 ⋅ 10^5); 
  * "2 x y" (1 ≤ x, y ≤ 5 ⋅ 10^5). 



It's guaranteed that there is at least one query of the first type.

Output

In a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.

Examples

Input


7
1 3
1 1
2 1 2
1 2
1 1
1 2
2 1 3


Output


3 2 2 3 2 

Input


4
1 1
1 2
1 1
2 2 2


Output


1 2 1 

Input


8
2 1 4
1 1
1 4
1 2
2 2 4
2 4 3
1 2
2 2 7


Output


1 3 3 7 

Note

In the first example, the array changes as follows:

[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].

In the second example, the array changes as follows:

[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].

In the third example, the array changes as follows:

[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].
generating with deepseek-coder
----------updating----------
analyst reward: 0.2635979652404785
final_output reward: 0
total reward: 0.2635979652404785
add mutated seed into prompt node list
seed_index: 369
mutated_seed_index: 420
reward = 0.2635979652404785
saving......
in recording...
len prompt_nodes
421
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 375------------------------------
----------selecting seed----------
path & finish
[False, False, False, False]
current seed index:365
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n, and now he will divide the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it's feasible to divide the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end, and note that discovering the longest increasing subsequence in each subarray requires careful implementation for correctness and efficiency.

--------------------------------------------------
YouKn0wWho has an integer sequence a_1, a_2, … a_n, and now he will divide the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. For example, if we split [2, 5, 3, 1, 4, 3, 2, 2, 5, 1] into [2, 5, 3, 1, 4], [3, 2, 2, 5], [1], then h = [3, 2, 1]. YouKn0wWho wonders if it's feasible to divide the sequence a in such a way that the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of h_1, h_2, …, h_k is equal to 0. You have to tell whether it is possible. The longest increasing subsequence (LIS) of a sequence b_1, b_2, …, b_m is the longest sequence of valid indices i_1, i_2, …, i_k such that i_1 < i_2 < … < i_k and b_{i_1} < b_{i_2} < … < b_{i_k}. For example, the LIS of [2, 5, 3, 3, 5] is [2, 3, 5], which has length 3. An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. You should note that discovering the longest increasing subsequence in each subarray requires careful implementation. This is important for ensuring correctness and efficiency.

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 YouKn0wWho has a sequence of numbers a_1, a_2, … a_n. He wants to divide this sequence into one or more consecutive parts called subarrays, where each element of the original sequence belongs to exactly one subarray. Let's denote the number of resulting subarrays as k, and the lengths of the longest increasing subsequences of these subarrays as h_1, h_2, …, h_k.

For instance, if the original sequence is [2, 5, 3, 1, 4, 3, 2, 

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
multi-gen-prompt:
 YouKn0wWho has an integer sequence a_1, a_2, … a_n. He splits the sequence into one or more consecutive subarrays, and each element belongs to exactly one subarray. Let k be the number of resulting subarrays, and h_1, h_2, …, h_k be the lengths of the longest increasing subsequences of corresponding subarrays. Determine if it's possible to split the sequence a such that the bitwise XOR of h_1, h_2, …, h_k is 0. The longest increasing subsequence (LIS)

Input

The first line contains a single integer t (1 ≤ t ≤ 10 000) — the number of test cases.

The first line of each test case contains a single integer n (2 ≤ n ≤ 10^5).

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9).

It is guaranteed that the sum of n over all test cases doesn't exceed 3 ⋅ 10^5.

Output

For each test case, print "YES" (without quotes) if it is possible to split into subarrays in the desired way, print "NO" (without quotes) otherwise. You can print each letter in any register (upper or lower).

Example

Input


4
7
1 3 4 2 2 1 5
3
1 3 4
5
1 3 2 4 2
4
4 3 2 1


Output


YES
NO
YES
YES

Note

In the first test case, YouKn0wWho can split the sequence in the following way: [1, 3, 4], [2, 2], [1, 5]. This way, the LIS lengths are h = [3, 1, 2], and the bitwise XOR of the LIS lengths is 3 ⊕ 1 ⊕ 2 = 0.

In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.
generating with deepseek-coder
----------updating----------
analyst reward: 0.2930276393890381
final_output reward: 0
total reward: 0.2930276393890381
add mutated seed into prompt node list
seed_index: 365
mutated_seed_index: 421
reward = 0.2930276393890381
saving......
in recording...
len prompt_nodes
422
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 376------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:127
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert. 

He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.

Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution.

--------------------------------------------------
Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts. Every song should be included to exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible; the duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider all possible combinations of distributions to achieve the optimal solution.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Luntik has decided to try singing. He has a one-minute song, b two-minute songs, and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included in exactly one concert. He wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
multi-gen-prompt:
 Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.

Each test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.

Output

For each test case print the minimal possible difference in minutes between the concerts durations.

Example

Input


4
1 1 1
2 1 3
5 5 5
1 1 2


Output


0
1
0
1

Note

In the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.

In the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.
generating with deepseek-coder
Request timed out.
[{'role': 'system', 'content': "\nYou are a process monitor for the interaction process of a coding requirement analyst and a programmer. The task of coding requirement analyst is to write requirement coding plan for the programmer, and the task of programmer is to write python code based on the user's requirement and coding plan from analyst. \n"}, {'role': 'user', 'content': '\nNow you receive a python code generated by the programmer, and the plan written by analyst as well as the original question. Your task is to judge whether the code follow the plan. If not, please explain the code\'s misunderstanding code to the plan. Your judgement should base on the following perspective. \n1. Does the code correctly understand the core concept of the plan?\n2. Can the code handle all the edge cases provided in the plan?\nNoted that you should output \'YES\' or \'NO\' \n[YES] indicates that the code contain misunderstanding of plan, need regenerate\n[NO] indicates that the code does not contain misunderstanding of plan, do not need regenerate\nIf your answer is yes, please write suggestions for the programmer to better understand the plan\n\n- The format of your output should be:\n\n[YES] / [NO]\n\n(if the answer is yes)\n[suggestions]\n1. ...\n\n\n## Example\n## Prompt 1:\n[requirement]\ndef circular_shift(x, shift):\n\'\'\'Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    Ensure that the result maintains any leading zeros from the original number.\n>>> circular_shift(12, 1)\n    "21"\n    >>> circular_shift(12, 2)\n    "12"\n    \'\'\'\n[plan]\n{\n  "plan": {\n    "subproblems": [\n      "Identify the number of digits in the input integer x",\n      "Determine the actual number of shifts needed based on the input shift value",\n      "Perform circular shifting of the digits to the right by the determined number of shifts",\n      "Handle cases where the shift value is greater than the number of digits in the input integer"\n    ],\n    "high-level steps": [\n      "Get the input integer x and shift value from the user",\n      "Calculate the number of digits in the input integer x",\n      "Determine the actual number of shifts needed based on the input shift value",\n      "Perform circular shifting of the digits to the right by the determined number of shifts",\n      "Handle cases where the shift value is greater than the number of digits in the input integer",\n      "Return the result as a string"\n    ]\n  }\n}\n[code from programmer]\ndef circular_shift(x, shift):\n    x_str = str(x)\n    num_digits = len(x_str)\n    actual_shift = shift % num_digits\n    if actual_shift == 0:\n        return x_str\n    else:\n        shifted_str = x_str[-actual_shift:] + x_str[:-actual_shift]\n        return shifted_str.zfill(num_digits)\n\n## Answer 1:\n[YES] \n[suggestions]\n1. the programmer should first consider the edge case when the shift value is greater than the number of digits, and then consider the other condtions.\n\n\n## Prompt 2:\n[requirement]\n Luntik has songs with durations a (one-minute), b (two-minute), and c (three-minute). He needs to distribute these songs into two concerts with the goal of minimizing the absolute difference in their durations. Find the smallest possible difference.\n\nInput\n\nThe first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 ≤ a, b, c ≤ 10^9) — the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.\n[plan]\n- name: \nGreedy Distribution Strategy\n\n- content: \nTo minimize the absolute difference in durations between the two concerts, we can use a greedy approach. The key is to balance the distribution of songs as evenly as possible.\n\n**Solution Approach**:\n1. Calculate the total number of songs and their total duration.\n2. Determine the optimal distribution by trying to balance the durations of the two concerts. This can be done by first trying to match the durations as closely as possible, and then adjusting if necessary.\n3. The optimal distribution will typically involve distributing as many 3-minute songs as possible between the two concerts, followed by 2-minute songs, and then 1-minute songs.\n4. Calculate the difference between the two concerts\' durations and return this value as the result.\n\n**Handling Edge Cases**:\n- If all songs are of the same duration, the difference will be 0.\n- If one type of song dominates, focus on balancing the remaining types to minimize the difference.\n- Consider large numbers of songs to ensure efficiency.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'absolute difference\': the smallest possible difference between two values\n    \'minimize\': find the lowest possible value\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates a comparison where one value is greater than another\n    \'at least as many times\': means the frequency of an item is at least as high as its value\n\n# [degree adverb] \n    \'smallest\': indicates the need to find the smallest possible value\n\n# [code logic]\n    The steps should be implemented simultaneously to find the optimal distribution.\n    - Calculate the total duration of all songs.\n    - Distribute the songs to two concerts to minimize the absolute difference.\n    - This can be done by sorting the songs by their durations and then distributing them as evenly as possible.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 1, 1]\n    Explanation: All songs are of the same duration, so the difference will be 0.\n    Expected Output: 0\n\n    Edge case 2:\n    Input: [2, 1, 3]\n    Explanation: The optimal distribution would be to put two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The difference will be 1.\n    Expected Output: 1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where all songs are of the same duration.\n[code from programmer]\n ```python\ndef f1(a, b, c):\n    # Calculate the total duration of all songs\n    total_duration = a + 2*b + 3*c\n    # The optimal way to minimize the difference is to distribute the songs as evenly as possible\n    # We can try to balance the durations by distributing 3-minute songs first, then 2-minute songs, and then 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can distribute the 3-minute songs first because they have the highest value\n    # Then we distribute the 2-minute songs, and finally the 1-minute songs\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute the songs as evenly as possible\n    # The optimal distribution will be to put as many 3-minute songs as possible in one concert and the rest in the other\n    # Then we do the same for 2-minute and 1-minute songs\n    # The difference will be the minimum of the absolute difference between the two concerts\' durations\n    # We can calculate the difference by trying to distribute\n\n## Answer 2:\n'}]
----------updating----------
analyst reward: 0.17493778467178345
final_output reward: 0.3
total reward: 0.47493778467178344
add mutated seed into prompt node list
seed_index: 127
mutated_seed_index: 422
reward = 0.47493778467178344
saving......
in recording...
len prompt_nodes
423
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 377------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:311
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Petya has got an interesting flower. Petya is a busy person, so he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 



At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

--------------------------------------------------
Petya has got an interesting flower. Petya is a busy person. So he sometimes fails to remember to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end.

The flower grows as follows: 

  * If the flower isn't watered for two consecutive days, it dies. 
  * If the flower is watered in the i-th day, it grows by 1 centimeter. 
  * If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters instead of 1. 
  * If the flower is not watered in the i-th day, it does not grow. 

At the beginning of the 1-st day the flower is 1 centimeter tall. What is its height after n days?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 Petya has received a lovely flower, but he often neglects to water it. You are provided with a record of n days during which Petya's activities are to be analyzed to determine the fate of his flower. 

The flower's growth pattern is as follows: 

  * If the flower goes without water for two consecutive days, it will wither and die. 
  * If the flower is watered on the i-th day, it will increase in height by 1 centimeter. 
  * If the flower is watered on both the i-th and the (i

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
multi-gen-prompt:
 Petya has got an interesting flower. Petya is a busy person, so he sometimes forgets to water it. You are given n days from Petya's live and you have to determine what happened with his flower in the end. The flower grows as follows: If the flower isn't watered for two days in a row, it dies. If the flower is watered in the i-th day, it grows by 1 centimeter. If the flower is watered in the i-th and in the (i-1)-th day (i > 1), then it grows by 5 centimeters

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The first line of each test case contains the only integer n (1 ≤ n ≤ 100).

The second line of each test case contains n integers a_1, a_2, ..., a_n (a_i = 0 or a_i = 1). If a_i = 1, the flower is watered in the i-th day, otherwise it is not watered.

Output

For each test case print a single integer k — the flower's height after n days, or -1, if the flower dies.

Example

Input


4
3
1 0 1
3
0 1 1
4
1 0 0 1
1
0


Output


3
7
-1
1
generating with deepseek-coder
----------updating----------
analyst reward: 0.28400760889053345
final_output reward: 0.2
total reward: 0.48400760889053346
add mutated seed into prompt node list
seed_index: 311
mutated_seed_index: 423
reward = 0.48400760889053346
saving......
in recording...
len prompt_nodes
424
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 378------------------------------
----------selecting seed----------
path & finish
[False, False, False]
current seed index:227
----------mutating----------
--------------------------------------------------
condense_two2one
--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones. Their mission is to find a secret treasure in a maze buried below a desert full of illusions.

The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.

The i-th room (1 ≤ i ≤ n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y. It takes max(|a_x + a_y|, |a_x - a_y|) energy to make this journey. |z| denotes the absolute value of z.

To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.

There are two types of queries to be done:

  * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). 
  * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). 

Help them, so you can get a portion of the treasure! Ensure efficiency due to constraints on the number of rooms and queries.

--------------------------------------------------
Chanek Jones is back, helping his long-lost relative Indiana Jones on a mission to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, enabling travel between each pair of rooms through several tunnels. The i-th room (1 ≤ i ≤ n) has a_i illusion rate, and to go from the x-th room to the y-th room, there must exist a tunnel between x and y, taking max(|a_x + a_y|, |a_x - a_y|) energy for the journey. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, with Chanek and Indiana asking q queries. There are two types of queries to be done: * 1\ u\ c — The illusion rate of the x-th room is changed to c (1 ≤ u ≤ n, 0 ≤ |c| ≤ 10^9). * 2\ u\ v — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 ≤ u, v ≤ n). Help them, so you can get a portion of the treasure! Ensure efficiency due to constraints on the number of rooms and queries.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 
Chanek Jones has returned to assist his distant relative, Indiana Jones, in their quest to uncover a hidden treasure within a maze buried beneath a desert filled with deceptive illusions. The labyrinth's map is structured as a tree, consisting of n rooms numbered from 1 to n, interconnected by n - 1 tunnels that allow travel between any two rooms.

Each room i (1 ≤ i ≤ n) has an associated illusion rate, denoted as a_i. The energy required to traverse from room x to room y depends on the sum or difference of their illusion rates, with the energy cost being the absolute

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
multi-gen-prompt:
 Chanek Jones aids Indiana Jones in searching for a secret treasure in a maze with n rooms, each having an illusion rate a_i. The maze has n - 1 tunnels connecting rooms, and travel between rooms requires max(|a_x + a_y|, |a_x - a_y|) energy. The maze can alter the illusion rate of any room with queries of type 1, and queries of type 2 ask for the minimum energy needed to reach the treasure in room v from room u.

Input

The first line contains two integers n and q (2 ≤ n ≤ 10^5, 1 ≤ q ≤ 10^5) — the number of rooms in the maze and the number of queries.

The second line contains n integers a_1, a_2, …, a_n (0 ≤ |a_i| ≤ 10^9) — inital illusion rate of each room.

The i-th of the next n-1 lines contains two integers s_i and t_i (1 ≤ s_i, t_i ≤ n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.

The next q lines contain the query as described. The given queries are valid.

Output

For each type 2 query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.

Example

Input


6 4
10 -9 2 -1 4 -6
1 5
5 4
5 6
6 2
6 3
2 1 2
1 1 -3
2 1 2
2 3 3


Output


39
32
0

Note

<image>

In the first query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|10 + 4|, |10 - 4|) = 14 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 

In total, it takes 39 energy.

In the second query, the illusion rate of the 1-st room changes from 10 to -3.

In the third query, their movement from the 1-st to the 2-nd room is as follows.

  * 1 → 5 — takes max(|-3 + 4|, |-3 - 4|) = 7 energy. 
  * 5 → 6 — takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. 
  * 6 → 2 — takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. 



Now, it takes 32 energy.
generating with deepseek-coder
----------updating----------
analyst reward: 0.3795773983001709
final_output reward: 0
total reward: 0.3795773983001709
add mutated seed into prompt node list
seed_index: 227
mutated_seed_index: 424
reward = 0.3795773983001709
saving......
in recording...
len prompt_nodes
425
initial_seed_num
46
[False, False, False, True, False, False, False, True, True, False, False, True, True, False, False, False, False, False, False, False, False, True, False, True, False, True, True, False, True, False, True, True, True, False, True, False, True, True, False, False, True, False, True, False, False, False]
total pass@10:28
------------------------------
saving result into: ./outputs/repair_fuzzing/results-repair_fuzzing_deepseek-coder_codecontest_1-1/_final_result.jsonl
----------------------------------------round: 379------------------------------
----------selecting seed----------
path & finish
[False, False]
current seed index:370
----------mutating----------
--------------------------------------------------
rephrase_one
--------------------------------------------------
You are presented with an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up entirely of zeroes and ones. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.

In one step, the array a is replaced by another array of length n according to the following rules: 

1. Initially, a new array a^{→ d} is established as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It indicates that the full array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process stops when the array no longer changes. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

--------------------------------------------------
You are presented with an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] made up entirely of zeroes and ones. Be aware that in this problem, unlike others, the array indices are designated starting from zero instead of one.

In one step, the array a is replaced by another array of length n according to the following rules: 

1. Initially, a new array a^{→ d} is established as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{→ d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n.

It indicates that the full array a^{→ d} can be represented as a sequence $$$a^{→ d} = [a_{n - d}, a_{n - d + 1}, …, a_{n - 1}, a_0, a_1, …, a_{n - d - 1}]$$$

2. Then each element of the array a_i is replaced by a_i  \&  a^{→ d}_i, where \& is a logical "AND" operator.

For example, if a = [0, 0, 1, 1] and d = 1, then a^{→ d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \&  1, 0  \&  0, 1  \&  0, 1  \&  1], that is [0, 0, 0, 1].

The process stops when the array no longer changes. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
--------------------------------------------------
----------evaluating mutated seed----------
multi-gen-prompt:
 You are given an array a[0 … n - 1] = [a_0, a_1, …, a_{n - 1}] that contains only zeroes and ones. The array indexes start from zero, not from one.

In each step, the array a is transformed into a new array of the same length by following these rules:

1. First, a new array a^{→ d} is created, which is a cyclic shift of the array a to the right by d cells. The elements of this new array are defined as a^{→ d}_i = a_{(

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
multi-gen-prompt:
 You are given an array a[0 … n - 1] containing only zeroes and ones. In each step, the array is cyclically shifted to the right by d cells, and then each element is replaced by the logical "AND" of the original element and its shifted counterpart. Determine if the array will eventually consist of only zeroes and find the number of steps required for this to happen.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains two integers: n (1 ≤ n ≤ 10^6) — array size and d (1 ≤ d ≤ n) — cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 ≤ a_i ≤ 1) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 10^6.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.

Example

Input


5
2 1
0 1
3 2
0 1 0
5 2
1 1 0 1 0
4 2
0 1 0 1
1 1
0


Output


1
1
3
-1
0

Note

In the third sample test case the array will change as follows: 

  1. At the beginning a = [1, 1, 0, 1, 0], and a^{→ 2} = [1, 0, 1, 1, 0]. Their element-by-element "AND" is equal to $$$[1  \&  1, 1  \&  0, 0  \&  1, 1  \&  1, 0  \&  0] = [1, 0, 0, 1, 0]$$$ 
  2. Now a = [1, 0, 0, 1, 0], then a^{→ 2} = [1, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  1, 0  \&  0, 0  \&  1, 1  \&  0, 0  \&  0] = [1, 0, 0, 0, 0]$$$ 
  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{→ 2} = [0, 0, 1, 0, 0]. Their element-by-element "AND" equals to $$$[1  \&  0, 0  \&  0, 0  \&  1, 0  \&  0, 0  \&  0] = [0, 0, 0, 0, 0]$$$ 

Thus, the answer is 3 steps.

In the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \&  0 or 1  \&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.
generating with deepseek-coder
